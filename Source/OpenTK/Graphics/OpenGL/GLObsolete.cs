using System;
using System.Runtime.InteropServices;

namespace OpenTK.Graphics.OpenGL
{
	partial class GL
    {
		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <param name="program">
		/// <para>
		/// Specifies the program object to be queried.
		/// </para>
		/// </param>
		/// <param name="maxCount">
		/// <para>
		/// Specifies the size of the array for storing the returned object names.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Returns the number of names actually returned in objects.
		/// </para>
		/// </param>
		/// <param name="obj">
		/// <para>
		/// Specifies an array that is used to return the names of attached shader objects.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		[AutoGenerated(Category = "Version20", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
		[Obsolete("Use GetAttachedShaders out/array overload instead")]
		public static 
		unsafe void GetAttachedShaders(Int32 program, Int32 maxCount, [OutAttribute] Int32* count, [OutAttribute] Int32[] obj)
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				fixed (Int32* obj_ptr = obj)
				{
					Delegates.glGetAttachedShaders((UInt32)program, (Int32)maxCount, (Int32*)count, (UInt32*)obj_ptr);
				}
				#if DEBUG
			}
			#endif
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <param name="program">
		/// <para>
		/// Specifies the program object to be queried.
		/// </para>
		/// </param>
		/// <param name="maxCount">
		/// <para>
		/// Specifies the size of the array for storing the returned object names.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Returns the number of names actually returned in objects.
		/// </para>
		/// </param>
		/// <param name="obj">
		/// <para>
		/// Specifies an array that is used to return the names of attached shader objects.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		[AutoGenerated(Category = "Version20", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
		[Obsolete("Use GetAttachedShaders out/array overload instead")]
		public static 
		unsafe void GetAttachedShaders(UInt32 program, Int32 maxCount, [OutAttribute] Int32* count, [OutAttribute] UInt32[] obj)
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				fixed (UInt32* obj_ptr = obj)
				{
					Delegates.glGetAttachedShaders((UInt32)program, (Int32)maxCount, (Int32*)count, (UInt32*)obj_ptr);
				}
				#if DEBUG
			}
			#endif
		}

		/// <summary>
		/// Get separable convolution filter kernel images
		/// </summary>
		/// <param name="target">
		/// <para>
		/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to storage for the row filter image.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to storage for the column filter image.
		/// </para>
		/// </param>
		/// <param name="span">
		/// <para>
		/// Pointer to storage for the span filter image (currently unused).
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
		[Obsolete("Use GetSeparableFilter<T3, T4, T5> overload instead")]
		public static 
		void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] T5[] span)
			where T5 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
				try
				{
					Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
				}
				finally
				{
					span_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}


		/// <summary>
		/// Get separable convolution filter kernel images
		/// </summary>
		/// <param name="target">
		/// <para>
		/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to storage for the row filter image.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to storage for the column filter image.
		/// </para>
		/// </param>
		/// <param name="span">
		/// <para>
		/// Pointer to storage for the span filter image (currently unused).
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
		[Obsolete("Use GetSeparableFilter<T3, T4, T5> overload instead")]
		public static 
		void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] T5[,] span)
			where T5 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
				try
				{
					Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
				}
				finally
				{
					span_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}


		/// <summary>
		/// Get separable convolution filter kernel images
		/// </summary>
		/// <param name="target">
		/// <para>
		/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to storage for the row filter image.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to storage for the column filter image.
		/// </para>
		/// </param>
		/// <param name="span">
		/// <para>
		/// Pointer to storage for the span filter image (currently unused).
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
		[Obsolete("Use GetSeparableFilter<T3, T4, T5> overload instead")]
		public static 
		void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] T5[,,] span)
			where T5 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
				try
				{
					Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
				}
				finally
				{
					span_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}


		/// <summary>
		/// Get separable convolution filter kernel images
		/// </summary>
		/// <param name="target">
		/// <para>
		/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to storage for the row filter image.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to storage for the column filter image.
		/// </para>
		/// </param>
		/// <param name="span">
		/// <para>
		/// Pointer to storage for the span filter image (currently unused).
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
		[Obsolete("Use GetSeparableFilter<T3, T4, T5> overload instead")]
		public static 
		void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] ref T5 span)
			where T5 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
				try
				{
					Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
					span = (T5)span_ptr.Target;
				}
				finally
				{
					span_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}

		/// <summary>
		/// Get separable convolution filter kernel images
		/// </summary>
		/// <param name="target">
		/// <para>
		/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to storage for the row filter image.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to storage for the column filter image.
		/// </para>
		/// </param>
		/// <param name="span">
		/// <para>
		/// Pointer to storage for the span filter image (currently unused).
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
		[Obsolete("Use GetSeparableFilter<T3, T4, T5> overload instead")]
		public static 
		void GetSeparableFilter<T4,T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] T4[] column, [InAttribute, OutAttribute] T5[,,] span)
			where T4 : struct
			where T5 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
				try
				{
					Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
				}
				finally
				{
					column_ptr.Free();
					span_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}

		/// <summary>
		/// Get separable convolution filter kernel images
		/// </summary>
		/// <param name="target">
		/// <para>
		/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to storage for the row filter image.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to storage for the column filter image.
		/// </para>
		/// </param>
		/// <param name="span">
		/// <para>
		/// Pointer to storage for the span filter image (currently unused).
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
		[Obsolete("Use GetSeparableFilter<T3, T4, T5> overload instead")]
		public static 
		void GetSeparableFilter<T4,T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] T4[,] column, [InAttribute, OutAttribute] T5[,,] span)
			where T4 : struct
			where T5 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
				try
				{
					Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
				}
				finally
				{
					column_ptr.Free();
					span_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}


		/// <summary>
		/// Get separable convolution filter kernel images
		/// </summary>
		/// <param name="target">
		/// <para>
		/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to storage for the row filter image.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to storage for the column filter image.
		/// </para>
		/// </param>
		/// <param name="span">
		/// <para>
		/// Pointer to storage for the span filter image (currently unused).
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
		[Obsolete("Use GetSeparableFilter<T3, T4, T5> overload instead")]
		public static 
		void GetSeparableFilter<T4,T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
			where T4 : struct
			where T5 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
				try
				{
					Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
				}
				finally
				{
					column_ptr.Free();
					span_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}


		/// <summary>
		/// Get separable convolution filter kernel images
		/// </summary>
		/// <param name="target">
		/// <para>
		/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to storage for the row filter image.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to storage for the column filter image.
		/// </para>
		/// </param>
		/// <param name="span">
		/// <para>
		/// Pointer to storage for the span filter image (currently unused).
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
		[Obsolete("Use GetSeparableFilter<T3, T4, T5> overload instead")]
		public static 
		void GetSeparableFilter<T4,T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] ref T4 column, [InAttribute, OutAttribute] T5[,,] span)
			where T4 : struct
			where T5 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
				try
				{
					Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
					column = (T4)column_ptr.Target;
				}
				finally
				{
					column_ptr.Free();
					span_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}

		/// <summary>
		/// Get separable convolution filter kernel images
		/// </summary>
		/// <param name="target">
		/// <para>
		/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to storage for the row filter image.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to storage for the column filter image.
		/// </para>
		/// </param>
		/// <param name="span">
		/// <para>
		/// Pointer to storage for the span filter image (currently unused).
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
		[Obsolete("Use GetSeparableFilter<T3, T4, T5> overload with equal array dimensions instead")]
		public static 
		void GetSeparableFilter<T3,T4,T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[] row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
			where T3 : struct
			where T4 : struct
			where T5 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
				try
				{
					Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
				}
				finally
				{
					row_ptr.Free();
					column_ptr.Free();
					span_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}


		/// <summary>
		/// Get separable convolution filter kernel images
		/// </summary>
		/// <param name="target">
		/// <para>
		/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to storage for the row filter image.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to storage for the column filter image.
		/// </para>
		/// </param>
		/// <param name="span">
		/// <para>
		/// Pointer to storage for the span filter image (currently unused).
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
		[Obsolete("Use GetSeparableFilter<T3, T4, T5> overload with equal array dimensions instead")]
		public static 
		void GetSeparableFilter<T3,T4,T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,] row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
			where T3 : struct
			where T4 : struct
			where T5 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
				try
				{
					Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
				}
				finally
				{
					row_ptr.Free();
					column_ptr.Free();
					span_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}

		/// <summary>
		/// Get separable convolution filter kernel images
		/// </summary>
		/// <param name="target">
		/// <para>
		/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to storage for the row filter image.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to storage for the column filter image.
		/// </para>
		/// </param>
		/// <param name="span">
		/// <para>
		/// Pointer to storage for the span filter image (currently unused).
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
		[Obsolete("Use GetSeparableFilter<T3, T4, T5> with three ref arguments instead")]
		public static 
		void GetSeparableFilter<T3,T4,T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T3 row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
			where T3 : struct
			where T4 : struct
			where T5 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
				try
				{
					Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
					row = (T3)row_ptr.Target;
				}
				finally
				{
					row_ptr.Free();
					column_ptr.Free();
					span_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}

		[System.CLSCompliant(false)]
		[AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glGetSynciv")]
		[Obsolete("Use out/array overload instead")]
		public static 
		unsafe void GetSync(IntPtr sync, OpenTK.Graphics.OpenGL.ArbSync pname, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32[] values)
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				fixed (Int32* values_ptr = values)
				{
					Delegates.glGetSynciv((IntPtr)sync, (OpenTK.Graphics.OpenGL.SyncParameterName)pname, (Int32)bufSize, (Int32*)length, (Int32*)values_ptr);
				}
				#if DEBUG
			}
			#endif
		}

		/// <summary>
		/// Define a separable two-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
		[Obsolete("Use overload with equal array dimensions instead")]
		public static 
		void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] T7[] column)
			where T7 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				try
				{
					Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
				}
				finally
				{
					column_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}


		/// <summary>
		/// Define a separable two-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
		[Obsolete("Use overload with equal array dimensions instead")]
		public static 
		void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] T7[,] column)
			where T7 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				try
				{
					Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
				}
				finally
				{
					column_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}


		/// <summary>
		/// Define a separable two-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
		[Obsolete("Use overload with equal array dimensions instead")]
		public static 
		void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] T7[,,] column)
			where T7 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				try
				{
					Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
				}
				finally
				{
					column_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}


		/// <summary>
		/// Define a separable two-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
		[Obsolete("Use overload with equal array dimensions instead")]
		public static 
		void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] ref T7 column)
			where T7 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				try
				{
					Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
					column = (T7)column_ptr.Target;
				}
				finally
				{
					column_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}


		/// <summary>
		/// Define a separable two-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
		[Obsolete("Use overload with equal array dimensions instead")]
		public static 
		void SeparableFilter2D<T6,T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[] row, [InAttribute, OutAttribute] T7[,,] column)
			where T6 : struct
			where T7 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				try
				{
					Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
				}
				finally
				{
					row_ptr.Free();
					column_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}


		/// <summary>
		/// Define a separable two-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
		[Obsolete("Use overload with equal array dimensions instead")]
		public static 
		void SeparableFilter2D<T6,T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,] row, [InAttribute, OutAttribute] T7[,,] column)
			where T6 : struct
			where T7 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				try
				{
					Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
				}
				finally
				{
					row_ptr.Free();
					column_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}

		/// <summary>
		/// Define a separable two-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
		/// </para>
		/// </param>
		[AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
		[Obsolete("Use overload with equal array dimensions instead")]
		public static 
		void SeparableFilter2D<T6,T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T6 row, [InAttribute, OutAttribute] T7[,,] column)
			where T6 : struct
			where T7 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				try
				{
					Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
					row = (T6)row_ptr.Target;
				}
				finally
				{
					row_ptr.Free();
					column_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}

		partial class Amd
		{
			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
			[Obsolete("Use ref/array overloads instead")]
			public static 
			unsafe void GetPerfMonitorCounterData(Int32 monitor, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, Int32 dataSize, [OutAttribute] Int32[] data, [OutAttribute] Int32* bytesWritten)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Int32* data_ptr = data)
					{
						Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (Int32)dataSize, (UInt32*)data_ptr, (Int32*)bytesWritten);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
			[Obsolete("Use ref/array overloads instead")]
			public static 
			unsafe void GetPerfMonitorCounterData(Int32 monitor, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, Int32 dataSize, [OutAttribute] UInt32[] data, [OutAttribute] Int32* bytesWritten)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (UInt32* data_ptr = data)
					{
						Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (Int32)dataSize, (UInt32*)data_ptr, (Int32*)bytesWritten);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
			[Obsolete("Use ref/array overloads instead")]
			public static 
			unsafe void GetPerfMonitorCounterData(UInt32 monitor, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, Int32 dataSize, [OutAttribute] UInt32[] data, [OutAttribute] Int32* bytesWritten)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (UInt32* data_ptr = data)
					{
						Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (Int32)dataSize, (UInt32*)data_ptr, (Int32*)bytesWritten);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCountersAMD")]
			[Obsolete("Use ref/array overloads instead")]
			public static 
			unsafe void GetPerfMonitorCounters(Int32 group, [OutAttribute] Int32* numCounters, [OutAttribute] Int32* maxActiveCounters, Int32 counterSize, [OutAttribute] Int32[] counters)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Int32* counters_ptr = counters)
					{
						Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters, (Int32*)maxActiveCounters, (Int32)counterSize, (UInt32*)counters_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCountersAMD")]
			[Obsolete("Use ref/array overloads instead")]
			public static 
			unsafe void GetPerfMonitorCounters(UInt32 group, [OutAttribute] Int32* numCounters, [OutAttribute] Int32* maxActiveCounters, Int32 counterSize, [OutAttribute] UInt32[] counters)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (UInt32* counters_ptr = counters)
					{
						Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters, (Int32*)maxActiveCounters, (Int32)counterSize, (UInt32*)counters_ptr);
					}
					#if DEBUG
				}
				#endif
			}


			[AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupsAMD")]
			[Obsolete("Use GetPerfMonitorGroups instead")]
			public static 
			void GetPerfMonitorGroup([OutAttribute] out Int32 numGroups, Int32 groupsSize, [OutAttribute] out Int32 groups)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int32* numGroups_ptr = &numGroups)
						fixed (Int32* groups_ptr = &groups)
						{
							Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups_ptr, (Int32)groupsSize, (UInt32*)groups_ptr);
							numGroups = *numGroups_ptr;
							groups = *groups_ptr;
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupsAMD")]
			[Obsolete("Use GetPerfMonitorGroups instead")]
			public static 
			void GetPerfMonitorGroup([OutAttribute] out Int32 numGroups, Int32 groupsSize, [OutAttribute] out UInt32 groups)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int32* numGroups_ptr = &numGroups)
						fixed (UInt32* groups_ptr = &groups)
						{
							Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups_ptr, (Int32)groupsSize, (UInt32*)groups_ptr);
							numGroups = *numGroups_ptr;
							groups = *groups_ptr;
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupsAMD")]
			[Obsolete("Use GetPerfMonitorGroups instead")]
			public static 
			unsafe void GetPerfMonitorGroup([OutAttribute] Int32* numGroups, Int32 groupsSize, [OutAttribute] Int32[] groups)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Int32* groups_ptr = groups)
					{
						Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups, (Int32)groupsSize, (UInt32*)groups_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupsAMD")]
			[Obsolete("Use GetPerfMonitorGroups instead")]
			public static 
			unsafe void GetPerfMonitorGroup([OutAttribute] Int32* numGroups, Int32 groupsSize, [OutAttribute] Int32* groups)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups, (Int32)groupsSize, (UInt32*)groups);
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupsAMD")]
			[Obsolete("Use GetPerfMonitorGroups instead")]
			public static 
			unsafe void GetPerfMonitorGroup([OutAttribute] Int32* numGroups, Int32 groupsSize, [OutAttribute] UInt32[] groups)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (UInt32* groups_ptr = groups)
					{
						Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups, (Int32)groupsSize, (UInt32*)groups_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupsAMD")]
			[Obsolete("Use GetPerfMonitorGroups instead")]
			public static 
			unsafe void GetPerfMonitorGroup([OutAttribute] Int32* numGroups, Int32 groupsSize, [OutAttribute] UInt32* groups)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups, (Int32)groupsSize, (UInt32*)groups);
					#if DEBUG
				}
				#endif
			}
		}

		partial class Arb
		{
			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetAttachedObjectsARB")]
			[Obsolete("Use ref/array overloads instead")]
			public static 
			unsafe void GetAttachedObjects(Int32 containerObj, Int32 maxCount, [OutAttribute] Int32* count, [OutAttribute] Int32[] obj)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Int32* obj_ptr = obj)
					{
						Delegates.glGetAttachedObjectsARB((UInt32)containerObj, (Int32)maxCount, (Int32*)count, (UInt32*)obj_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetAttachedObjectsARB")]
			[Obsolete("Use ref/array overloads instead")]
			public static 
			unsafe void GetAttachedObjects(UInt32 containerObj, Int32 maxCount, [OutAttribute] Int32* count, [OutAttribute] UInt32[] obj)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (UInt32* obj_ptr = obj)
					{
						Delegates.glGetAttachedObjectsARB((UInt32)containerObj, (Int32)maxCount, (Int32*)count, (UInt32*)obj_ptr);
					}
					#if DEBUG
				}
				#endif
			}
		}

		partial class Ati
		{
			[AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glPassTexCoordATI")]
			[Obsolete("Use PassTexCoord instead")]
			public static 
			void PassTexCoor(Int32 dst, Int32 coord, OpenTK.Graphics.OpenGL.AtiFragmentShader swizzle)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glPassTexCoordATI((UInt32)dst, (UInt32)coord, (OpenTK.Graphics.OpenGL.AtiFragmentShader)swizzle);
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glPassTexCoordATI")]
			[Obsolete("Use PassTexCoord instead")]
			public static 
			void PassTexCoor(UInt32 dst, UInt32 coord, OpenTK.Graphics.OpenGL.AtiFragmentShader swizzle)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glPassTexCoordATI((UInt32)dst, (UInt32)coord, (OpenTK.Graphics.OpenGL.AtiFragmentShader)swizzle);
					#if DEBUG
				}
				#endif
			}
		}

		partial class Ext
		{
			[AutoGenerated(Category = "ExtTimerQuery", Version = "1.5", EntryPoint = "glGetQueryObjecti64vEXT")]
			[Obsolete("Use GetQueryObject overload instead")]
			public static 
			void GetQueryObjecti64(Int32 id, OpenTK.Graphics.OpenGL.ExtTimerQuery pname, [OutAttribute] Int64[] @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int64* @params_ptr = @params)
						{
							Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtTimerQuery)pname, (Int64*)@params_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "ExtTimerQuery", Version = "1.5", EntryPoint = "glGetQueryObjecti64vEXT")]
			[Obsolete("Use GetQueryObject overload instead")]
			public static 
			void GetQueryObjecti64(Int32 id, OpenTK.Graphics.OpenGL.ExtTimerQuery pname, [OutAttribute] out Int64 @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int64* @params_ptr = &@params)
						{
							Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtTimerQuery)pname, (Int64*)@params_ptr);
							@params = *@params_ptr;
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "ExtTimerQuery", Version = "1.5", EntryPoint = "glGetQueryObjecti64vEXT")]
			[Obsolete("Use GetQueryObject overload instead")]
			public static 
			unsafe void GetQueryObjecti64(Int32 id, OpenTK.Graphics.OpenGL.ExtTimerQuery pname, [OutAttribute] Int64* @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtTimerQuery)pname, (Int64*)@params);
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "ExtTimerQuery", Version = "1.5", EntryPoint = "glGetQueryObjecti64vEXT")]
			[Obsolete("Use GetQueryObject overload instead")]
			public static 
			void GetQueryObjecti64(UInt32 id, OpenTK.Graphics.OpenGL.ExtTimerQuery pname, [OutAttribute] Int64[] @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int64* @params_ptr = @params)
						{
							Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtTimerQuery)pname, (Int64*)@params_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "ExtTimerQuery", Version = "1.5", EntryPoint = "glGetQueryObjecti64vEXT")]
			[Obsolete("Use GetQueryObject overload instead")]
			public static 
			void GetQueryObjecti64(UInt32 id, OpenTK.Graphics.OpenGL.ExtTimerQuery pname, [OutAttribute] out Int64 @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int64* @params_ptr = &@params)
						{
							Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtTimerQuery)pname, (Int64*)@params_ptr);
							@params = *@params_ptr;
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "ExtTimerQuery", Version = "1.5", EntryPoint = "glGetQueryObjecti64vEXT")]
			[Obsolete("Use GetQueryObject overload instead")]
			public static 
			unsafe void GetQueryObjecti64(UInt32 id, OpenTK.Graphics.OpenGL.ExtTimerQuery pname, [OutAttribute] Int64* @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtTimerQuery)pname, (Int64*)@params);
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "ExtTimerQuery", Version = "1.5", EntryPoint = "glGetQueryObjectui64vEXT")]
			[Obsolete("Use GetQueryObject overload instead")]
			public static 
			void GetQueryObjectui64(Int32 id, OpenTK.Graphics.OpenGL.ExtTimerQuery pname, [OutAttribute] Int64[] @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int64* @params_ptr = @params)
						{
							Delegates.glGetQueryObjectui64vEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtTimerQuery)pname, (UInt64*)@params_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "ExtTimerQuery", Version = "1.5", EntryPoint = "glGetQueryObjectui64vEXT")]
			[Obsolete("Use GetQueryObject overload instead")]
			public static 
			void GetQueryObjectui64(Int32 id, OpenTK.Graphics.OpenGL.ExtTimerQuery pname, [OutAttribute] out Int64 @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int64* @params_ptr = &@params)
						{
							Delegates.glGetQueryObjectui64vEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtTimerQuery)pname, (UInt64*)@params_ptr);
							@params = *@params_ptr;
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "ExtTimerQuery", Version = "1.5", EntryPoint = "glGetQueryObjectui64vEXT")]
			[Obsolete("Use GetQueryObject overload instead")]
			public static 
			unsafe void GetQueryObjectui64(Int32 id, OpenTK.Graphics.OpenGL.ExtTimerQuery pname, [OutAttribute] Int64* @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glGetQueryObjectui64vEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtTimerQuery)pname, (UInt64*)@params);
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "ExtTimerQuery", Version = "1.5", EntryPoint = "glGetQueryObjectui64vEXT")]
			[Obsolete("Use GetQueryObject overload instead")]
			public static 
			void GetQueryObjectui64(UInt32 id, OpenTK.Graphics.OpenGL.ExtTimerQuery pname, [OutAttribute] UInt64[] @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (UInt64* @params_ptr = @params)
						{
							Delegates.glGetQueryObjectui64vEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtTimerQuery)pname, (UInt64*)@params_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "ExtTimerQuery", Version = "1.5", EntryPoint = "glGetQueryObjectui64vEXT")]
			[Obsolete("Use GetQueryObject overload instead")]
			public static 
			void GetQueryObjectui64(UInt32 id, OpenTK.Graphics.OpenGL.ExtTimerQuery pname, [OutAttribute] out UInt64 @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (UInt64* @params_ptr = &@params)
						{
							Delegates.glGetQueryObjectui64vEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtTimerQuery)pname, (UInt64*)@params_ptr);
							@params = *@params_ptr;
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "ExtTimerQuery", Version = "1.5", EntryPoint = "glGetQueryObjectui64vEXT")]
			[Obsolete("Use GetQueryObject overload instead")]
			public static 
			unsafe void GetQueryObjectui64(UInt32 id, OpenTK.Graphics.OpenGL.ExtTimerQuery pname, [OutAttribute] UInt64* @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glGetQueryObjectui64vEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtTimerQuery)pname, (UInt64*)@params);
					#if DEBUG
				}
				#endif
			}

			/// <summary>
			/// Get separable convolution filter kernel images
			/// </summary>
			/// <param name="target">
			/// <para>
			/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to storage for the row filter image.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to storage for the column filter image.
			/// </para>
			/// </param>
			/// <param name="span">
			/// <para>
			/// Pointer to storage for the span filter image (currently unused).
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
			[Obsolete("Use GetSeparableFilter<T4, T5, T6> overloads instead")]
			public static 
			void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] T5[] span)
				where T5 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
					try
					{
						Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
					}
					finally
					{
						span_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}


			/// <summary>
			/// Get separable convolution filter kernel images
			/// </summary>
			/// <param name="target">
			/// <para>
			/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to storage for the row filter image.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to storage for the column filter image.
			/// </para>
			/// </param>
			/// <param name="span">
			/// <para>
			/// Pointer to storage for the span filter image (currently unused).
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
			[Obsolete("Use GetSeparableFilter<T4, T5, T6> overloads instead")]
			public static 
			void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] T5[,] span)
				where T5 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
					try
					{
						Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
					}
					finally
					{
						span_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}


			/// <summary>
			/// Get separable convolution filter kernel images
			/// </summary>
			/// <param name="target">
			/// <para>
			/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to storage for the row filter image.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to storage for the column filter image.
			/// </para>
			/// </param>
			/// <param name="span">
			/// <para>
			/// Pointer to storage for the span filter image (currently unused).
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
			[Obsolete("Use GetSeparableFilter<T4, T5, T6> overloads instead")]
			public static 
			void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] T5[,,] span)
				where T5 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
					try
					{
						Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
					}
					finally
					{
						span_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}

			/// <summary>
			/// Get separable convolution filter kernel images
			/// </summary>
			/// <param name="target">
			/// <para>
			/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to storage for the row filter image.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to storage for the column filter image.
			/// </para>
			/// </param>
			/// <param name="span">
			/// <para>
			/// Pointer to storage for the span filter image (currently unused).
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
			[Obsolete("Use GetSeparableFilter<T4, T5, T6> overloads instead")]
			public static 
			void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] ref T5 span)
				where T5 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
					try
					{
						Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
						span = (T5)span_ptr.Target;
					}
					finally
					{
						span_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}


			/// <summary>
			/// Get separable convolution filter kernel images
			/// </summary>
			/// <param name="target">
			/// <para>
			/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to storage for the row filter image.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to storage for the column filter image.
			/// </para>
			/// </param>
			/// <param name="span">
			/// <para>
			/// Pointer to storage for the span filter image (currently unused).
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
			[Obsolete("Use GetSeparableFilter<T4, T5, T6> overloads instead")]
			public static 
			void GetSeparableFilter<T4,T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] T4[] column, [InAttribute, OutAttribute] T5[,,] span)
				where T4 : struct
				where T5 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
					GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
					try
					{
						Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
					}
					finally
					{
						column_ptr.Free();
						span_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}


			/// <summary>
			/// Get separable convolution filter kernel images
			/// </summary>
			/// <param name="target">
			/// <para>
			/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to storage for the row filter image.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to storage for the column filter image.
			/// </para>
			/// </param>
			/// <param name="span">
			/// <para>
			/// Pointer to storage for the span filter image (currently unused).
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
			[Obsolete("Use GetSeparableFilter<T4, T5, T6> overloads instead")]
			public static 
			void GetSeparableFilter<T4,T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] T4[,] column, [InAttribute, OutAttribute] T5[,,] span)
				where T4 : struct
				where T5 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
					GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
					try
					{
						Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
					}
					finally
					{
						column_ptr.Free();
						span_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}


			/// <summary>
			/// Get separable convolution filter kernel images
			/// </summary>
			/// <param name="target">
			/// <para>
			/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to storage for the row filter image.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to storage for the column filter image.
			/// </para>
			/// </param>
			/// <param name="span">
			/// <para>
			/// Pointer to storage for the span filter image (currently unused).
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
			[Obsolete("Use GetSeparableFilter<T4, T5, T6> overloads instead")]
			public static 
			void GetSeparableFilter<T4,T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
				where T4 : struct
				where T5 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
					GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
					try
					{
						Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
					}
					finally
					{
						column_ptr.Free();
						span_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}


			/// <summary>
			/// Get separable convolution filter kernel images
			/// </summary>
			/// <param name="target">
			/// <para>
			/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to storage for the row filter image.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to storage for the column filter image.
			/// </para>
			/// </param>
			/// <param name="span">
			/// <para>
			/// Pointer to storage for the span filter image (currently unused).
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
			[Obsolete("Use GetSeparableFilter<T4, T5, T6> overloads instead")]
			public static 
			void GetSeparableFilter<T4,T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] ref T4 column, [InAttribute, OutAttribute] T5[,,] span)
				where T4 : struct
				where T5 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
					GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
					try
					{
						Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
						column = (T4)column_ptr.Target;
					}
					finally
					{
						column_ptr.Free();
						span_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}


			/// <summary>
			/// Get separable convolution filter kernel images
			/// </summary>
			/// <param name="target">
			/// <para>
			/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to storage for the row filter image.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to storage for the column filter image.
			/// </para>
			/// </param>
			/// <param name="span">
			/// <para>
			/// Pointer to storage for the span filter image (currently unused).
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
			[Obsolete("Use ref/array overloads instead")]
			public static 
			void GetSeparableFilter<T3,T4,T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[] row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
				where T3 : struct
				where T4 : struct
				where T5 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
					GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
					GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
					try
					{
						Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
					}
					finally
					{
						row_ptr.Free();
						column_ptr.Free();
						span_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}


			/// <summary>
			/// Get separable convolution filter kernel images
			/// </summary>
			/// <param name="target">
			/// <para>
			/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to storage for the row filter image.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to storage for the column filter image.
			/// </para>
			/// </param>
			/// <param name="span">
			/// <para>
			/// Pointer to storage for the span filter image (currently unused).
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
			[Obsolete("Use ref/array overloads instead")]
			public static 
			void GetSeparableFilter<T3,T4,T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,] row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
				where T3 : struct
				where T4 : struct
				where T5 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
					GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
					GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
					try
					{
						Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
					}
					finally
					{
						row_ptr.Free();
						column_ptr.Free();
						span_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}

			/// <summary>
			/// Get separable convolution filter kernel images
			/// </summary>
			/// <param name="target">
			/// <para>
			/// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to storage for the row filter image.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to storage for the column filter image.
			/// </para>
			/// </param>
			/// <param name="span">
			/// <para>
			/// Pointer to storage for the span filter image (currently unused).
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
			[Obsolete("Use ref/array overloads instead")]
			public static 
			void GetSeparableFilter<T3,T4,T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T3 row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
				where T3 : struct
				where T4 : struct
				where T5 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
					GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
					GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
					try
					{
						Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
					}
					finally
					{
						row_ptr.Free();
						column_ptr.Free();
						span_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}

			/// <summary>
			/// Define a separable two-dimensional convolution filter
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="internalformat">
			/// <para>
			/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
			/// </para>
			/// </param>
			/// <param name="width">
			/// <para>
			/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
			/// </para>
			/// </param>
			/// <param name="height">
			/// <para>
			/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
			[Obsolete("Use SeparableFilter2D<T6, T7> overloads instead")]
			public static 
			void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] T7[] column)
				where T7 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
					try
					{
						Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
					}
					finally
					{
						column_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}

			/// <summary>
			/// Define a separable two-dimensional convolution filter
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="internalformat">
			/// <para>
			/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
			/// </para>
			/// </param>
			/// <param name="width">
			/// <para>
			/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
			/// </para>
			/// </param>
			/// <param name="height">
			/// <para>
			/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
			[Obsolete("Use SeparableFilter2D<T6, T7> overloads instead")]
			public static 
			void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] T7[,] column)
				where T7 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
					try
					{
						Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
					}
					finally
					{
						column_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}

			/// <summary>
			/// Define a separable two-dimensional convolution filter
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="internalformat">
			/// <para>
			/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
			/// </para>
			/// </param>
			/// <param name="width">
			/// <para>
			/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
			/// </para>
			/// </param>
			/// <param name="height">
			/// <para>
			/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
			[Obsolete("Use SeparableFilter2D<T6, T7> overloads instead")]
			public static 
			void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] T7[,,] column)
				where T7 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
					try
					{
						Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
					}
					finally
					{
						column_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}


			/// <summary>
			/// Define a separable two-dimensional convolution filter
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="internalformat">
			/// <para>
			/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
			/// </para>
			/// </param>
			/// <param name="width">
			/// <para>
			/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
			/// </para>
			/// </param>
			/// <param name="height">
			/// <para>
			/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
			[Obsolete("Use SeparableFilter2D<T6, T7> overloads instead")]
			public static 
			void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] ref T7 column)
				where T7 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
					try
					{
						Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
						column = (T7)column_ptr.Target;
					}
					finally
					{
						column_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}


			/// <summary>
			/// Define a separable two-dimensional convolution filter
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="internalformat">
			/// <para>
			/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
			/// </para>
			/// </param>
			/// <param name="width">
			/// <para>
			/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
			/// </para>
			/// </param>
			/// <param name="height">
			/// <para>
			/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
			[Obsolete("Use ref/array overloads instead")]
			public static 
			void SeparableFilter2D<T6,T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[] row, [InAttribute, OutAttribute] T7[,,] column)
				where T6 : struct
				where T7 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
					GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
					try
					{
						Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
					}
					finally
					{
						row_ptr.Free();
						column_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}


			/// <summary>
			/// Define a separable two-dimensional convolution filter
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Must be GL_SEPARABLE_2D.
			/// </para>
			/// </param>
			/// <param name="internalformat">
			/// <para>
			/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
			/// </para>
			/// </param>
			/// <param name="width">
			/// <para>
			/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
			/// </para>
			/// </param>
			/// <param name="height">
			/// <para>
			/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
			/// </para>
			/// </param>
			/// <param name="format">
			/// <para>
			/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
			/// </para>
			/// </param>
			/// <param name="type">
			/// <para>
			/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
			/// </para>
			/// </param>
			/// <param name="row">
			/// <para>
			/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
			/// </para>
			/// </param>
			/// <param name="column">
			/// <para>
			/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
			/// </para>
			/// </param>
			[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
			[Obsolete("Use ref/array overloads instead")]
			public static 
			void SeparableFilter2D<T6,T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,] row, [InAttribute, OutAttribute] T7[,,] column)
				where T6 : struct
				where T7 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
					GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
					try
					{
						Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
					}
					finally
					{
						row_ptr.Free();
						column_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}
		}

		/// <summary>
		/// Define a separable two-dimensional convolution filter
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Must be GL_SEPARABLE_2D.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
		/// </para>
		/// </param>
		/// <param name="row">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
		/// </para>
		/// </param>
		/// <param name="column">
		/// <para>
		/// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
		/// </para>
		/// </param>
		[AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
		[Obsolete("Use ref/array overloads instead")]
		public static 
		void SeparableFilter2D<T6,T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T6 row, [InAttribute, OutAttribute] T7[,,] column)
			where T6 : struct
			where T7 : struct
		{
			#if DEBUG
			using (new ErrorHelper(GraphicsContext.CurrentContext))
			{
				#endif
				GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
				GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
				try
				{
					Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
					row = (T6)row_ptr.Target;
				}
				finally
				{
					row_ptr.Free();
					column_ptr.Free();
				}
				#if DEBUG
			}
			#endif
		}

		partial class Ibm
		{
			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawArraysIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			void MultiModeDrawArrays(OpenTK.Graphics.OpenGL.BeginMode[] mode, Int32[] first, Int32[] count, Int32 primcount, Int32 modestride)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = mode)
						fixed (Int32* first_ptr = first)
						fixed (Int32* count_ptr = count)
						{
							Delegates.glMultiModeDrawArraysIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode_ptr, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount, (Int32)modestride);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawArraysIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			void MultiModeDrawArrays(ref OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 first, ref Int32 count, Int32 primcount, Int32 modestride)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = &mode)
						fixed (Int32* first_ptr = &first)
						fixed (Int32* count_ptr = &count)
						{
							Delegates.glMultiModeDrawArraysIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode_ptr, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount, (Int32)modestride);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawArraysIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			unsafe void MultiModeDrawArrays(OpenTK.Graphics.OpenGL.BeginMode* mode, Int32* first, Int32* count, Int32 primcount, Int32 modestride)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glMultiModeDrawArraysIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode, (Int32*)first, (Int32*)count, (Int32)primcount, (Int32)modestride);
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			void MultiModeDrawElements(OpenTK.Graphics.OpenGL.BeginMode[] mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount, Int32 modestride)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = mode)
						fixed (Int32* count_ptr = count)
						{
							Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount, (Int32)modestride);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode[] mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount, Int32 modestride)
				where T3 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = mode)
						fixed (Int32* count_ptr = count)
						{
							GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
							try
							{
								Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
							}
							finally
							{
								indices_ptr.Free();
							}
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode[] mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount, Int32 modestride)
				where T3 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = mode)
						fixed (Int32* count_ptr = count)
						{
							GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
							try
							{
								Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
							}
							finally
							{
								indices_ptr.Free();
							}
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode[] mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount, Int32 modestride)
				where T3 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = mode)
						fixed (Int32* count_ptr = count)
						{
							GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
							try
							{
								Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
							}
							finally
							{
								indices_ptr.Free();
							}
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode[] mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount, Int32 modestride)
				where T3 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = mode)
						fixed (Int32* count_ptr = count)
						{
							GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
							try
							{
								Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
								indices = (T3)indices_ptr.Target;
							}
							finally
							{
								indices_ptr.Free();
							}
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			void MultiModeDrawElements(ref OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount, Int32 modestride)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = &mode)
						fixed (Int32* count_ptr = &count)
						{
							Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount, (Int32)modestride);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			void MultiModeDrawElements<T3>(ref OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount, Int32 modestride)
				where T3 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = &mode)
						fixed (Int32* count_ptr = &count)
						{
							GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
							try
							{
								Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
							}
							finally
							{
								indices_ptr.Free();
							}
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			void MultiModeDrawElements<T3>(ref OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount, Int32 modestride)
				where T3 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = &mode)
						fixed (Int32* count_ptr = &count)
						{
							GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
							try
							{
								Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
							}
							finally
							{
								indices_ptr.Free();
							}
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			void MultiModeDrawElements<T3>(ref OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount, Int32 modestride)
				where T3 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = &mode)
						fixed (Int32* count_ptr = &count)
						{
							GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
							try
							{
								Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
							}
							finally
							{
								indices_ptr.Free();
							}
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			void MultiModeDrawElements<T3>(ref OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount, Int32 modestride)
				where T3 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = &mode)
						fixed (Int32* count_ptr = &count)
						{
							GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
							try
							{
								Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
								indices = (T3)indices_ptr.Target;
							}
							finally
							{
								indices_ptr.Free();
							}
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			unsafe void MultiModeDrawElements(OpenTK.Graphics.OpenGL.BeginMode* mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount, Int32 modestride)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount, (Int32)modestride);
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			unsafe void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode* mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount, Int32 modestride)
				where T3 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
					try
					{
						Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
					}
					finally
					{
						indices_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			unsafe void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode* mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount, Int32 modestride)
				where T3 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
					try
					{
						Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
					}
					finally
					{
						indices_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			unsafe void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode* mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount, Int32 modestride)
				where T3 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
					try
					{
						Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
					}
					finally
					{
						indices_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
			[Obsolete("Use PrimitiveType overload instead")]
			public static 
			unsafe void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode* mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount, Int32 modestride)
				where T3 : struct
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
					try
					{
						Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.PrimitiveType*)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
						indices = (T3)indices_ptr.Target;
					}
					finally
					{
						indices_ptr.Free();
					}
					#if DEBUG
				}
				#endif
			}
		}

		partial class NV
		{
			[AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDeleteTransformFeedbacksNV")]
			[Obsolete("Use DeleteTransformFeedbacks overload instead")]
			public static 
			void DeleteTransformFeedback(Int32 n, Int32[] ids)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int32* ids_ptr = ids)
						{
							Delegates.glDeleteTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDeleteTransformFeedbacksNV")]
			[Obsolete("Use DeleteTransformFeedbacks overload instead")]
			public static 
			void DeleteTransformFeedback(Int32 n, ref Int32 ids)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int32* ids_ptr = &ids)
						{
							Delegates.glDeleteTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDeleteTransformFeedbacksNV")]
			[Obsolete("Use DeleteTransformFeedbacks overload instead")]
			public static 
			unsafe void DeleteTransformFeedback(Int32 n, Int32* ids)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glDeleteTransformFeedbacksNV((Int32)n, (UInt32*)ids);
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDeleteTransformFeedbacksNV")]
			[Obsolete("Use DeleteTransformFeedbacks overload instead")]
			public static 
			void DeleteTransformFeedback(Int32 n, UInt32[] ids)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (UInt32* ids_ptr = ids)
						{
							Delegates.glDeleteTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDeleteTransformFeedbacksNV")]
			[Obsolete("Use DeleteTransformFeedbacks overload instead")]
			public static 
			void DeleteTransformFeedback(Int32 n, ref UInt32 ids)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (UInt32* ids_ptr = &ids)
						{
							Delegates.glDeleteTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDeleteTransformFeedbacksNV")]
			[Obsolete("Use DeleteTransformFeedbacks overload instead")]
			public static 
			unsafe void DeleteTransformFeedback(Int32 n, UInt32* ids)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glDeleteTransformFeedbacksNV((Int32)n, (UInt32*)ids);
					#if DEBUG
				}
				#endif
			}


			[AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glGenTransformFeedbacksNV")]
			[Obsolete("Use GenTransformFeedbacks overload instead")]
			public static 
			void GenTransformFeedback(Int32 n, [OutAttribute] Int32[] ids)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int32* ids_ptr = ids)
						{
							Delegates.glGenTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glGenTransformFeedbacksNV")]
			[Obsolete("Use GenTransformFeedbacks overload instead")]
			public static 
			void GenTransformFeedback(Int32 n, [OutAttribute] out Int32 ids)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int32* ids_ptr = &ids)
						{
							Delegates.glGenTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
							ids = *ids_ptr;
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glGenTransformFeedbacksNV")]
			[Obsolete("Use GenTransformFeedbacks overload instead")]
			public static 
			unsafe void GenTransformFeedback(Int32 n, [OutAttribute] Int32* ids)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glGenTransformFeedbacksNV((Int32)n, (UInt32*)ids);
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glGenTransformFeedbacksNV")]
			[Obsolete("Use GenTransformFeedbacks overload instead")]
			public static 
			void GenTransformFeedback(Int32 n, [OutAttribute] UInt32[] ids)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (UInt32* ids_ptr = ids)
						{
							Delegates.glGenTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glGenTransformFeedbacksNV")]
			[Obsolete("Use GenTransformFeedbacks overload instead")]
			public static 
			void GenTransformFeedback(Int32 n, [OutAttribute] out UInt32 ids)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (UInt32* ids_ptr = &ids)
						{
							Delegates.glGenTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
							ids = *ids_ptr;
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glGenTransformFeedbacksNV")]
			[Obsolete("Use GenTransformFeedbacks overload instead")]
			public static 
			unsafe void GenTransformFeedback(Int32 n, [OutAttribute] UInt32* ids)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glGenTransformFeedbacksNV((Int32)n, (UInt32*)ids);
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterdvNV")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void GetProgramNamedParameter(Int32 id, Int32 len, Byte* name, [OutAttribute] Double[] @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Double* @params_ptr = @params)
					{
						Delegates.glGetProgramNamedParameterdvNV((UInt32)id, (Int32)len, (Byte*)name, (Double*)@params_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterdvNV")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void GetProgramNamedParameter(UInt32 id, Int32 len, Byte* name, [OutAttribute] Double[] @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Double* @params_ptr = @params)
					{
						Delegates.glGetProgramNamedParameterdvNV((UInt32)id, (Int32)len, (Byte*)name, (Double*)@params_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterfvNV")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void GetProgramNamedParameter(Int32 id, Int32 len, Byte* name, [OutAttribute] Single[] @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* @params_ptr = @params)
					{
						Delegates.glGetProgramNamedParameterfvNV((UInt32)id, (Int32)len, (Byte*)name, (Single*)@params_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterfvNV")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void GetProgramNamedParameter(UInt32 id, Int32 len, Byte* name, [OutAttribute] Single[] @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* @params_ptr = @params)
					{
						Delegates.glGetProgramNamedParameterfvNV((UInt32)id, (Int32)len, (Byte*)name, (Single*)@params_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoi64vNV")]
			[Obsolete("Use GetVideo overload instead")]
			public static 
			void GetVideoi64(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int64[] @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int64* @params_ptr = @params)
						{
							Delegates.glGetVideoi64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int64*)@params_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoi64vNV")]
			[Obsolete("Use GetVideo overload instead")]
			public static 
			void GetVideoi64(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] out Int64 @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int64* @params_ptr = &@params)
						{
							Delegates.glGetVideoi64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int64*)@params_ptr);
							@params = *@params_ptr;
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoi64vNV")]
			[Obsolete("Use GetVideo overload instead")]
			public static 
			unsafe void GetVideoi64(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int64* @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glGetVideoi64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int64*)@params);
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoi64vNV")]
			[Obsolete("Use GetVideo overload instead")]
			public static 
			void GetVideoi64(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int64[] @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int64* @params_ptr = @params)
						{
							Delegates.glGetVideoi64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int64*)@params_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoi64vNV")]
			[Obsolete("Use GetVideo overload instead")]
			public static 
			void GetVideoi64(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] out Int64 @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int64* @params_ptr = &@params)
						{
							Delegates.glGetVideoi64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int64*)@params_ptr);
							@params = *@params_ptr;
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoi64vNV")]
			[Obsolete("Use GetVideo overload instead")]
			public static 
			unsafe void GetVideoi64(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int64* @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glGetVideoi64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int64*)@params);
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoui64vNV")]
			[Obsolete("Use GetVideo overload instead")]
			public static 
			void GetVideoui64(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int64[] @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int64* @params_ptr = @params)
						{
							Delegates.glGetVideoui64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt64*)@params_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoui64vNV")]
			[Obsolete("Use GetVideo overload instead")]
			public static 
			void GetVideoui64(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] out Int64 @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (Int64* @params_ptr = &@params)
						{
							Delegates.glGetVideoui64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt64*)@params_ptr);
							@params = *@params_ptr;
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoui64vNV")]
			[Obsolete("Use GetVideo overload instead")]
			public static 
			unsafe void GetVideoui64(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int64* @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glGetVideoui64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt64*)@params);
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoui64vNV")]
			[Obsolete("Use GetVideo overload instead")]
			public static 
			void GetVideoui64(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] UInt64[] @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (UInt64* @params_ptr = @params)
						{
							Delegates.glGetVideoui64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt64*)@params_ptr);
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoui64vNV")]
			[Obsolete("Use GetVideo overload instead")]
			public static 
			void GetVideoui64(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] out UInt64 @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					unsafe
					{
						fixed (UInt64* @params_ptr = &@params)
						{
							Delegates.glGetVideoui64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt64*)@params_ptr);
							@params = *@params_ptr;
						}
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoui64vNV")]
			[Obsolete("Use GetVideo overload instead")]
			public static 
			unsafe void GetVideoui64(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] UInt64* @params)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					Delegates.glGetVideoui64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt64*)@params);
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4dvNV")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ProgramNamedParameter4(Int32 id, Int32 len, Byte* name, Double[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Double* v_ptr = v)
					{
						Delegates.glProgramNamedParameter4dvNV((UInt32)id, (Int32)len, (Byte*)name, (Double*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4dvNV")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ProgramNamedParameter4(UInt32 id, Int32 len, Byte* name, Double[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Double* v_ptr = v)
					{
						Delegates.glProgramNamedParameter4dvNV((UInt32)id, (Int32)len, (Byte*)name, (Double*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4fvNV")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ProgramNamedParameter4(Int32 id, Int32 len, Byte* name, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* v_ptr = v)
					{
						Delegates.glProgramNamedParameter4fvNV((UInt32)id, (Int32)len, (Byte*)name, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4fvNV")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ProgramNamedParameter4(UInt32 id, Int32 len, Byte* name, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* v_ptr = v)
					{
						Delegates.glProgramNamedParameter4fvNV((UInt32)id, (Int32)len, (Byte*)name, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}
		}

		partial class Sun
		{
			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor3fVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiColor3fVertex3(Int32* rc, Single[] c, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* c_ptr = c)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiColor3fVertex3fvSUN((UInt32*)rc, (Single*)c_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor3fVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiColor3fVertex3(UInt32* rc, Single[] c, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* c_ptr = c)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiColor3fVertex3fvSUN((UInt32*)rc, (Single*)c_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4fNormal3fVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiColor4fNormal3fVertex3(Int32* rc, Single[] c, Single[] n, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* c_ptr = c)
					fixed (Single* n_ptr = n)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiColor4fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4fNormal3fVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiColor4fNormal3fVertex3(UInt32* rc, Single[] c, Single[] n, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* c_ptr = c)
					fixed (Single* n_ptr = n)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiColor4fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4ubVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiColor4ubVertex3(Int32* rc, Byte[] c, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Byte* c_ptr = c)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiColor4ubVertex3fvSUN((UInt32*)rc, (Byte*)c_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4ubVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiColor4ubVertex3(UInt32* rc, Byte[] c, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Byte* c_ptr = c)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiColor4ubVertex3fvSUN((UInt32*)rc, (Byte*)c_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiNormal3fVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiNormal3fVertex3(Int32* rc, Single[] n, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* n_ptr = n)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiNormal3fVertex3fvSUN((UInt32*)rc, (Single*)n_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiNormal3fVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiNormal3fVertex3(UInt32* rc, Single[] n, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* n_ptr = n)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiNormal3fVertex3fvSUN((UInt32*)rc, (Single*)n_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3(Int32* rc, Single[] tc, Single[] c, Single[] n, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* tc_ptr = tc)
					fixed (Single* c_ptr = c)
					fixed (Single* n_ptr = n)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)tc_ptr, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3(UInt32* rc, Single[] tc, Single[] c, Single[] n, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* tc_ptr = tc)
					fixed (Single* c_ptr = c)
					fixed (Single* n_ptr = n)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)tc_ptr, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiTexCoord2fNormal3fVertex3(Int32* rc, Single[] tc, Single[] n, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* tc_ptr = tc)
					fixed (Single* n_ptr = n)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)tc_ptr, (Single*)n_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiTexCoord2fNormal3fVertex3(UInt32* rc, Single[] tc, Single[] n, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* tc_ptr = tc)
					fixed (Single* n_ptr = n)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)tc_ptr, (Single*)n_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiTexCoord2fVertex3(Int32* rc, Single[] tc, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* tc_ptr = tc)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiTexCoord2fVertex3fvSUN((UInt32*)rc, (Single*)tc_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiTexCoord2fVertex3(UInt32* rc, Single[] tc, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* tc_ptr = tc)
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiTexCoord2fVertex3fvSUN((UInt32*)rc, (Single*)tc_ptr, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiVertex3(Int32* rc, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiVertex3fvSUN((UInt32*)rc, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}

			[System.CLSCompliant(false)]
			[AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiVertex3fvSUN")]
			[Obsolete("Use ref/array overload instead")]
			public static 
			unsafe void ReplacementCodeuiVertex3(UInt32* rc, Single[] v)
			{
				#if DEBUG
				using (new ErrorHelper(GraphicsContext.CurrentContext))
				{
					#endif
					fixed (Single* v_ptr = v)
					{
						Delegates.glReplacementCodeuiVertex3fvSUN((UInt32*)rc, (Single*)v_ptr);
					}
					#if DEBUG
				}
				#endif
			}
		}
    }
}

