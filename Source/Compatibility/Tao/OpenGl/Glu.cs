#region License
/*
MIT License
Copyright ©2003-2006 Tao Framework Team
http://www.taoframework.com
All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#endregion License

using System;
using System.Runtime.InteropServices;
using System.Security;

#pragma warning disable 169 // private field is never used

namespace Tao.OpenGl
{
    #region Class Documentation
    /// <summary>
    ///     GLU (OpenGL Utility) binding for .NET, implementing GLU 1.3.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         Binds functions and definitions in glu32.dll or libGLU.so.
    ///     </para>
    ///     <para>
    ///         The OpenGL Utility (GLU) library contains several groups of functions that
    ///         complement the core OpenGL interface by providing support for auxiliary features.
    ///         These features include: mipmapping, matrix manipulation, polygon tessellation,
    ///         quadrics, NURBS, and error handling.
    ///     </para>
    ///     <para>
    ///         Mipmapping routines include image scaling and automatic mipmap generation.  A
    ///         variety of matrix manipulation functions build projection and viewing matrices,
    ///         or project vertices from one coordinate system to another.  Polygon tessellation
    ///         routines convert concave polygons into triangles for easy rendering.  Quadrics
    ///         support renders a few basic quadrics such as spheres and cones.  NURBS code maps
    ///         complicated NURBS curves and trimmed surfaces into simpler OpenGL evaluators.
    ///         Lastly, an error lookup routine translates OpenGL and GLU error codes into
    ///         strings.  GLU library routines may call OpenGL library routines.  Thus, an OpenGL
    ///         context should be made current before calling any GLU functions.  Otherwise an
    ///         OpenGL error may occur.
    ///     </para>
    ///     <para>
    ///         These utility functions make use of core OpenGL functions, so any OpenGL
    ///         implementation is guaranteed to support the utility functions.
    ///     </para>
    /// </remarks>
    #endregion Class Documentation
    [Obsolete]
    public static class Glu
    {
        // --- Fields ---
        #region Private Constants
        #region CallingConvention CALLING_CONVENTION
        /// <summary>
        ///     Specifies the calling convention.
        /// </summary>
        /// <remarks>
        ///     Specifies <see cref="CallingConvention.Winapi" /> for Windows and
        ///     Linux, to indicate that the default should be used.
        /// </remarks>
        private const CallingConvention CALLING_CONVENTION = CallingConvention.Winapi;
        #endregion CallingConvention CALLING_CONVENTION
        #endregion Private Constants

        #region Public Constants
        #region Version
        #region bool GLU_VERSION_1_1
        /// <summary>
        ///     GLU API revision.
        /// </summary>
        /// <remarks>
        ///     Specifies GLU 1.1.
        /// </remarks>
        // #define GLU_VERSION_1_1 1
        public const bool GLU_VERSION_1_1 = true;
        #endregion bool GLU_VERSION_1_1

        #region bool GLU_VERSION_1_2
        /// <summary>
        ///     GLU API revision.
        /// </summary>
        /// <remarks>
        ///     Specifies GLU 1.2.
        /// </remarks>
        // #define GLU_VERSION_1_2 1
        public const bool GLU_VERSION_1_2 = true;
        #endregion bool GLU_VERSION_1_2

        #region bool GLU_VERSION_1_3
        /// <summary>
        ///     GLU API revision.
        /// </summary>
        /// <remarks>
        ///     Specifies GLU 1.3.
        /// </remarks>
        // #define GLU_VERSION_1_3 1
        public const bool GLU_VERSION_1_3 = true;
        #endregion bool GLU_VERSION_1_3
        #endregion Version

        #region Errors
        #region int GLU_INVALID_ENUM
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_INVALID_ENUM 100900
        public const int GLU_INVALID_ENUM = 100900;
        #endregion int GLU_INVALID_ENUM

        #region int GLU_INVALID_VALUE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_INVALID_VALUE 100901
        public const int GLU_INVALID_VALUE = 100901;
        #endregion int GLU_INVALID_VALUE

        #region int GLU_OUT_OF_MEMORY
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_OUT_OF_MEMORY 100902
        public const int GLU_OUT_OF_MEMORY = 100902;
        #endregion int GLU_OUT_OF_MEMORY

        #region int GLU_INCOMPATIBLE_GL_VERSION
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_INCOMPATIBLE_GL_VERSION 100903
        public const int GLU_INCOMPATIBLE_GL_VERSION = 100903;
        #endregion int GLU_INCOMPATIBLE_GL_VERSION

        #region int GLU_INVALID_OPERATION
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_INVALID_OPERATION 100904
        public const int GLU_INVALID_OPERATION = 100904;
        #endregion int GLU_INVALID_OPERATION
        #endregion Errors

        #region StringName
        #region int GLU_VERSION
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_VERSION 100800
        public const int GLU_VERSION = 100800;
        #endregion int GLU_VERSION

        #region int GLU_EXTENSIONS
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_EXTENSIONS 100801
        public const int GLU_EXTENSIONS = 100801;
        #endregion int GLU_EXTENSIONS
        #endregion StringName

        #region bool
        #region int GLU_TRUE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TRUE GL_TRUE
        public const int GLU_TRUE = 1;
        #endregion int GLU_TRUE

        #region int GLU_FALSE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_FALSE GL_FALSE
        public const int GLU_FALSE = 0;
        #endregion int GLU_FALSE
        #endregion bool

        #region QuadricNormal
        #region int GLU_SMOOTH
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_SMOOTH 100000
        public const int GLU_SMOOTH = 100000;
        #endregion int GLU_SMOOTH

        #region int GLU_FLAT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_FLAT 100001
        public const int GLU_FLAT = 100001;
        #endregion int GLU_FLAT

        #region int GLU_NONE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NONE 100002
        public const int GLU_NONE = 100002;
        #endregion int GLU_NONE
        #endregion QuadricNormal

        #region QuadricDrawStyle
        #region int GLU_POINT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_POINT 100010
        public const int GLU_POINT = 100010;
        #endregion int GLU_POINT

        #region int GLU_LINE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_LINE 100011
        public const int GLU_LINE = 100011;
        #endregion int GLU_LINE

        #region int GLU_FILL
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_FILL 100012
        public const int GLU_FILL = 100012;
        #endregion int GLU_FILL

        #region int GLU_SILHOUETTE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_SILHOUETTE 100013
        public const int GLU_SILHOUETTE = 100013;
        #endregion int GLU_SILHOUETTE
        #endregion QuadricDrawStyle

        #region QuadraticOrientation
        #region int GLU_OUTSIDE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_OUTSIDE 100020
        public const int GLU_OUTSIDE = 100020;
        #endregion int GLU_OUTSIDE

        #region int GLU_INSIDE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_INSIDE 100021
        public const int GLU_INSIDE = 100021;
        #endregion int GLU_INSIDE
        #endregion QuadraticOrientation

        #region Tesselation Limits
        #region double GLU_TESS_MAX_COORD
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_MAX_COORD 1.0e150
        public const double GLU_TESS_MAX_COORD = 1.0e150;
        #endregion double GLU_TESS_MAX_COORD
        #endregion Tesselation Limits

        #region TessProperty
        #region int GLU_TESS_WINDING_RULE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_WINDING_RULE 100140
        public const int GLU_TESS_WINDING_RULE = 100140;
        #endregion int GLU_TESS_WINDING_RULE

        #region int GLU_TESS_BOUNDARY_ONLY
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_BOUNDARY_ONLY 100141
        public const int GLU_TESS_BOUNDARY_ONLY = 100141;
        #endregion int GLU_TESS_BOUNDARY_ONLY

        #region int GLU_TESS_TOLERANCE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_TOLERANCE 100142
        public const int GLU_TESS_TOLERANCE = 100142;
        #endregion int GLU_TESS_TOLERANCE
        #endregion TessProperty

        #region TessWinding
        #region int GLU_TESS_WINDING_ODD
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_WINDING_ODD 100130
        public const int GLU_TESS_WINDING_ODD = 100130;
        #endregion int GLU_TESS_WINDING_ODD

        #region int GLU_TESS_WINDING_NONZERO
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_WINDING_NONZERO 100131
        public const int GLU_TESS_WINDING_NONZERO = 100131;
        #endregion int GLU_TESS_WINDING_NONZERO

        #region int GLU_TESS_WINDING_POSITIVE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_WINDING_POSITIVE 100132
        public const int GLU_TESS_WINDING_POSITIVE = 100132;
        #endregion int GLU_TESS_WINDING_POSITIVE

        #region int GLU_TESS_WINDING_NEGATIVE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_WINDING_NEGATIVE 100133
        public const int GLU_TESS_WINDING_NEGATIVE = 100133;
        #endregion int GLU_TESS_WINDING_NEGATIVE

        #region int GLU_TESS_WINDING_ABS_GEQ_TWO
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_WINDING_ABS_GEQ_TWO 100134
        public const int GLU_TESS_WINDING_ABS_GEQ_TWO = 100134;
        #endregion int GLU_TESS_WINDING_ABS_GEQ_TWO
        #endregion TessWinding

        #region TessCallback
        #region int GLU_TESS_BEGIN
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_BEGIN 100100
        public const int GLU_TESS_BEGIN = 100100;
        #endregion int GLU_TESS_BEGIN

        #region int GLU_BEGIN
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_BEGIN 100100
        public const int GLU_BEGIN = 100100;
        #endregion int GLU_BEGIN

        #region int GLU_TESS_VERTEX
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_VERTEX 100101
        public const int GLU_TESS_VERTEX = 100101;
        #endregion int GLU_TESS_VERTEX

        #region int GLU_VERTEX
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_VERTEX 100101
        public const int GLU_VERTEX = 100101;
        #endregion int GLU_VERTEX

        #region int GLU_TESS_END
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_END 100102
        public const int GLU_TESS_END = 100102;
        #endregion int GLU_TESS_END

        #region int GLU_END
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_END 100102
        public const int GLU_END = 100102;
        #endregion int GLU_END

        #region int GLU_TESS_ERROR
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_ERROR 100103
        public const int GLU_TESS_ERROR = 100103;
        #endregion int GLU_TESS_ERROR

        #region int GLU_TESS_EDGE_FLAG
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_EDGE_FLAG 100104
        public const int GLU_TESS_EDGE_FLAG = 100104;
        #endregion int GLU_TESS_EDGE_FLAG

        #region int GLU_EDGE_FLAG
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_EDGE_FLAG 100104
        public const int GLU_EDGE_FLAG = 100104;
        #endregion int GLU_EDGE_FLAG

        #region int GLU_TESS_COMBINE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_COMBINE 100105
        public const int GLU_TESS_COMBINE = 100105;
        #endregion int GLU_TESS_COMBINE

        #region int GLU_TESS_BEGIN_DATA
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_BEGIN_DATA 100106
        public const int GLU_TESS_BEGIN_DATA = 100106;
        #endregion int GLU_TESS_BEGIN_DATA

        #region int GLU_TESS_VERTEX_DATA
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_VERTEX_DATA 100107
        public const int GLU_TESS_VERTEX_DATA = 100107;
        #endregion int GLU_TESS_VERTEX_DATA

        #region int GLU_TESS_END_DATA
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_END_DATA 100108
        public const int GLU_TESS_END_DATA = 100108;
        #endregion int GLU_TESS_END_DATA

        #region int GLU_TESS_ERROR_DATA
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_ERROR_DATA 100109
        public const int GLU_TESS_ERROR_DATA = 100109;
        #endregion int GLU_TESS_ERROR_DATA

        #region int GLU_TESS_EDGE_FLAG_DATA
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_EDGE_FLAG_DATA 100110
        public const int GLU_TESS_EDGE_FLAG_DATA = 100110;
        #endregion int GLU_TESS_EDGE_FLAG_DATA

        #region int GLU_TESS_COMBINE_DATA
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_COMBINE_DATA 100111
        public const int GLU_TESS_COMBINE_DATA = 100111;
        #endregion int GLU_TESS_COMBINE_DATA
        #endregion TessCallback

        #region TessError
        #region int GLU_TESS_ERROR1
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_ERROR1 100151
        public const int GLU_TESS_ERROR1 = 100151;
        #endregion int GLU_TESS_ERROR1

        #region int GLU_TESS_ERROR2
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_ERROR2 100152
        public const int GLU_TESS_ERROR2 = 100152;
        #endregion int GLU_TESS_ERROR2

        #region int GLU_TESS_ERROR3
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_ERROR3 100153
        public const int GLU_TESS_ERROR3 = 100153;
        #endregion int GLU_TESS_ERROR3

        #region int GLU_TESS_ERROR4
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_ERROR4 100154
        public const int GLU_TESS_ERROR4 = 100154;
        #endregion int GLU_TESS_ERROR4

        #region int GLU_TESS_ERROR5
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_ERROR5 100155
        public const int GLU_TESS_ERROR5 = 100155;
        #endregion int GLU_TESS_ERROR5

        #region int GLU_TESS_ERROR6
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_ERROR6 100156
        public const int GLU_TESS_ERROR6 = 100156;
        #endregion int GLU_TESS_ERROR6

        #region int GLU_TESS_ERROR7
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_ERROR7 100157
        public const int GLU_TESS_ERROR7 = 100157;
        #endregion int GLU_TESS_ERROR7

        #region int GLU_TESS_ERROR8
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_ERROR8 100158
        public const int GLU_TESS_ERROR8 = 100158;
        #endregion int GLU_TESS_ERROR8

        #region int GLU_TESS_MISSING_BEGIN_POLYGON
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_MISSING_BEGIN_POLYGON GLU_TESS_ERROR1
        public const int GLU_TESS_MISSING_BEGIN_POLYGON = GLU_TESS_ERROR1;
        #endregion int GLU_TESS_MISSING_BEGIN_POLYGON

        #region int GLU_TESS_MISSING_BEGIN_CONTOUR
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_MISSING_BEGIN_CONTOUR GLU_TESS_ERROR2
        public const int GLU_TESS_MISSING_BEGIN_CONTOUR = GLU_TESS_ERROR2;
        #endregion int GLU_TESS_MISSING_BEGIN_CONTOUR

        #region int GLU_TESS_MISSING_END_POLYGON
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_MISSING_END_POLYGON GLU_TESS_ERROR3
        public const int GLU_TESS_MISSING_END_POLYGON = GLU_TESS_ERROR3;
        #endregion int GLU_TESS_MISSING_END_POLYGON

        #region int GLU_TESS_MISSING_END_CONTOUR
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_MISSING_END_CONTOUR GLU_TESS_ERROR4
        public const int GLU_TESS_MISSING_END_CONTOUR = GLU_TESS_ERROR4;
        #endregion int GLU_TESS_MISSING_END_CONTOUR

        #region int GLU_TESS_COORD_TOO_LARGE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_COORD_TOO_LARGE GLU_TESS_ERROR5
        public const int GLU_TESS_COORD_TOO_LARGE = GLU_TESS_ERROR5;
        #endregion int GLU_TESS_COORD_TOO_LARGE

        #region int GLU_TESS_NEED_COMBINE_CALLBACK
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_TESS_NEED_COMBINE_CALLBACK GLU_TESS_ERROR6
        public const int GLU_TESS_NEED_COMBINE_CALLBACK = GLU_TESS_ERROR6;
        #endregion int GLU_TESS_NEED_COMBINE_CALLBACK
        #endregion TessError

        #region NurbsProperty
        #region int GLU_AUTO_LOAD_MATRIX
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_AUTO_LOAD_MATRIX 100200
        public const int GLU_AUTO_LOAD_MATRIX = 100200;
        #endregion int GLU_AUTO_LOAD_MATRIX

        #region int GLU_CULLING
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_CULLING 100201
        public const int GLU_CULLING = 100201;
        #endregion int GLU_CULLING

        #region int GLU_PARAMETRIC_TOLERANCE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_PARAMETRIC_TOLERANCE 100202
        public const int GLU_PARAMETRIC_TOLERANCE = 100202;
        #endregion int GLU_PARAMETRIC_TOLERANCE

        #region int GLU_SAMPLING_TOLERANCE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_SAMPLING_TOLERANCE 100203
        public const int GLU_SAMPLING_TOLERANCE = 100203;
        #endregion int GLU_SAMPLING_TOLERANCE

        #region int GLU_DISPLAY_MODE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_DISPLAY_MODE 100204
        public const int GLU_DISPLAY_MODE = 100204;
        #endregion int GLU_DISPLAY_MODE

        #region int GLU_SAMPLING_METHOD
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_SAMPLING_METHOD 100205
        public const int GLU_SAMPLING_METHOD = 100205;
        #endregion int GLU_SAMPLING_METHOD

        #region int GLU_U_STEP
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_U_STEP 100206
        public const int GLU_U_STEP = 100206;
        #endregion int GLU_U_STEP

        #region int GLU_V_STEP
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_V_STEP 100207
        public const int GLU_V_STEP = 100207;
        #endregion int GLU_V_STEP

        #region int GLU_NURBS_MODE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_MODE 100160
        public const int GLU_NURBS_MODE = 100160;
        #endregion int GLU_NURBS_MODE

        #region int GLU_NURBS_MODE_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_MODE_EXT 100160
        public const int GLU_NURBS_MODE_EXT = 100160;
        #endregion int GLU_NURBS_MODE_EXT

        #region int GLU_NURBS_TESSELLATOR
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_TESSELLATOR 100161
        public const int GLU_NURBS_TESSELLATOR = 100161;
        #endregion int GLU_NURBS_TESSELLATOR

        #region int GLU_NURBS_TESSELLATOR_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_TESSELLATOR_EXT 100161
        public const int GLU_NURBS_TESSELLATOR_EXT = 100161;
        #endregion int GLU_NURBS_TESSELLATOR_EXT

        #region int GLU_NURBS_RENDERER
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_RENDERER 100162
        public const int GLU_NURBS_RENDERER = 100162;
        #endregion int GLU_NURBS_RENDERER

        #region int GLU_NURBS_RENDERER_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_RENDERER_EXT 100162
        public const int GLU_NURBS_RENDERER_EXT = 100162;
        #endregion int GLU_NURBS_RENDERER_EXT
        #endregion NurbsProperty

        #region NurbsSampling
        #region int GLU_OBJECT_PARAMETRIC_ERROR
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_OBJECT_PARAMETRIC_ERROR 100208
        public const int GLU_OBJECT_PARAMETRIC_ERROR = 100208;
        #endregion int GLU_OBJECT_PARAMETRIC_ERROR

        #region int GLU_OBJECT_PARAMETRIC_ERROR_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_OBJECT_PARAMETRIC_ERROR_EXT 100208
        public const int GLU_OBJECT_PARAMETRIC_ERROR_EXT = 100208;
        #endregion int GLU_OBJECT_PARAMETRIC_ERROR_EXT

        #region int GLU_OBJECT_PATH_LENGTH
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_OBJECT_PATH_LENGTH 100209
        public const int GLU_OBJECT_PATH_LENGTH = 100209;
        #endregion int GLU_OBJECT_PATH_LENGTH

        #region int GLU_OBJECT_PATH_LENGTH_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_OBJECT_PATH_LENGTH_EXT 100209
        public const int GLU_OBJECT_PATH_LENGTH_EXT = 100209;
        #endregion int GLU_OBJECT_PATH_LENGTH_EXT

        #region int GLU_PATH_LENGTH
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_PATH_LENGTH 100215
        public const int GLU_PATH_LENGTH = 100215;
        #endregion int GLU_PATH_LENGTH

        #region int GLU_PARAMETRIC_ERROR
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_PARAMETRIC_ERROR 100216
        public const int GLU_PARAMETRIC_ERROR = 100216;
        #endregion int GLU_PARAMETRIC_ERROR

        #region int GLU_DOMAIN_DISTANCE
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_DOMAIN_DISTANCE 100217
        public const int GLU_DOMAIN_DISTANCE = 100217;
        #endregion int GLU_DOMAIN_DISTANCE
        #endregion NurbsSampling

        #region NurbsTrim
        #region int GLU_MAP1_TRIM_2
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_MAP1_TRIM_2 100210
        public const int GLU_MAP1_TRIM_2 = 100210;
        #endregion int GLU_MAP1_TRIM_2

        #region int GLU_MAP1_TRIM_3
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_MAP1_TRIM_3 100211
        public const int GLU_MAP1_TRIM_3 = 100211;
        #endregion int GLU_MAP1_TRIM_3
        #endregion NurbsTrim

        #region NurbsDisplay
        #region int GLU_OUTLINE_POLYGON
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_OUTLINE_POLYGON 100240
        public const int GLU_OUTLINE_POLYGON = 100240;
        #endregion int GLU_OUTLINE_POLYGON

        #region int GLU_OUTLINE_PATCH
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_OUTLINE_PATCH 100241
        public const int GLU_OUTLINE_PATCH = 100241;
        #endregion int GLU_OUTLINE_PATCH
        #endregion NurbsDisplay

        #region NurbsCallback
        #region int GLU_NURBS_ERROR
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR 100103
        public const int GLU_NURBS_ERROR = 100103;
        #endregion int GLU_NURBS_ERROR

        #region int GLU_ERROR
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_ERROR 100103
        public const int GLU_ERROR = 100103;
        #endregion int GLU_ERROR

        #region int GLU_NURBS_BEGIN
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_BEGIN 100164
        public const int GLU_NURBS_BEGIN = 100164;
        #endregion int GLU_NURBS_BEGIN

        #region int GLU_NURBS_BEGIN_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_BEGIN_EXT 100164
        public const int GLU_NURBS_BEGIN_EXT = 100164;
        #endregion int GLU_NURBS_BEGIN_EXT

        #region int GLU_NURBS_VERTEX
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_VERTEX 100165
        public const int GLU_NURBS_VERTEX = 100165;
        #endregion int GLU_NURBS_VERTEX

        #region int GLU_NURBS_VERTEX_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_VERTEX_EXT 100165
        public const int GLU_NURBS_VERTEX_EXT = 100165;
        #endregion int GLU_NURBS_VERTEX_EXT

        #region int GLU_NURBS_NORMAL
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_NORMAL 100166
        public const int GLU_NURBS_NORMAL = 100166;
        #endregion int GLU_NURBS_NORMAL

        #region int GLU_NURBS_NORMAL_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_NORMAL_EXT 100166
        public const int GLU_NURBS_NORMAL_EXT = 100166;
        #endregion int GLU_NURBS_NORMAL_EXT

        #region int GLU_NURBS_COLOR
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_COLOR 100167
        public const int GLU_NURBS_COLOR = 100167;
        #endregion int GLU_NURBS_COLOR

        #region int GLU_NURBS_COLOR_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_COLOR_EXT 100167
        public const int GLU_NURBS_COLOR_EXT = 100167;
        #endregion int GLU_NURBS_COLOR_EXT

        #region int GLU_NURBS_TEXTURE_COORD
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_TEXTURE_COORD 100168
        public const int GLU_NURBS_TEXTURE_COORD = 100168;
        #endregion int GLU_NURBS_TEXTURE_COORD

        #region int GLU_NURBS_TEX_COORD_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_TEX_COORD_EXT 100168
        public const int GLU_NURBS_TEX_COORD_EXT = 100168;
        #endregion int GLU_NURBS_TEX_COORD_EXT

        #region int GLU_NURBS_END
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_END 100169
        public const int GLU_NURBS_END = 100169;
        #endregion int GLU_NURBS_END

        #region int GLU_NURBS_END_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_END_EXT 100169
        public const int GLU_NURBS_END_EXT = 100169;
        #endregion int GLU_NURBS_END_EXT

        #region int GLU_NURBS_BEGIN_DATA
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_BEGIN_DATA 100170
        public const int GLU_NURBS_BEGIN_DATA = 100170;
        #endregion int GLU_NURBS_BEGIN_DATA

        #region int GLU_NURBS_BEGIN_DATA_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_BEGIN_DATA_EXT 100170
        public const int GLU_NURBS_BEGIN_DATA_EXT = 100170;
        #endregion int GLU_NURBS_BEGIN_DATA_EXT

        #region int GLU_NURBS_VERTEX_DATA
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_VERTEX_DATA 100171
        public const int GLU_NURBS_VERTEX_DATA = 100171;
        #endregion int GLU_NURBS_VERTEX_DATA

        #region int GLU_NURBS_VERTEX_DATA_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_VERTEX_DATA_EXT 100171
        public const int GLU_NURBS_VERTEX_DATA_EXT = 100171;
        #endregion int GLU_NURBS_VERTEX_DATA_EXT

        #region int GLU_NURBS_NORMAL_DATA
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_NORMAL_DATA 100172
        public const int GLU_NURBS_NORMAL_DATA = 100172;
        #endregion int GLU_NURBS_NORMAL_DATA

        #region int GLU_NURBS_NORMAL_DATA_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_NORMAL_DATA_EXT 100172
        public const int GLU_NURBS_NORMAL_DATA_EXT = 100172;
        #endregion int GLU_NURBS_NORMAL_DATA_EXT

        #region int GLU_NURBS_COLOR_DATA
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_COLOR_DATA 100173
        public const int GLU_NURBS_COLOR_DATA = 100173;
        #endregion int GLU_NURBS_COLOR_DATA

        #region int GLU_NURBS_COLOR_DATA_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_COLOR_DATA_EXT 100173
        public const int GLU_NURBS_COLOR_DATA_EXT = 100173;
        #endregion int GLU_NURBS_COLOR_DATA_EXT

        #region int GLU_NURBS_TEXTURE_COORD_DATA
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_TEXTURE_COORD_DATA 100174
        public const int GLU_NURBS_TEXTURE_COORD_DATA = 100174;
        #endregion int GLU_NURBS_TEXTURE_COORD_DATA

        #region int GLU_NURBS_TEX_COORD_DATA_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_TEX_COORD_DATA_EXT 100174
        public const int GLU_NURBS_TEX_COORD_DATA_EXT = 100174;
        #endregion int GLU_NURBS_TEX_COORD_DATA_EXT

        #region int GLU_NURBS_END_DATA
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_END_DATA 100175
        public const int GLU_NURBS_END_DATA = 100175;
        #endregion int GLU_NURBS_END_DATA

        #region int GLU_NURBS_END_DATA_EXT
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_END_DATA_EXT 100175
        public const int GLU_NURBS_END_DATA_EXT = 100175;
        #endregion int GLU_NURBS_END_DATA_EXT
        #endregion NurbsCallback

        #region NurbsErrors
        #region int GLU_NURBS_ERROR1
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR1 100251
        public const int GLU_NURBS_ERROR1 = 100251;
        #endregion int GLU_NURBS_ERROR1

        #region int GLU_NURBS_ERROR2
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR2 100252
        public const int GLU_NURBS_ERROR2 = 100252;
        #endregion int GLU_NURBS_ERROR2

        #region int GLU_NURBS_ERROR3
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR3 100253
        public const int GLU_NURBS_ERROR3 = 100253;
        #endregion int GLU_NURBS_ERROR3

        #region int GLU_NURBS_ERROR4
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR4 100254
        public const int GLU_NURBS_ERROR4 = 100254;
        #endregion int GLU_NURBS_ERROR4

        #region int GLU_NURBS_ERROR5
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR5 100255
        public const int GLU_NURBS_ERROR5 = 100255;
        #endregion int GLU_NURBS_ERROR5

        #region int GLU_NURBS_ERROR6
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR6 100256
        public const int GLU_NURBS_ERROR6 = 100256;
        #endregion int GLU_NURBS_ERROR6

        #region int GLU_NURBS_ERROR7
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR7 100257
        public const int GLU_NURBS_ERROR7 = 100257;
        #endregion int GLU_NURBS_ERROR7

        #region int GLU_NURBS_ERROR8
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR8 100258
        public const int GLU_NURBS_ERROR8 = 100258;
        #endregion int GLU_NURBS_ERROR8

        #region int GLU_NURBS_ERROR9
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR9 100259
        public const int GLU_NURBS_ERROR9 = 100259;
        #endregion int GLU_NURBS_ERROR9

        #region int GLU_NURBS_ERROR10
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR10 100260
        public const int GLU_NURBS_ERROR10 = 100260;
        #endregion int GLU_NURBS_ERROR10

        #region int GLU_NURBS_ERROR11
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR11 100261
        public const int GLU_NURBS_ERROR11 = 100261;
        #endregion int GLU_NURBS_ERROR11

        #region int GLU_NURBS_ERROR12
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR12 100262
        public const int GLU_NURBS_ERROR12 = 100262;
        #endregion int GLU_NURBS_ERROR12

        #region int GLU_NURBS_ERROR13
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR13 100263
        public const int GLU_NURBS_ERROR13 = 100263;
        #endregion int GLU_NURBS_ERROR13

        #region int GLU_NURBS_ERROR14
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR14 100264
        public const int GLU_NURBS_ERROR14 = 100264;
        #endregion int GLU_NURBS_ERROR14

        #region int GLU_NURBS_ERROR15
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR15 100265
        public const int GLU_NURBS_ERROR15 = 100265;
        #endregion int GLU_NURBS_ERROR15

        #region int GLU_NURBS_ERROR16
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR16 100266
        public const int GLU_NURBS_ERROR16 = 100266;
        #endregion int GLU_NURBS_ERROR16

        #region int GLU_NURBS_ERROR17
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR17 100267
        public const int GLU_NURBS_ERROR17 = 100267;
        #endregion int GLU_NURBS_ERROR17

        #region int GLU_NURBS_ERROR18
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR18 100268
        public const int GLU_NURBS_ERROR18 = 100268;
        #endregion int GLU_NURBS_ERROR18

        #region int GLU_NURBS_ERROR19
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR19 100269
        public const int GLU_NURBS_ERROR19 = 100269;
        #endregion int GLU_NURBS_ERROR19

        #region int GLU_NURBS_ERROR20
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR20 100270
        public const int GLU_NURBS_ERROR20 = 100270;
        #endregion int GLU_NURBS_ERROR20

        #region int GLU_NURBS_ERROR21
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR21 100271
        public const int GLU_NURBS_ERROR21 = 100271;
        #endregion int GLU_NURBS_ERROR21

        #region int GLU_NURBS_ERROR22
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR22 100272
        public const int GLU_NURBS_ERROR22 = 100272;
        #endregion int GLU_NURBS_ERROR22

        #region int GLU_NURBS_ERROR23
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR23 100273
        public const int GLU_NURBS_ERROR23 = 100273;
        #endregion int GLU_NURBS_ERROR23

        #region int GLU_NURBS_ERROR24
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR24 100274
        public const int GLU_NURBS_ERROR24 = 100274;
        #endregion int GLU_NURBS_ERROR24

        #region int GLU_NURBS_ERROR25
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR25 100275
        public const int GLU_NURBS_ERROR25 = 100275;
        #endregion int GLU_NURBS_ERROR25

        #region int GLU_NURBS_ERROR26
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR26 100276
        public const int GLU_NURBS_ERROR26 = 100276;
        #endregion int GLU_NURBS_ERROR26

        #region int GLU_NURBS_ERROR27
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR27 100277
        public const int GLU_NURBS_ERROR27 = 100277;
        #endregion int GLU_NURBS_ERROR27

        #region int GLU_NURBS_ERROR28
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR28 100278
        public const int GLU_NURBS_ERROR28 = 100278;
        #endregion int GLU_NURBS_ERROR28

        #region int GLU_NURBS_ERROR29
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR29 100279
        public const int GLU_NURBS_ERROR29 = 100279;
        #endregion int GLU_NURBS_ERROR29

        #region int GLU_NURBS_ERROR30
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR30 100280
        public const int GLU_NURBS_ERROR30 = 100280;
        #endregion int GLU_NURBS_ERROR30

        #region int GLU_NURBS_ERROR31
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR31 100281
        public const int GLU_NURBS_ERROR31 = 100281;
        #endregion int GLU_NURBS_ERROR31

        #region int GLU_NURBS_ERROR32
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR32 100282
        public const int GLU_NURBS_ERROR32 = 100282;
        #endregion int GLU_NURBS_ERROR32

        #region int GLU_NURBS_ERROR33
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR33 100283
        public const int GLU_NURBS_ERROR33 = 100283;
        #endregion int GLU_NURBS_ERROR33

        #region int GLU_NURBS_ERROR34
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR34 100284
        public const int GLU_NURBS_ERROR34 = 100284;
        #endregion int GLU_NURBS_ERROR34

        #region int GLU_NURBS_ERROR35
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR35 100285
        public const int GLU_NURBS_ERROR35 = 100285;
        #endregion int GLU_NURBS_ERROR35

        #region int GLU_NURBS_ERROR36
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR36 100286
        public const int GLU_NURBS_ERROR36 = 100286;
        #endregion int GLU_NURBS_ERROR36

        #region int GLU_NURBS_ERROR37
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_NURBS_ERROR37 100287
        public const int GLU_NURBS_ERROR37 = 100287;
        #endregion int GLU_NURBS_ERROR37
        #endregion NurbsErrors

        #region Contours types
        #region int GLU_CW
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_CW 100120
        public const int GLU_CW = 100120;
        #endregion int GLU_CW

        #region int GLU_CCW
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_CCW 100121
        public const int GLU_CCW = 100121;
        #endregion int GLU_CCW

        #region int GLU_INTERIOR
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_INTERIOR 100122
        public const int GLU_INTERIOR = 100122;
        #endregion int GLU_INTERIOR

        #region int GLU_EXTERIOR
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_EXTERIOR 100123
        public const int GLU_EXTERIOR = 100123;
        #endregion int GLU_EXTERIOR

        #region int GLU_UNKNOWN
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_UNKNOWN 100124
        public const int GLU_UNKNOWN = 100124;
        #endregion int GLU_UNKNOWN
        #endregion Contours types

        #region Extensions
        #region int GLU_EXT_object_space_tess
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_EXT_object_space_tess 1
        public const int GLU_EXT_object_space_tess = 1;
        #endregion int GLU_EXT_object_space_tess

        #region int GLU_EXT_nurbs_tessellator
        /// <summary>
        ///     Unknown.  Unable to locate definitive documentation on this constant.
        /// </summary>
        // #define GLU_EXT_nurbs_tessellator 1
        public const int GLU_EXT_nurbs_tessellator = 1;
        #endregion int GLU_EXT_nurbs_tessellator
        #endregion Extensions
        #endregion Public Constants

        #region Public Structs
        #region GLUnurbs
        /// <summary>
        ///     Defines a GLU NURBS object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct GLUnurbs
        {
            /// <summary>
            ///     Keeps the struct from being garbage collected prematurely.
            /// </summary>
            private IntPtr Data;
        }
        #endregion GLUnurbs

        #region GLUquadric
        /// <summary>
        ///     Defines a GLU quadric object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct GLUquadric
        {
            /// <summary>
            ///     Keeps the struct from being garbage collected prematurely.
            /// </summary>
            private IntPtr Data;
        }
        #endregion GLUquadric

        #region GLUtesselator
        /// <summary>
        ///     Defines a GLU tesselator object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct GLUtesselator
        {
            /// <summary>
            ///     Keeps the struct from being garbage collected prematurely.
            /// </summary>
            private IntPtr Data;
        }
        #endregion GLUtesselator

        #region GLUnurbsObj
        /// <summary>
        ///     Defines a GLU NURBS object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct GLUnurbsObj
        {
            /// <summary>
            ///     Keeps the struct from being garbage collected prematurely.
            /// </summary>
            private IntPtr Data;
        }
        #endregion GLUnurbsObj

        #region GLUquadricObj
        /// <summary>
        ///     Defines a GLU quadric object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct GLUquadricObj
        {
            /// <summary>
            ///     Keeps the struct from being garbage collected prematurely.
            /// </summary>
            private IntPtr Data;
        }
        #endregion GLUquadricObj

        #region GLUtesselatorObj
        /// <summary>
        ///     Defines a GLU tesselator object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct GLUtesselatorObj
        {
            /// <summary>
            ///     Keeps the struct from being garbage collected prematurely.
            /// </summary>
            private IntPtr Data;
        }
        #endregion GLUtesselatorObj

        #region GLUtriangulatorObj
        /// <summary>
        ///     Defines a GLU triangulator object.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct GLUtriangulatorObj
        {
            /// <summary>
            ///     Keeps the struct from being garbage collected prematurely.
            /// </summary>
            private IntPtr Data;
        }
        #endregion GLUtriangulatorObj
        #endregion Public Structs

        #region Private Fields
        // These fields hold references to any callbacks used so as to prevent the garbage
        // collector from sweeping the delegates even though the application may not be done
        // with them.
        private static NurbsBeginCallback nurbsBeginCallback;
        private static NurbsBeginDataCallback nurbsBeginDataCallback;
        private static NurbsColorCallback nurbsColorCallback;
        private static NurbsColorDataCallback nurbsColorDataCallback;
        private static NurbsEndCallback nurbsEndCallback;
        private static NurbsEndDataCallback nurbsEndDataCallback;
        private static NurbsErrorCallback nurbsErrorCallback;
        private static NurbsNormalCallback nurbsNormalCallback;
        private static NurbsNormalDataCallback nurbsNormalDataCallback;
        private static NurbsTexCoordCallback nurbsTexCoordCallback;
        private static NurbsTexCoordDataCallback nurbsTexCoordDataCallback;
        private static NurbsVertexCallback nurbsVertexCallback;
        private static NurbsVertexDataCallback nurbsVertexDataCallback;
        private static QuadricErrorCallback quadricErrorCallback;
        private static TessBeginCallback tessBeginCallback;
        private static TessBeginDataCallback tessBeginDataCallback;
        private static TessCombineCallback tessCombineCallback;
        private static TessCombineCallback1 tessCombineCallback1;
        private static TessCombineDataCallback tessCombineDataCallback;
        private static TessEdgeFlagCallback tessEdgeFlagCallback;
        private static TessEdgeFlagDataCallback tessEdgeFlagDataCallback;
        private static TessEndCallback tessEndCallback;
        private static TessEndDataCallback tessEndDataCallback;
        private static TessErrorCallback tessErrorCallback;
        private static TessErrorDataCallback tessErrorDataCallback;
        private static TessVertexCallback tessVertexCallback;
        private static TessVertexCallback1 tessVertexCallback1;
        private static TessVertexDataCallback tessVertexDataCallback;
        #endregion Private Fields

        // --- Public Delegates ---
        #region NurbsBeginCallback(int type)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // void begin(GLenum type);
        public delegate void NurbsBeginCallback(int type);
        #endregion NurbsBeginCallback(int type)

        #region NurbsBeginDataCallback(int type, [In] IntPtr[] userData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // void beginData(GLenum type, void *userData);
        public delegate void NurbsBeginDataCallback(int type, [In] IntPtr[] userData);
        #endregion NurbsBeginDataCallback(int type, [In] IntPtr[] userData)

        #region NurbsColorCallback([In] float[] colorData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // void color(GLfloat *color);
        public delegate void NurbsColorCallback([In] float[] colorData);
        #endregion NurbsColorCallback([In] float[] colorData)

        #region NurbsColorDataCallback([In] float[] colorData, [In] IntPtr[] userData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // void colorData(GLfloat *color, void *userData);
        public delegate void NurbsColorDataCallback([In] float[] colorData, [In] IntPtr[] userData);
        #endregion NurbsColorDataCallback([In] float[] colorData, [In] IntPtr[] userData)

        #region NurbsEndCallback()
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // void end(void);
        public delegate void NurbsEndCallback();
        #endregion NurbsEndCallback()

        #region NurbsEndDataCallback([In] IntPtr[] userData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // void endData(void *userData);
        public delegate void NurbsEndDataCallback([In] IntPtr[] userData);
        #endregion NurbsEndDataCallback([In] IntPtr[] userData)

        #region NurbsErrorCallback(int type)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // typedef void (CALLBACK* GLUnurbsErrorProc) (GLenum);
        public delegate void NurbsErrorCallback(int type);
        #endregion NurbsErrorCallback(int type)

        #region NurbsNormalCallback([In] float[] normalData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // void normal(GLfloat *normal);
        public delegate void NurbsNormalCallback([In] float[] normalData);
        #endregion NurbsNormalCallback([In] float[] normalData)

        #region NurbsNormalDataCallback([In] float[] normalData, [In] IntPtr[] userData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // void normalData(GLfloat *normal, void *userData);
        public delegate void NurbsNormalDataCallback([In] float[] normalData, [In] IntPtr[] userData);
        #endregion NurbsNormalDataCallback([In] float[] normalData, [In] IntPtr[] userData)

        #region NurbsTexCoordCallback([In] float[] texCoord)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // void texCoord(GLfloat *tex coord);
        public delegate void NurbsTexCoordCallback([In] float[] texCoord);
        #endregion NurbsTexCoordCallback([In] float[] texCoord)

        #region NurbsTexCoordDataCallback([In] float[] texCoord, [In] IntPtr[] userData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // void texCoordData(GLfloat *tex coord, void *userData);
        public delegate void NurbsTexCoordDataCallback([In] float[] texCoord, [In] IntPtr[] userData);
        #endregion NurbsTexCoordDataCallback([In] float[] texCoord, [In] IntPtr[] userData)

        #region NurbsVertexCallback([In] float[] vertexData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // void vertex(GLfloat *vertex);
        public delegate void NurbsVertexCallback([In] float[] vertexData);
        #endregion NurbsVertexCallback([In] float[] vertexData)

        #region NurbsVertexDataCallback([In] float[] vertexData, [In] IntPtr[] userData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // void vertexData(GLfloat *vertex, void *userData);
        public delegate void NurbsVertexDataCallback([In] float[] vertexData, [In] IntPtr[] userData);
        #endregion NurbsVertexDataCallback([In] float[] vertexData, [In] IntPtr[] userData)

        #region QuadricErrorCallback(int errorCode)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluQuadricCallback" />.
        /// </summary>
        /// <seealso cref="gluQuadricCallback" />
        // typedef void (CALLBACK* GLUquadricErrorProc) (GLenum);
        public delegate void QuadricErrorCallback(int errorCode);
        #endregion QuadricErrorCallback(int errorCode)

        #region TessBeginCallback(int type)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessBeginProc) (GLenum);
        public delegate void TessBeginCallback(int type);
        #endregion TessBeginCallback(int type)

        #region TessBeginDataCallback(int type, [In] IntPtr polygonData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessBeginDataProc) (GLenum, void *);
        public delegate void TessBeginDataCallback(int type, [In] IntPtr polygonData);
        #endregion TessBeginDataCallback(int type, [In] IntPtr polygonData)

        #region TessCombineCallback([In] double[] coordinates, [In] IntPtr[] vertexData, [In] float[] weight, [Out] IntPtr[] outData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessCombineProc) (GLdouble[3], void*[4], GLfloat[4], void**);
        public delegate void TessCombineCallback([In] double[] coordinates, [In] IntPtr[] vertexData, [In] float[] weight, [Out] IntPtr[] outData);
        #endregion TessCombineCallback([In] double[] coordinates, [In] IntPtr[] vertexData, [In] float[] weight, [Out] IntPtr[] outData)

        #region TessCombineCallback1([In] double[] coordinates, [In] double[][] vertexData, [In] float[] weight, [Out] double[] outData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessCombineProc) (GLdouble[3], void*[4], GLfloat[4], void**);
        public delegate void TessCombineCallback1([MarshalAs(UnmanagedType.LPArray, SizeConst = 3)] [In] double[] coordinates, [MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] [In] double[] vertexData, [MarshalAs(UnmanagedType.LPArray, SizeConst = 4)] [In] float[] weight, [Out] double[] outData);
        #endregion TessCombineCallback1([In] double[] coordinates, [In] double[][] vertexData, [In] float[] weight, [Out] double[] outData)

        #region TessCombineDataCallback([In] double[] coordinates, [In] IntPtr[] vertexData, [In] float[] weight, [Out] IntPtr[] outData, [In] IntPtr polygonData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessCombineDataProc) (GLdouble[3], void*[4], GLfloat[4], void**, void*);
        public delegate void TessCombineDataCallback([In] double[] coordinates, [In] IntPtr[] vertexData, [In] float[] weight, [Out] IntPtr[] outData, [In] IntPtr polygonData);
        #endregion TessCombineDataCallback([In] double[] coordinates, [In] IntPtr[] vertexData, [In] float[] weight, [Out] IntPtr[] outData, [In] IntPtr polygonData)

        #region TessEdgeFlagCallback(int flag)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessEdgeFlagProc) (GLboolean);
        public delegate void TessEdgeFlagCallback(int flag);
        #endregion TessEdgeFlagCallback(int flag)

        #region TessEdgeFlagDataCallback(int flag, [In] IntPtr polygonData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessEdgeFlagDataProc) (GLboolean, void *);
        public delegate void TessEdgeFlagDataCallback(int flag, [In] IntPtr polygonData);
        #endregion TessEdgeFlagDataCallback(int flag, [In] IntPtr polygonData)

        #region TessEndCallback()
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessEndProc) (void);
        public delegate void TessEndCallback();
        #endregion TessEndCallback()

        #region TessEndDataCallback([In] IntPtr polygonData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessEndDataProc) (void *);
        public delegate void TessEndDataCallback(IntPtr polygonData);
        #endregion TessEndDataCallback(IntPtr polygonData)

        #region TessErrorCallback(int errorCode)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessErrorProc) (GLenum);
        public delegate void TessErrorCallback(int errorCode);
        #endregion TessErrorCallback(int errorCode)

        #region TessErrorDataCallback(int errorCode, [In] IntPtr polygonData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessErrorDataProc) (GLenum, void *);
        public delegate void TessErrorDataCallback(int errorCode, [In] IntPtr polygonData);
        #endregion TessErrorDataCallback(int errorCode, [In] IntPtr polygonData)

        #region TessVertexCallback([In] IntPtr vertexData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessVertexProc) (void *);
        public delegate void TessVertexCallback([In] IntPtr vertexData);
        #endregion TessVertexCallback([In] IntPtr vertexData)

        #region TessVertexCallback1([In] double[] vertexData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessVertexProc) (void *);
        public delegate void TessVertexCallback1([In] double[] vertexData);
        #endregion TessVertexCallback1([In] double[] vertexData)

        #region TessVertexDataCallback([In] IntPtr vertexData, [In] IntPtr polygonData)
        /// <summary>
        ///     Callback (delegate) for use with <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // typedef void (CALLBACK* GLUtessVertexDataProc) (void *, void *);
        public delegate void TessVertexDataCallback([In] IntPtr vertexData, [In] IntPtr polygonData);
        #endregion TessVertexDataCallback([In] IntPtr vertexData, [In] IntPtr polygonData)

        // --- Private Externs ---
        #region __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsBeginCallback func)
        /// <summary>
        ///     Called from <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluNurbsCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsBeginCallback func);
        #endregion __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsBeginCallback func)

        #region __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsBeginDataCallback func)
        /// <summary>
        ///     Called from <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluNurbsCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsBeginDataCallback func);
        #endregion __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsBeginDataCallback func)

        #region __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsColorCallback func)
        /// <summary>
        ///     Called from <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluNurbsCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsColorCallback func);
        #endregion __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsColorCallback func)

        #region __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsColorDataCallback func)
        /// <summary>
        ///     Called from <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluNurbsCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsColorDataCallback func);
        #endregion __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsColorDataCallback func)

        #region __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsEndCallback func)
        /// <summary>
        ///     Called from <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluNurbsCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsEndCallback func);
        #endregion __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsEndCallback func)

        #region __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsEndDataCallback func)
        /// <summary>
        ///     Called from <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluNurbsCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsEndDataCallback func);
        #endregion __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsEndDataCallback func)

        #region __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsErrorCallback func)
        /// <summary>
        ///     Called from <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluNurbsCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsErrorCallback func);
        #endregion __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsErrorCallback func)

        #region __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsNormalCallback func)
        /// <summary>
        ///     Called from <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluNurbsCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsNormalCallback func);
        #endregion __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsNormalCallback func)

        #region __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsNormalDataCallback func)
        /// <summary>
        ///     Called from <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluNurbsCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsNormalDataCallback func);
        #endregion __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsNormalDataCallback func)

        #region __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsTexCoordCallback func)
        /// <summary>
        ///     Called from <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluNurbsCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsTexCoordCallback func);
        #endregion __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsTexCoordCallback func)

        #region __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsTexCoordDataCallback func)
        /// <summary>
        ///     Called from <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluNurbsCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsTexCoordDataCallback func);
        #endregion __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsTexCoordDataCallback func)

        #region __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsVertexCallback func)
        /// <summary>
        ///     Called from <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluNurbsCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsVertexCallback func);
        #endregion __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsVertexCallback func)

        #region __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsVertexDataCallback func)
        /// <summary>
        ///     Called from <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluNurbsCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsVertexDataCallback func);
        #endregion __gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsVertexDataCallback func)

        #region __gluQuadricCallback([In] GLUquadric quad, int which, [In] QuadricErrorCallback func)
        /// <summary>
        ///     Called from <see cref="gluQuadricCallback" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluQuadricCallback(GLUquadric *qobj, GLenum which, void (CALLBACK* fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluQuadricCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluQuadricCallback([In] GLUquadric quad, int which, [In] QuadricErrorCallback func);
        #endregion __gluQuadricCallback([In] GLUquadric quad, int which, [In] QuadricErrorCallback func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessBeginCallback func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessBeginCallback func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessBeginCallback func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessBeginDataCallback func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessBeginDataCallback func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessBeginDataCallback func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineCallback func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineCallback func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineCallback func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineCallback1 func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineCallback1 func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineCallback1 func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineDataCallback func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineDataCallback func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineDataCallback func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessEdgeFlagCallback func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessEdgeFlagCallback func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessEdgeFlagCallback func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessEdgeFlagDataCallback func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessEdgeFlagDataCallback func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessEdgeFlagDataCallback func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessEndCallback func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessEndCallback func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessEndCallback func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessEndDataCallback func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessEndDataCallback func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessEndDataCallback func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessErrorCallback func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessErrorCallback func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessErrorCallback func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessErrorDataCallback func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessErrorDataCallback func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessErrorDataCallback func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexCallback func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexCallback func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexCallback func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexCallback1 func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexCallback1 func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexCallback1 func)

        #region __gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexDataCallback func)
        /// <summary>
        ///     Called from <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />.
        /// </summary>
        /// <remarks>
        ///     <b>This method is not CLS-compliant due to naming conventions.</b>
        /// </remarks>
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluTessCallback"), SuppressUnmanagedCodeSecurity]
        private static extern void __gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexDataCallback func);
        #endregion __gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexDataCallback func)

        // --- Public Externs ---
        #region gluBeginCurve([In] GLUnurbs nurb)
        /// <summary>
        ///     Delimits a Non-Uniform Rational B-Spline (NURBS) curve definition.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         Use <b>gluBeginCurve</b> to mark the beginning of a NURBS curve definition.
        ///         After calling <b>gluBeginCurve</b>, make one or more calls to
        ///         <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" /> to define the attributes of the curve.  Exactly
        ///         one of the calls to <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" /> must have a curve type of
        ///         <see cref="Gl.GL_MAP1_VERTEX_3" /> or <see cref="Gl.GL_MAP1_VERTEX_4" />.  To
        ///         mark the end of the NURBS curve definition, call <see cref="gluEndCurve" />.
        ///     </para>
        ///     <para>
        ///         OpenGL evaluators are used to render the NURBS curve as a series of line
        ///         segments.  Evaluator state is preserved during rendering with
        ///         <c>Gl.glPushAttrib(Gl.GL_EVAL_BIT)</c> and <c>Gl.glPopAttrib</c>.  For
        ///         information on exactly what state these calls preserve, see
        ///         <see cref="Gl.glPushAttrib" />.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following commands render a textured NURBS curve with normals; texture
        ///         coordinates and normals are also specified as NURBS curves:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginCurve(nobj);
        ///                 Glu.gluNurbsCurve(nobj, ..., Gl.GL_MAP1_TEXTURE_COORD_2);
        ///                 Glu.gluNurbsCurve(nobj, ..., Gl.GL_MAP1_NORMAL);
        ///                 Glu.gluNurbsCurve(nobj, ..., Gl.GL_MAP1_VERTEX_4);
        ///             Glu.gluEndCurve(nobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glPopAttrib" />
        /// <seealso cref="Gl.glPushAttrib" />
        /// <seealso cref="gluBeginSurface" />
        /// <seealso cref="gluBeginTrim" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />
        // void APIENTRY gluBeginCurve(GLUnurbs *nobj);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluBeginCurve([In] GLUnurbs nurb);
        #endregion gluBeginCurve([In] GLUnurbs nurb)

        #region gluBeginPolygon([In] GLUtesselator tess)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluBeginPolygon</b> delimits the definition of a nonconvex polygon.  To
        ///         define such a polygon, first call <b>gluBeginPolygon</b>.  Then define the
        ///         contours of the polygon by calling <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" /> for each
        ///         vertex and <see cref="gluNextContour" /> to start each new contour.  Finally,
        ///         call <see cref="gluEndPolygon" /> to signal the end of the definition.  See
        ///         the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" /> and <see cref="gluNextContour" /> reference
        ///         pages for more details.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluEndPolygon" /> is called, the polygon is tessellated, and
        ///         the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         This command is obsolete and is provided for backward compatibility only.
        ///         Calls to <b>gluBeginPolygon</b> are mapped to
        ///         <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> followed by
        ///         <see cref="gluTessBeginContour" />.  Calls to <see cref="gluEndPolygon" />
        ///         are mapped to <see cref="gluTessEndContour" /> followed by
        ///         <see cref="gluTessEndPolygon" />.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         A quadrilateral with a triangular hole in it can be described like this:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginPolygon(tobj);
        ///                 Glu.gluTessVertex(tobj, v1, v1);
        ///                 Glu.gluTessVertex(tobj, v2, v2);
        ///                 Glu.gluTessVertex(tobj, v3, v3);
        ///                 Glu.gluTessVertex(tobj, v4, v4);
        ///             Glu.gluNextContour(tobj, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessVertex(tobj, v5, v5);
        ///                 Glu.gluTessVertex(tobj, v6, v6);
        ///                 Glu.gluTessVertex(tobj, v7, v7);
        ///             Glu.gluEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluNextContour" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluBeginPolygon(GLUtesselator *tess);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluBeginPolygon([In] GLUtesselator tess);
        #endregion gluBeginPolygon([In] GLUtesselator tess)

        #region gluBeginSurface([In] GLUnurbs nurb)
        /// <summary>
        ///     Delimits a NURBS surface definition.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         Use <b>gluBeginSurface</b> to mark the beginning of a NURBS surface
        ///         definition.  After calling <b>gluBeginSurface</b>, make one or more calls to
        ///         <see cref="gluNurbsSurface(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int, float[], int, int, int)" /> to define the attributes of the surface.
        ///         Exactly one of these calls to <see cref="gluNurbsSurface(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int, float[], int, int, int)" /> must have a
        ///         surface type of <see cref="Gl.GL_MAP2_VERTEX_3" /> or
        ///         <see cref="Gl.GL_MAP2_VERTEX_4" />.  To mark the end of the NURBS surface
        ///         definition, call <see cref="gluEndSurface" />.
        ///     </para>
        ///     <para>
        ///         Trimming of NURBS surfaces is supported with <see cref="gluBeginTrim" />,
        ///         <see cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />, <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />, and
        ///         <see cref="gluEndTrim" />.  See the <see cref="gluBeginTrim" /> reference
        ///         page for details. 
        ///     </para>
        ///     <para>
        ///         OpenGL evaluators are used to render the NURBS surface as a set of polygons.
        ///         Evaluator state is preserved during rendering with
        ///         <c>Gl.glPushAttrib(Gl.GL_EVAL_BIT)</c> and <c>Gl.glPopAttrib()</c>.  See the
        ///         <see cref="Gl.glPushAttrib" /> reference page for details on exactly what
        ///         state these calls preserve.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following commands render a textured NURBS surface with normals; the
        ///         texture coordinates and normals are also described as NURBS surfaces:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginSurface(nobj);
        ///                 Glu.gluNurbsSurface(nobj, ..., Gl.GL_MAP2_TEXTURE_COORD_2);
        ///                 Glu.gluNurbsSurface(nobj, ..., Gl.GL_MAP2_NORMAL);
        ///                 Glu.gluNurbsSurface(nobj, ..., Gl.GL_MAP2_VERTEX_4);
        ///             Glu.gluEndSurface(nobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluBeginCurve" />
        /// <seealso cref="gluBeginTrim" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />
        /// <see cref="gluNurbsSurface(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int, float[], int, int, int)" />
        /// <seealso cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />
        // void APIENTRY gluBeginSurface(GLUnurbs *nobj);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluBeginSurface([In] GLUnurbs nurb);
        #endregion gluBeginSurface([In] GLUnurbs nurb)

        #region gluBeginTrim([In] GLUnurbs nurb)
        /// <summary>
        ///     Delimits a NURBS trimming loop definition.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />). 
        /// </param>
        /// <remarks>
        ///     <para>
        ///         Use <b>gluBeginTrim</b> to mark the beginning of a trimming loop, and
        ///         <see cref="gluEndTrim" /> to mark the end of a trimming loop.  A trimming
        ///         loop is a set of oriented curve segments (forming a closed curve) that define
        ///         boundaries of a NURBS surface.  You include these trimming loops in the
        ///         definition of a NURBS surface, between calls to
        ///         <see cref="gluBeginSurface" /> and <see cref="gluEndSurface" />.
        ///     </para>
        ///     <para>
        ///         The definition for a NURBS surface can contain many trimming loops.  For
        ///         example, if you wrote a definition for a NURBS surface that resembled a
        ///         rectangle with a hole punched out, the definition would contain two trimming
        ///         loops.  One loop would define the outer edge of the rectangle; the other
        ///         would define the hole punched out of the rectangle.  The definitions of each
        ///         of these trimming loops would be bracketed by a <b>gluBeginTrim</b> and
        ///         <see cref="gluEndTrim" /> pair.
        ///     </para>
        ///     <para>
        ///         The definition of a single closed trimming loop can consist of multiple curve
        ///         segments, each described as a piecewise linear curve (see
        ///         <see cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />) or as a single NURBS curve (see
        ///         <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />), or as a combination of both in any order.  The
        ///         only library calls that can appear in a trimming loop definition (between the
        ///         calls to <b>gluBeginTrim</b> and <see cref="gluEndTrim" />) are
        ///         <see cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" /> and <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />.
        ///     </para>
        ///     <para>
        ///         The area of the NURBS surface that is displayed is the region in the domain
        ///         to the left of the trimming curve as the curve parameter increases.  Thus,
        ///         the retained region of the NURBS surface is inside a counterclockwise
        ///         trimming loop and outside a clockwise trimming loop.  For the rectangle
        ///         mentioned earlier, the trimming loop for the outer edge of the rectangle runs
        ///         counterclockwise, while the trimming loop for the punched-out hole runs
        ///         clockwise.
        ///     </para>
        ///     <para>
        ///         If you use more than one curve to define a single trimming loop, the curve
        ///         segments must form a closed loop (that is, the endpoint of each curve must be
        ///         the starting point of the next curve, and the endpoint of the final curve
        ///         must be the starting point of the first curve).  If the endpoints of the
        ///         curve are sufficiently close together but not exactly coincident, they will
        ///         be coerced to match.  If the endpoints are not sufficiently close, an error
        ///         results (see <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         If a trimming loop definition contains multiple curves, the direction of the
        ///         curves must be consistent (that is, the inside must be to the left of all of
        ///         the curves).  Nested trimming loops are legal as long as the curve
        ///         orientations alternate correctly.  If trimming curves are self-intersecting,
        ///         or intersect one another, an error results.
        ///     </para>
        ///     <para>
        ///         If no trimming information is given for a NURBS surface, the entire surface
        ///         is drawn.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         This code fragment defines a trimming loop that consists of one piecewise
        ///         linear curve, and two NURBS curves:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginTrim(nobj);
        ///                 Glu.gluPwlCurve(..., Glu.GLU_MAP1_TRIM_2);
        ///                 Glu.gluNurbsCurve(..., Glu.GLU_MAP1_TRIM_2);
        ///                 Glu.gluNurbsCurve(..., Glu.GLU_MAP1_TRIM_3);
        ///             Glu.gluEndTrim(nobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluBeginSurface" />
        /// <seealso cref="gluEndSurface" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        /// <seealso cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />
        /// <seealso cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />
        // void APIENTRY gluBeginTrim(GLUnurbs *nobj);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluBeginTrim([In] GLUnurbs nurb);
        #endregion gluBeginTrim([In] GLUnurbs nurb)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] byte[] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glGetTexLevelParameterfv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] byte[] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] byte[] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] byte[ , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glGetTexLevelParameterfv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] byte[,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] byte[ , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] byte[ , , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glGetTexLevelParameterfv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] byte[, ,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] byte[ , , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] double[] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] double[] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] double[] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] double[ , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glGetTexLevelParameterfv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] double[,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] double[ , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] double[ , , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glGetTexLevelParameterfv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] double[, ,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] double[ , , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] short[] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] short[] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] short[] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] short[ , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] short[,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] short[ , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] short[ , , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] short[, ,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] short[ , , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] int[] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] int[] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] int[] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] int[ , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] int[,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] int[ , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] int[ , , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] int[, ,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] int[ , , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] float[] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] float[] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] float[] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] float[ , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] float[,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] float[ , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] float[ , , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glGetTexLevelParameterfv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] float[, ,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] float[ , , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] ushort[] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] ushort[] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] ushort[] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] ushort[ , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] ushort[,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] ushort[ , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] ushort[ , , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] ushort[, ,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] ushort[ , , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] uint[] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] uint[] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] uint[] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] uint[ , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] uint[,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] uint[ , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] uint[ , , ] data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] uint[, ,] data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] uint[ , , ] data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] IntPtr data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] IntPtr data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] IntPtr data)

        #region int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] void *data)
        /// <summary>
        ///     Builds a subset of one-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     or 4 or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" /> or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width in pixels of the texture image.  This should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for data.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> builds a subset of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating data in half until size 1×1 is reached.  At each level, each texel
        ///         in the halved mipmap level is an average of the corresponding two texels in
        ///         the larger mipmap level.  <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load
        ///         these mipmap levels from <i>min</i> to <i>max</i>.  If <i>max</i> is larger
        ///         than the highest mipmap level for the texture of the specified size, then a
        ///         GLU error code is returned (see <see cref="gluErrorString" />) and nothing is
        ///         loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, the following
        ///         levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1.  These correspond to levels 2
        ///         through 6 respectively.  If <i>min</i> is 3 and <i>max</i> is 5, then only
        ///         mipmap levels 8×1, 4×1 and 2×1 are loaded.  However, if <i>max</i> is 7 then
        ///         an error is returned and nothing is loaded since <i>max</i> is larger than
        ///         the highest mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2((width)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>level</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild1DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> are not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public unsafe static extern int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] void* data);
        #endregion int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int min, int max, [In] void *data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] byte[] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] byte[] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] byte[] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] byte[ , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] byte[,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] byte[ , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] byte[ , , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] byte[, ,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] byte[ , , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] double[] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] double[] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] double[] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] double[ , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] double[,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] double[ , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] double[ , , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] double[, ,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] double[ , , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] short[] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] short[] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] short[] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] short[ , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] short[,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] short[ , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] short[ , , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] short[, ,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] short[ , , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] int[] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] int[] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] int[] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] int[ , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] int[,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] int[ , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] int[ , , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] int[, ,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] int[ , , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] float[] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] float[] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] float[] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] float[ , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] float[,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] float[ , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] float[ , , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] float[, ,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] float[ , , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] ushort[] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] ushort[] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] ushort[] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] ushort[ , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] ushort[,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] ushort[ , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] ushort[ , , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] ushort[, ,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] ushort[ , , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] uint[] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] uint[] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] uint[] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] uint[ , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] uint[,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] uint[ , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] uint[ , , ] data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] uint[, ,] data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] uint[ , , ] data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] IntPtr data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] IntPtr data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] IntPtr data)

        #region int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] void *data)
        /// <summary>
        ///     Builds a one-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_1D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" />, or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild1DMipmaps</b> builds a series of prefiltered one-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> of <i>data</i> is checked to see if it is a power
        ///         of 2.  If not, a copy of <i>data</i> is scaled up or down to the nearest
        ///         power of 2.  (If <i>width</i> is exactly between powers of 2, then the copy
        ///         of <i>data</i> will scale upwards.)  This copy will be used for subsequent
        ///         mipmapping operations described below.  For example, if <i>width</i> is 57
        ///         then a copy of <i>data</i> will scale up to 64 before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, width
        ///         is continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half until size 1×1 is reached.  At each level, each texel in the halved
        ///         mipmap level is an average of the corresponding two texels in the larger
        ///         mipmap level.
        ///     </para>
        ///     <para>
        ///         <b>glTexImage1D</b> is called to load each of these mipmap levels.  Level 0
        ///         is a copy of <i>data</i>.  The highest level is <c>log2(width)</c>.  For
        ///         example, if <i>width</i> is 64 and the implementation can store a texture of
        ///         this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1,
        ///         2×1 and 1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>type</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for the <i>data</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Note that there is no direct way of querying the maximum level.  This can be
        ///         derived indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First,
        ///         query for the width actually used at level 0.  (The width may not be equal to
        ///         <i>width</i> since proxy textures might have scaled it to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(width)</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater, and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i> or <i>type</i>
        ///         are not legal. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public unsafe static extern int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] void* data);
        #endregion int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, [In] void *data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] byte[] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] byte[] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] byte[] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] byte[ , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] byte[,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] byte[ , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] byte[ , , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] byte[, ,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] byte[ , , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] double[] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] double[] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] double[] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] double[ , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] double[,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] double[ , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] double[ , , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] double[, ,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] double[ , , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] short[] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] short[] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] short[] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] short[ , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] short[,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] short[ , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] short[ , , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] short[, ,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] short[ , , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] int[] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] int[] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] int[] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] int[ , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] int[,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] int[ , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] int[ , , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] int[, ,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] int[ , , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] float[] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] float[] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] float[] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] float[ , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] float[,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] float[ , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] float[ , , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] float[, ,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] float[ , , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] ushort[] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] ushort[] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] ushort[] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] ushort[ , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] ushort[,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] ushort[ , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] ushort[ , , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] ushort[, ,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] ushort[ , , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] uint[] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] uint[] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] uint[] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] uint[ , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] uint[,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] uint[ , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] uint[ , , ] data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] uint[, ,] data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] uint[ , , ] data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] IntPtr data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] IntPtr data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] IntPtr data)

        #region int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] void *data)
        /// <summary>
        ///     Builds a subset of two-dimensional mipmap levels.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies the width, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies the height, in pixels, of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> builds a subset of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///         decimating <i>data</i> in half along both dimensions until size 1×1 is
        ///         reached.  At each level, each texel in the halved mipmap level is an average
        ///         of the corresponding four texels in the larger mipmap level.  (In the case of
        ///         rectangular images, the decimation will ultimately reach an N×1 or 1×N
        ///         configuration.  Here, two texels are averaged instead.)
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load these mipmap levels from
        ///         <i>min</i> to <i>max</i>.  If <i>max</i> is larger than the highest mipmap
        ///         level for the texture of the specified size, then a GLU error code is
        ///         returned (see <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16 and <i>height</i> is
        ///         8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1.  These
        ///         correspond to levels 2 through 6 respectively.  If <i>min</i> is 3 and
        ///         <i>max</i> is 5, then only mipmap levels 8×4, 4×2 and 2×1 are loaded.
        ///         However, if <i>max</i> is 7 then an error is returned and nothing is loaded
        ///         since <i>max</i> is larger than the highest mipmap level which is, in this
        ///         case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild2DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />. 
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public unsafe static extern int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] void* data);
        #endregion int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int min, int max, [In] void *data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] byte[] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] byte[] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] byte[] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] byte[ , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] byte[,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] byte[ , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] byte[ , , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] byte[, ,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] byte[ , , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] double[] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] double[] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] double[] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] double[ , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] double[,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] double[ , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] double[ , , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] double[, ,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] double[ , , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] short[] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] short[] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] short[] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] short[ , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] short[,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] short[ , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] short[ , , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] short[, ,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] short[ , , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] int[] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] int[] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] int[] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] int[ , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] int[,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] int[ , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] int[ , , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] int[, ,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] int[ , , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] float[] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] float[] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] float[] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] float[ , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] float[,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] float[ , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] float[ , , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] float[, ,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] float[ , , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] ushort[] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] ushort[] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] ushort[] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] ushort[ , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] ushort[,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] ushort[ , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] ushort[ , , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] ushort[, ,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] ushort[ , , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] uint[] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] uint[] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] uint[] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] uint[ , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] uint[,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] uint[ , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] uint[ , , ] data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] uint[, ,] data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] uint[ , , ] data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] IntPtr data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] IntPtr data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] IntPtr data)

        #region int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] void *data)
        /// <summary>
        ///     Builds a two-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_2D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />,
        ///     <see cref="Gl.GL_INTENSITY" />, <see cref="Gl.GL_INTENSITY4" />,
        ///     <see cref="Gl.GL_INTENSITY8" />, <see cref="Gl.GL_INTENSITY12" />,
        ///     <see cref="Gl.GL_INTENSITY16" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_R3_G3_B2" />, <see cref="Gl.GL_RGB4" />,
        ///     <see cref="Gl.GL_RGB5" />, <see cref="Gl.GL_RGB8" />,
        ///     <see cref="Gl.GL_RGB10" />, <see cref="Gl.GL_RGB12" />,
        ///     <see cref="Gl.GL_RGB16" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_RGBA2" />, <see cref="Gl.GL_RGBA4" />,
        ///     <see cref="Gl.GL_RGB5_A1" />, <see cref="Gl.GL_RGBA8" />,
        ///     <see cref="Gl.GL_RGB10_A2" />, <see cref="Gl.GL_RGBA12" /> or
        ///     <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild2DMipmaps</b> builds a series of prefiltered two-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for
        ///         the antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i> and <i>height</i> of <i>data</i> are checked to
        ///         see if they are a power of 2.  If not, a copy of <i>data</i> (not <i>data</i>
        ///         itself), is scaled up or down to the nearest power of 2.  This copy will be
        ///         used for subsequent mipmapping operations described below.  (If <i>width</i>
        ///         or <i>height</i> is exactly between powers of 2, then the copy of <i>data</i>
        ///         will scale upwards.)  For example, if <i>width</i> is 57 and <i>height</i> is
        ///         23 then a copy of <i>data</i> will scale up to 64 in <i>width</i> and down to
        ///         16 in depth, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, both
        ///         dimensions are continually halved until it fits.  (If the OpenGL version is
        ///         &lt;= 1.0, both maximum texture dimensions are clamped to the value returned
        ///         by <see cref="Gl.glGetIntegerv(int, IntPtr)" /> with the argument
        ///         <see cref="Gl.GL_MAX_TEXTURE_SIZE" />.)
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along both dimensions until size 1×1 is reached.  At each level, each
        ///         texel in the halved mipmap level is an average of the corresponding four
        ///         texels in the larger mipmap level.  (In the case of rectangular images, the
        ///         decimation will ultimately reach an N×1 or 1×N configuration.  Here, two
        ///         texels are averaged instead.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height))</c>.  For example, if <i>width</i> is 64 and
        ///         <i>height</i> is 16 and the implementation can store a texture of this size,
        ///         the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1 and
        ///         1×1.  These correspond to levels 0 through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width and height actually used at level 0.  (The width and height may not
        ///         be equal to <i>width</i> and <i>height</i> respectively since proxy textures
        ///         might have scaled them to fit the implementation.)  Then the maximum level
        ///         can be derived from the formula <c>log2(max(width,height))</c>.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater and if the GLU version is 1.3 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i> or <i>height</i>
        ///         is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public unsafe static extern int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] void* data);
        #endregion int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, [In] void *data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] byte[] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] byte[] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] byte[] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] byte[ , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] byte[,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] byte[ , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] byte[ , , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] byte[, ,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] byte[ , , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] double[] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] double[] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] double[] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] double[ , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] double[,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] double[ , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] double[ , , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] double[, ,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] double[ , , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] short[] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] short[] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] short[] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] short[ , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] short[,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] short[ , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] short[ , , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] short[, ,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] short[ , , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] int[] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] int[] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] int[] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] int[ , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] int[,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] int[ , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] int[ , , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] int[, ,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] int[ , , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] float[] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] float[] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] float[] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] float[ , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] float[,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] float[ , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] float[ , , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] float[, ,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] float[ , , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] ushort[] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] ushort[] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] ushort[] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] ushort[ , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] ushort[,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] ushort[ , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] ushort[ , , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] ushort[, ,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] ushort[ , , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] uint[] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] uint[] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] uint[] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] uint[ , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] uint[,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] uint[ , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] uint[ , , ] data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] uint[, ,] data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] uint[ , , ] data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] IntPtr data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] IntPtr data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] IntPtr data)

        #region int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] void *data)
        /// <summary>
        ///     Builds a subset of three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth of the texture image.  Should be a power of 2.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="level">
        ///     Specifies the mipmap level of the image data.
        /// </param>
        /// <param name="min">
        ///     Specifies the minimum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="max">
        ///     Specifies the maximum mipmap level to pass to <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> builds a subset of prefiltered
        ///         three-dimensional texture maps of decreasing resolutions called a mipmap.
        ///         This is used for the antialiasing of texture mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///          A series of mipmap levels from <i>min</i> to <i>max</i> is built by
        ///          decimating <i>data</i> in half along both dimensions until size 1×1×1 is
        ///          reached.  At each level, each texel in the halved mipmap level is an average
        ///          of the corresponding eight texels in the larger mipmap level.  (If exactly
        ///          one of the dimensions is 1, four texels are averaged.  If exactly two of the
        ///          dimensions are 1, two texels are averaged.)  <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        ///          is called to load these mipmap levels from <i>min</i> to <i>max</i>.  If
        ///          <i>max</i> is larger than the highest mipmap level for the texture of the
        ///          specified size, then a GLU error code is returned (see
        ///          <see cref="gluErrorString" />) and nothing is loaded.
        ///     </para>
        ///     <para>
        ///         For example, if <i>level</i> is 2 and <i>width</i> is 16, <i>height</i> is 8
        ///         and <i>depth</i> is 4, the following levels are possible: 16×8×4, 8×4×2,
        ///         4×2×1, 2×1×1, 1×1×1.  These correspond to levels 2 through 6 respectively.
        ///         If <i>min</i> is 3 and <i>max</i> is 5, then only mipmap levels 8×4×2,
        ///         4×2×1 and 2×1×1 are loaded.  However, if <i>max</i> is 7 then an error is
        ///         returned and nothing is loaded since <i>max</i> is larger than the highest
        ///         mipmap level which is, in this case, 6.
        ///     </para>
        ///     <para>
        ///         The highest mipmap level can be derived from the formula
        ///         <c>log2(max(width,height,depth)*(2^level))</c>.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmapLevels</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>level</i> &gt; <i>min</i>,
        ///         <i>min</i> &lt; 0, <i>max</i> &lt; <i>min</i> or <i>max</i> is &gt; the
        ///         highest mipmap level for <i>data</i>.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public unsafe static extern int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] void* data);
        #endregion int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int min, int max, [In] void *data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] byte[] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] byte[] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] byte[] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] byte[ , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] byte[,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] byte[ , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] byte[ , , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] byte[, ,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] byte[ , , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] double[] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] double[] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] double[] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] double[ , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] double[,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] double[ , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] double[ , , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] double[, ,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] double[ , , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] short[] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] short[] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] short[] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] short[ , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] short[,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] short[ , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] short[ , , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] short[, ,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] short[ , , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] int[] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] int[] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] int[] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] int[ , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] int[,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] int[ , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] int[ , , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] int[, ,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] int[ , , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] float[] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] float[] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] float[] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] float[ , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] float[,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] float[ , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] float[ , , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] float[, ,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] float[ , , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] ushort[] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] ushort[] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] ushort[] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] ushort[ , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] ushort[,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] ushort[ , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] ushort[ , , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] ushort[, ,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] ushort[ , , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] uint[] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] uint[] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] uint[] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] uint[ , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] uint[,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] uint[ , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] uint[ , , ] data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] uint[, ,] data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] uint[ , , ] data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] IntPtr data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] IntPtr data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] IntPtr data)

        #region int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] void *data)
        /// <summary>
        ///     Builds a three-dimensional mipmap.
        /// </summary>
        /// <param name="target">
        ///     Specifies the target texture.  Must be <see cref="Gl.GL_TEXTURE_3D" />.
        /// </param>
        /// <param name="internalFormat">
        ///     Requests the internal storage format of the texture image.  Must be 1, 2, 3,
        ///     4, or one of the following symbolic constants: <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_ALPHA4" />, <see cref="Gl.GL_ALPHA8" />,
        ///     <see cref="Gl.GL_ALPHA12" />, <see cref="Gl.GL_ALPHA16" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, <see cref="Gl.GL_LUMINANCE4" />,
        ///     <see cref="Gl.GL_LUMINANCE8" />, <see cref="Gl.GL_LUMINANCE12" />,
        ///     <see cref="Gl.GL_LUMINANCE16" />, <see cref="Gl.GL_LUMINANCE_ALPHA" />,
        ///     <see cref="Gl.GL_LUMINANCE4_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE6_ALPHA2" />,
        ///     <see cref="Gl.GL_LUMINANCE8_ALPHA8" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA4" />,
        ///     <see cref="Gl.GL_LUMINANCE12_ALPHA12" />,
        ///     <see cref="Gl.GL_LUMINANCE16_ALPHA16" />, <see cref="Gl.GL_INTENSITY" />,
        ///     <see cref="Gl.GL_INTENSITY4" />, <see cref="Gl.GL_INTENSITY8" />,
        ///     <see cref="Gl.GL_INTENSITY12" />, <see cref="Gl.GL_INTENSITY16" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_R3_G3_B2" />,
        ///     <see cref="Gl.GL_RGB4" />, <see cref="Gl.GL_RGB5" />,
        ///     <see cref="Gl.GL_RGB8" />, <see cref="Gl.GL_RGB10" />,
        ///     <see cref="Gl.GL_RGB12" />, <see cref="Gl.GL_RGB16" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_RGBA2" />,
        ///     <see cref="Gl.GL_RGBA4" />, <see cref="Gl.GL_RGB5_A1" />,
        ///     <see cref="Gl.GL_RGBA8" />, <see cref="Gl.GL_RGB10_A2" />,
        ///     <see cref="Gl.GL_RGBA12" />, or <see cref="Gl.GL_RGBA16" />.
        /// </param>
        /// <param name="width">
        ///     Specifies, in pixels, the width in pixels of the texture image.
        /// </param>
        /// <param name="height">
        ///     Specifies, in pixels, the height in pixels of the texture image.
        /// </param>
        /// <param name="depth">
        ///     Specifies, in pixels, the depth in pixels of the texture image.
        /// </param>
        /// <param name="format">
        ///     Specifies the format of the pixel data.  Must be one of
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_DEPTH_COMPONENT" />,
        ///     <see cref="Gl.GL_RED" />, <see cref="Gl.GL_GREEN" />,
        ///     <see cref="Gl.GL_BLUE" />, <see cref="Gl.GL_ALPHA" />,
        ///     <see cref="Gl.GL_RGB" />, <see cref="Gl.GL_RGBA" />,
        ///     <see cref="Gl.GL_BGR" />, <see cref="Gl.GL_BGRA" />,
        ///     <see cref="Gl.GL_LUMINANCE" />, or <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="type">
        ///     Specifies the data type for <i>data</i>.  Must be one of:
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="data">
        ///     Specifies a pointer to the image data in memory.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> builds a series of prefiltered three-dimensional
        ///         texture maps of decreasing resolutions called a mipmap.  This is used for the
        ///         antialiasing of texture-mapped primitives.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         Initially, the <i>width</i>, <i>height</i> and <i>depth</i> of <i>data</i>
        ///         are checked to see if they are a power of two.  If not, a copy of <i>data</i>
        ///         (not <i>data</i> itself), is scaled up or down to the nearest power of two.
        ///         This copy will be used for subsequent mipmapping operations described below.
        ///         (If <i>width</i>, <i>height</i> or <i>depth</i> is exactly between powers of
        ///         2, then the copy of <i>data</i> will scale upwards.)  For example, if
        ///         <i>width</i> is 57, <i>height</i> is 23 and <i>depth</i> is 24 then a copy of
        ///         <i>data</i> will scale up to 64 in <i>width</i>, down to 16 in <i>height</i>
        ///         and up to 32 in <i>depth</i>, before mipmapping takes place.
        ///     </para>
        ///     <para>
        ///         Then, proxy textures (see <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />) are used to
        ///         determine if the implementation can fit the requested texture.  If not, all
        ///         three dimensions are continually halved until it fits.
        ///     </para>
        ///     <para>
        ///         Next, a series of mipmap levels is built by decimating a copy of <i>data</i>
        ///         in half along all three dimensions until size 1×1×1 is reached.  At each
        ///         level, each texel in the halved mipmap level is an average of the
        ///         corresponding eight texels in the larger mipmap level.  (If exactly one of
        ///         the dimensions is 1, four texels are averaged.  If exactly two of the
        ///         dimensions are 1, two texels are averaged.)
        ///     </para>
        ///     <para>
        ///         <see cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" /> is called to load each of these mipmap levels.
        ///         Level 0 is a copy of <i>data</i>.  The highest level is
        ///         <c>log2(max(width,height,depth))</c>.  For example, if <i>width</i> is 64,
        ///         <i>height</i> is 16 and <i>depth</i> is 32, and the implementation can store
        ///         a texture of this size, the following mipmap levels are built: 64×16×32,
        ///         32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1 and 1×1×1.  These correspond to levels 0
        ///         through 6, respectively.
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for <i>format</i> parameter.  See the
        ///         <see cref="Gl.glDrawPixels(int, int, int, int, object)" /> reference page for a description of the
        ///         acceptable values for <i>type</i> parameter.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         There is no direct way of querying the maximum level.  This can be derived
        ///         indirectly via <see cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />.  First, query for
        ///         the width, height and depth actually used at level 0.  (The width, height
        ///         and depth may not be equal to <i>width</i>, <i>height</i> and <i>depth</i>
        ///         respectively since proxy textures might have scaled them to fit the
        ///         implementation.)  Then the maximum level can be derived from the formula
        ///         <c>log2(max(width,height,depth))</c>.
        ///     </para>
        ///     <para>
        ///         <b>gluBuild3DMipmaps</b> is only available if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>width</i>, <i>height</i>,
        ///         or <i>depth</i> is &lt; 1.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>internalFormat</i>,
        ///         <i>format</i>, or <i>type</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>type</i> is
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexImage(int, int, int, int, object)" />
        /// <seealso cref="Gl.glGetTexLevelParameteriv(int, int, int, IntPtr)" />
        /// <seealso cref="Gl.glTexImage1D(int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage2D(int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="Gl.glTexImage3D(int, int, int, int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmapLevels(int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmapLevels(int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmapLevels(int, int, int, int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // GLAPI GLint GLAPIENTRY gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public unsafe static extern int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] void* data);
        #endregion int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, [In] void *data)

        #region int gluCheckExtension(string extensionName, string extensionString)
        /// <summary>
        ///     Determines if an extension name is supported.
        /// </summary>
        /// <param name="extensionName">
        ///     Specifies an extension name.
        /// </param>
        /// <param name="extensionString">
        ///     Specifies a space-separated list of extension names supported.
        /// </param>
        /// <returns>
        ///     Returns <see cref="Gl.GL_TRUE" /> if <i>extensionName</i> is supported
        ///     otherwise <see cref="Gl.GL_FALSE" /> is returned.
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluCheckExtension</b> is used to check for the presence for OpenGL, GLU or
        ///         GLX extension names by passing the extension strings returned by
        ///         <see cref="Gl.glGetString" />, <see cref="gluGetString" />,
        ///         /*see cref="glXGetClientString" />*/, /*see cref="glXQueryExtensionsString" />*/,
        ///         or /*see cref="glXQueryServerString" />*/, respectively, as
        ///         <i>extensionString</i>.
        ///     </para>
        ///     <para>
        ///         Returns <see cref="Gl.GL_TRUE" /> if <i>extensionName</i> is supported
        ///         otherwise <see cref="Gl.GL_FALSE" /> is returned.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Cases where one extension name is a substring of another are correctly
        ///         handled.
        ///     </para>
        ///     <para>
        ///         There may or may not be leading or trailing blanks in <i>extensionString</i>.
        ///     </para>
        ///     <para>
        ///         Extension names should not contain embedded spaces.
        ///     </para>
        ///     <para>
        ///         All strings are null-terminated.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glGetString" />
        /// <seealso cref="gluGetString" />
        /// /*seealso cref="glXGetClientString" />*/
        /// /*seealso cref="glXQueryExtensionsString" />*/
        /// /*seealso cref="glXQueryServerString" />*/
        // GLAPI GLboolean GLAPIENTRY gluCheckExtension (const GLubyte *extName, const GLubyte *extString);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluCheckExtension(string extensionName, string extensionString);
        #endregion int gluCheckExtension(string extensionName, string extensionString)

        #region gluCylinder([In] GLUquadric quad, double baseRadius, double topRadius, double height, int slices, int stacks)
        /// <summary>
        ///     Draws a cylinder.
        /// </summary>
        /// <param name="quad">
        ///     Specifies the quadrics object (created with <see cref="gluNewQuadric" />).
        /// </param>
        /// <param name="baseRadius">
        ///     Specifies the radius of the cylinder at <c>z = 0</c>.
        /// </param>
        /// <param name="topRadius">
        ///     Specifies the radius of the cylinder at <c>z = height</c>.  If <i>top</i> is
        ///     set to 0, this subroutine generates a cone.
        /// </param>
        /// <param name="height">
        ///     Specifies the height of the cylinder.
        /// </param>
        /// <param name="slices">
        ///     Specifies the number of subdivisions around the z axis.
        /// </param>
        /// <param name="stacks">
        ///     Specifies the number of subdivisions along the z axis.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluCylinder</b> draws a cylinder oriented along the z axis.  The base of
        ///         the cylinder is placed at z = 0, and the top at z = height.  Like a sphere,
        ///         a cylinder is subdivided around the z axis into slices, and along the z axis
        ///         into stacks.
        ///     </para>
        ///     <para>
        ///         Note that if <i>top</i> is set to 0.0, this routine generates a cone.
        ///     </para>
        ///     <para>
        ///         If the orientation is set to <see cref="GLU_OUTSIDE" /> (with
        ///         <see cref="gluQuadricOrientation" />), then any generated normals point away
        ///         from the z axis.  Otherwise, they point toward the z axis.
        ///     </para>
        ///     <para>
        ///         If texturing is turned on using the <see cref="gluQuadricTexture" />
        ///         subroutine, texture coordinates are generated so that t ranges linearly from
        ///         0.0 at z = 0 to 1.0 at z = height, and s ranges from 0.0 at the +y axis to
        ///         0.25 at the +x axis, as well as up to 0.5 at the -y axis and 0.75 at the
        ///         -x axis, then back to 1.0 at the +y axis.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluDisk" />
        /// <seealso cref="gluNewQuadric" />
        /// <seealso cref="gluPartialDisk" />
        /// <seealso cref="gluQuadricOrientation" />
        /// <seealso cref="gluQuadricTexture" />
        /// <seealso cref="gluSphere" />
        // void APIENTRY gluCylinder(GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluCylinder([In] GLUquadric quad, double baseRadius, double topRadius, double height, int slices, int stacks);
        #endregion gluCylinder([In] GLUquadric quad, double baseRadius, double topRadius, double height, int slices, int stacks)

        #region gluDeleteNurbsRenderer([In] GLUnurbs nurb)
        /// <summary>
        ///     Destroys a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object to be destroyed (created with
        ///     <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <remarks>
        ///     <b>gluDeleteNurbsRenderer</b> destroys the NURBS object (which was created with
        ///     <see cref="gluNewNurbsRenderer" />) and frees any memory it uses.  Once
        ///     <b>gluDeleteNurbsRenderer</b> has been called, <i>nurb</i> cannot be used again.
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        // void APIENTRY gluDeleteNurbsRenderer(GLUnurbs *nobj);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluDeleteNurbsRenderer([In] GLUnurbs nurb);
        #endregion gluDeleteNurbsRenderer([In] GLUnurbs nurb)

        #region gluDeleteQuadric([In] GLUquadric quad)
        /// <summary>
        ///     Destroys a quadrics object.
        /// </summary>
        /// <param name="quad">
        ///     The quadric object to be destroyed (created with
        ///     <see cref="gluNewQuadric" />).
        /// </param>
        /// <remarks>
        ///     <b>gluDeleteQuadric</b> destroys the quadrics object (created with
        ///     <see cref="gluNewQuadric" />) and frees any memory it uses.  Once
        ///     <b>gluDeleteQuadric</b> has been called, <i>quad</i> cannot be used again.
        /// </remarks>
        /// <seealso cref="gluNewQuadric" />
        // void APIENTRY gluDeleteQuadric(GLUquadric *state);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluDeleteQuadric([In] GLUquadric quad);
        #endregion gluDeleteQuadric([In] GLUquadric quad)

        #region gluDeleteTess([In] GLUtesselator tess)
        /// <summary>
        ///     Destroys a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object to destroy (created with <see cref="gluNewTess" />).
        /// </param>
        /// <remarks>
        ///     <b>gluDeleteTess</b> destroys the indicated tessellation object (which was
        ///     created with <see cref="gluNewTess" />) and frees any memory that it used.
        ///     Once <b>gluDeleteTess</b> has been called, <i>tess</i> cannot be used again.
        /// </remarks>
        /// <seealso cref="gluBeginPolygon" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // void APIENTRY gluDeleteTess(GLUtesselator *tess);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluDeleteTess([In] GLUtesselator tess);
        #endregion gluDeleteTess([In] GLUtesselator tess)

        #region gluDisk([In] GLUquadric quad, double innerRadius, double outerRadius, int slices, int loops)
        /// <summary>
        ///     Draws a disk.
        /// </summary>
        /// <param name="quad">
        ///     The quadric object (created with <see cref="gluNewQuadric" />).
        /// </param>
        /// <param name="innerRadius">
        ///     The inner radius of the disk (may be zero).
        /// </param>
        /// <param name="outerRadius">
        ///     The outer radius of the disk.
        /// </param>
        /// <param name="slices">
        ///     The number of subdivisions around the z-axis.
        /// </param>
        /// <param name="loops">
        ///     The number of concentric rings about the origin into which the disk is subdivided.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluDisk</b> renders a disk on the z = 0 plane.  The disk has a radius of
        ///         <i>outerRadius</i>, and contains a concentric circular hole with a radius of
        ///         <i>innerRadius</i>.  If <i>innerRadius</i> is 0, then no hole is generated.
        ///         The disk is subdivided around the z axis into slices (like pizza slices),
        ///         and also about the z axis into rings (as specified by <i>slices</i> and
        ///         <i>loops</i>, respectively).
        ///     </para>
        ///     <para>
        ///         With respect to orientation, the +z side of the disk is considered to be
        ///         "outside" (see <see cref="gluQuadricOrientation" />).  This means that if the
        ///         orientation is set to <see cref="GLU_OUTSIDE" />, then any normals generated
        ///         point along the +z axis.  Otherwise, they point along the -z axis.
        ///     </para>
        ///     <para>
        ///         If texturing has been turned on (with <see cref="gluQuadricTexture" />),
        ///         texture coordinates are generated linearly such that where r = outerRadius,
        ///         the value at (r, 0, 0) is (1, 0.5), at (0, r, 0) it is (0.5, 1), at
        ///         (-r, 0, 0) it is (0, 0.5), and at (0, -r, 0) it is (0.5, 0).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluCylinder" />
        /// <seealso cref="gluNewQuadric" />
        /// <seealso cref="gluPartialDisk" />
        /// <seealso cref="gluQuadricOrientation" />
        /// <seealso cref="gluQuadricTexture" />
        /// <seealso cref="gluSphere" />
        // void APIENTRY gluDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluDisk([In] GLUquadric quad, double innerRadius, double outerRadius, int slices, int loops);
        #endregion gluDisk([In] GLUquadric quad, double innerRadius, double outerRadius, int slices, int loops)

        #region gluEndCurve([In] GLUnurbs nurb)
        /// <summary>
        ///     Delimits a Non-Uniform Rational B-Spline (NURBS) curve definition.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         Use <see cref="gluBeginCurve" /> to mark the beginning of a NURBS curve
        ///         definition.  After calling <see cref="gluBeginCurve" />, make one or more
        ///         calls to <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" /> to define the attributes of the curve.
        ///         Exactly one of the calls to <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" /> must have a curve
        ///         type of <see cref="Gl.GL_MAP1_VERTEX_3" /> or
        ///         <see cref="Gl.GL_MAP1_VERTEX_4" />.  To mark the end of the NURBS curve
        ///         definition, call <b>gluEndCurve</b>.
        ///     </para>
        ///     <para>
        ///         OpenGL evaluators are used to render the NURBS curve as a series of line
        ///         segments.  Evaluator state is preserved during rendering with
        ///         <c>Gl.glPushAttrib(Gl.GL_EVAL_BIT)</c> and <c>Gl.glPopAttrib</c>.  For
        ///         information on exactly what state these calls preserve, see
        ///         <see cref="Gl.glPushAttrib" />.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following commands render a textured NURBS curve with normals; texture
        ///         coordinates and normals are also specified as NURBS curves:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginCurve(nobj);
        ///                 Glu.gluNurbsCurve(nobj, ..., Gl.GL_MAP1_TEXTURE_COORD_2);
        ///                 Glu.gluNurbsCurve(nobj, ..., Gl.GL_MAP1_NORMAL);
        ///                 Glu.gluNurbsCurve(nobj, ..., Gl.GL_MAP1_VERTEX_4);
        ///             Glu.gluEndCurve(nobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glPopAttrib" />
        /// <seealso cref="Gl.glPushAttrib" />
        /// <seealso cref="gluBeginSurface" />
        /// <seealso cref="gluBeginTrim" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />
        // void APIENTRY gluEndCurve(GLUnurbs *nobj);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluEndCurve([In] GLUnurbs nurb);
        #endregion gluEndCurve([In] GLUnurbs nurb)

        #region gluEndPolygon([In] GLUtesselator tess)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <see cref="gluBeginPolygon" /> delimits the definition of a nonconvex
        ///         polygon.  To define such a polygon, first call
        ///         <see cref="gluBeginPolygon" />.  Then define the contours of the polygon by
        ///         calling <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" /> for each vertex and
        ///         <see cref="gluNextContour" /> to start each new contour.  Finally, call
        ///         <b>gluEndPolygon</b> to signal the end of the definition.  See the
        ///         <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" /> and <see cref="gluNextContour" /> reference
        ///         pages for more details.
        ///     </para>
        ///     <para>
        ///         Once <b>gluEndPolygon</b> is called, the polygon is tessellated, and the
        ///         resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         This command is obsolete and is provided for backward compatibility only.
        ///         Calls to <see cref="gluBeginPolygon" /> are mapped to
        ///         <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> followed by
        ///         <see cref="gluTessBeginContour" />.  Calls to <b>gluEndPolygon</b> are mapped
        ///         to <see cref="gluTessEndContour" /> followed by
        ///         <see cref="gluTessEndPolygon" />.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         A quadrilateral with a triangular hole in it can be described like this:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginPolygon(tobj);
        ///                 Glu.gluTessVertex(tobj, v1, v1);
        ///                 Glu.gluTessVertex(tobj, v2, v2);
        ///                 Glu.gluTessVertex(tobj, v3, v3);
        ///                 Glu.gluTessVertex(tobj, v4, v4);
        ///             Glu.gluNextContour(tobj, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessVertex(tobj, v5, v5);
        ///                 Glu.gluTessVertex(tobj, v6, v6);
        ///                 Glu.gluTessVertex(tobj, v7, v7);
        ///             Glu.gluEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluNextContour" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluEndPolygon(GLUtesselator *tess);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluEndPolygon([In] GLUtesselator tess);
        #endregion gluEndPolygon([In] GLUtesselator tess)

        #region gluEndSurface([In] GLUnurbs nurb)
        /// <summary>
        ///     Delimits a NURBS surface definition.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         Use <see cref="gluBeginSurface" /> to mark the beginning of a NURBS surface
        ///         definition.  After calling <see cref="gluBeginSurface" />, make one or more
        ///         calls to <see cref="gluNurbsSurface(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int, float[], int, int, int)" /> to define the attributes of the
        ///         surface.  Exactly one of these calls to <see cref="gluNurbsSurface(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int, float[], int, int, int)" /> must
        ///         have a surface type of <see cref="Gl.GL_MAP2_VERTEX_3" /> or
        ///         <see cref="Gl.GL_MAP2_VERTEX_4" />.  To mark the end of the NURBS surface
        ///         definition, call <b>gluEndSurface</b>.
        ///     </para>
        ///     <para>
        ///         Trimming of NURBS surfaces is supported with <see cref="gluBeginTrim" />,
        ///         <see cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />, <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />, and
        ///         <see cref="gluEndTrim" />.  See the <see cref="gluBeginTrim" /> reference
        ///         page for details. 
        ///     </para>
        ///     <para>
        ///         OpenGL evaluators are used to render the NURBS surface as a set of polygons.
        ///         Evaluator state is preserved during rendering with
        ///         <c>Gl.glPushAttrib(Gl.GL_EVAL_BIT)</c> and <c>Gl.glPopAttrib()</c>.  See the
        ///         <see cref="Gl.glPushAttrib" /> reference page for details on exactly what
        ///         state these calls preserve.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following commands render a textured NURBS surface with normals; the
        ///         texture coordinates and normals are also described as NURBS surfaces:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginSurface(nobj);
        ///                 Glu.gluNurbsSurface(nobj, ..., Gl.GL_MAP2_TEXTURE_COORD_2);
        ///                 Glu.gluNurbsSurface(nobj, ..., Gl.GL_MAP2_NORMAL);
        ///                 Glu.gluNurbsSurface(nobj, ..., Gl.GL_MAP2_VERTEX_4);
        ///             Glu.gluEndSurface(nobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluBeginCurve" />
        /// <seealso cref="gluBeginTrim" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />
        /// <see cref="gluNurbsSurface(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int, float[], int, int, int)" />
        /// <seealso cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />
        // void APIENTRY gluEndSurface(GLUnurbs *nobj);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluEndSurface([In] GLUnurbs nurb);
        #endregion gluEndSurface([In] GLUnurbs nurb)

        #region gluEndTrim([In] GLUnurbs nurb)
        /// <summary>
        ///     Delimits a NURBS trimming loop definition.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />). 
        /// </param>
        /// <remarks>
        ///     <para>
        ///         Use <see cref="gluBeginTrim" /> to mark the beginning of a trimming loop, and
        ///         <b>gluEndTrim</b> to mark the end of a trimming loop.  A trimming loop is a
        ///         set of oriented curve segments (forming a closed curve) that define
        ///         boundaries of a NURBS surface.  You include these trimming loops in the
        ///         definition of a NURBS surface, between calls to
        ///         <see cref="gluBeginSurface" /> and <see cref="gluEndSurface" />.
        ///     </para>
        ///     <para>
        ///         The definition for a NURBS surface can contain many trimming loops.  For
        ///         example, if you wrote a definition for a NURBS surface that resembled a
        ///         rectangle with a hole punched out, the definition would contain two trimming
        ///         loops.  One loop would define the outer edge of the rectangle; the other
        ///         would define the hole punched out of the rectangle.  The definitions of each
        ///         of these trimming loops would be bracketed by a <see cref="gluBeginTrim" />
        ///         and <b>gluEndTrim</b> pair.
        ///     </para>
        ///     <para>
        ///         The definition of a single closed trimming loop can consist of multiple curve
        ///         segments, each described as a piecewise linear curve (see
        ///         <see cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />) or as a single NURBS curve (see
        ///         <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />), or as a combination of both in any order.  The
        ///         only library calls that can appear in a trimming loop definition (between the
        ///         calls to <see cref="gluBeginTrim" /> and <b>gluEndTrim</b> are
        ///         <see cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" /> and <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />.
        ///     </para>
        ///     <para>
        ///         The area of the NURBS surface that is displayed is the region in the domain
        ///         to the left of the trimming curve as the curve parameter increases.  Thus,
        ///         the retained region of the NURBS surface is inside a counterclockwise
        ///         trimming loop and outside a clockwise trimming loop.  For the rectangle
        ///         mentioned earlier, the trimming loop for the outer edge of the rectangle runs
        ///         counterclockwise, while the trimming loop for the punched-out hole runs
        ///         clockwise.
        ///     </para>
        ///     <para>
        ///         If you use more than one curve to define a single trimming loop, the curve
        ///         segments must form a closed loop (that is, the endpoint of each curve must be
        ///         the starting point of the next curve, and the endpoint of the final curve
        ///         must be the starting point of the first curve).  If the endpoints of the
        ///         curve are sufficiently close together but not exactly coincident, they will
        ///         be coerced to match.  If the endpoints are not sufficiently close, an error
        ///         results (see <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         If a trimming loop definition contains multiple curves, the direction of the
        ///         curves must be consistent (that is, the inside must be to the left of all of
        ///         the curves).  Nested trimming loops are legal as long as the curve
        ///         orientations alternate correctly.  If trimming curves are self-intersecting,
        ///         or intersect one another, an error results.
        ///     </para>
        ///     <para>
        ///         If no trimming information is given for a NURBS surface, the entire surface
        ///         is drawn.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         This code fragment defines a trimming loop that consists of one piecewise
        ///         linear curve, and two NURBS curves:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginTrim(nobj);
        ///                 Glu.gluPwlCurve(..., Glu.GLU_MAP1_TRIM_2);
        ///                 Glu.gluNurbsCurve(..., Glu.GLU_MAP1_TRIM_2);
        ///                 Glu.gluNurbsCurve(..., Glu.GLU_MAP1_TRIM_3);
        ///             Glu.gluEndTrim(nobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluBeginSurface" />
        /// <seealso cref="gluEndSurface" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        /// <seealso cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />
        /// <seealso cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />
        // void APIENTRY gluEndTrim(GLUnurbs *nobj);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluEndTrim([In] GLUnurbs nurb);
        #endregion gluEndTrim([In] GLUnurbs nurb)

        #region string gluErrorString(int errorCode)
        /// <summary>
        ///     Produces an error string from a GL or GLU error code.
        /// </summary>
        /// <param name="errorCode">
        ///     An OpenGL or GLU error code.
        /// </param>
        /// <returns>
        ///     A string representation of the error.
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluErrorString</b> produces an error string from a GL or GLU error code.
        ///         The string is in ISO Latin 1 format.  For example,
        ///         <c>gluErrorString(Gl.GL_OUT_OF_MEMORY)</c> returns the string 'out of
        ///         memory'.
        ///     </para>
        ///     <para>
        ///         The standard GLU error codes are <see cref="GLU_INVALID_ENUM" />,
        ///         <see cref="GLU_INVALID_VALUE" />, and <see cref="GLU_OUT_OF_MEMORY" />.
        ///         Certain other GLU functions can return specialized error codes through
        ///         callbacks.  See the <see cref="Gl.glGetError" /> reference page for the list
        ///         of GL error codes.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <c>NULL</c> is returned if <i>errorCode</i> is not a valid GL or GLU error
        ///         code.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glGetError" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        /// <seealso cref="gluQuadricCallback" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // const GLubyte* APIENTRY gluErrorString(GLenum errCode);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluErrorString"), SuppressUnmanagedCodeSecurity]
        private static extern IntPtr gluErrorStringUnsafe(int errorCode);

        public static string gluErrorString(int errorCode)
        {
            return Marshal.PtrToStringAnsi(gluErrorStringUnsafe(errorCode));
        }
        #endregion string gluErrorString(int errorCode)

        #region string gluErrorStringWIN(int errorCode)
        /// <summary>
        ///     Produces an error string from a GL or GLU error code.
        /// </summary>
        /// <param name="errorCode">
        ///     An OpenGL or GLU error code.
        /// </param>
        /// <returns>
        ///     A string representation of the error.
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluErrorStringWIN</b> produces an error string from a GL or GLU error
        ///         code.  The string is in UNICODE format.  For example,
        ///         <c>gluErrorStringWIN(Gl.GL_OUT_OF_MEMORY)</c> returns the string 'out of
        ///         memory'.
        ///     </para>
        ///     <para>
        ///         The standard GLU error codes are <see cref="GLU_INVALID_ENUM" />,
        ///         <see cref="GLU_INVALID_VALUE" />, and <see cref="GLU_OUT_OF_MEMORY" />.
        ///         Certain other GLU functions can return specialized error codes through
        ///         callbacks.  See the <see cref="Gl.glGetError" /> reference page for the list
        ///         of GL error codes.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <c>NULL</c> is returned if <i>errorCode</i> is not a valid GL or GLU error
        ///         code.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glGetError" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        /// <seealso cref="gluQuadricCallback" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // const GLubyte* APIENTRY gluErrorStringWIN(GLenum errCode);
        public static string gluErrorStringWIN(int errorCode)
        {
            return gluErrorUnicodeStringEXT(errorCode);
        }
        #endregion string gluErrorStringWIN(int errorCode)

        #region string gluErrorUnicodeStringEXT(int errorCode)
        /// <summary>
        ///     Produces an error string from a GL or GLU error code.
        /// </summary>
        /// <param name="errorCode">
        ///     An OpenGL or GLU error code.
        /// </param>
        /// <returns>
        ///     A Unicode string representation of the error.
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluErrorString</b> produces an error string from a GL or GLU error code.
        ///         The string is in UNICODE format.  For example,
        ///         <c>gluErrorString(Gl.GL_OUT_OF_MEMORY)</c> returns the string 'out of
        ///         memory'.
        ///     </para>
        ///     <para>
        ///         The standard GLU error codes are <see cref="GLU_INVALID_ENUM" />,
        ///         <see cref="GLU_INVALID_VALUE" />, and <see cref="GLU_OUT_OF_MEMORY" />.
        ///         Certain other GLU functions can return specialized error codes through
        ///         callbacks.  See the <see cref="Gl.glGetError" /> reference page for the list
        ///         of GL error codes.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <c>NULL</c> is returned if <i>errorCode</i> is not a valid GL or GLU error
        ///         code.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glGetError" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        /// <seealso cref="gluQuadricCallback" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // const wchar_t* APIENTRY gluErrorUnicodeStringEXT(GLenum errCode);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluErrorUnicodeStringEXT"), SuppressUnmanagedCodeSecurity]
        private static extern IntPtr gluErrorUnicodeStringEXTUnsafe(int errorCode);

        public static string gluErrorUnicodeStringEXT(int errorCode)
        {
            return Marshal.PtrToStringAnsi(gluErrorUnicodeStringEXTUnsafe(errorCode));
        }
        #endregion string gluErrorUnicodeStringEXT(int errorCode)

        #region gluGetNurbsProperty([In] GLUnurbs nurb, int property, [Out] float[] data)
        /// <summary>
        ///     Gets a NURBS property.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="property">
        ///     The property whose value is to be retrieved.  The following values are valid:
        ///     <see cref="GLU_SAMPLING_TOLERANCE" />, <see cref="GLU_DISPLAY_MODE" />,
        ///     <see cref="GLU_CULLING" />, <see cref="GLU_AUTO_LOAD_MATRIX" />,
        ///     <see cref="GLU_PARAMETRIC_TOLERANCE" />,
        ///     <see cref="GLU_SAMPLING_METHOD" />, <see cref="GLU_U_STEP" />, and
        ///     <see cref="GLU_V_STEP" />.
        /// </param>
        /// <param name="data">
        ///     A pointer to the location into which the value of the named property is
        ///     written.
        /// </param>
        /// <remarks>
        ///     <b>gluGetNurbsProperty</b> retrieves properties stored in a NURBS object.
        ///     These properties affect the way that NURBS curves and surfaces are rendered.
        ///     See the <see cref="gluNurbsProperty" /> reference page for information about
        ///     what the properties are and what they do.
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluGetNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat *value);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluGetNurbsProperty([In] GLUnurbs nurb, int property, [Out] float[] data);
        #endregion gluGetNurbsProperty([In] GLUnurbs nurb, int property, [Out] float[] data)

        #region gluGetNurbsProperty([In] GLUnurbs nurb, int property, out float data)
        /// <summary>
        ///     Gets a NURBS property.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="property">
        ///     The property whose value is to be retrieved.  The following values are valid:
        ///     <see cref="GLU_SAMPLING_TOLERANCE" />, <see cref="GLU_DISPLAY_MODE" />,
        ///     <see cref="GLU_CULLING" />, <see cref="GLU_AUTO_LOAD_MATRIX" />,
        ///     <see cref="GLU_PARAMETRIC_TOLERANCE" />,
        ///     <see cref="GLU_SAMPLING_METHOD" />, <see cref="GLU_U_STEP" />, and
        ///     <see cref="GLU_V_STEP" />.
        /// </param>
        /// <param name="data">
        ///     A pointer to the location into which the value of the named property is
        ///     written.
        /// </param>
        /// <remarks>
        ///     <b>gluGetNurbsProperty</b> retrieves properties stored in a NURBS object.
        ///     These properties affect the way that NURBS curves and surfaces are rendered.
        ///     See the <see cref="gluNurbsProperty" /> reference page for information about
        ///     what the properties are and what they do.
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluGetNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat *value);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluGetNurbsProperty([In] GLUnurbs nurb, int property, out float data);
        #endregion gluGetNurbsProperty([In] GLUnurbs nurb, int property, out float data)

        #region gluGetNurbsProperty([In] GLUnurbs nurb, int property, [Out] IntPtr data)
        /// <summary>
        ///     Gets a NURBS property.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="property">
        ///     The property whose value is to be retrieved.  The following values are valid:
        ///     <see cref="GLU_SAMPLING_TOLERANCE" />, <see cref="GLU_DISPLAY_MODE" />,
        ///     <see cref="GLU_CULLING" />, <see cref="GLU_AUTO_LOAD_MATRIX" />,
        ///     <see cref="GLU_PARAMETRIC_TOLERANCE" />,
        ///     <see cref="GLU_SAMPLING_METHOD" />, <see cref="GLU_U_STEP" />, and
        ///     <see cref="GLU_V_STEP" />.
        /// </param>
        /// <param name="data">
        ///     A pointer to the location into which the value of the named property is
        ///     written.
        /// </param>
        /// <remarks>
        ///     <b>gluGetNurbsProperty</b> retrieves properties stored in a NURBS object.
        ///     These properties affect the way that NURBS curves and surfaces are rendered.
        ///     See the <see cref="gluNurbsProperty" /> reference page for information about
        ///     what the properties are and what they do.
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluGetNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat *value);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluGetNurbsProperty([In] GLUnurbs nurb, int property, [Out] IntPtr data);
        #endregion gluGetNurbsProperty([In] GLUnurbs nurb, int property, [Out] IntPtr data)

        #region string gluGetString(int name)
        /// <summary>
        ///     Gets a string that describes the GLU version number or supported GLU extension
        ///     calls.
        /// </summary>
        /// <param name="name">
        ///     Either the version number of GLU (<see cref="GLU_VERSION" />) or available
        ///     vendor-specific extension calls (<see cref="GLU_EXTENSIONS" />).
        /// </param>
        /// <returns>
        ///     Returns a string describing the GLU version or the GLU extensions that are
        ///     supported.
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluGetString</b> returns a string describing the GLU version or the GLU
        ///         extensions that are supported.  When <i>name</i> is
        ///         <see cref="GLU_VERSION" />, the returned string is a value that represents
        ///         the version number of GLU.  The format of the version number is as follows:
        ///     </para>
        ///     <para>
        ///         &lt;version number&gt;&lt;space&gt;&lt;vendor-specific information&gt; 
        ///         (for example, "1.2.11 Microsoft Windows NT")
        ///     </para>
        ///     <para>
        ///         The version number has the form "major_number.minor_number" or
        ///         "major_number.minor_number.release_number".  The vendor-specific information
        ///         is optional, and the format and contents depend on the implementation.
        ///     </para>
        ///     <para>
        ///         When <i>name</i> is <see cref="GLU_EXTENSIONS" />, the returned string
        ///         contains a list of names of supported GLU extensions that are separated by
        ///         spaces.  The format of the returned list of names is as follows:
        ///     </para>
        ///     <para>
        ///         &lt;extension_name&gt;&lt;space&gt;&lt;extension_name&gt;&lt;space&gt; . . .
        ///         (for example, "GLU_NURBS GL_TESSELATION")
        ///     </para>
        ///     <para>
        ///         The extension names cannot contain any spaces.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         The <b>gluGetString</b> function is valid for GLU version 1.1 or later.
        ///     </para>
        ///     <para>
        ///         All strings are NULL-terminated.
        ///     </para>
        ///     <para>
        ///         <b>gluGetString</b> only returns information about GLU extensions.  Call
        ///         <see cref="Gl.glGetString" /> to get a list of GL extensions.
        ///     </para>
        ///     <para>
        ///         <b>gluGetString</b> is an initialization routine.  Calling it after a
        ///         <see cref="Gl.glNewList(int, int)" /> results in undefined behavior.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <c>NULL</c> is returned if name is not <see cref="GLU_VERSION" /> or
        ///         <see cref="GLU_EXTENSIONS" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glGetString" />
        // const GLubyte* APIENTRY gluGetString(GLenum name);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION, EntryPoint = "gluGetString"), SuppressUnmanagedCodeSecurity]
        private static extern IntPtr gluGetStringUnsafe(int name);

        public static string gluGetString(int name)
        {
            return Marshal.PtrToStringAnsi(gluGetStringUnsafe(name));
        }
        #endregion string gluGetString(int name)

        #region gluGetTessProperty([In] GLUtesselator tess, int which, [Out] double[] data)
        /// <summary>
        ///     Gets a tessellation object property.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     The property whose value is to be retrieved.  The following values are valid:
        ///     <see cref="GLU_TESS_WINDING_RULE" />, <see cref="GLU_TESS_BOUNDARY_ONLY" />,
        ///     and <see cref="GLU_TESS_TOLERANCE" />.
        /// </param>
        /// <param name="data">
        ///     A pointer to the location where the value of the named property is written.
        /// </param>
        /// <remarks>
        ///     <b>gluGetTessProperty</b> retrieves properties stored in a tessellation
        ///     object.  These properties affect the way that tessellation objects are
        ///     interpreted and rendered.  See the <see cref="gluTessProperty" /> reference
        ///     page for information about the properties and what they do.
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *value);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluGetTessProperty([In] GLUtesselator tess, int which, [Out] double[] data);
        #endregion gluGetTessProperty([In] GLUtesselator tess, int which, [Out] double[] data)

        #region gluGetTessProperty([In] GLUtesselator tess, int which, out double data)
        /// <summary>
        ///     Gets a tessellation object property.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     The property whose value is to be retrieved.  The following values are valid:
        ///     <see cref="GLU_TESS_WINDING_RULE" />, <see cref="GLU_TESS_BOUNDARY_ONLY" />,
        ///     and <see cref="GLU_TESS_TOLERANCE" />.
        /// </param>
        /// <param name="data">
        ///     A pointer to the location where the value of the named property is written.
        /// </param>
        /// <remarks>
        ///     <b>gluGetTessProperty</b> retrieves properties stored in a tessellation
        ///     object.  These properties affect the way that tessellation objects are
        ///     interpreted and rendered.  See the <see cref="gluTessProperty" /> reference
        ///     page for information about the properties and what they do.
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *value);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluGetTessProperty([In] GLUtesselator tess, int which, out double data);
        #endregion gluGetTessProperty([In] GLUtesselator tess, int which, out double data)

        #region gluGetTessProperty([In] GLUtesselator tess, int which, [Out] IntPtr data)
        /// <summary>
        ///     Gets a tessellation object property.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     The property whose value is to be retrieved.  The following values are valid:
        ///     <see cref="GLU_TESS_WINDING_RULE" />, <see cref="GLU_TESS_BOUNDARY_ONLY" />,
        ///     and <see cref="GLU_TESS_TOLERANCE" />.
        /// </param>
        /// <param name="data">
        ///     A pointer to the location where the value of the named property is written.
        /// </param>
        /// <remarks>
        ///     <b>gluGetTessProperty</b> retrieves properties stored in a tessellation
        ///     object.  These properties affect the way that tessellation objects are
        ///     interpreted and rendered.  See the <see cref="gluTessProperty" /> reference
        ///     page for information about the properties and what they do.
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *value);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluGetTessProperty([In] GLUtesselator tess, int which, [Out] IntPtr data);
        #endregion gluGetTessProperty([In] GLUtesselator tess, int which, [Out] IntPtr data)

        #region gluLoadSamplingMatrices([In] GLUnurbs nurb, [In] float[] modelMatrix, [In] float[] projectionMatrix, [In] int[] viewport)
        /// <summary>
        ///     Loads NURBS sampling and culling matrices.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="modelMatrix">
        ///     A modelview matrix (as from a <see cref="Gl.glGetFloatv(int, IntPtr)" /> call).
        /// </param>
        /// <param name="projectionMatrix">
        ///     A projection matrix (as from a <see cref="Gl.glGetFloatv(int, IntPtr)" /> call).
        /// </param>
        /// <param name="viewport">
        ///     A viewport (as from a <see cref="Gl.glGetIntegerv(int, IntPtr)" /> call).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluLoadSamplingMatrices</b> uses <i>modelMatrix</i>,
        ///         <i>projectionMatrix</i>, and <i>viewport</i> to recompute the sampling and
        ///         culling matrices stored in <i>nurb</i>.  The sampling matrix determines how
        ///         finely a NURBS curve or surface must be tessellated to satisfy the sampling
        ///         tolerance (as determined by the <see cref="GLU_SAMPLING_TOLERANCE" />
        ///         property).  The culling matrix is used in deciding if a NURBS curve or
        ///         surface should be culled before rendering (when the
        ///         <see cref="GLU_CULLING" /> property is turned on).
        ///     </para>
        ///     <para>
        ///         <b>gluLoadSamplingMatrices</b> is necessary only if the
        ///         <see cref="GLU_AUTO_LOAD_MATRIX" /> property is turned off (see
        ///         <see cref="gluNurbsProperty" />).  Although it can be convenient to leave the
        ///         <see cref="GLU_AUTO_LOAD_MATRIX" /> property turned on, there can be a
        ///         performance penalty for doing so.  (A round trip to the GL server is needed
        ///         to fetch the current values of the modelview matrix, projection matrix, and
        ///         viewport.)
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glGetFloatv(int, IntPtr)" />
        /// <seealso cref="Gl.glGetIntegerv(int, IntPtr)" />
        /// <seealso cref="gluGetNurbsProperty(Tao.OpenGl.Glu.GLUnurbs, int, float[])" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluLoadSamplingMatrices(GLUnurbs *nobj, const GLfloat modelMatrix[16], const GLfloat projMatrix[16], const GLint viewport[4]);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluLoadSamplingMatrices([In] GLUnurbs nurb, [In] float[] modelMatrix, [In] float[] projectionMatrix, [In] int[] viewport);
        #endregion gluLoadSamplingMatrices([In] GLUnurbs nurb, [In] float[] modelMatrix, [In] float[] projectionMatrix, [In] int[] viewport)

        #region gluLookAt(double eyeX, double eyeY, double eyeZ, double centerX, double centerY, double centerZ, double upX, double upY, double upZ)
        /// <summary>
        ///     Defines a viewing transformation.
        /// </summary>
        /// <param name="eyeX">
        ///     The x axis position of the eye point.
        /// </param>
        /// <param name="eyeY">
        ///     The y axis position of the eye point.
        /// </param>
        /// <param name="eyeZ">
        ///     The z axis position of the eye point.
        /// </param>
        /// <param name="centerX">
        ///     The x axis position of the reference point.
        /// </param>
        /// <param name="centerY">
        ///     The y axis position of the reference point.
        /// </param>
        /// <param name="centerZ">
        ///     The z axis position of the reference point.
        /// </param>
        /// <param name="upX">
        ///     The x axis direction of the up vector.
        /// </param>
        /// <param name="upY">
        ///     The y axis direction of the up vector.
        /// </param>
        /// <param name="upZ">
        ///     The z axis direction of the up vector.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluLookAt</b> creates a viewing matrix derived from an eye point, a
        ///         reference point indicating the center of the scene, and an UP vector.
        ///     </para>
        ///     <para>
        ///         The matrix maps the reference point to the negative z axis and the eye point
        ///         to the origin.  When a typical projection matrix is used, the center of the
        ///         scene therefore maps to the center of the viewport.  Similarly, the direction
        ///         described by the UP vector projected onto the viewing plane is mapped to the
        ///         positive y axis so that it points upward in the viewport.  The UP vector must
        ///         not be parallel to the line of sight from the eye point to the reference
        ///         point.
        ///     </para>
        ///     <para>
        ///         The matrix generated by <b>gluLookAt</b> postmultiplies the current matrix.
        ///     </para>
        ///     <para>
        ///         The matrix M generated by the OpenGL could be computed as follows:
        ///     </para>
        ///     <para>
        ///         Let E be the 3d column vector (eyeX, eyeY, eyeZ).
        ///         Let C be the 3d column vector (centerX, centerY, centerZ).
        ///         Let U be the 3d column vector (upX, upY, upZ).
        ///         Compute L = C - E.
        ///         Normalize L.
        ///         Compute S = L x U.
        ///         Normalize S.
        ///         Compute U' = S x L.
        ///     </para>
        ///     <para>
        ///         M is the matrix whose columns are, in order:
        ///     </para>
        ///     <para>
        ///         (S, 0), (U', 0), (-L, 0), (-E, 1)  (all column vectors)
        ///     </para>
        ///     <para>
        ///         Note: This matrix is defined for use in systems where the the modelling
        ///         coordinate vector is a column vector and is multiplied on the left by the
        ///         matrices.  If you prefer a row vector which gets multiplied by matrices to
        ///         its right, then use the transpose of this matrix M.
        ///     </para>
        ///     <para>
        ///         Note: It is necessary that the UP vector NOT be parallel to the line
        ///         connecting the center point with the eye point.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glFrustum" />
        /// <seealso cref="gluPerspective" />
        // void APIENTRY gluLookAt(GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluLookAt(double eyeX, double eyeY, double eyeZ, double centerX, double centerY, double centerZ, double upX, double upY, double upZ);
        #endregion gluLookAt(double eyeX, double eyeY, double eyeZ, double centerX, double centerY, double centerZ, double upX, double upY, double upZ)

        #region GLUnurbs gluNewNurbsRenderer()
        /// <summary>
        ///     Creates a NURBS object.
        /// </summary>
        /// <returns>
        ///     Returns a pointer to a new NURBS object.
        /// </returns>
        /// <remarks>
        ///     <b>gluNewNurbsRenderer</b> creates and returns a pointer to a new NURBS
        ///     object.  This object must be referred to when calling NURBS rendering and
        ///     control functions.  A return value of 0 means that there is not enough memory
        ///     to allocate the object.
        /// </remarks>
        /// <seealso cref="gluBeginCurve" />
        /// <seealso cref="gluBeginSurface" />
        /// <seealso cref="gluBeginTrim" />
        /// <seealso cref="gluDeleteNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        /// <seealso cref="gluNurbsProperty" />
        // GLUnurbs* APIENTRY gluNewNurbsRenderer(void);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern GLUnurbs gluNewNurbsRenderer();
        #endregion GLUnurbs gluNewNurbsRenderer()

        #region GLUquadric gluNewQuadric()
        /// <summary>
        ///     Creates a quadrics object.
        /// </summary>
        /// <returns>
        ///     Returns a pointer to a new quadrics object.
        /// </returns>
        /// <remarks>
        ///     <b>gluNewQuadric</b> creates and returns a pointer to a new quadrics object.
        ///     This object must be referred to when calling quadrics rendering and control
        ///     functions.  A return value of 0 means that there is not enough memory to
        ///     allocate the object.
        /// </remarks>
        /// <seealso cref="gluCylinder" />
        /// <seealso cref="gluDeleteQuadric" />
        /// <seealso cref="gluDisk" />
        /// <seealso cref="gluPartialDisk" />
        /// <seealso cref="gluQuadricCallback" />
        /// <seealso cref="gluQuadricDrawStyle" />
        /// <seealso cref="gluQuadricNormals" />
        /// <seealso cref="gluQuadricOrientation" />
        /// <seealso cref="gluQuadricTexture" />
        /// <seealso cref="gluSphere" />
        // GLUquadric* APIENTRY gluNewQuadric(void);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern GLUquadric gluNewQuadric();
        #endregion GLUquadric gluNewQuadric()

        #region GLUtesselator gluNewTess()
        /// <summary>
        ///     Creates a tessellation object.
        /// </summary>
        /// <returns>
        ///     Returns a pointer to a new tessellation object.
        /// </returns>
        /// <remarks>
        ///     <b>gluNewTess</b> creates and returns a pointer to a new tessellation object.
        ///     This object must be referred to when calling tessellation functions.  A
        ///     return value of 0 means that there is not enough memory to allocate the
        ///     object.
        /// </remarks>
        /// <seealso cref="gluDeleteTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        // GLUtesselator* APIENTRY gluNewTess(void);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern GLUtesselator gluNewTess();
        #endregion GLUtesselator gluNewTess()

        #region gluNextContour([In] GLUtesselator tess, int type)
        /// <summary>
        ///     Marks the beginning of another contour.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="type">
        ///     <para>
        ///         The type of the contour being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_EXTERIOR" /></term>
        ///                 <description>
        ///                     An exterior contour defines an exterior boundary of the polygon.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_INTERIOR" /></term>
        ///                 <description>
        ///                     An interior contour defines an interior boundary of the polygon
        ///                     (such as a hole).
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_UNKNOWN" /></term>
        ///                 <description>
        ///                     An unknown contour is analyzed by the library to determine
        ///                     whether it is interior or exterior.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_CCW" />, <see cref="GLU_CW" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The first <see cref="GLU_CCW" /> or <see cref="GLU_CW" />
        ///                         contour defined is considered to be exterior.  All other
        ///                         contours are considered to be exterior if they are oriented
        ///                         in the same direction (clockwise or counterclockwise) as the
        ///                         first contour, and interior if they are not.
        ///                     </para>
        ///                     <para>
        ///                         If one contour is of type <see cref="GLU_CCW" /> or
        ///                         <see cref="GLU_CW" />, then all contours must be of the same
        ///                         type (if they are not, then all <see cref="GLU_CCW" /> and
        ///                         <see cref="GLU_CW" /> contours will be changed to
        ///                         <see cref="GLU_UNKNOWN" />).  Note that there is no real
        ///                         difference between the <see cref="GLU_CCW" /> and
        ///                         <see cref="GLU_CW" /> contour types.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNextContour</b> is used in describing polygons with multiple contours.
        ///         After the first contour has been described through a series of
        ///         <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" /> calls, a <b>gluNextContour</b> call indicates
        ///         that the previous contour is complete and that the next contour is about to
        ///         begin.  Another series of <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" /> calls is then used to
        ///         describe the new contour.  This process can be repeated until all contours
        ///         have been described.
        ///     </para>
        ///     <para>
        ///         Before the first contour is described, <b>gluNextContour</b> can be called to
        ///         define the type of the first contour.  If <b>gluNextContour</b> is not called
        ///         before the first contour, then the first contour is marked
        ///         <see cref="GLU_EXTERIOR" />.
        ///     </para>
        ///     <para>
        ///         This command is obsolete and is provided for backward compatibility only.
        ///         Calls to <b>gluNextContour</b> are mapped to <see cref="gluTessEndContour" />
        ///         followed by <see cref="gluTessBeginContour" />.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can describe a quadrilateral with a triangular hole in it as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginPolygon(tess); 
        ///                 Glu.gluTessVertex(tess, v1, v1); 
        ///                 Glu.gluTessVertex(tess, v2, v2); 
        ///                 Glu.gluTessVertex(tess, v3, v3); 
        ///                 Glu.gluTessVertex(tess, v4, v4);  
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR); 
        ///                 Glu.gluTessVertex(tess, v5, v5); 
        ///                 Glu.gluTessVertex(tess, v6, v6); 
        ///                 Glu.gluTessVertex(tess, v7, v7);  
        ///             Glu.gluEndPolygon(tess); 
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndContour" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluNextContour(GLUtesselator *tess, GLenum type);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNextContour([In] GLUtesselator tess, int type);
        #endregion gluNextContour([In] GLUtesselator tess, int type)

        #region gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsBeginCallback func)
        /// <summary>
        ///     The <b>gluNurbsCallback</b> mehtod defines a callback for a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The legal callbacks are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback indicates the start of a primitive.  The
        ///                     function takes a single argument of type <see cref="int" />,
        ///                     which can be one of <see cref="Gl.GL_LINES" />,
        ///                     <see cref="Gl.GL_LINE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLES" />, or
        ///                     <see cref="Gl.GL_QUAD_STRIP" />.  The default begin callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR" /></term>
        ///                 <description>
        ///                     The color callback is invoked as the color of a vertex is
        ///                     generated.  The components of the color are stored in the
        ///                     parameter <i>colorData</i>.  This callback is effective only when
        ///                     the user provides a color map (<see cref="Gl.GL_MAP1_COLOR_4" />
        ///                     or <see cref="Gl.GL_MAP2_COLOR_4" />).  <i>colorData</i>
        ///                     contains four components: R,G,B,A.  The default color callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_COLOR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END" /></term>
        ///                 <description>
        ///                     The end callback is invoked at the end of a primitive.  The
        ///                     default end callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is <see cref="NurbsEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_END" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_ERROR" /></term>
        ///                 <description>
        ///                     The error function is called when an error is encountered.  Its
        ///                     single argument is of type <see cref="int" />, and it indicates
        ///                     the specific error that occurred.  There are 37 errors unique to
        ///                     NURBS named <see cref="GLU_NURBS_ERROR1" /> through
        ///                     <see cref="GLU_NURBS_ERROR37" />.  Character strings describing
        ///                     these errors can be retrieved with <see cref="gluErrorString" />.
        ///                     The delegate prototype for this callback is
        ///                     <see cref="NurbsErrorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL" /></term>
        ///                 <description>
        ///                     The normal callback is invoked as the vertex normal is generated.
        ///                     The components of the normal are stored in the parameter
        ///                     <i>normalData</i>.  In the case of a NURBS curve, the callback
        ///                     function is effective only when the user provides a normal map
        ///                     (<see cref="Gl.GL_MAP1_NORMAL" />).  In the case of a NURBS
        ///                     surface, if a normal map (<see cref="Gl.GL_MAP2_NORMAL" />) is
        ///                     provided, then the generated normal is computed from the normal
        ///                     map.  If a normal map is not provided then a surface normal is
        ///                     computed in a manner similar to that described for evaluators
        ///                     when <see cref="Gl.GL_AUTO_NORMAL" /> is enabled.  The default
        ///                     normal callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsNormalCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_NORMAL" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsNormalDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD" /></term>
        ///                 <description>
        ///                     The texture callback is invoked as the texture coordinates of a
        ///                     vertex are generated.  These coordinates are stored in the
        ///                     parameter <i>texCoord</i>.  The number of texture coordinates can
        ///                     be 1, 2, 3, or 4 depending on which type of texture map is
        ///                     specified (<see cref="Gl.GL_MAP1_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_4" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_4" />).  If no texture map is
        ///                     specified, this callback function will not be called.  The
        ///                     default texture callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsTexCoordCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_TEXTURE_COORD" />
        ///                     callback, except that it takes an additional pointer argument.
        ///                     This pointer is a copy of the pointer that was specified at the
        ///                     last call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsTexCoordDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback indicates a vertex of the primitive.  The
        ///                     coordinates of the vertex are stored in the parameter
        ///                     <i>vertexData</i>.  All the generated vertices have dimension 3,
        ///                     that is, homogeneous coordinates have been transformed into
        ///                     affine coordinates.  The default vertex callback function is
        ///                     <c>null</c>. The delegate prototype for this callback is
        ///                     <see cref="NurbsVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_VERTEX" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function that the callback invokes.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is used to define a callback to be used by a NURBS
        ///         object.  If the specified callback is already defined, then it is replaced.
        ///         If <i>func</i> is <c>null</c>, then this callback will not get invoked and
        ///         the related data, if any, will be lost.
        ///     </para>
        ///     <para>
        ///         Except the error callback, these callbacks are used by NURBS tessellator
        ///         (when <see cref="GLU_NURBS_MODE" /> is set to be
        ///         <see cref="GLU_NURBS_TESSELLATOR" />) to return back the OpenGL polygon
        ///         primitives resulting from the tessellation.  Note that there are two
        ///         versions of each callback: one with a user data pointer and one without.  If
        ///         both versions for a particular callback are specified then the callback with
        ///         the user data pointer will be used.  Note that <i>userData</i> is a copy of
        ///         the pointer that was specified at the last call to
        ///         <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.
        ///     </para>
        ///     <para>
        ///         The error callback function is effective no matter which value that
        ///         <see cref="GLU_NURBS_MODE" /> is set to.  All other callback functions are
        ///         effective only when <see cref="GLU_NURBS_MODE" /> is set to
        ///         <see cref="GLU_NURBS_TESSELLATOR" />.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is available only if the GLU version is 1.2 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         GLU version 1.2 supports only the <see cref="GLU_ERROR" /> parameter for
        ///         <i>which</i>.  The <see cref="GLU_ERROR" /> value is deprecated in GLU
        ///         version 1.3 in favor of <see cref="GLU_NURBS_ERROR" />.  All other
        ///         accepted values for <i>func</i> are available only if the GLU version is 1.3
        ///         or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="NurbsBeginCallback" />
        /// <seealso cref="NurbsBeginDataCallback" />
        /// <seealso cref="NurbsColorCallback" />
        /// <seealso cref="NurbsColorDataCallback" />
        /// <seealso cref="NurbsEndCallback" />
        /// <seealso cref="NurbsEndDataCallback" />
        /// <seealso cref="NurbsErrorCallback" />
        /// <seealso cref="NurbsNormalCallback" />
        /// <seealso cref="NurbsNormalDataCallback" />
        /// <seealso cref="NurbsTexCoordCallback" />
        /// <seealso cref="NurbsTexCoordDataCallback" />
        /// <seealso cref="NurbsVertexCallback" />
        /// <seealso cref="NurbsVertexDataCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        public static void gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsBeginCallback func)
        {
            nurbsBeginCallback = func;
            __gluNurbsCallback(nurb, which, nurbsBeginCallback);
        }
        #endregion gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsBeginCallback func)

        #region gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsBeginDataCallback func)
        /// <summary>
        ///     The <b>gluNurbsCallback</b> mehtod defines a callback for a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The legal callbacks are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback indicates the start of a primitive.  The
        ///                     function takes a single argument of type <see cref="int" />,
        ///                     which can be one of <see cref="Gl.GL_LINES" />,
        ///                     <see cref="Gl.GL_LINE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLES" />, or
        ///                     <see cref="Gl.GL_QUAD_STRIP" />.  The default begin callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR" /></term>
        ///                 <description>
        ///                     The color callback is invoked as the color of a vertex is
        ///                     generated.  The components of the color are stored in the
        ///                     parameter <i>colorData</i>.  This callback is effective only when
        ///                     the user provides a color map (<see cref="Gl.GL_MAP1_COLOR_4" />
        ///                     or <see cref="Gl.GL_MAP2_COLOR_4" />).  <i>colorData</i>
        ///                     contains four components: R,G,B,A.  The default color callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_COLOR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END" /></term>
        ///                 <description>
        ///                     The end callback is invoked at the end of a primitive.  The
        ///                     default end callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is <see cref="NurbsEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_END" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_ERROR" /></term>
        ///                 <description>
        ///                     The error function is called when an error is encountered.  Its
        ///                     single argument is of type <see cref="int" />, and it indicates
        ///                     the specific error that occurred.  There are 37 errors unique to
        ///                     NURBS named <see cref="GLU_NURBS_ERROR1" /> through
        ///                     <see cref="GLU_NURBS_ERROR37" />.  Character strings describing
        ///                     these errors can be retrieved with <see cref="gluErrorString" />.
        ///                     The delegate prototype for this callback is
        ///                     <see cref="NurbsErrorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL" /></term>
        ///                 <description>
        ///                     The normal callback is invoked as the vertex normal is generated.
        ///                     The components of the normal are stored in the parameter
        ///                     <i>normalData</i>.  In the case of a NURBS curve, the callback
        ///                     function is effective only when the user provides a normal map
        ///                     (<see cref="Gl.GL_MAP1_NORMAL" />).  In the case of a NURBS
        ///                     surface, if a normal map (<see cref="Gl.GL_MAP2_NORMAL" />) is
        ///                     provided, then the generated normal is computed from the normal
        ///                     map.  If a normal map is not provided then a surface normal is
        ///                     computed in a manner similar to that described for evaluators
        ///                     when <see cref="Gl.GL_AUTO_NORMAL" /> is enabled.  The default
        ///                     normal callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsNormalCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_NORMAL" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsNormalDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD" /></term>
        ///                 <description>
        ///                     The texture callback is invoked as the texture coordinates of a
        ///                     vertex are generated.  These coordinates are stored in the
        ///                     parameter <i>texCoord</i>.  The number of texture coordinates can
        ///                     be 1, 2, 3, or 4 depending on which type of texture map is
        ///                     specified (<see cref="Gl.GL_MAP1_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_4" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_4" />).  If no texture map is
        ///                     specified, this callback function will not be called.  The
        ///                     default texture callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsTexCoordCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_TEXTURE_COORD" />
        ///                     callback, except that it takes an additional pointer argument.
        ///                     This pointer is a copy of the pointer that was specified at the
        ///                     last call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsTexCoordDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback indicates a vertex of the primitive.  The
        ///                     coordinates of the vertex are stored in the parameter
        ///                     <i>vertexData</i>.  All the generated vertices have dimension 3,
        ///                     that is, homogeneous coordinates have been transformed into
        ///                     affine coordinates.  The default vertex callback function is
        ///                     <c>null</c>. The delegate prototype for this callback is
        ///                     <see cref="NurbsVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_VERTEX" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function that the callback invokes.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is used to define a callback to be used by a NURBS
        ///         object.  If the specified callback is already defined, then it is replaced.
        ///         If <i>func</i> is <c>null</c>, then this callback will not get invoked and
        ///         the related data, if any, will be lost.
        ///     </para>
        ///     <para>
        ///         Except the error callback, these callbacks are used by NURBS tessellator
        ///         (when <see cref="GLU_NURBS_MODE" /> is set to be
        ///         <see cref="GLU_NURBS_TESSELLATOR" />) to return back the OpenGL polygon
        ///         primitives resulting from the tessellation.  Note that there are two
        ///         versions of each callback: one with a user data pointer and one without.  If
        ///         both versions for a particular callback are specified then the callback with
        ///         the user data pointer will be used.  Note that <i>userData</i> is a copy of
        ///         the pointer that was specified at the last call to
        ///         <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.
        ///     </para>
        ///     <para>
        ///         The error callback function is effective no matter which value that
        ///         <see cref="GLU_NURBS_MODE" /> is set to.  All other callback functions are
        ///         effective only when <see cref="GLU_NURBS_MODE" /> is set to
        ///         <see cref="GLU_NURBS_TESSELLATOR" />.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is available only if the GLU version is 1.2 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         GLU version 1.2 supports only the <see cref="GLU_ERROR" /> parameter for
        ///         <i>which</i>.  The <see cref="GLU_ERROR" /> value is deprecated in GLU
        ///         version 1.3 in favor of <see cref="GLU_NURBS_ERROR" />.  All other
        ///         accepted values for <i>func</i> are available only if the GLU version is 1.3
        ///         or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="NurbsBeginCallback" />
        /// <seealso cref="NurbsBeginDataCallback" />
        /// <seealso cref="NurbsColorCallback" />
        /// <seealso cref="NurbsColorDataCallback" />
        /// <seealso cref="NurbsEndCallback" />
        /// <seealso cref="NurbsEndDataCallback" />
        /// <seealso cref="NurbsErrorCallback" />
        /// <seealso cref="NurbsNormalCallback" />
        /// <seealso cref="NurbsNormalDataCallback" />
        /// <seealso cref="NurbsTexCoordCallback" />
        /// <seealso cref="NurbsTexCoordDataCallback" />
        /// <seealso cref="NurbsVertexCallback" />
        /// <seealso cref="NurbsVertexDataCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        public static void gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsBeginDataCallback func)
        {
            nurbsBeginDataCallback = func;
            __gluNurbsCallback(nurb, which, nurbsBeginDataCallback);
        }
        #endregion gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsBeginDataCallback func)

        #region gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsColorCallback func)
        /// <summary>
        ///     The <b>gluNurbsCallback</b> mehtod defines a callback for a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The legal callbacks are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback indicates the start of a primitive.  The
        ///                     function takes a single argument of type <see cref="int" />,
        ///                     which can be one of <see cref="Gl.GL_LINES" />,
        ///                     <see cref="Gl.GL_LINE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLES" />, or
        ///                     <see cref="Gl.GL_QUAD_STRIP" />.  The default begin callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR" /></term>
        ///                 <description>
        ///                     The color callback is invoked as the color of a vertex is
        ///                     generated.  The components of the color are stored in the
        ///                     parameter <i>colorData</i>.  This callback is effective only when
        ///                     the user provides a color map (<see cref="Gl.GL_MAP1_COLOR_4" />
        ///                     or <see cref="Gl.GL_MAP2_COLOR_4" />).  <i>colorData</i>
        ///                     contains four components: R,G,B,A.  The default color callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_COLOR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END" /></term>
        ///                 <description>
        ///                     The end callback is invoked at the end of a primitive.  The
        ///                     default end callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is <see cref="NurbsEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_END" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_ERROR" /></term>
        ///                 <description>
        ///                     The error function is called when an error is encountered.  Its
        ///                     single argument is of type <see cref="int" />, and it indicates
        ///                     the specific error that occurred.  There are 37 errors unique to
        ///                     NURBS named <see cref="GLU_NURBS_ERROR1" /> through
        ///                     <see cref="GLU_NURBS_ERROR37" />.  Character strings describing
        ///                     these errors can be retrieved with <see cref="gluErrorString" />.
        ///                     The delegate prototype for this callback is
        ///                     <see cref="NurbsErrorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL" /></term>
        ///                 <description>
        ///                     The normal callback is invoked as the vertex normal is generated.
        ///                     The components of the normal are stored in the parameter
        ///                     <i>normalData</i>.  In the case of a NURBS curve, the callback
        ///                     function is effective only when the user provides a normal map
        ///                     (<see cref="Gl.GL_MAP1_NORMAL" />).  In the case of a NURBS
        ///                     surface, if a normal map (<see cref="Gl.GL_MAP2_NORMAL" />) is
        ///                     provided, then the generated normal is computed from the normal
        ///                     map.  If a normal map is not provided then a surface normal is
        ///                     computed in a manner similar to that described for evaluators
        ///                     when <see cref="Gl.GL_AUTO_NORMAL" /> is enabled.  The default
        ///                     normal callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsNormalCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_NORMAL" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsNormalDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD" /></term>
        ///                 <description>
        ///                     The texture callback is invoked as the texture coordinates of a
        ///                     vertex are generated.  These coordinates are stored in the
        ///                     parameter <i>texCoord</i>.  The number of texture coordinates can
        ///                     be 1, 2, 3, or 4 depending on which type of texture map is
        ///                     specified (<see cref="Gl.GL_MAP1_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_4" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_4" />).  If no texture map is
        ///                     specified, this callback function will not be called.  The
        ///                     default texture callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsTexCoordCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_TEXTURE_COORD" />
        ///                     callback, except that it takes an additional pointer argument.
        ///                     This pointer is a copy of the pointer that was specified at the
        ///                     last call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsTexCoordDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback indicates a vertex of the primitive.  The
        ///                     coordinates of the vertex are stored in the parameter
        ///                     <i>vertexData</i>.  All the generated vertices have dimension 3,
        ///                     that is, homogeneous coordinates have been transformed into
        ///                     affine coordinates.  The default vertex callback function is
        ///                     <c>null</c>. The delegate prototype for this callback is
        ///                     <see cref="NurbsVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_VERTEX" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function that the callback invokes.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is used to define a callback to be used by a NURBS
        ///         object.  If the specified callback is already defined, then it is replaced.
        ///         If <i>func</i> is <c>null</c>, then this callback will not get invoked and
        ///         the related data, if any, will be lost.
        ///     </para>
        ///     <para>
        ///         Except the error callback, these callbacks are used by NURBS tessellator
        ///         (when <see cref="GLU_NURBS_MODE" /> is set to be
        ///         <see cref="GLU_NURBS_TESSELLATOR" />) to return back the OpenGL polygon
        ///         primitives resulting from the tessellation.  Note that there are two
        ///         versions of each callback: one with a user data pointer and one without.  If
        ///         both versions for a particular callback are specified then the callback with
        ///         the user data pointer will be used.  Note that <i>userData</i> is a copy of
        ///         the pointer that was specified at the last call to
        ///         <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.
        ///     </para>
        ///     <para>
        ///         The error callback function is effective no matter which value that
        ///         <see cref="GLU_NURBS_MODE" /> is set to.  All other callback functions are
        ///         effective only when <see cref="GLU_NURBS_MODE" /> is set to
        ///         <see cref="GLU_NURBS_TESSELLATOR" />.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is available only if the GLU version is 1.2 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         GLU version 1.2 supports only the <see cref="GLU_ERROR" /> parameter for
        ///         <i>which</i>.  The <see cref="GLU_ERROR" /> value is deprecated in GLU
        ///         version 1.3 in favor of <see cref="GLU_NURBS_ERROR" />.  All other
        ///         accepted values for <i>func</i> are available only if the GLU version is 1.3
        ///         or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="NurbsBeginCallback" />
        /// <seealso cref="NurbsBeginDataCallback" />
        /// <seealso cref="NurbsColorCallback" />
        /// <seealso cref="NurbsColorDataCallback" />
        /// <seealso cref="NurbsEndCallback" />
        /// <seealso cref="NurbsEndDataCallback" />
        /// <seealso cref="NurbsErrorCallback" />
        /// <seealso cref="NurbsNormalCallback" />
        /// <seealso cref="NurbsNormalDataCallback" />
        /// <seealso cref="NurbsTexCoordCallback" />
        /// <seealso cref="NurbsTexCoordDataCallback" />
        /// <seealso cref="NurbsVertexCallback" />
        /// <seealso cref="NurbsVertexDataCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        public static void gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsColorCallback func)
        {
            nurbsColorCallback = func;
            __gluNurbsCallback(nurb, which, nurbsColorCallback);
        }
        #endregion gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsColorCallback func)

        #region gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsColorDataCallback func)
        /// <summary>
        ///     The <b>gluNurbsCallback</b> mehtod defines a callback for a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The legal callbacks are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback indicates the start of a primitive.  The
        ///                     function takes a single argument of type <see cref="int" />,
        ///                     which can be one of <see cref="Gl.GL_LINES" />,
        ///                     <see cref="Gl.GL_LINE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLES" />, or
        ///                     <see cref="Gl.GL_QUAD_STRIP" />.  The default begin callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR" /></term>
        ///                 <description>
        ///                     The color callback is invoked as the color of a vertex is
        ///                     generated.  The components of the color are stored in the
        ///                     parameter <i>colorData</i>.  This callback is effective only when
        ///                     the user provides a color map (<see cref="Gl.GL_MAP1_COLOR_4" />
        ///                     or <see cref="Gl.GL_MAP2_COLOR_4" />).  <i>colorData</i>
        ///                     contains four components: R,G,B,A.  The default color callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_COLOR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END" /></term>
        ///                 <description>
        ///                     The end callback is invoked at the end of a primitive.  The
        ///                     default end callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is <see cref="NurbsEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_END" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_ERROR" /></term>
        ///                 <description>
        ///                     The error function is called when an error is encountered.  Its
        ///                     single argument is of type <see cref="int" />, and it indicates
        ///                     the specific error that occurred.  There are 37 errors unique to
        ///                     NURBS named <see cref="GLU_NURBS_ERROR1" /> through
        ///                     <see cref="GLU_NURBS_ERROR37" />.  Character strings describing
        ///                     these errors can be retrieved with <see cref="gluErrorString" />.
        ///                     The delegate prototype for this callback is
        ///                     <see cref="NurbsErrorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL" /></term>
        ///                 <description>
        ///                     The normal callback is invoked as the vertex normal is generated.
        ///                     The components of the normal are stored in the parameter
        ///                     <i>normalData</i>.  In the case of a NURBS curve, the callback
        ///                     function is effective only when the user provides a normal map
        ///                     (<see cref="Gl.GL_MAP1_NORMAL" />).  In the case of a NURBS
        ///                     surface, if a normal map (<see cref="Gl.GL_MAP2_NORMAL" />) is
        ///                     provided, then the generated normal is computed from the normal
        ///                     map.  If a normal map is not provided then a surface normal is
        ///                     computed in a manner similar to that described for evaluators
        ///                     when <see cref="Gl.GL_AUTO_NORMAL" /> is enabled.  The default
        ///                     normal callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsNormalCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_NORMAL" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsNormalDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD" /></term>
        ///                 <description>
        ///                     The texture callback is invoked as the texture coordinates of a
        ///                     vertex are generated.  These coordinates are stored in the
        ///                     parameter <i>texCoord</i>.  The number of texture coordinates can
        ///                     be 1, 2, 3, or 4 depending on which type of texture map is
        ///                     specified (<see cref="Gl.GL_MAP1_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_4" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_4" />).  If no texture map is
        ///                     specified, this callback function will not be called.  The
        ///                     default texture callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsTexCoordCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_TEXTURE_COORD" />
        ///                     callback, except that it takes an additional pointer argument.
        ///                     This pointer is a copy of the pointer that was specified at the
        ///                     last call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsTexCoordDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback indicates a vertex of the primitive.  The
        ///                     coordinates of the vertex are stored in the parameter
        ///                     <i>vertexData</i>.  All the generated vertices have dimension 3,
        ///                     that is, homogeneous coordinates have been transformed into
        ///                     affine coordinates.  The default vertex callback function is
        ///                     <c>null</c>. The delegate prototype for this callback is
        ///                     <see cref="NurbsVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_VERTEX" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function that the callback invokes.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is used to define a callback to be used by a NURBS
        ///         object.  If the specified callback is already defined, then it is replaced.
        ///         If <i>func</i> is <c>null</c>, then this callback will not get invoked and
        ///         the related data, if any, will be lost.
        ///     </para>
        ///     <para>
        ///         Except the error callback, these callbacks are used by NURBS tessellator
        ///         (when <see cref="GLU_NURBS_MODE" /> is set to be
        ///         <see cref="GLU_NURBS_TESSELLATOR" />) to return back the OpenGL polygon
        ///         primitives resulting from the tessellation.  Note that there are two
        ///         versions of each callback: one with a user data pointer and one without.  If
        ///         both versions for a particular callback are specified then the callback with
        ///         the user data pointer will be used.  Note that <i>userData</i> is a copy of
        ///         the pointer that was specified at the last call to
        ///         <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.
        ///     </para>
        ///     <para>
        ///         The error callback function is effective no matter which value that
        ///         <see cref="GLU_NURBS_MODE" /> is set to.  All other callback functions are
        ///         effective only when <see cref="GLU_NURBS_MODE" /> is set to
        ///         <see cref="GLU_NURBS_TESSELLATOR" />.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is available only if the GLU version is 1.2 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         GLU version 1.2 supports only the <see cref="GLU_ERROR" /> parameter for
        ///         <i>which</i>.  The <see cref="GLU_ERROR" /> value is deprecated in GLU
        ///         version 1.3 in favor of <see cref="GLU_NURBS_ERROR" />.  All other
        ///         accepted values for <i>func</i> are available only if the GLU version is 1.3
        ///         or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="NurbsBeginCallback" />
        /// <seealso cref="NurbsBeginDataCallback" />
        /// <seealso cref="NurbsColorCallback" />
        /// <seealso cref="NurbsColorDataCallback" />
        /// <seealso cref="NurbsEndCallback" />
        /// <seealso cref="NurbsEndDataCallback" />
        /// <seealso cref="NurbsErrorCallback" />
        /// <seealso cref="NurbsNormalCallback" />
        /// <seealso cref="NurbsNormalDataCallback" />
        /// <seealso cref="NurbsTexCoordCallback" />
        /// <seealso cref="NurbsTexCoordDataCallback" />
        /// <seealso cref="NurbsVertexCallback" />
        /// <seealso cref="NurbsVertexDataCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        public static void gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsColorDataCallback func)
        {
            nurbsColorDataCallback = func;
            __gluNurbsCallback(nurb, which, nurbsColorDataCallback);
        }
        #endregion gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsColorDataCallback func)

        #region gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsEndCallback func)
        /// <summary>
        ///     The <b>gluNurbsCallback</b> mehtod defines a callback for a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The legal callbacks are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback indicates the start of a primitive.  The
        ///                     function takes a single argument of type <see cref="int" />,
        ///                     which can be one of <see cref="Gl.GL_LINES" />,
        ///                     <see cref="Gl.GL_LINE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLES" />, or
        ///                     <see cref="Gl.GL_QUAD_STRIP" />.  The default begin callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR" /></term>
        ///                 <description>
        ///                     The color callback is invoked as the color of a vertex is
        ///                     generated.  The components of the color are stored in the
        ///                     parameter <i>colorData</i>.  This callback is effective only when
        ///                     the user provides a color map (<see cref="Gl.GL_MAP1_COLOR_4" />
        ///                     or <see cref="Gl.GL_MAP2_COLOR_4" />).  <i>colorData</i>
        ///                     contains four components: R,G,B,A.  The default color callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_COLOR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END" /></term>
        ///                 <description>
        ///                     The end callback is invoked at the end of a primitive.  The
        ///                     default end callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is <see cref="NurbsEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_END" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_ERROR" /></term>
        ///                 <description>
        ///                     The error function is called when an error is encountered.  Its
        ///                     single argument is of type <see cref="int" />, and it indicates
        ///                     the specific error that occurred.  There are 37 errors unique to
        ///                     NURBS named <see cref="GLU_NURBS_ERROR1" /> through
        ///                     <see cref="GLU_NURBS_ERROR37" />.  Character strings describing
        ///                     these errors can be retrieved with <see cref="gluErrorString" />.
        ///                     The delegate prototype for this callback is
        ///                     <see cref="NurbsErrorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL" /></term>
        ///                 <description>
        ///                     The normal callback is invoked as the vertex normal is generated.
        ///                     The components of the normal are stored in the parameter
        ///                     <i>normalData</i>.  In the case of a NURBS curve, the callback
        ///                     function is effective only when the user provides a normal map
        ///                     (<see cref="Gl.GL_MAP1_NORMAL" />).  In the case of a NURBS
        ///                     surface, if a normal map (<see cref="Gl.GL_MAP2_NORMAL" />) is
        ///                     provided, then the generated normal is computed from the normal
        ///                     map.  If a normal map is not provided then a surface normal is
        ///                     computed in a manner similar to that described for evaluators
        ///                     when <see cref="Gl.GL_AUTO_NORMAL" /> is enabled.  The default
        ///                     normal callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsNormalCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_NORMAL" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsNormalDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD" /></term>
        ///                 <description>
        ///                     The texture callback is invoked as the texture coordinates of a
        ///                     vertex are generated.  These coordinates are stored in the
        ///                     parameter <i>texCoord</i>.  The number of texture coordinates can
        ///                     be 1, 2, 3, or 4 depending on which type of texture map is
        ///                     specified (<see cref="Gl.GL_MAP1_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_4" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_4" />).  If no texture map is
        ///                     specified, this callback function will not be called.  The
        ///                     default texture callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsTexCoordCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_TEXTURE_COORD" />
        ///                     callback, except that it takes an additional pointer argument.
        ///                     This pointer is a copy of the pointer that was specified at the
        ///                     last call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsTexCoordDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback indicates a vertex of the primitive.  The
        ///                     coordinates of the vertex are stored in the parameter
        ///                     <i>vertexData</i>.  All the generated vertices have dimension 3,
        ///                     that is, homogeneous coordinates have been transformed into
        ///                     affine coordinates.  The default vertex callback function is
        ///                     <c>null</c>. The delegate prototype for this callback is
        ///                     <see cref="NurbsVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_VERTEX" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function that the callback invokes.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is used to define a callback to be used by a NURBS
        ///         object.  If the specified callback is already defined, then it is replaced.
        ///         If <i>func</i> is <c>null</c>, then this callback will not get invoked and
        ///         the related data, if any, will be lost.
        ///     </para>
        ///     <para>
        ///         Except the error callback, these callbacks are used by NURBS tessellator
        ///         (when <see cref="GLU_NURBS_MODE" /> is set to be
        ///         <see cref="GLU_NURBS_TESSELLATOR" />) to return back the OpenGL polygon
        ///         primitives resulting from the tessellation.  Note that there are two
        ///         versions of each callback: one with a user data pointer and one without.  If
        ///         both versions for a particular callback are specified then the callback with
        ///         the user data pointer will be used.  Note that <i>userData</i> is a copy of
        ///         the pointer that was specified at the last call to
        ///         <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.
        ///     </para>
        ///     <para>
        ///         The error callback function is effective no matter which value that
        ///         <see cref="GLU_NURBS_MODE" /> is set to.  All other callback functions are
        ///         effective only when <see cref="GLU_NURBS_MODE" /> is set to
        ///         <see cref="GLU_NURBS_TESSELLATOR" />.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is available only if the GLU version is 1.2 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         GLU version 1.2 supports only the <see cref="GLU_ERROR" /> parameter for
        ///         <i>which</i>.  The <see cref="GLU_ERROR" /> value is deprecated in GLU
        ///         version 1.3 in favor of <see cref="GLU_NURBS_ERROR" />.  All other
        ///         accepted values for <i>func</i> are available only if the GLU version is 1.3
        ///         or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="NurbsBeginCallback" />
        /// <seealso cref="NurbsBeginDataCallback" />
        /// <seealso cref="NurbsColorCallback" />
        /// <seealso cref="NurbsColorDataCallback" />
        /// <seealso cref="NurbsEndCallback" />
        /// <seealso cref="NurbsEndDataCallback" />
        /// <seealso cref="NurbsErrorCallback" />
        /// <seealso cref="NurbsNormalCallback" />
        /// <seealso cref="NurbsNormalDataCallback" />
        /// <seealso cref="NurbsTexCoordCallback" />
        /// <seealso cref="NurbsTexCoordDataCallback" />
        /// <seealso cref="NurbsVertexCallback" />
        /// <seealso cref="NurbsVertexDataCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        public static void gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsEndCallback func)
        {
            nurbsEndCallback = func;
            __gluNurbsCallback(nurb, which, nurbsEndCallback);
        }
        #endregion gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsEndCallback func)

        #region gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsEndDataCallback func)
        /// <summary>
        ///     The <b>gluNurbsCallback</b> mehtod defines a callback for a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The legal callbacks are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback indicates the start of a primitive.  The
        ///                     function takes a single argument of type <see cref="int" />,
        ///                     which can be one of <see cref="Gl.GL_LINES" />,
        ///                     <see cref="Gl.GL_LINE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLES" />, or
        ///                     <see cref="Gl.GL_QUAD_STRIP" />.  The default begin callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR" /></term>
        ///                 <description>
        ///                     The color callback is invoked as the color of a vertex is
        ///                     generated.  The components of the color are stored in the
        ///                     parameter <i>colorData</i>.  This callback is effective only when
        ///                     the user provides a color map (<see cref="Gl.GL_MAP1_COLOR_4" />
        ///                     or <see cref="Gl.GL_MAP2_COLOR_4" />).  <i>colorData</i>
        ///                     contains four components: R,G,B,A.  The default color callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_COLOR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END" /></term>
        ///                 <description>
        ///                     The end callback is invoked at the end of a primitive.  The
        ///                     default end callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is <see cref="NurbsEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_END" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_ERROR" /></term>
        ///                 <description>
        ///                     The error function is called when an error is encountered.  Its
        ///                     single argument is of type <see cref="int" />, and it indicates
        ///                     the specific error that occurred.  There are 37 errors unique to
        ///                     NURBS named <see cref="GLU_NURBS_ERROR1" /> through
        ///                     <see cref="GLU_NURBS_ERROR37" />.  Character strings describing
        ///                     these errors can be retrieved with <see cref="gluErrorString" />.
        ///                     The delegate prototype for this callback is
        ///                     <see cref="NurbsErrorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL" /></term>
        ///                 <description>
        ///                     The normal callback is invoked as the vertex normal is generated.
        ///                     The components of the normal are stored in the parameter
        ///                     <i>normalData</i>.  In the case of a NURBS curve, the callback
        ///                     function is effective only when the user provides a normal map
        ///                     (<see cref="Gl.GL_MAP1_NORMAL" />).  In the case of a NURBS
        ///                     surface, if a normal map (<see cref="Gl.GL_MAP2_NORMAL" />) is
        ///                     provided, then the generated normal is computed from the normal
        ///                     map.  If a normal map is not provided then a surface normal is
        ///                     computed in a manner similar to that described for evaluators
        ///                     when <see cref="Gl.GL_AUTO_NORMAL" /> is enabled.  The default
        ///                     normal callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsNormalCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_NORMAL" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsNormalDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD" /></term>
        ///                 <description>
        ///                     The texture callback is invoked as the texture coordinates of a
        ///                     vertex are generated.  These coordinates are stored in the
        ///                     parameter <i>texCoord</i>.  The number of texture coordinates can
        ///                     be 1, 2, 3, or 4 depending on which type of texture map is
        ///                     specified (<see cref="Gl.GL_MAP1_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_4" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_4" />).  If no texture map is
        ///                     specified, this callback function will not be called.  The
        ///                     default texture callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsTexCoordCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_TEXTURE_COORD" />
        ///                     callback, except that it takes an additional pointer argument.
        ///                     This pointer is a copy of the pointer that was specified at the
        ///                     last call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsTexCoordDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback indicates a vertex of the primitive.  The
        ///                     coordinates of the vertex are stored in the parameter
        ///                     <i>vertexData</i>.  All the generated vertices have dimension 3,
        ///                     that is, homogeneous coordinates have been transformed into
        ///                     affine coordinates.  The default vertex callback function is
        ///                     <c>null</c>. The delegate prototype for this callback is
        ///                     <see cref="NurbsVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_VERTEX" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function that the callback invokes.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is used to define a callback to be used by a NURBS
        ///         object.  If the specified callback is already defined, then it is replaced.
        ///         If <i>func</i> is <c>null</c>, then this callback will not get invoked and
        ///         the related data, if any, will be lost.
        ///     </para>
        ///     <para>
        ///         Except the error callback, these callbacks are used by NURBS tessellator
        ///         (when <see cref="GLU_NURBS_MODE" /> is set to be
        ///         <see cref="GLU_NURBS_TESSELLATOR" />) to return back the OpenGL polygon
        ///         primitives resulting from the tessellation.  Note that there are two
        ///         versions of each callback: one with a user data pointer and one without.  If
        ///         both versions for a particular callback are specified then the callback with
        ///         the user data pointer will be used.  Note that <i>userData</i> is a copy of
        ///         the pointer that was specified at the last call to
        ///         <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.
        ///     </para>
        ///     <para>
        ///         The error callback function is effective no matter which value that
        ///         <see cref="GLU_NURBS_MODE" /> is set to.  All other callback functions are
        ///         effective only when <see cref="GLU_NURBS_MODE" /> is set to
        ///         <see cref="GLU_NURBS_TESSELLATOR" />.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is available only if the GLU version is 1.2 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         GLU version 1.2 supports only the <see cref="GLU_ERROR" /> parameter for
        ///         <i>which</i>.  The <see cref="GLU_ERROR" /> value is deprecated in GLU
        ///         version 1.3 in favor of <see cref="GLU_NURBS_ERROR" />.  All other
        ///         accepted values for <i>func</i> are available only if the GLU version is 1.3
        ///         or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="NurbsBeginCallback" />
        /// <seealso cref="NurbsBeginDataCallback" />
        /// <seealso cref="NurbsColorCallback" />
        /// <seealso cref="NurbsColorDataCallback" />
        /// <seealso cref="NurbsEndCallback" />
        /// <seealso cref="NurbsEndDataCallback" />
        /// <seealso cref="NurbsErrorCallback" />
        /// <seealso cref="NurbsNormalCallback" />
        /// <seealso cref="NurbsNormalDataCallback" />
        /// <seealso cref="NurbsTexCoordCallback" />
        /// <seealso cref="NurbsTexCoordDataCallback" />
        /// <seealso cref="NurbsVertexCallback" />
        /// <seealso cref="NurbsVertexDataCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        public static void gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsEndDataCallback func)
        {
            nurbsEndDataCallback = func;
            __gluNurbsCallback(nurb, which, nurbsEndDataCallback);
        }
        #endregion gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsEndDataCallback func)

        #region gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsErrorCallback func)
        /// <summary>
        ///     The <b>gluNurbsCallback</b> mehtod defines a callback for a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The legal callbacks are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback indicates the start of a primitive.  The
        ///                     function takes a single argument of type <see cref="int" />,
        ///                     which can be one of <see cref="Gl.GL_LINES" />,
        ///                     <see cref="Gl.GL_LINE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLES" />, or
        ///                     <see cref="Gl.GL_QUAD_STRIP" />.  The default begin callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR" /></term>
        ///                 <description>
        ///                     The color callback is invoked as the color of a vertex is
        ///                     generated.  The components of the color are stored in the
        ///                     parameter <i>colorData</i>.  This callback is effective only when
        ///                     the user provides a color map (<see cref="Gl.GL_MAP1_COLOR_4" />
        ///                     or <see cref="Gl.GL_MAP2_COLOR_4" />).  <i>colorData</i>
        ///                     contains four components: R,G,B,A.  The default color callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_COLOR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END" /></term>
        ///                 <description>
        ///                     The end callback is invoked at the end of a primitive.  The
        ///                     default end callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is <see cref="NurbsEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_END" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_ERROR" /></term>
        ///                 <description>
        ///                     The error function is called when an error is encountered.  Its
        ///                     single argument is of type <see cref="int" />, and it indicates
        ///                     the specific error that occurred.  There are 37 errors unique to
        ///                     NURBS named <see cref="GLU_NURBS_ERROR1" /> through
        ///                     <see cref="GLU_NURBS_ERROR37" />.  Character strings describing
        ///                     these errors can be retrieved with <see cref="gluErrorString" />.
        ///                     The delegate prototype for this callback is
        ///                     <see cref="NurbsErrorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL" /></term>
        ///                 <description>
        ///                     The normal callback is invoked as the vertex normal is generated.
        ///                     The components of the normal are stored in the parameter
        ///                     <i>normalData</i>.  In the case of a NURBS curve, the callback
        ///                     function is effective only when the user provides a normal map
        ///                     (<see cref="Gl.GL_MAP1_NORMAL" />).  In the case of a NURBS
        ///                     surface, if a normal map (<see cref="Gl.GL_MAP2_NORMAL" />) is
        ///                     provided, then the generated normal is computed from the normal
        ///                     map.  If a normal map is not provided then a surface normal is
        ///                     computed in a manner similar to that described for evaluators
        ///                     when <see cref="Gl.GL_AUTO_NORMAL" /> is enabled.  The default
        ///                     normal callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsNormalCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_NORMAL" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsNormalDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD" /></term>
        ///                 <description>
        ///                     The texture callback is invoked as the texture coordinates of a
        ///                     vertex are generated.  These coordinates are stored in the
        ///                     parameter <i>texCoord</i>.  The number of texture coordinates can
        ///                     be 1, 2, 3, or 4 depending on which type of texture map is
        ///                     specified (<see cref="Gl.GL_MAP1_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_4" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_4" />).  If no texture map is
        ///                     specified, this callback function will not be called.  The
        ///                     default texture callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsTexCoordCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_TEXTURE_COORD" />
        ///                     callback, except that it takes an additional pointer argument.
        ///                     This pointer is a copy of the pointer that was specified at the
        ///                     last call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsTexCoordDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback indicates a vertex of the primitive.  The
        ///                     coordinates of the vertex are stored in the parameter
        ///                     <i>vertexData</i>.  All the generated vertices have dimension 3,
        ///                     that is, homogeneous coordinates have been transformed into
        ///                     affine coordinates.  The default vertex callback function is
        ///                     <c>null</c>. The delegate prototype for this callback is
        ///                     <see cref="NurbsVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_VERTEX" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function that the callback invokes.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is used to define a callback to be used by a NURBS
        ///         object.  If the specified callback is already defined, then it is replaced.
        ///         If <i>func</i> is <c>null</c>, then this callback will not get invoked and
        ///         the related data, if any, will be lost.
        ///     </para>
        ///     <para>
        ///         Except the error callback, these callbacks are used by NURBS tessellator
        ///         (when <see cref="GLU_NURBS_MODE" /> is set to be
        ///         <see cref="GLU_NURBS_TESSELLATOR" />) to return back the OpenGL polygon
        ///         primitives resulting from the tessellation.  Note that there are two
        ///         versions of each callback: one with a user data pointer and one without.  If
        ///         both versions for a particular callback are specified then the callback with
        ///         the user data pointer will be used.  Note that <i>userData</i> is a copy of
        ///         the pointer that was specified at the last call to
        ///         <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.
        ///     </para>
        ///     <para>
        ///         The error callback function is effective no matter which value that
        ///         <see cref="GLU_NURBS_MODE" /> is set to.  All other callback functions are
        ///         effective only when <see cref="GLU_NURBS_MODE" /> is set to
        ///         <see cref="GLU_NURBS_TESSELLATOR" />.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is available only if the GLU version is 1.2 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         GLU version 1.2 supports only the <see cref="GLU_ERROR" /> parameter for
        ///         <i>which</i>.  The <see cref="GLU_ERROR" /> value is deprecated in GLU
        ///         version 1.3 in favor of <see cref="GLU_NURBS_ERROR" />.  All other
        ///         accepted values for <i>func</i> are available only if the GLU version is 1.3
        ///         or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="NurbsBeginCallback" />
        /// <seealso cref="NurbsBeginDataCallback" />
        /// <seealso cref="NurbsColorCallback" />
        /// <seealso cref="NurbsColorDataCallback" />
        /// <seealso cref="NurbsEndCallback" />
        /// <seealso cref="NurbsEndDataCallback" />
        /// <seealso cref="NurbsErrorCallback" />
        /// <seealso cref="NurbsNormalCallback" />
        /// <seealso cref="NurbsNormalDataCallback" />
        /// <seealso cref="NurbsTexCoordCallback" />
        /// <seealso cref="NurbsTexCoordDataCallback" />
        /// <seealso cref="NurbsVertexCallback" />
        /// <seealso cref="NurbsVertexDataCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        public static void gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsErrorCallback func)
        {
            nurbsErrorCallback = func;
            __gluNurbsCallback(nurb, which, nurbsErrorCallback);
        }
        #endregion gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsErrorCallback func)

        #region gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsNormalCallback func)
        /// <summary>
        ///     The <b>gluNurbsCallback</b> mehtod defines a callback for a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The legal callbacks are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback indicates the start of a primitive.  The
        ///                     function takes a single argument of type <see cref="int" />,
        ///                     which can be one of <see cref="Gl.GL_LINES" />,
        ///                     <see cref="Gl.GL_LINE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLES" />, or
        ///                     <see cref="Gl.GL_QUAD_STRIP" />.  The default begin callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR" /></term>
        ///                 <description>
        ///                     The color callback is invoked as the color of a vertex is
        ///                     generated.  The components of the color are stored in the
        ///                     parameter <i>colorData</i>.  This callback is effective only when
        ///                     the user provides a color map (<see cref="Gl.GL_MAP1_COLOR_4" />
        ///                     or <see cref="Gl.GL_MAP2_COLOR_4" />).  <i>colorData</i>
        ///                     contains four components: R,G,B,A.  The default color callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_COLOR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END" /></term>
        ///                 <description>
        ///                     The end callback is invoked at the end of a primitive.  The
        ///                     default end callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is <see cref="NurbsEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_END" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_ERROR" /></term>
        ///                 <description>
        ///                     The error function is called when an error is encountered.  Its
        ///                     single argument is of type <see cref="int" />, and it indicates
        ///                     the specific error that occurred.  There are 37 errors unique to
        ///                     NURBS named <see cref="GLU_NURBS_ERROR1" /> through
        ///                     <see cref="GLU_NURBS_ERROR37" />.  Character strings describing
        ///                     these errors can be retrieved with <see cref="gluErrorString" />.
        ///                     The delegate prototype for this callback is
        ///                     <see cref="NurbsErrorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL" /></term>
        ///                 <description>
        ///                     The normal callback is invoked as the vertex normal is generated.
        ///                     The components of the normal are stored in the parameter
        ///                     <i>normalData</i>.  In the case of a NURBS curve, the callback
        ///                     function is effective only when the user provides a normal map
        ///                     (<see cref="Gl.GL_MAP1_NORMAL" />).  In the case of a NURBS
        ///                     surface, if a normal map (<see cref="Gl.GL_MAP2_NORMAL" />) is
        ///                     provided, then the generated normal is computed from the normal
        ///                     map.  If a normal map is not provided then a surface normal is
        ///                     computed in a manner similar to that described for evaluators
        ///                     when <see cref="Gl.GL_AUTO_NORMAL" /> is enabled.  The default
        ///                     normal callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsNormalCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_NORMAL" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsNormalDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD" /></term>
        ///                 <description>
        ///                     The texture callback is invoked as the texture coordinates of a
        ///                     vertex are generated.  These coordinates are stored in the
        ///                     parameter <i>texCoord</i>.  The number of texture coordinates can
        ///                     be 1, 2, 3, or 4 depending on which type of texture map is
        ///                     specified (<see cref="Gl.GL_MAP1_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_4" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_4" />).  If no texture map is
        ///                     specified, this callback function will not be called.  The
        ///                     default texture callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsTexCoordCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_TEXTURE_COORD" />
        ///                     callback, except that it takes an additional pointer argument.
        ///                     This pointer is a copy of the pointer that was specified at the
        ///                     last call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsTexCoordDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback indicates a vertex of the primitive.  The
        ///                     coordinates of the vertex are stored in the parameter
        ///                     <i>vertexData</i>.  All the generated vertices have dimension 3,
        ///                     that is, homogeneous coordinates have been transformed into
        ///                     affine coordinates.  The default vertex callback function is
        ///                     <c>null</c>. The delegate prototype for this callback is
        ///                     <see cref="NurbsVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_VERTEX" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function that the callback invokes.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is used to define a callback to be used by a NURBS
        ///         object.  If the specified callback is already defined, then it is replaced.
        ///         If <i>func</i> is <c>null</c>, then this callback will not get invoked and
        ///         the related data, if any, will be lost.
        ///     </para>
        ///     <para>
        ///         Except the error callback, these callbacks are used by NURBS tessellator
        ///         (when <see cref="GLU_NURBS_MODE" /> is set to be
        ///         <see cref="GLU_NURBS_TESSELLATOR" />) to return back the OpenGL polygon
        ///         primitives resulting from the tessellation.  Note that there are two
        ///         versions of each callback: one with a user data pointer and one without.  If
        ///         both versions for a particular callback are specified then the callback with
        ///         the user data pointer will be used.  Note that <i>userData</i> is a copy of
        ///         the pointer that was specified at the last call to
        ///         <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.
        ///     </para>
        ///     <para>
        ///         The error callback function is effective no matter which value that
        ///         <see cref="GLU_NURBS_MODE" /> is set to.  All other callback functions are
        ///         effective only when <see cref="GLU_NURBS_MODE" /> is set to
        ///         <see cref="GLU_NURBS_TESSELLATOR" />.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is available only if the GLU version is 1.2 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         GLU version 1.2 supports only the <see cref="GLU_ERROR" /> parameter for
        ///         <i>which</i>.  The <see cref="GLU_ERROR" /> value is deprecated in GLU
        ///         version 1.3 in favor of <see cref="GLU_NURBS_ERROR" />.  All other
        ///         accepted values for <i>func</i> are available only if the GLU version is 1.3
        ///         or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="NurbsBeginCallback" />
        /// <seealso cref="NurbsBeginDataCallback" />
        /// <seealso cref="NurbsColorCallback" />
        /// <seealso cref="NurbsColorDataCallback" />
        /// <seealso cref="NurbsEndCallback" />
        /// <seealso cref="NurbsEndDataCallback" />
        /// <seealso cref="NurbsErrorCallback" />
        /// <seealso cref="NurbsNormalCallback" />
        /// <seealso cref="NurbsNormalDataCallback" />
        /// <seealso cref="NurbsTexCoordCallback" />
        /// <seealso cref="NurbsTexCoordDataCallback" />
        /// <seealso cref="NurbsVertexCallback" />
        /// <seealso cref="NurbsVertexDataCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        public static void gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsNormalCallback func)
        {
            nurbsNormalCallback = func;
            __gluNurbsCallback(nurb, which, nurbsNormalCallback);
        }
        #endregion gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsNormalCallback func)

        #region gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsNormalDataCallback func)
        /// <summary>
        ///     The <b>gluNurbsCallback</b> mehtod defines a callback for a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The legal callbacks are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback indicates the start of a primitive.  The
        ///                     function takes a single argument of type <see cref="int" />,
        ///                     which can be one of <see cref="Gl.GL_LINES" />,
        ///                     <see cref="Gl.GL_LINE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLES" />, or
        ///                     <see cref="Gl.GL_QUAD_STRIP" />.  The default begin callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR" /></term>
        ///                 <description>
        ///                     The color callback is invoked as the color of a vertex is
        ///                     generated.  The components of the color are stored in the
        ///                     parameter <i>colorData</i>.  This callback is effective only when
        ///                     the user provides a color map (<see cref="Gl.GL_MAP1_COLOR_4" />
        ///                     or <see cref="Gl.GL_MAP2_COLOR_4" />).  <i>colorData</i>
        ///                     contains four components: R,G,B,A.  The default color callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_COLOR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END" /></term>
        ///                 <description>
        ///                     The end callback is invoked at the end of a primitive.  The
        ///                     default end callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is <see cref="NurbsEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_END" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_ERROR" /></term>
        ///                 <description>
        ///                     The error function is called when an error is encountered.  Its
        ///                     single argument is of type <see cref="int" />, and it indicates
        ///                     the specific error that occurred.  There are 37 errors unique to
        ///                     NURBS named <see cref="GLU_NURBS_ERROR1" /> through
        ///                     <see cref="GLU_NURBS_ERROR37" />.  Character strings describing
        ///                     these errors can be retrieved with <see cref="gluErrorString" />.
        ///                     The delegate prototype for this callback is
        ///                     <see cref="NurbsErrorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL" /></term>
        ///                 <description>
        ///                     The normal callback is invoked as the vertex normal is generated.
        ///                     The components of the normal are stored in the parameter
        ///                     <i>normalData</i>.  In the case of a NURBS curve, the callback
        ///                     function is effective only when the user provides a normal map
        ///                     (<see cref="Gl.GL_MAP1_NORMAL" />).  In the case of a NURBS
        ///                     surface, if a normal map (<see cref="Gl.GL_MAP2_NORMAL" />) is
        ///                     provided, then the generated normal is computed from the normal
        ///                     map.  If a normal map is not provided then a surface normal is
        ///                     computed in a manner similar to that described for evaluators
        ///                     when <see cref="Gl.GL_AUTO_NORMAL" /> is enabled.  The default
        ///                     normal callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsNormalCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_NORMAL" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsNormalDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD" /></term>
        ///                 <description>
        ///                     The texture callback is invoked as the texture coordinates of a
        ///                     vertex are generated.  These coordinates are stored in the
        ///                     parameter <i>texCoord</i>.  The number of texture coordinates can
        ///                     be 1, 2, 3, or 4 depending on which type of texture map is
        ///                     specified (<see cref="Gl.GL_MAP1_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_4" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_4" />).  If no texture map is
        ///                     specified, this callback function will not be called.  The
        ///                     default texture callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsTexCoordCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_TEXTURE_COORD" />
        ///                     callback, except that it takes an additional pointer argument.
        ///                     This pointer is a copy of the pointer that was specified at the
        ///                     last call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsTexCoordDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback indicates a vertex of the primitive.  The
        ///                     coordinates of the vertex are stored in the parameter
        ///                     <i>vertexData</i>.  All the generated vertices have dimension 3,
        ///                     that is, homogeneous coordinates have been transformed into
        ///                     affine coordinates.  The default vertex callback function is
        ///                     <c>null</c>. The delegate prototype for this callback is
        ///                     <see cref="NurbsVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_VERTEX" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function that the callback invokes.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is used to define a callback to be used by a NURBS
        ///         object.  If the specified callback is already defined, then it is replaced.
        ///         If <i>func</i> is <c>null</c>, then this callback will not get invoked and
        ///         the related data, if any, will be lost.
        ///     </para>
        ///     <para>
        ///         Except the error callback, these callbacks are used by NURBS tessellator
        ///         (when <see cref="GLU_NURBS_MODE" /> is set to be
        ///         <see cref="GLU_NURBS_TESSELLATOR" />) to return back the OpenGL polygon
        ///         primitives resulting from the tessellation.  Note that there are two
        ///         versions of each callback: one with a user data pointer and one without.  If
        ///         both versions for a particular callback are specified then the callback with
        ///         the user data pointer will be used.  Note that <i>userData</i> is a copy of
        ///         the pointer that was specified at the last call to
        ///         <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.
        ///     </para>
        ///     <para>
        ///         The error callback function is effective no matter which value that
        ///         <see cref="GLU_NURBS_MODE" /> is set to.  All other callback functions are
        ///         effective only when <see cref="GLU_NURBS_MODE" /> is set to
        ///         <see cref="GLU_NURBS_TESSELLATOR" />.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is available only if the GLU version is 1.2 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         GLU version 1.2 supports only the <see cref="GLU_ERROR" /> parameter for
        ///         <i>which</i>.  The <see cref="GLU_ERROR" /> value is deprecated in GLU
        ///         version 1.3 in favor of <see cref="GLU_NURBS_ERROR" />.  All other
        ///         accepted values for <i>func</i> are available only if the GLU version is 1.3
        ///         or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="NurbsBeginCallback" />
        /// <seealso cref="NurbsBeginDataCallback" />
        /// <seealso cref="NurbsColorCallback" />
        /// <seealso cref="NurbsColorDataCallback" />
        /// <seealso cref="NurbsEndCallback" />
        /// <seealso cref="NurbsEndDataCallback" />
        /// <seealso cref="NurbsErrorCallback" />
        /// <seealso cref="NurbsNormalCallback" />
        /// <seealso cref="NurbsNormalDataCallback" />
        /// <seealso cref="NurbsTexCoordCallback" />
        /// <seealso cref="NurbsTexCoordDataCallback" />
        /// <seealso cref="NurbsVertexCallback" />
        /// <seealso cref="NurbsVertexDataCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        public static void gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsNormalDataCallback func)
        {
            nurbsNormalDataCallback = func;
            __gluNurbsCallback(nurb, which, nurbsNormalDataCallback);
        }
        #endregion gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsNormalDataCallback func)

        #region gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsTexCoordCallback func)
        /// <summary>
        ///     The <b>gluNurbsCallback</b> mehtod defines a callback for a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The legal callbacks are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback indicates the start of a primitive.  The
        ///                     function takes a single argument of type <see cref="int" />,
        ///                     which can be one of <see cref="Gl.GL_LINES" />,
        ///                     <see cref="Gl.GL_LINE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLES" />, or
        ///                     <see cref="Gl.GL_QUAD_STRIP" />.  The default begin callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR" /></term>
        ///                 <description>
        ///                     The color callback is invoked as the color of a vertex is
        ///                     generated.  The components of the color are stored in the
        ///                     parameter <i>colorData</i>.  This callback is effective only when
        ///                     the user provides a color map (<see cref="Gl.GL_MAP1_COLOR_4" />
        ///                     or <see cref="Gl.GL_MAP2_COLOR_4" />).  <i>colorData</i>
        ///                     contains four components: R,G,B,A.  The default color callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_COLOR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END" /></term>
        ///                 <description>
        ///                     The end callback is invoked at the end of a primitive.  The
        ///                     default end callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is <see cref="NurbsEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_END" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_ERROR" /></term>
        ///                 <description>
        ///                     The error function is called when an error is encountered.  Its
        ///                     single argument is of type <see cref="int" />, and it indicates
        ///                     the specific error that occurred.  There are 37 errors unique to
        ///                     NURBS named <see cref="GLU_NURBS_ERROR1" /> through
        ///                     <see cref="GLU_NURBS_ERROR37" />.  Character strings describing
        ///                     these errors can be retrieved with <see cref="gluErrorString" />.
        ///                     The delegate prototype for this callback is
        ///                     <see cref="NurbsErrorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL" /></term>
        ///                 <description>
        ///                     The normal callback is invoked as the vertex normal is generated.
        ///                     The components of the normal are stored in the parameter
        ///                     <i>normalData</i>.  In the case of a NURBS curve, the callback
        ///                     function is effective only when the user provides a normal map
        ///                     (<see cref="Gl.GL_MAP1_NORMAL" />).  In the case of a NURBS
        ///                     surface, if a normal map (<see cref="Gl.GL_MAP2_NORMAL" />) is
        ///                     provided, then the generated normal is computed from the normal
        ///                     map.  If a normal map is not provided then a surface normal is
        ///                     computed in a manner similar to that described for evaluators
        ///                     when <see cref="Gl.GL_AUTO_NORMAL" /> is enabled.  The default
        ///                     normal callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsNormalCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_NORMAL" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsNormalDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD" /></term>
        ///                 <description>
        ///                     The texture callback is invoked as the texture coordinates of a
        ///                     vertex are generated.  These coordinates are stored in the
        ///                     parameter <i>texCoord</i>.  The number of texture coordinates can
        ///                     be 1, 2, 3, or 4 depending on which type of texture map is
        ///                     specified (<see cref="Gl.GL_MAP1_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_4" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_4" />).  If no texture map is
        ///                     specified, this callback function will not be called.  The
        ///                     default texture callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsTexCoordCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_TEXTURE_COORD" />
        ///                     callback, except that it takes an additional pointer argument.
        ///                     This pointer is a copy of the pointer that was specified at the
        ///                     last call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsTexCoordDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback indicates a vertex of the primitive.  The
        ///                     coordinates of the vertex are stored in the parameter
        ///                     <i>vertexData</i>.  All the generated vertices have dimension 3,
        ///                     that is, homogeneous coordinates have been transformed into
        ///                     affine coordinates.  The default vertex callback function is
        ///                     <c>null</c>. The delegate prototype for this callback is
        ///                     <see cref="NurbsVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_VERTEX" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function that the callback invokes.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is used to define a callback to be used by a NURBS
        ///         object.  If the specified callback is already defined, then it is replaced.
        ///         If <i>func</i> is <c>null</c>, then this callback will not get invoked and
        ///         the related data, if any, will be lost.
        ///     </para>
        ///     <para>
        ///         Except the error callback, these callbacks are used by NURBS tessellator
        ///         (when <see cref="GLU_NURBS_MODE" /> is set to be
        ///         <see cref="GLU_NURBS_TESSELLATOR" />) to return back the OpenGL polygon
        ///         primitives resulting from the tessellation.  Note that there are two
        ///         versions of each callback: one with a user data pointer and one without.  If
        ///         both versions for a particular callback are specified then the callback with
        ///         the user data pointer will be used.  Note that <i>userData</i> is a copy of
        ///         the pointer that was specified at the last call to
        ///         <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.
        ///     </para>
        ///     <para>
        ///         The error callback function is effective no matter which value that
        ///         <see cref="GLU_NURBS_MODE" /> is set to.  All other callback functions are
        ///         effective only when <see cref="GLU_NURBS_MODE" /> is set to
        ///         <see cref="GLU_NURBS_TESSELLATOR" />.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is available only if the GLU version is 1.2 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         GLU version 1.2 supports only the <see cref="GLU_ERROR" /> parameter for
        ///         <i>which</i>.  The <see cref="GLU_ERROR" /> value is deprecated in GLU
        ///         version 1.3 in favor of <see cref="GLU_NURBS_ERROR" />.  All other
        ///         accepted values for <i>func</i> are available only if the GLU version is 1.3
        ///         or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="NurbsBeginCallback" />
        /// <seealso cref="NurbsBeginDataCallback" />
        /// <seealso cref="NurbsColorCallback" />
        /// <seealso cref="NurbsColorDataCallback" />
        /// <seealso cref="NurbsEndCallback" />
        /// <seealso cref="NurbsEndDataCallback" />
        /// <seealso cref="NurbsErrorCallback" />
        /// <seealso cref="NurbsNormalCallback" />
        /// <seealso cref="NurbsNormalDataCallback" />
        /// <seealso cref="NurbsTexCoordCallback" />
        /// <seealso cref="NurbsTexCoordDataCallback" />
        /// <seealso cref="NurbsVertexCallback" />
        /// <seealso cref="NurbsVertexDataCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        public static void gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsTexCoordCallback func)
        {
            nurbsTexCoordCallback = func;
            __gluNurbsCallback(nurb, which, nurbsTexCoordCallback);
        }
        #endregion gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsTexCoordCallback func)

        #region gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsTexCoordDataCallback func)
        /// <summary>
        ///     The <b>gluNurbsCallback</b> mehtod defines a callback for a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The legal callbacks are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback indicates the start of a primitive.  The
        ///                     function takes a single argument of type <see cref="int" />,
        ///                     which can be one of <see cref="Gl.GL_LINES" />,
        ///                     <see cref="Gl.GL_LINE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLES" />, or
        ///                     <see cref="Gl.GL_QUAD_STRIP" />.  The default begin callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR" /></term>
        ///                 <description>
        ///                     The color callback is invoked as the color of a vertex is
        ///                     generated.  The components of the color are stored in the
        ///                     parameter <i>colorData</i>.  This callback is effective only when
        ///                     the user provides a color map (<see cref="Gl.GL_MAP1_COLOR_4" />
        ///                     or <see cref="Gl.GL_MAP2_COLOR_4" />).  <i>colorData</i>
        ///                     contains four components: R,G,B,A.  The default color callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_COLOR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END" /></term>
        ///                 <description>
        ///                     The end callback is invoked at the end of a primitive.  The
        ///                     default end callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is <see cref="NurbsEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_END" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_ERROR" /></term>
        ///                 <description>
        ///                     The error function is called when an error is encountered.  Its
        ///                     single argument is of type <see cref="int" />, and it indicates
        ///                     the specific error that occurred.  There are 37 errors unique to
        ///                     NURBS named <see cref="GLU_NURBS_ERROR1" /> through
        ///                     <see cref="GLU_NURBS_ERROR37" />.  Character strings describing
        ///                     these errors can be retrieved with <see cref="gluErrorString" />.
        ///                     The delegate prototype for this callback is
        ///                     <see cref="NurbsErrorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL" /></term>
        ///                 <description>
        ///                     The normal callback is invoked as the vertex normal is generated.
        ///                     The components of the normal are stored in the parameter
        ///                     <i>normalData</i>.  In the case of a NURBS curve, the callback
        ///                     function is effective only when the user provides a normal map
        ///                     (<see cref="Gl.GL_MAP1_NORMAL" />).  In the case of a NURBS
        ///                     surface, if a normal map (<see cref="Gl.GL_MAP2_NORMAL" />) is
        ///                     provided, then the generated normal is computed from the normal
        ///                     map.  If a normal map is not provided then a surface normal is
        ///                     computed in a manner similar to that described for evaluators
        ///                     when <see cref="Gl.GL_AUTO_NORMAL" /> is enabled.  The default
        ///                     normal callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsNormalCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_NORMAL" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsNormalDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD" /></term>
        ///                 <description>
        ///                     The texture callback is invoked as the texture coordinates of a
        ///                     vertex are generated.  These coordinates are stored in the
        ///                     parameter <i>texCoord</i>.  The number of texture coordinates can
        ///                     be 1, 2, 3, or 4 depending on which type of texture map is
        ///                     specified (<see cref="Gl.GL_MAP1_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_4" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_4" />).  If no texture map is
        ///                     specified, this callback function will not be called.  The
        ///                     default texture callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsTexCoordCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_TEXTURE_COORD" />
        ///                     callback, except that it takes an additional pointer argument.
        ///                     This pointer is a copy of the pointer that was specified at the
        ///                     last call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsTexCoordDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback indicates a vertex of the primitive.  The
        ///                     coordinates of the vertex are stored in the parameter
        ///                     <i>vertexData</i>.  All the generated vertices have dimension 3,
        ///                     that is, homogeneous coordinates have been transformed into
        ///                     affine coordinates.  The default vertex callback function is
        ///                     <c>null</c>. The delegate prototype for this callback is
        ///                     <see cref="NurbsVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_VERTEX" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function that the callback invokes.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is used to define a callback to be used by a NURBS
        ///         object.  If the specified callback is already defined, then it is replaced.
        ///         If <i>func</i> is <c>null</c>, then this callback will not get invoked and
        ///         the related data, if any, will be lost.
        ///     </para>
        ///     <para>
        ///         Except the error callback, these callbacks are used by NURBS tessellator
        ///         (when <see cref="GLU_NURBS_MODE" /> is set to be
        ///         <see cref="GLU_NURBS_TESSELLATOR" />) to return back the OpenGL polygon
        ///         primitives resulting from the tessellation.  Note that there are two
        ///         versions of each callback: one with a user data pointer and one without.  If
        ///         both versions for a particular callback are specified then the callback with
        ///         the user data pointer will be used.  Note that <i>userData</i> is a copy of
        ///         the pointer that was specified at the last call to
        ///         <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.
        ///     </para>
        ///     <para>
        ///         The error callback function is effective no matter which value that
        ///         <see cref="GLU_NURBS_MODE" /> is set to.  All other callback functions are
        ///         effective only when <see cref="GLU_NURBS_MODE" /> is set to
        ///         <see cref="GLU_NURBS_TESSELLATOR" />.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is available only if the GLU version is 1.2 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         GLU version 1.2 supports only the <see cref="GLU_ERROR" /> parameter for
        ///         <i>which</i>.  The <see cref="GLU_ERROR" /> value is deprecated in GLU
        ///         version 1.3 in favor of <see cref="GLU_NURBS_ERROR" />.  All other
        ///         accepted values for <i>func</i> are available only if the GLU version is 1.3
        ///         or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="NurbsBeginCallback" />
        /// <seealso cref="NurbsBeginDataCallback" />
        /// <seealso cref="NurbsColorCallback" />
        /// <seealso cref="NurbsColorDataCallback" />
        /// <seealso cref="NurbsEndCallback" />
        /// <seealso cref="NurbsEndDataCallback" />
        /// <seealso cref="NurbsErrorCallback" />
        /// <seealso cref="NurbsNormalCallback" />
        /// <seealso cref="NurbsNormalDataCallback" />
        /// <seealso cref="NurbsTexCoordCallback" />
        /// <seealso cref="NurbsTexCoordDataCallback" />
        /// <seealso cref="NurbsVertexCallback" />
        /// <seealso cref="NurbsVertexDataCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        public static void gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsTexCoordDataCallback func)
        {
            nurbsTexCoordDataCallback = func;
            __gluNurbsCallback(nurb, which, nurbsTexCoordDataCallback);
        }
        #endregion gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsTexCoordDataCallback func)

        #region gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsVertexCallback func)
        /// <summary>
        ///     The <b>gluNurbsCallback</b> mehtod defines a callback for a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The legal callbacks are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback indicates the start of a primitive.  The
        ///                     function takes a single argument of type <see cref="int" />,
        ///                     which can be one of <see cref="Gl.GL_LINES" />,
        ///                     <see cref="Gl.GL_LINE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLES" />, or
        ///                     <see cref="Gl.GL_QUAD_STRIP" />.  The default begin callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR" /></term>
        ///                 <description>
        ///                     The color callback is invoked as the color of a vertex is
        ///                     generated.  The components of the color are stored in the
        ///                     parameter <i>colorData</i>.  This callback is effective only when
        ///                     the user provides a color map (<see cref="Gl.GL_MAP1_COLOR_4" />
        ///                     or <see cref="Gl.GL_MAP2_COLOR_4" />).  <i>colorData</i>
        ///                     contains four components: R,G,B,A.  The default color callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_COLOR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END" /></term>
        ///                 <description>
        ///                     The end callback is invoked at the end of a primitive.  The
        ///                     default end callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is <see cref="NurbsEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_END" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_ERROR" /></term>
        ///                 <description>
        ///                     The error function is called when an error is encountered.  Its
        ///                     single argument is of type <see cref="int" />, and it indicates
        ///                     the specific error that occurred.  There are 37 errors unique to
        ///                     NURBS named <see cref="GLU_NURBS_ERROR1" /> through
        ///                     <see cref="GLU_NURBS_ERROR37" />.  Character strings describing
        ///                     these errors can be retrieved with <see cref="gluErrorString" />.
        ///                     The delegate prototype for this callback is
        ///                     <see cref="NurbsErrorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL" /></term>
        ///                 <description>
        ///                     The normal callback is invoked as the vertex normal is generated.
        ///                     The components of the normal are stored in the parameter
        ///                     <i>normalData</i>.  In the case of a NURBS curve, the callback
        ///                     function is effective only when the user provides a normal map
        ///                     (<see cref="Gl.GL_MAP1_NORMAL" />).  In the case of a NURBS
        ///                     surface, if a normal map (<see cref="Gl.GL_MAP2_NORMAL" />) is
        ///                     provided, then the generated normal is computed from the normal
        ///                     map.  If a normal map is not provided then a surface normal is
        ///                     computed in a manner similar to that described for evaluators
        ///                     when <see cref="Gl.GL_AUTO_NORMAL" /> is enabled.  The default
        ///                     normal callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsNormalCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_NORMAL" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsNormalDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD" /></term>
        ///                 <description>
        ///                     The texture callback is invoked as the texture coordinates of a
        ///                     vertex are generated.  These coordinates are stored in the
        ///                     parameter <i>texCoord</i>.  The number of texture coordinates can
        ///                     be 1, 2, 3, or 4 depending on which type of texture map is
        ///                     specified (<see cref="Gl.GL_MAP1_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_4" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_4" />).  If no texture map is
        ///                     specified, this callback function will not be called.  The
        ///                     default texture callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsTexCoordCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_TEXTURE_COORD" />
        ///                     callback, except that it takes an additional pointer argument.
        ///                     This pointer is a copy of the pointer that was specified at the
        ///                     last call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsTexCoordDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback indicates a vertex of the primitive.  The
        ///                     coordinates of the vertex are stored in the parameter
        ///                     <i>vertexData</i>.  All the generated vertices have dimension 3,
        ///                     that is, homogeneous coordinates have been transformed into
        ///                     affine coordinates.  The default vertex callback function is
        ///                     <c>null</c>. The delegate prototype for this callback is
        ///                     <see cref="NurbsVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_VERTEX" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function that the callback invokes.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is used to define a callback to be used by a NURBS
        ///         object.  If the specified callback is already defined, then it is replaced.
        ///         If <i>func</i> is <c>null</c>, then this callback will not get invoked and
        ///         the related data, if any, will be lost.
        ///     </para>
        ///     <para>
        ///         Except the error callback, these callbacks are used by NURBS tessellator
        ///         (when <see cref="GLU_NURBS_MODE" /> is set to be
        ///         <see cref="GLU_NURBS_TESSELLATOR" />) to return back the OpenGL polygon
        ///         primitives resulting from the tessellation.  Note that there are two
        ///         versions of each callback: one with a user data pointer and one without.  If
        ///         both versions for a particular callback are specified then the callback with
        ///         the user data pointer will be used.  Note that <i>userData</i> is a copy of
        ///         the pointer that was specified at the last call to
        ///         <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.
        ///     </para>
        ///     <para>
        ///         The error callback function is effective no matter which value that
        ///         <see cref="GLU_NURBS_MODE" /> is set to.  All other callback functions are
        ///         effective only when <see cref="GLU_NURBS_MODE" /> is set to
        ///         <see cref="GLU_NURBS_TESSELLATOR" />.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is available only if the GLU version is 1.2 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         GLU version 1.2 supports only the <see cref="GLU_ERROR" /> parameter for
        ///         <i>which</i>.  The <see cref="GLU_ERROR" /> value is deprecated in GLU
        ///         version 1.3 in favor of <see cref="GLU_NURBS_ERROR" />.  All other
        ///         accepted values for <i>func</i> are available only if the GLU version is 1.3
        ///         or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="NurbsBeginCallback" />
        /// <seealso cref="NurbsBeginDataCallback" />
        /// <seealso cref="NurbsColorCallback" />
        /// <seealso cref="NurbsColorDataCallback" />
        /// <seealso cref="NurbsEndCallback" />
        /// <seealso cref="NurbsEndDataCallback" />
        /// <seealso cref="NurbsErrorCallback" />
        /// <seealso cref="NurbsNormalCallback" />
        /// <seealso cref="NurbsNormalDataCallback" />
        /// <seealso cref="NurbsTexCoordCallback" />
        /// <seealso cref="NurbsTexCoordDataCallback" />
        /// <seealso cref="NurbsVertexCallback" />
        /// <seealso cref="NurbsVertexDataCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        public static void gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsVertexCallback func)
        {
            nurbsVertexCallback = func;
            __gluNurbsCallback(nurb, which, nurbsVertexCallback);
        }
        #endregion gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsVertexCallback func)

        #region gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsVertexDataCallback func)
        /// <summary>
        ///     The <b>gluNurbsCallback</b> mehtod defines a callback for a NURBS object.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The legal callbacks are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback indicates the start of a primitive.  The
        ///                     function takes a single argument of type <see cref="int" />,
        ///                     which can be one of <see cref="Gl.GL_LINES" />,
        ///                     <see cref="Gl.GL_LINE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />,
        ///                     <see cref="Gl.GL_TRIANGLES" />, or
        ///                     <see cref="Gl.GL_QUAD_STRIP" />.  The default begin callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR" /></term>
        ///                 <description>
        ///                     The color callback is invoked as the color of a vertex is
        ///                     generated.  The components of the color are stored in the
        ///                     parameter <i>colorData</i>.  This callback is effective only when
        ///                     the user provides a color map (<see cref="Gl.GL_MAP1_COLOR_4" />
        ///                     or <see cref="Gl.GL_MAP2_COLOR_4" />).  <i>colorData</i>
        ///                     contains four components: R,G,B,A.  The default color callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_COLOR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_COLOR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsColorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END" /></term>
        ///                 <description>
        ///                     The end callback is invoked at the end of a primitive.  The
        ///                     default end callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is <see cref="NurbsEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_END_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_END" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_ERROR" /></term>
        ///                 <description>
        ///                     The error function is called when an error is encountered.  Its
        ///                     single argument is of type <see cref="int" />, and it indicates
        ///                     the specific error that occurred.  There are 37 errors unique to
        ///                     NURBS named <see cref="GLU_NURBS_ERROR1" /> through
        ///                     <see cref="GLU_NURBS_ERROR37" />.  Character strings describing
        ///                     these errors can be retrieved with <see cref="gluErrorString" />.
        ///                     The delegate prototype for this callback is
        ///                     <see cref="NurbsErrorCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL" /></term>
        ///                 <description>
        ///                     The normal callback is invoked as the vertex normal is generated.
        ///                     The components of the normal are stored in the parameter
        ///                     <i>normalData</i>.  In the case of a NURBS curve, the callback
        ///                     function is effective only when the user provides a normal map
        ///                     (<see cref="Gl.GL_MAP1_NORMAL" />).  In the case of a NURBS
        ///                     surface, if a normal map (<see cref="Gl.GL_MAP2_NORMAL" />) is
        ///                     provided, then the generated normal is computed from the normal
        ///                     map.  If a normal map is not provided then a surface normal is
        ///                     computed in a manner similar to that described for evaluators
        ///                     when <see cref="Gl.GL_AUTO_NORMAL" /> is enabled.  The default
        ///                     normal callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsNormalCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_NORMAL_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_NURBS_NORMAL" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is a
        ///                     copy of the pointer that was specified at the last call to
        ///                     <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default callback
        ///                     function is <c>null</c>.  The delegate prototype for this
        ///                     callback is <see cref="NurbsNormalDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD" /></term>
        ///                 <description>
        ///                     The texture callback is invoked as the texture coordinates of a
        ///                     vertex are generated.  These coordinates are stored in the
        ///                     parameter <i>texCoord</i>.  The number of texture coordinates can
        ///                     be 1, 2, 3, or 4 depending on which type of texture map is
        ///                     specified (<see cref="Gl.GL_MAP1_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP1_TEXTURE_COORD_4" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_1" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_2" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_3" />,
        ///                     <see cref="Gl.GL_MAP2_TEXTURE_COORD_4" />).  If no texture map is
        ///                     specified, this callback function will not be called.  The
        ///                     default texture callback function is <c>null</c>.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="NurbsTexCoordCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_TEXTURE_COORD_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_TEXTURE_COORD" />
        ///                     callback, except that it takes an additional pointer argument.
        ///                     This pointer is a copy of the pointer that was specified at the
        ///                     last call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsTexCoordDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback indicates a vertex of the primitive.  The
        ///                     coordinates of the vertex are stored in the parameter
        ///                     <i>vertexData</i>.  All the generated vertices have dimension 3,
        ///                     that is, homogeneous coordinates have been transformed into
        ///                     affine coordinates.  The default vertex callback function is
        ///                     <c>null</c>. The delegate prototype for this callback is
        ///                     <see cref="NurbsVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     This is the same as the <see cref="GLU_NURBS_VERTEX" /> callback,
        ///                     except that it takes an additional pointer argument.  This
        ///                     pointer is a copy of the pointer that was specified at the last
        ///                     call to <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.  The default
        ///                     callback function is <c>null</c>.  The delegate prototype for
        ///                     this callback is <see cref="NurbsVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function that the callback invokes.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is used to define a callback to be used by a NURBS
        ///         object.  If the specified callback is already defined, then it is replaced.
        ///         If <i>func</i> is <c>null</c>, then this callback will not get invoked and
        ///         the related data, if any, will be lost.
        ///     </para>
        ///     <para>
        ///         Except the error callback, these callbacks are used by NURBS tessellator
        ///         (when <see cref="GLU_NURBS_MODE" /> is set to be
        ///         <see cref="GLU_NURBS_TESSELLATOR" />) to return back the OpenGL polygon
        ///         primitives resulting from the tessellation.  Note that there are two
        ///         versions of each callback: one with a user data pointer and one without.  If
        ///         both versions for a particular callback are specified then the callback with
        ///         the user data pointer will be used.  Note that <i>userData</i> is a copy of
        ///         the pointer that was specified at the last call to
        ///         <see cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />.
        ///     </para>
        ///     <para>
        ///         The error callback function is effective no matter which value that
        ///         <see cref="GLU_NURBS_MODE" /> is set to.  All other callback functions are
        ///         effective only when <see cref="GLU_NURBS_MODE" /> is set to
        ///         <see cref="GLU_NURBS_TESSELLATOR" />.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallback</b> is available only if the GLU version is 1.2 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         GLU version 1.2 supports only the <see cref="GLU_ERROR" /> parameter for
        ///         <i>which</i>.  The <see cref="GLU_ERROR" /> value is deprecated in GLU
        ///         version 1.3 in favor of <see cref="GLU_NURBS_ERROR" />.  All other
        ///         accepted values for <i>func</i> are available only if the GLU version is 1.3
        ///         or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="NurbsBeginCallback" />
        /// <seealso cref="NurbsBeginDataCallback" />
        /// <seealso cref="NurbsColorCallback" />
        /// <seealso cref="NurbsColorDataCallback" />
        /// <seealso cref="NurbsEndCallback" />
        /// <seealso cref="NurbsEndDataCallback" />
        /// <seealso cref="NurbsErrorCallback" />
        /// <seealso cref="NurbsNormalCallback" />
        /// <seealso cref="NurbsNormalDataCallback" />
        /// <seealso cref="NurbsTexCoordCallback" />
        /// <seealso cref="NurbsTexCoordDataCallback" />
        /// <seealso cref="NurbsVertexCallback" />
        /// <seealso cref="NurbsVertexDataCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallbackData(Tao.OpenGl.Glu.GLUnurbs, byte[])" />
        /// <seealso cref="gluNurbsProperty" />
        // void APIENTRY gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (CALLBACK* fn)());
        public static void gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsVertexDataCallback func)
        {
            nurbsVertexDataCallback = func;
            __gluNurbsCallback(nurb, which, nurbsVertexDataCallback);
        }
        #endregion gluNurbsCallback([In] GLUnurbs nurb, int which, [In] NurbsVertexDataCallback func)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] byte[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] byte[] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] byte[] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] byte[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] byte[,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] byte[ , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] byte[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] byte[, ,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] byte[ , , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] double[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] double[] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] double[] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] double[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] double[,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] double[ , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] double[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] double[, ,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] double[ , , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] short[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] short[] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] short[] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] short[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] short[,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] short[ , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] short[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] short[, ,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] short[ , , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] int[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] int[] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] int[] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] int[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] int[,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] int[ , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] int[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] int[, ,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] int[ , , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] float[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] float[] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] float[] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] float[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] float[,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] float[ , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] float[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] float[, ,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] float[ , , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] ushort[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] ushort[] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] ushort[] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] ushort[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] ushort[,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] ushort[ , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] ushort[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] ushort[, ,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] ushort[ , , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] uint[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] uint[] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] uint[] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] uint[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] uint[,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] uint[ , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] uint[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] uint[, ,] userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] uint[ , , ] userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] IntPtr userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] IntPtr userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] IntPtr userData)

        #region gluNurbsCallbackData([In] GLUnurbs nurb, [In] void *userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is used to pass a pointer to the application's
        ///         data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///         tessellator in the NURBS callback functions (set by
        ///         <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         <b>gluNurbsCallbackData</b> is available only if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackData(GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public unsafe static extern void gluNurbsCallbackData([In] GLUnurbs nurb, [In] void* userData);
        #endregion gluNurbsCallbackData([In] GLUnurbs nurb, [In] void *userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] byte[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] byte[] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] byte[] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] byte[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] byte[,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] byte[ , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] byte[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] byte[, ,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] byte[ , , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] double[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] double[] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] double[] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] double[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] double[,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] double[ , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] double[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] double[, ,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] double[ , , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] short[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] short[] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] short[] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] short[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] short[,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] short[ , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] short[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] short[, ,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] short[ , , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] int[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] int[] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] int[] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] int[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] int[,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] int[ , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] int[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] int[, ,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] int[ , , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] float[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] float[] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] float[] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] float[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] float[,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] float[ , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] float[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] float[, ,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] float[ , , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] ushort[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] ushort[] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] ushort[] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] ushort[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] ushort[,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] ushort[ , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] ushort[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] ushort[, ,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] ushort[ , , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] uint[] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] uint[] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] uint[] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] uint[ , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] uint[,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] uint[ , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] uint[ , , ] userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] uint[, ,] userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] uint[ , , ] userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] IntPtr userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] IntPtr userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] IntPtr userData)

        #region gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] void *userData)
        /// <summary>
        ///     Sets a user data pointer.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="userData">
        ///     A pointer to the user's data.
        /// </param>
        /// <remarks>
        ///     <b>gluNurbsCallbackDataEXT</b> is used to pass a pointer to the application's
        ///     data to NURBS tessellator.  A copy of this pointer will be passed by the
        ///     tessellator in the NURBS callback functions (set by
        ///     <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).
        /// </remarks>
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // GLAPI void GLAPIENTRY gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public unsafe static extern void gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] void* userData);
        #endregion gluNurbsCallbackDataEXT([In] GLUnurbs nurb, [In] void *userData)

        #region gluNurbsCurve([In] GLUnurbs nurb, int knotCount, [In] float[] knots, int stride, [In] float[] control, int order, int type)
        /// <summary>
        ///     Defines the shape of a NURBS curve.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="knotCount">
        ///     The number of knots in <i>knot</i>.  The <i>knotCount</i> parameter equals
        ///     the number of control points plus the order.
        /// </param>
        /// <param name="knots">
        ///     An array of <i>knotCount</i> nondecreasing knot values.
        /// </param>
        /// <param name="stride">
        ///     The offset (as a number of single-precision floating-point values) between
        ///     successive curve control points.
        /// </param>
        /// <param name="control">
        ///     A pointer to an array of control points.  The coordinates must agree with
        ///     <i>type</i>.
        /// </param>
        /// <param name="order">
        ///     The order of the NURBS curve.  The <i>order</i> parameter equals degree + 1;
        ///     hence a cubic curve has an order of 4.
        /// </param>
        /// <param name="type">
        ///     The type of the curve.  If this curve is defined within a
        ///     <see cref="gluBeginCurve" />/<see cref="gluEndCurve" /> pair, then the type
        ///     can be any of the valid one-dimensional evaluator types (such as
        ///     <see cref="Gl.GL_MAP1_VERTEX_3" /> or <see cref="Gl.GL_MAP1_COLOR_4" />).
        ///     Between a <see cref="gluBeginTrim" />/<see cref="gluEndTrim" /> pair, the
        ///     only valid types are <see cref="GLU_MAP1_TRIM_2" /> and
        ///     <see cref="GLU_MAP1_TRIM_3" />. 
        /// </param>
        /// <remarks>
        ///     <para>
        ///         Use <b>gluNurbsCurve</b> to describe a NURBS curve.
        ///     </para>
        ///     <para>
        ///         When <b>gluNurbsCurve</b> appears between a
        ///         <see cref="gluBeginCurve" />/<see cref="gluEndCurve" /> pair, it is used to
        ///         describe a curve to be rendered.  Positional, texture, and color coordinates
        ///         are associated by presenting each as a separate <b>gluNurbsCurve</b> between
        ///         a <see cref="gluBeginCurve" />/<see cref="gluEndCurve" /> pair.  No more than
        ///         one call to <b>gluNurbsCurve</b> for each of color, position, and texture
        ///         data can be made within a single
        ///         <see cref="gluBeginCurve" />/<see cref="gluEndCurve" /> pair.  Exactly one
        ///         call must be made to describe the position of the curve (a type of
        ///         <see cref="Gl.GL_MAP1_VERTEX_3" /> or <see cref="Gl.GL_MAP1_VERTEX_4" />). 
        ///     </para>
        ///     <para>
        ///         When <b>gluNurbsCurve</b> appears between a
        ///         <see cref="gluBeginTrim" />/<see cref="gluEndTrim" /> pair, it is used to
        ///         describe a trimming curve on a NURBS surface.  If <i>type</i> is
        ///         <see cref="GLU_MAP1_TRIM_2" />, then it describes a curve in two-dimensional
        ///         (u and v) parameter space.  If it is <see cref="GLU_MAP1_TRIM_3" />, then it
        ///         describes a curve in two-dimensional homogeneous (u, v, and w) parameter
        ///         space.  See the <see cref="gluBeginTrim" /> reference page for more
        ///         discussion about trimming curves. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         To define trim curves which stitch well, use <see cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following commands render a textured NURBS curve with normals:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginCurve(nobj); 
        ///                 Glu.gluNurbsCurve(nobj, ..., Gl.GL_MAP1_TEXTURE_COORD_2); 
        ///                 Glu.gluNurbsCurve(nobj, ..., Gl.GL_MAP1_NORMAL); 
        ///                 Glu.gluNurbsCurve(nobj, ..., Gl.GL_MAP1_VERTEX_4);  
        ///             Glu.gluEndCurve(nobj); 
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluBeginCurve" />
        /// <seealso cref="gluBeginTrim" />
        /// <seealso cref="gluEndCurve" />
        /// <seealso cref="gluEndTrim" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />
        // void APIENTRY gluNurbsCurve(GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCurve([In] GLUnurbs nurb, int knotCount, [In] float[] knots, int stride, [In] float[] control, int order, int type);
        #endregion gluNurbsCurve([In] GLUnurbs nurb, int knotCount, [In] float[] knots, int stride, [In] float[] control, int order, int type)

        #region gluNurbsCurve([In] GLUnurbs nurb, int knotCount, [In] float[] knots, int stride, [In] float[ , ] control, int order, int type)
        /// <summary>
        ///     Defines the shape of a NURBS curve.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="knotCount">
        ///     The number of knots in <i>knot</i>.  The <i>knotCount</i> parameter equals
        ///     the number of control points plus the order.
        /// </param>
        /// <param name="knots">
        ///     An array of <i>knotCount</i> nondecreasing knot values.
        /// </param>
        /// <param name="stride">
        ///     The offset (as a number of single-precision floating-point values) between
        ///     successive curve control points.
        /// </param>
        /// <param name="control">
        ///     A pointer to an array of control points.  The coordinates must agree with
        ///     <i>type</i>.
        /// </param>
        /// <param name="order">
        ///     The order of the NURBS curve.  The <i>order</i> parameter equals degree + 1;
        ///     hence a cubic curve has an order of 4.
        /// </param>
        /// <param name="type">
        ///     The type of the curve.  If this curve is defined within a
        ///     <see cref="gluBeginCurve" />/<see cref="gluEndCurve" /> pair, then the type
        ///     can be any of the valid one-dimensional evaluator types (such as
        ///     <see cref="Gl.GL_MAP1_VERTEX_3" /> or <see cref="Gl.GL_MAP1_COLOR_4" />).
        ///     Between a <see cref="gluBeginTrim" />/<see cref="gluEndTrim" /> pair, the
        ///     only valid types are <see cref="GLU_MAP1_TRIM_2" /> and
        ///     <see cref="GLU_MAP1_TRIM_3" />. 
        /// </param>
        /// <remarks>
        ///     <para>
        ///         Use <b>gluNurbsCurve</b> to describe a NURBS curve.
        ///     </para>
        ///     <para>
        ///         When <b>gluNurbsCurve</b> appears between a
        ///         <see cref="gluBeginCurve" />/<see cref="gluEndCurve" /> pair, it is used to
        ///         describe a curve to be rendered.  Positional, texture, and color coordinates
        ///         are associated by presenting each as a separate <b>gluNurbsCurve</b> between
        ///         a <see cref="gluBeginCurve" />/<see cref="gluEndCurve" /> pair.  No more than
        ///         one call to <b>gluNurbsCurve</b> for each of color, position, and texture
        ///         data can be made within a single
        ///         <see cref="gluBeginCurve" />/<see cref="gluEndCurve" /> pair.  Exactly one
        ///         call must be made to describe the position of the curve (a type of
        ///         <see cref="Gl.GL_MAP1_VERTEX_3" /> or <see cref="Gl.GL_MAP1_VERTEX_4" />). 
        ///     </para>
        ///     <para>
        ///         When <b>gluNurbsCurve</b> appears between a
        ///         <see cref="gluBeginTrim" />/<see cref="gluEndTrim" /> pair, it is used to
        ///         describe a trimming curve on a NURBS surface.  If <i>type</i> is
        ///         <see cref="GLU_MAP1_TRIM_2" />, then it describes a curve in two-dimensional
        ///         (u and v) parameter space.  If it is <see cref="GLU_MAP1_TRIM_3" />, then it
        ///         describes a curve in two-dimensional homogeneous (u, v, and w) parameter
        ///         space.  See the <see cref="gluBeginTrim" /> reference page for more
        ///         discussion about trimming curves. 
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         To define trim curves which stitch well, use <see cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following commands render a textured NURBS curve with normals:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginCurve(nobj); 
        ///                 Glu.gluNurbsCurve(nobj, ..., Gl.GL_MAP1_TEXTURE_COORD_2); 
        ///                 Glu.gluNurbsCurve(nobj, ..., Gl.GL_MAP1_NORMAL); 
        ///                 Glu.gluNurbsCurve(nobj, ..., Gl.GL_MAP1_VERTEX_4);  
        ///             Glu.gluEndCurve(nobj); 
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluBeginCurve" />
        /// <seealso cref="gluBeginTrim" />
        /// <seealso cref="gluEndCurve" />
        /// <seealso cref="gluEndTrim" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />
        // void APIENTRY gluNurbsCurve(GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsCurve([In] GLUnurbs nurb, int knotCount, [In] float[] knots, int stride, [In] float[,] control, int order, int type);
        #endregion gluNurbsCurve([In] GLUnurbs nurb, int knotCount, [In] float[] knots, int stride, [In] float[ , ] control, int order, int type)

        #region gluNurbsProperty([In] GLUnurbs nurb, int property, float val)
        /// <summary>
        ///     Sets a NURBS property.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="property">
        ///     The property to be set.  Valid values are
        ///     <see cref="GLU_SAMPLING_TOLERANCE" />, <see cref="GLU_DISPLAY_MODE" />,
        ///     <see cref="GLU_CULLING" />, <see cref="GLU_AUTO_LOAD_MATRIX" />,
        ///     <see cref="GLU_PARAMETRIC_TOLERANCE" />, <see cref="GLU_SAMPLING_METHOD" />,
        ///     <see cref="GLU_U_STEP" />, <see cref="GLU_V_STEP" />, or
        ///     <see cref="GLU_NURBS_MODE" />.
        /// </param>
        /// <param name="val">
        ///     The value of the indicated property.  It may be a numeric value, or one of
        ///     <see cref="GLU_OUTLINE_POLYGON" />, <see cref="GLU_FILL" />,
        ///     <see cref="GLU_OUTLINE_PATCH" />, <see cref="Gl.GL_TRUE" />,
        ///     <see cref="Gl.GL_FALSE" />, <see cref="GLU_PATH_LENGTH" />,
        ///     <see cref="GLU_PARAMETRIC_ERROR" />, <see cref="GLU_DOMAIN_DISTANCE" />,
        ///     <see cref="GLU_NURBS_RENDERER" />, or <see cref="GLU_NURBS_TESSELLATOR" />.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluNurbsProperty</b> is used to control properties stored in a NURBS
        ///         object.  These properties affect the way that a NURBS curve is rendered.  The
        ///         accepted values for property are as follows:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NURBS_MODE" /></term>
        ///                 <description>
        ///                     <i>val</i> should be set to be either
        ///                     <see cref="GLU_NURBS_RENDERER" /> or
        ///                     <see cref="GLU_NURBS_TESSELLATOR" />.  When set to
        ///                     <see cref="GLU_NURBS_RENDERER" />, NURBS objects are tessellated
        ///                     into OpenGL primitives and sent to the pipeline for rendering.
        ///                     When set to <see cref="GLU_NURBS_TESSELLATOR" />, NURBS objects
        ///                     are tessellated into OpenGL primitives but the vertices, normals,
        ///                     colors, and/or textures are retrieved back through a callback
        ///                     interface (see <see cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />).  This allows the
        ///                     user to cache the tessellated results for further processing.
        ///                     The initial value is <see cref="GLU_NURBS_RENDERER" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_SAMPLING_METHOD" /></term>
        ///                 <description>
        ///                     <para>
        ///                         Specifies how a NURBS surface should be tessellated.
        ///                         <i>val</i> may be one of <see cref="GLU_PATH_LENGTH" />,
        ///                         <see cref="GLU_PARAMETRIC_ERROR" />,
        ///                         <see cref="GLU_DOMAIN_DISTANCE" />,
        ///                         <see cref="GLU_OBJECT_PATH_LENGTH" />, or
        ///                         <see cref="GLU_OBJECT_PARAMETRIC_ERROR" />.  When set to
        ///                         <see cref="GLU_PATH_LENGTH" />, the surface is rendered so
        ///                         that the maximum length, in pixels, of the edges of the
        ///                         tessellation polygons is no greater than what is specified by
        ///                         <see cref="GLU_SAMPLING_TOLERANCE" />.
        ///                     </para>
        ///                     <para>
        ///                         <see cref="GLU_PARAMETRIC_ERROR" /> specifies that the
        ///                         surface is rendered in such a way that the value specified by
        ///                         <see cref="GLU_PARAMETRIC_TOLERANCE" /> describes the maximum
        ///                         distance, in pixels, between the tessellation polygons and
        ///                         the surfaces they approximate.
        ///                     </para>
        ///                     <para>
        ///                         <see cref="GLU_DOMAIN_DISTANCE" /> allows users to specify,
        ///                         in parametric coordinates, how many sample points per unit
        ///                         length are taken in u, v direction.
        ///                     </para>
        ///                     <para>
        ///                         <see cref="GLU_OBJECT_PATH_LENGTH" /> is similar to
        ///                         <see cref="GLU_PATH_LENGTH" /> except that it is view
        ///                         independent, that is, the surface is rendered so that the
        ///                         maximum length, in object space, of edges of the tessellation
        ///                         polygons is no greater than what is specified by
        ///                         <see cref="GLU_SAMPLING_TOLERANCE" />.
        ///                     </para>
        ///                     <para>
        ///                         <see cref="GLU_OBJECT_PARAMETRIC_ERROR" /> is similar to
        ///                         <see cref="GLU_PARAMETRIC_ERROR" /> except that it is view
        ///                         independent, that is, the surface is rendered in such a way
        ///                         that the value specified by
        ///                         <see cref="GLU_PARAMETRIC_TOLERANCE" /> describes the maximum
        ///                         distance, in object space, between the tessellation polygons
        ///                         and the surfaces they approximate.
        ///                     </para>
        ///                     <para>
        ///                         The initial value of <see cref="GLU_SAMPLING_METHOD" /> is
        ///                         <see cref="GLU_PATH_LENGTH" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_SAMPLING_TOLERANCE" /></term>
        ///                 <description>
        ///                     Specifies the maximum length, in pixels or in object space length
        ///                     unit, to use when the sampling method is set to
        ///                     <see cref="GLU_PATH_LENGTH" /> or
        ///                     <see cref="GLU_OBJECT_PATH_LENGTH" />.  The NURBS code is
        ///                     conservative when rendering a curve or surface, so the actual
        ///                     length can be somewhat shorter.  The initial value is 50.0
        ///                     pixels.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_PARAMETRIC_TOLERANCE" /></term>
        ///                 <description>
        ///                     Specifies the maximum distance, in pixels or in object space
        ///                     length unit, to use when the sampling method is
        ///                     <see cref="GLU_PARAMETRIC_ERROR" /> or
        ///                     <see cref="GLU_OBJECT_PARAMETRIC_ERROR" />.  The initial value is
        ///                     0.5.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_U_STEP" /></term>
        ///                 <description>
        ///                     Specifies the number of sample points per unit length taken along
        ///                     the u axis in parametric coordinates.  It is needed when
        ///                     <see cref="GLU_SAMPLING_METHOD" /> is set to
        ///                     <see cref="GLU_DOMAIN_DISTANCE" />.  The initial value is 100.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_V_STEP" /></term>
        ///                 <description>
        ///                     Specifies the number of sample points per unit length taken along
        ///                     the v axis in parametric coordinate.  It is needed when
        ///                     <see cref="GLU_SAMPLING_METHOD" /> is set to
        ///                     <see cref="GLU_DOMAIN_DISTANCE" />.  The initial value is 100.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_DISPLAY_MODE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         <i>val</i> can be set to <see cref="GLU_OUTLINE_POLYGON" />,
        ///                         <see cref="GLU_FILL" />, or <see cref="GLU_OUTLINE_PATCH" />.
        ///                         When <see cref="GLU_NURBS_MODE" /> is set to be
        ///                         <see cref="GLU_NURBS_RENDERER" />, <i>val</i> defines how a
        ///                         NURBS surface should be rendered.  When <i>val</i> is set to
        ///                         <see cref="GLU_FILL" />, the surface is rendered as a set of
        ///                         polygons.  When <i>val</i> is set to
        ///                         <see cref="GLU_OUTLINE_POLYGON" />, the NURBS library draws
        ///                         only the outlines of the polygons created by tessellation.
        ///                         When <i>val</i> is set to
        ///                         <see cref="GLU_OUTLINE_PATCH" /> just the outlines of patches
        ///                         and trim curves defined by the user are drawn.
        ///                     </para>
        ///                     <para>
        ///                         When <see cref="GLU_NURBS_MODE" /> is set to be
        ///                         <see cref="GLU_NURBS_TESSELLATOR" />, <i>val</i> defines how
        ///                         a NURBS surface should be tessellated.  When
        ///                         <see cref="GLU_DISPLAY_MODE" /> is set to
        ///                         <see cref="GLU_FILL" /> or
        ///                         <see cref="GLU_OUTLINE_POLYGON" />, the NURBS surface is
        ///                         tessellated into OpenGL triangle primitives which can be
        ///                         retrieved back through callback functions.  If
        ///                         <see cref="GLU_DISPLAY_MODE" /> is set to
        ///                         <see cref="GLU_OUTLINE_PATCH" />, only the outlines of the
        ///                         patches and trim curves are generated as a sequence of
        ///                         line strips which can be retrieved back through callback
        ///                         functions.
        ///                     </para>
        ///                     <para>
        ///                         The initial value is <see cref="GLU_FILL" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_CULLING" /></term>
        ///                 <description>
        ///                     <i>val</i> is a boolean value that, when set to
        ///                     <see cref="Gl.GL_TRUE" />, indicates that a NURBS curve should be
        ///                     discarded prior to tessellation if its control points lie outside
        ///                     the current viewport.  The initial value is
        ///                     <see cref="Gl.GL_FALSE" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_AUTO_LOAD_MATRIX" /></term>
        ///                 <description>
        ///                     <para>
        ///                         <i>val</i> is a boolean value.  When set to
        ///                         <see cref="Gl.GL_TRUE" />, the NURBS code downloads the
        ///                         projection matrix, the modelview matrix, and the viewport
        ///                         from the GL server to compute sampling and culling matrices
        ///                         for each NURBS curve that is rendered.  Sampling and culling
        ///                         matrices are required to determine the tessellation of a
        ///                         NURBS surface into line segments or polygons and to cull a
        ///                         NURBS surface if it lies outside the viewport.
        ///                     </para>
        ///                     <para>
        ///                         If this mode is set to <see cref="Gl.GL_FALSE" />, then the
        ///                         program needs to provide a projection matrix, a modelview
        ///                         matrix, and a viewport for the NURBS renderer to use to
        ///                         construct sampling and culling matrices.  This can be done
        ///                         with the <see cref="gluLoadSamplingMatrices" /> function.
        ///                         This mode is initially set to <see cref="Gl.GL_TRUE" />.
        ///                         Changing it from <see cref="Gl.GL_TRUE" /> to
        ///                         <see cref="Gl.GL_FALSE" /> does not affect the sampling and
        ///                         culling matrices until <see cref="gluLoadSamplingMatrices" />
        ///                         is called.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         If <see cref="GLU_AUTO_LOAD_MATRIX" /> is true, sampling and culling may be
        ///         executed incorrectly if NURBS routines are compiled into a display list.
        ///     </para>
        ///     <para>
        ///         A <i>property</i> of <see cref="GLU_PARAMETRIC_TOLERANCE" />,
        ///         <see cref="GLU_SAMPLING_METHOD" />, <see cref="GLU_U_STEP" />, or
        ///         <see cref="GLU_V_STEP" />, or a <i>val</i> of <see cref="GLU_PATH_LENGTH" />,
        ///         <see cref="GLU_PARAMETRIC_ERROR" />, <see cref="GLU_DOMAIN_DISTANCE" /> are
        ///         only available if the GLU version is 1.1 or greater.  They are not valid
        ///         parameters in GLU 1.0.
        ///     </para>
        ///     <para>
        ///         <see cref="gluGetString" /> can be used to determine the GLU version.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_NURBS_MODE" /> is only availble if the GLU version is 1.3 or
        ///         greater.
        ///     </para>
        ///     <para>
        ///         The <see cref="GLU_OBJECT_PATH_LENGTH" /> and
        ///         <see cref="GLU_OBJECT_PARAMETRIC_ERROR" /> values for the
        ///         <see cref="GLU_SAMPLING_METHOD" /> property are only available if the GLU
        ///         version is 1.3 or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluGetNurbsProperty(Tao.OpenGl.Glu.GLUnurbs, int, float[])" />
        /// <seealso cref="gluGetString" />
        /// <seealso cref="gluLoadSamplingMatrices" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCallback(Tao.OpenGl.Glu.GLUnurbs, int, Tao.OpenGl.Glu.NurbsBeginCallback)" />
        // void APIENTRY gluNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat value);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsProperty([In] GLUnurbs nurb, int property, float val);
        #endregion gluNurbsProperty([In] GLUnurbs nurb, int property, float val)

        #region gluNurbsSurface([In] GLUnurbs nurb, int sKnotCount, [In] float[] sKnots, int tKnotCount, [In] float[] tKnots, int sStride, int tStride, [In] float[] control, int sOrder, int tOrder, int type)
        /// <summary>
        ///     Defines the shape of a NURBS surface.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="sKnotCount">
        ///     The number of knots in the parametric u direction.
        /// </param>
        /// <param name="sKnots">
        ///     An array of <i>sKnotCount</i> nondecreasing knot values in the parametric
        ///     u direction
        /// </param>
        /// <param name="tKnotCount">
        ///     The number of knots in the parametric v direction.
        /// </param>
        /// <param name="tKnots">
        ///     An array of <i>tKnotCount</i> nondecreasing knot values in the parametric
        ///     v direction.
        /// </param>
        /// <param name="sStride">
        ///     The offset (as a number of single-precision floating-point values) between
        ///     successive control points in the parametric u direction in <i>control</i>.
        /// </param>
        /// <param name="tStride">
        ///     The offset (in single-precision floating-point values) between successive
        ///     control points in the parametric v direction in <i>control</i>.
        /// </param>
        /// <param name="control">
        ///     An array containing control points for the NURBS surface.  The offsets
        ///     between successive control points in the parametric u and v directions are
        ///     given by <i>sStride</i> and <i>tStride</i>.
        /// </param>
        /// <param name="sOrder">
        ///     The order of the NURBS surface in the parametric u direction.  The order is
        ///     one more than the degree, hence a surface that is cubic in u has a u order of
        ///     4.
        /// </param>
        /// <param name="tOrder">
        ///     The order of the NURBS surface in the parametric v direction.  The order is
        ///     one more than the degree, hence a surface that is cubic in v has a v order of
        ///     4.
        /// </param>
        /// <param name="type">
        ///     The type of the surface.  The <i>type</i> parameter can be any of the valid
        ///     two-dimensional evaluator types (such as <see cref="Gl.GL_MAP2_VERTEX_3" />
        ///     or <see cref="Gl.GL_MAP2_COLOR_4" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         Use <b>gluNurbsSurface</b> within a NURBS (Non-Uniform Rational B-Spline)
        ///         surface definition to describe the shape of a NURBS surface (before any
        ///         trimming).  To mark the beginning of a NURBS surface definition, use the
        ///         <see cref="gluBeginSurface" /> command.  To mark the end of a NURBS surface
        ///         definition, use the <see cref="gluEndSurface" /> command.  Call
        ///         <b>gluNurbsSurface</b> within a NURBS surface definition only.
        ///     </para>
        ///     <para>
        ///         Positional, texture, and color coordinates are associated with a surface by
        ///         presenting each as a separate <b>gluNurbsSurface</b> between a
        ///         <see cref="gluBeginSurface" />/<see cref="gluEndSurface" /> pair.  No more
        ///         than one call to <b>gluNurbsSurface</b> for each of color, position, and
        ///         texture data can be made within a single
        ///         <see cref="gluBeginSurface" />/<see cref="gluEndSurface" /> pair.  Exactly
        ///         one call must be made to describe the position of the surface (a type of
        ///         <see cref="Gl.GL_MAP2_VERTEX_3" /> or <see cref="Gl.GL_MAP2_VERTEX_4" />).
        ///     </para>
        ///     <para>
        ///         A NURBS surface can be trimmed by using the commands
        ///         <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" /> and <see cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" /> between calls to
        ///         <see cref="gluBeginTrim" /> and <see cref="gluEndTrim" />.
        ///     </para>
        ///     <para>
        ///         Note that a <b>gluNurbsSurface</b> with <i>sKnotCount</i> knots in the u
        ///         direction and <i>tKnotCount</i> knots in the v direction with orders
        ///         <i>sOrder</i> and <i>tOrder</i> must have (<i>sKnotCount</i> - <i>sOrder</i>)
        ///         multiplied by (<i>tKnotCount</i> - <i>tOrder</i>) control points.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginSurface(nobj);
        ///                 Glu.gluNurbsSurface(nobj, . . ., Gl.GL_MAP2_TEXTURE_COORD_2);
        ///                 Glu.gluNurbsSurface(nobj, . . ., Gl.GL_MAP2_NORMAL);
        ///                 Glu.gluNurbsSurface(nobj, . . ., Gl.GL_MAP2_VERTEX_4);
        ///             Glu.gluEndSurface(nobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluBeginSurface" />
        /// <seealso cref="gluBeginTrim" />
        /// <seealso cref="gluEndSurface" />
        /// <seealso cref="gluEndTrim" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />
        /// <seealso cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />
        // void APIENTRY gluNurbsSurface(GLUnurbs *nobj, GLint sknot_count, float *sknot, GLint tknot_count, GLfloat *tknot, GLint s_stride, GLint t_stride, GLfloat *ctlarray, GLint sorder, GLint torder, GLenum type);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsSurface([In] GLUnurbs nurb, int sKnotCount, [In] float[] sKnots, int tKnotCount, [In] float[] tKnots, int sStride, int tStride, float[] control, int sOrder, int tOrder, int type);
        #endregion gluNurbsSurface([In] GLUnurbs nurb, int sKnotCount, [In] float[] sKnots, int tKnotCount, [In] float[] tKnots, int sStride, int tStride, float[] control, int sOrder, int tOrder, int type)

        #region gluNurbsSurface([In] GLUnurbs nurb, int sKnotCount, [In] float[] sKnots, int tKnotCount, [In] float[] tKnots, int sStride, int tStride, [In] float[ , ] control, int sOrder, int tOrder, int type)
        /// <summary>
        ///     Defines the shape of a NURBS surface.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="sKnotCount">
        ///     The number of knots in the parametric u direction.
        /// </param>
        /// <param name="sKnots">
        ///     An array of <i>sKnotCount</i> nondecreasing knot values in the parametric
        ///     u direction
        /// </param>
        /// <param name="tKnotCount">
        ///     The number of knots in the parametric v direction.
        /// </param>
        /// <param name="tKnots">
        ///     An array of <i>tKnotCount</i> nondecreasing knot values in the parametric
        ///     v direction.
        /// </param>
        /// <param name="sStride">
        ///     The offset (as a number of single-precision floating-point values) between
        ///     successive control points in the parametric u direction in <i>control</i>.
        /// </param>
        /// <param name="tStride">
        ///     The offset (in single-precision floating-point values) between successive
        ///     control points in the parametric v direction in <i>control</i>.
        /// </param>
        /// <param name="control">
        ///     An array containing control points for the NURBS surface.  The offsets
        ///     between successive control points in the parametric u and v directions are
        ///     given by <i>sStride</i> and <i>tStride</i>.
        /// </param>
        /// <param name="sOrder">
        ///     The order of the NURBS surface in the parametric u direction.  The order is
        ///     one more than the degree, hence a surface that is cubic in u has a u order of
        ///     4.
        /// </param>
        /// <param name="tOrder">
        ///     The order of the NURBS surface in the parametric v direction.  The order is
        ///     one more than the degree, hence a surface that is cubic in v has a v order of
        ///     4.
        /// </param>
        /// <param name="type">
        ///     The type of the surface.  The <i>type</i> parameter can be any of the valid
        ///     two-dimensional evaluator types (such as <see cref="Gl.GL_MAP2_VERTEX_3" />
        ///     or <see cref="Gl.GL_MAP2_COLOR_4" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         Use <b>gluNurbsSurface</b> within a NURBS (Non-Uniform Rational B-Spline)
        ///         surface definition to describe the shape of a NURBS surface (before any
        ///         trimming).  To mark the beginning of a NURBS surface definition, use the
        ///         <see cref="gluBeginSurface" /> command.  To mark the end of a NURBS surface
        ///         definition, use the <see cref="gluEndSurface" /> command.  Call
        ///         <b>gluNurbsSurface</b> within a NURBS surface definition only.
        ///     </para>
        ///     <para>
        ///         Positional, texture, and color coordinates are associated with a surface by
        ///         presenting each as a separate <b>gluNurbsSurface</b> between a
        ///         <see cref="gluBeginSurface" />/<see cref="gluEndSurface" /> pair.  No more
        ///         than one call to <b>gluNurbsSurface</b> for each of color, position, and
        ///         texture data can be made within a single
        ///         <see cref="gluBeginSurface" />/<see cref="gluEndSurface" /> pair.  Exactly
        ///         one call must be made to describe the position of the surface (a type of
        ///         <see cref="Gl.GL_MAP2_VERTEX_3" /> or <see cref="Gl.GL_MAP2_VERTEX_4" />).
        ///     </para>
        ///     <para>
        ///         A NURBS surface can be trimmed by using the commands
        ///         <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" /> and <see cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" /> between calls to
        ///         <see cref="gluBeginTrim" /> and <see cref="gluEndTrim" />.
        ///     </para>
        ///     <para>
        ///         Note that a <b>gluNurbsSurface</b> with <i>sKnotCount</i> knots in the u
        ///         direction and <i>tKnotCount</i> knots in the v direction with orders
        ///         <i>sOrder</i> and <i>tOrder</i> must have (<i>sKnotCount</i> - <i>sOrder</i>)
        ///         multiplied by (<i>tKnotCount</i> - <i>tOrder</i>) control points.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginSurface(nobj);
        ///                 Glu.gluNurbsSurface(nobj, . . ., Gl.GL_MAP2_TEXTURE_COORD_2);
        ///                 Glu.gluNurbsSurface(nobj, . . ., Gl.GL_MAP2_NORMAL);
        ///                 Glu.gluNurbsSurface(nobj, . . ., Gl.GL_MAP2_VERTEX_4);
        ///             Glu.gluEndSurface(nobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluBeginSurface" />
        /// <seealso cref="gluBeginTrim" />
        /// <seealso cref="gluEndSurface" />
        /// <seealso cref="gluEndTrim" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />
        /// <seealso cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />
        // void APIENTRY gluNurbsSurface(GLUnurbs *nobj, GLint sknot_count, float *sknot, GLint tknot_count, GLfloat *tknot, GLint s_stride, GLint t_stride, GLfloat *ctlarray, GLint sorder, GLint torder, GLenum type);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsSurface([In] GLUnurbs nurb, int sKnotCount, [In] float[] sKnots, int tKnotCount, [In] float[] tKnots, int sStride, int tStride, float[,] control, int sOrder, int tOrder, int type);
        #endregion gluNurbsSurface([In] GLUnurbs nurb, int sKnotCount, [In] float[] sKnots, int tKnotCount, [In] float[] tKnots, int sStride, int tStride, float[ , ] control, int sOrder, int tOrder, int type)

        #region gluNurbsSurface([In] GLUnurbs nurb, int sKnotCount, [In] float[] sKnots, int tKnotCount, [In] float[] tKnots, int sStride, int tStride, [In] float[ , , ] control, int sOrder, int tOrder, int type)
        /// <summary>
        ///     Defines the shape of a NURBS surface.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="sKnotCount">
        ///     The number of knots in the parametric u direction.
        /// </param>
        /// <param name="sKnots">
        ///     An array of <i>sKnotCount</i> nondecreasing knot values in the parametric
        ///     u direction
        /// </param>
        /// <param name="tKnotCount">
        ///     The number of knots in the parametric v direction.
        /// </param>
        /// <param name="tKnots">
        ///     An array of <i>tKnotCount</i> nondecreasing knot values in the parametric
        ///     v direction.
        /// </param>
        /// <param name="sStride">
        ///     The offset (as a number of single-precision floating-point values) between
        ///     successive control points in the parametric u direction in <i>control</i>.
        /// </param>
        /// <param name="tStride">
        ///     The offset (in single-precision floating-point values) between successive
        ///     control points in the parametric v direction in <i>control</i>.
        /// </param>
        /// <param name="control">
        ///     An array containing control points for the NURBS surface.  The offsets
        ///     between successive control points in the parametric u and v directions are
        ///     given by <i>sStride</i> and <i>tStride</i>.
        /// </param>
        /// <param name="sOrder">
        ///     The order of the NURBS surface in the parametric u direction.  The order is
        ///     one more than the degree, hence a surface that is cubic in u has a u order of
        ///     4.
        /// </param>
        /// <param name="tOrder">
        ///     The order of the NURBS surface in the parametric v direction.  The order is
        ///     one more than the degree, hence a surface that is cubic in v has a v order of
        ///     4.
        /// </param>
        /// <param name="type">
        ///     The type of the surface.  The <i>type</i> parameter can be any of the valid
        ///     two-dimensional evaluator types (such as <see cref="Gl.GL_MAP2_VERTEX_3" />
        ///     or <see cref="Gl.GL_MAP2_COLOR_4" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         Use <b>gluNurbsSurface</b> within a NURBS (Non-Uniform Rational B-Spline)
        ///         surface definition to describe the shape of a NURBS surface (before any
        ///         trimming).  To mark the beginning of a NURBS surface definition, use the
        ///         <see cref="gluBeginSurface" /> command.  To mark the end of a NURBS surface
        ///         definition, use the <see cref="gluEndSurface" /> command.  Call
        ///         <b>gluNurbsSurface</b> within a NURBS surface definition only.
        ///     </para>
        ///     <para>
        ///         Positional, texture, and color coordinates are associated with a surface by
        ///         presenting each as a separate <b>gluNurbsSurface</b> between a
        ///         <see cref="gluBeginSurface" />/<see cref="gluEndSurface" /> pair.  No more
        ///         than one call to <b>gluNurbsSurface</b> for each of color, position, and
        ///         texture data can be made within a single
        ///         <see cref="gluBeginSurface" />/<see cref="gluEndSurface" /> pair.  Exactly
        ///         one call must be made to describe the position of the surface (a type of
        ///         <see cref="Gl.GL_MAP2_VERTEX_3" /> or <see cref="Gl.GL_MAP2_VERTEX_4" />).
        ///     </para>
        ///     <para>
        ///         A NURBS surface can be trimmed by using the commands
        ///         <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" /> and <see cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" /> between calls to
        ///         <see cref="gluBeginTrim" /> and <see cref="gluEndTrim" />.
        ///     </para>
        ///     <para>
        ///         Note that a <b>gluNurbsSurface</b> with <i>sKnotCount</i> knots in the u
        ///         direction and <i>tKnotCount</i> knots in the v direction with orders
        ///         <i>sOrder</i> and <i>tOrder</i> must have (<i>sKnotCount</i> - <i>sOrder</i>)
        ///         multiplied by (<i>tKnotCount</i> - <i>tOrder</i>) control points.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluBeginSurface(nobj);
        ///                 Glu.gluNurbsSurface(nobj, . . ., Gl.GL_MAP2_TEXTURE_COORD_2);
        ///                 Glu.gluNurbsSurface(nobj, . . ., Gl.GL_MAP2_NORMAL);
        ///                 Glu.gluNurbsSurface(nobj, . . ., Gl.GL_MAP2_VERTEX_4);
        ///             Glu.gluEndSurface(nobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluBeginSurface" />
        /// <seealso cref="gluBeginTrim" />
        /// <seealso cref="gluEndSurface" />
        /// <seealso cref="gluEndTrim" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />
        /// <seealso cref="gluPwlCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, int)" />
        // void APIENTRY gluNurbsSurface(GLUnurbs *nobj, GLint sknot_count, float *sknot, GLint tknot_count, GLfloat *tknot, GLint s_stride, GLint t_stride, GLfloat *ctlarray, GLint sorder, GLint torder, GLenum type);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluNurbsSurface([In] GLUnurbs nurb, int sKnotCount, [In] float[] sKnots, int tKnotCount, [In] float[] tKnots, int sStride, int tStride, float[, ,] control, int sOrder, int tOrder, int type);
        #endregion gluNurbsSurface([In] GLUnurbs nurb, int sKnotCount, [In] float[] sKnots, int tKnotCount, [In] float[] tKnots, int sStride, int tStride, float[ , , ] control, int sOrder, int tOrder, int type)

        #region gluOrtho2D(double left, double right, double bottom, double top)
        /// <summary>
        ///     Defines a 2D orthographic projection matrix.
        /// </summary>
        /// <param name="left">
        ///     The coordinates for the leftvertical clipping planes.
        /// </param>
        /// <param name="right">
        ///     The coordinates for the right vertical clipping planes.
        /// </param>
        /// <param name="bottom">
        ///     The coordinates for the bottom horizontal clipping planes.
        /// </param>
        /// <param name="top">
        ///     The coordinates for the top horizontal clipping planes.
        /// </param>
        /// <remarks>
        ///     The <b>gluOrtho2D</b> function sets up a two-dimensional orthographic viewing
        ///     region.  This is equivalent to calling <see cref="Gl.glOrtho" /> with
        ///     <i>near</i> = 1 and <i>far</i> = 1.
        /// </remarks>
        /// <seealso cref="Gl.glOrtho" />
        /// <seealso cref="gluPerspective" />
        // void APIENTRY gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluOrtho2D(double left, double right, double bottom, double top);
        #endregion gluOrtho2D(double left, double right, double bottom, double top)

        #region gluPartialDisk([In] GLUquadric quad, double innerRadius, double outerRadius, int slices, int loops, double startAngle, double sweepAngle)
        /// <summary>
        ///     Draws an arc of a disk.
        /// </summary>
        /// <param name="quad">
        ///     A quadric object (created with <see cref="gluNewQuadric" />).
        /// </param>
        /// <param name="innerRadius">
        ///     The inner radius of the partial disk (can be zero).
        /// </param>
        /// <param name="outerRadius">
        ///     The outer radius of the partial disk.
        /// </param>
        /// <param name="slices">
        ///     The number of subdivisions around the z-axis.
        /// </param>
        /// <param name="loops">
        ///     The number of concentric rings about the origin into which the partial disk
        ///     is subdivided.
        /// </param>
        /// <param name="startAngle">
        ///     The starting angle, in degrees, of the disk portion.
        /// </param>
        /// <param name="sweepAngle">
        ///     The sweep angle, in degrees, of the disk portion.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluPartialDisk</b> renders a partial disk on the z = 0 plane.  A partial
        ///         disk is similar to a full disk, except that only the subset of the disk from
        ///         <i>startAngle</i> through <i>startAngle</i> + <i>sweepAngle</i> is included
        ///         (where 0 degrees is along the +y axis, 90 degrees along the +x axis, 180
        ///         degrees along the -y axis, and 270 degrees along the -x axis).
        ///     </para>
        ///     <para>
        ///         The partial disk has a radius of <i>outerRadius</i>, and contains a
        ///         concentric circular hole with a radius of <i>innerRadius</i>.  If
        ///         <i>innerRadius</i> is 0, then no hole is generated.  The partial disk is
        ///         subdivided around the z axis into slices (like pizza slices), and also about
        ///         the z axis into rings (as specified by <i>slices</i> and <i>loops</i>,
        ///         respectively).
        ///     </para>
        ///     <para>
        ///         With respect to orientation, the +z side of the partial disk is considered
        ///         to be outside (see <see cref="gluQuadricOrientation" />).  This means that if
        ///         the orientation is set to <see cref="GLU_OUTSIDE" />, then any normals
        ///         generated point along the +z axis.  Otherwise, they point along the -z axis.
        ///     </para>
        ///     <para>
        ///         If texturing is turned on (with <see cref="gluQuadricTexture" />), texture
        ///         coordinates are generated linearly such that where r = <i>outerRadius</i>,
        ///         the value at (r, 0, 0) is (1.0, 0.5), at (0, r, 0) it is (0.5, 1.0), at
        ///         (-r, 0, 0) it is (0.0, 0.5), and at (0, -r, 0) it is (0.5, 0.0).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluCylinder" />
        /// <seealso cref="gluDisk" />
        /// <seealso cref="gluNewQuadric" />
        /// <seealso cref="gluQuadricOrientation" />
        /// <seealso cref="gluQuadricTexture" />
        /// <seealso cref="gluSphere" />
        // void APIENTRY gluPartialDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluPartialDisk([In] GLUquadric quad, double innerRadius, double outerRadius, int slices, int loops, double startAngle, double sweepAngle);
        #endregion gluPartialDisk([In] GLUquadric quad, double innerRadius, double outerRadius, int slices, int loops, double startAngle, double sweepAngle)

        #region gluPerspective(double fovY, double aspectRatio, double zNear, double zFar)
        /// <summary>
        ///     Sets up a perspective projection matrix.
        /// </summary>
        /// <param name="fovY">
        ///     The field of view angle, in degrees, in the y-direction.
        /// </param>
        /// <param name="aspectRatio">
        ///     The aspect ratio that determines the field of view in the x-direction.  The
        ///     aspect ratio is the ratio of x (width) to y (height).
        /// </param>
        /// <param name="zNear">
        ///     The distance from the viewer to the near clipping plane (always positive).
        /// </param>
        /// <param name="zFar">
        ///     The distance from the viewer to the far clipping plane (always positive).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         The <b>gluPerspective</b> subroutine specifies a viewing frustum into the
        ///         world coordinate system.  Generally, the aspect ratio used with this
        ///         subroutine should match that of its associated viewport.  For example, an
        ///         aspect ratio value of aspect = 2.0 means the viewer's angle of view is twice
        ///         as wide in x as it is in y.  If the viewport is twice as wide as it is tall,
        ///         it displays the image without distortion.
        ///     </para>
        ///     <para>
        ///         The matrix generated by <b>gluPerspective</b> is multipled by the current
        ///         matrix, just as if Gl.glMultMatrix* were called with the generated matrix.
        ///         To load the perspective matrix onto the current matrix stack instead,
        ///         precede the call to <b>gluPerspective</b> with a call to
        ///         <see cref="Gl.glLoadIdentity" />.
        ///     </para>
        ///     <para>
        ///         Given f defined as follows:
        ///     </para>
        ///     <para>
        ///         <c>f = cotangent(fovY / 2)</c>
        ///     </para>
        ///     <para>
        ///         The generated matrix is:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             (     f                                       )
        ///             |  ------        0       0            0       |
        ///             |  aspectRatio                                |
        ///             |                                             |
        ///             |                                             |
        ///             |     0          f       0            0       |
        ///             |                                             |
        ///             |                                             |
        ///             |                    zFar+zNear  2*zFar*zNear |
        ///             |     0          0   ----------  ------------ |
        ///             |                    zNear-zFar   zNear-zFar  |
        ///             |                                             |
        ///             |                                             |
        ///             |     0          0      -1            0       |
        ///             (                                             )
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Depth buffer precision is affected by the values specified for <i>zNear</i>
        ///         and <i>zFar</i>.  The greater the ratio of <i>zFar</i> to <i>zNear</i> is,
        ///         the less effective the depth buffer will be at distinguishing between
        ///         surfaces that are near each other.  If <c>r = zFar / zNear</c> roughly
        ///         <c>log2(r)</c> bits of depth buffer precision are lost.  Because r approaches
        ///         infinity as <i>zNear</i> approaches 0, <i>zNear</i> must never be set to 0.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glFrustum" />
        /// <seealso cref="Gl.glLoadIdentity" />
        /// <seealso cref="gluOrtho2D" />
        // void APIENTRY gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluPerspective(double fovY, double aspectRatio, double zNear, double zFar);
        #endregion gluPerspective(double fovY, double aspectRatio, double zNear, double zFar)

        #region gluPickMatrix(double x, double y, double width, double height, [In] int[] viewport)
        /// <summary>
        ///     Defines a picking region.
        /// </summary>
        /// <param name="x">
        ///     The center of a picking region in x axis window coordinates.
        /// </param>
        /// <param name="y">
        ///     The center of a picking region in y axis window coordinates.
        /// </param>
        /// <param name="width">
        ///     The width of the picking region in window coordinates.
        /// </param>
        /// <param name="height">
        ///     The height of the picking region in window coordinates.
        /// </param>
        /// <param name="viewport">
        ///     The current viewport (as from a <see cref="Gl.glGetIntegerv(int, IntPtr)" /> call).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluPickMatrix</b> creates a projection matrix that can be used to restrict
        ///         drawing to a small region of the viewport.  This is typically useful to
        ///         determine what objects are being drawn near the cursor.  Use
        ///         <b>gluPickMatrix</b> to restrict drawing to a small region around the cursor.
        ///         Then, enter selection mode (with <see cref="Gl.glRenderMode" />) and rerender
        ///         the scene.  All primitives that would have been drawn near the cursor are
        ///         identified and stored in the selection buffer.
        ///     </para>
        ///     <para>
        ///         The matrix created by <b>gluPickMatrix</b> is multiplied by the current
        ///         matrix just as if Gl.glMultMatrix* is called with the generated matrix.
        ///         To effectively use the generated pick matrix for picking, first call
        ///         <see cref="Gl.glLoadIdentity" /> to load an identity matrix onto the
        ///         perspective matrix stack.  Then call <b>gluPickMatrix</b>, and finally, call
        ///         a command (such as <see cref="gluPerspective" />) to multiply the perspective
        ///         matrix by the pick matrix.
        ///     </para>
        ///     <para>
        ///         When using <b>gluPickMatrix</b> to pick NURBS, be careful to turn off the
        ///         NURBS property <see cref="GLU_AUTO_LOAD_MATRIX" />.  If
        ///         <see cref="GLU_AUTO_LOAD_MATRIX" /> is not turned off, then any NURBS
        ///         surface rendered is subdivided differently with the pick matrix than the way
        ///         it was subdivided without the pick matrix.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         When rendering a scene as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Gl.glMatrixMode(Gl.GL_PROJECTION);
        ///             Gl.glLoadIdentity();
        ///             Glu.gluPerspective(. . .);
        ///             Gl.glMatrixMode(Gl.GL_MODELVIEW);
        ///             // Draw the scene
        ///         </code>
        ///     </para>
        ///     <para>
        ///         The following code selects a portion of the viewport:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Gl.glMatrixMode(Gl.GL_PROJECTION);
        ///             Gl.glLoadIdentity();
        ///             Glu.gluPickMatrix(x, y, width, height, viewport);
        ///             Glu.gluPerspective(. . .);
        ///             Gl.glMatrixMode(Gl.GL_MODELVIEW);
        ///             // Draw the scene
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glLoadIdentity" />
        /// <seealso cref="Gl.glRenderMode" />
        /// <seealso cref="gluPerspective" />
        // void APIENTRY gluPickMatrix(GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4]);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluPickMatrix(double x, double y, double width, double height, [In] int[] viewport);
        #endregion gluPickMatrix(double x, double y, double width, double height, [In] int[] viewport)

        #region int gluProject(double objX, double objY, double objZ, [In] double[] modelMatrix, [In] double[] projectionMatrix, [In] int[] viewport, out double winX, out double winY, out double winZ)
        /// <summary>
        ///     Maps object coordinates to window coordinates.
        /// </summary>
        /// <param name="objX">
        ///     The object's x axis coordinate.
        /// </param>
        /// <param name="objY">
        ///     The object's y axis coordinate.
        /// </param>
        /// <param name="objZ">
        ///     The object's z axis coordinate.
        /// </param>
        /// <param name="modelMatrix">
        ///     The current modelview matrix (as from a <see cref="Gl.glGetDoublev(int, IntPtr)" /> call).
        /// </param>
        /// <param name="projectionMatrix">
        ///     The current projection matrix (as from a <see cref="Gl.glGetDoublev(int, IntPtr)" />
        ///     call).
        /// </param>
        /// <param name="viewport">
        ///     The current viewport (as from a <see cref="Gl.glGetIntegerv(int, IntPtr)" /> call).
        /// </param>
        /// <param name="winX">
        ///     The computed window's x axis coordinate.
        /// </param>
        /// <param name="winY">
        ///     The computed window's y axis coordinate.
        /// </param>
        /// <param name="winZ">
        ///     The computed window's z axis coordinate.
        /// </param>
        /// <returns>
        ///     Returns <see cref="Gl.GL_TRUE" /> indicates success, a return value of
        ///     <see cref="Gl.GL_FALSE" /> indicates failure.
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluProject</b> transforms the specified object coordinates into window
        ///         coordinates using <i>modelMatrix</i>, <i>projectionMatrix</i>, and
        ///         <i>viewport</i>.  The result is stored in <i>winX</i>, <i>winY</i>, and
        ///         <i>winZ</i>.  A return value of <see cref="Gl.GL_TRUE" /> indicates success,
        ///         a return value of <see cref="Gl.GL_FALSE" /> indicates failure.
        ///     </para>
        ///     <para>
        ///         To compute the coordinates, let <c>v = (objX, objY, objZ, 1.0)</c>
        ///         represented as a matrix with 4 rows and 1 column.  Then <b>gluProject</b>
        ///         computes v' as follows:
        ///     </para>
        ///     <para>
        ///         <c>v' = P x M x v</c>
        ///     </para>
        ///     <para>
        ///         Where P is the current projection matrix <i>projectionMatrix</i>, M is the
        ///         current modelview matrix <i>modelMatrix</i> (both represented as 4x4 matrices
        ///         in column-major order) and 'x' represents matrix multiplication.
        ///     </para>
        ///     <para>
        ///         The window coordinates are then computed as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             winX = view(0) + view(2) * (v'(0) + 1) / 2
        ///             winY = view(1) + view(3) * (v'(1) + 1) / 2
        ///             winZ = (v'(2) + 1) / 2
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glGetDoublev(int, IntPtr)" />
        /// <seealso cref="Gl.glGetIntegerv(int, IntPtr)" />
        /// <seealso cref="gluUnProject" />
        // int APIENTRY gluProject(GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluProject(double objX, double objY, double objZ, [In] double[] modelMatrix, [In] double[] projectionMatrix, [In] int[] viewport, out double winX, out double winY, out double winZ);
        #endregion int gluProject(double objX, double objY, double objZ, [In] double[] modelMatrix, [In] double[] projectionMatrix, [In] int[] viewport, out double winX, out double winY, out double winZ)

        #region gluPwlCurve([In] GLUnurbs nurb, int count, [In] float[] data, int stride, int type)
        /// <summary>
        ///     Describes a piecewise linear NURBS trimming curve.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="count">
        ///     The number of points on the curve.
        /// </param>
        /// <param name="data">
        ///     An array containing the curve points.
        /// </param>
        /// <param name="stride">
        ///     The offset (a number of single-precision floating-point values) between
        ///     points on the curve.
        /// </param>
        /// <param name="type">
        ///     The type of curve.  Must be either <see cref="GLU_MAP1_TRIM_2" /> or
        ///     <see cref="GLU_MAP1_TRIM_3" />.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluPwlCurve</b> describes a piecewise linear trimming curve for a NURBS
        ///         surface.  A piecewise linear curve consists of a list of coordinates of
        ///         points in the parameter space for the NURBS surface to be trimmed.  These
        ///         points are connected with line segments to form a curve.  If the curve is an
        ///         approximation to a curve that is not piecewise linear, the points should be
        ///         close enough in parameter space that the resulting path appears curved at the
        ///         resolution used in the application.
        ///     </para>
        ///     <para>
        ///         If type is <see cref="GLU_MAP1_TRIM_2" />, then it describes a curve in
        ///         two-dimensional (u and v) parameter space.  If it is
        ///         <see cref="GLU_MAP1_TRIM_3" />, then it describes a curve in two-dimensional
        ///         homogeneous (u, v, and w) parameter space.  See the
        ///         <see cref="gluBeginTrim" /> reference page for more information about
        ///         trimming curves.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         To describe a trim curve that closely follows the contours of a NURBS
        ///         surface, call <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluBeginCurve" />
        /// <seealso cref="gluBeginTrim" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />
        // void APIENTRY gluPwlCurve(GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluPwlCurve([In] GLUnurbs nurb, int count, [In] float[] data, int stride, int type);
        #endregion gluPwlCurve([In] GLUnurbs nurb, int count, [In] float[] data, int stride, int type)

        #region gluPwlCurve([In] GLUnurbs nurb, int count, [In] float[ , ] data, int stride, int type)
        /// <summary>
        ///     Describes a piecewise linear NURBS trimming curve.
        /// </summary>
        /// <param name="nurb">
        ///     The NURBS object (created with <see cref="gluNewNurbsRenderer" />).
        /// </param>
        /// <param name="count">
        ///     The number of points on the curve.
        /// </param>
        /// <param name="data">
        ///     An array containing the curve points.
        /// </param>
        /// <param name="stride">
        ///     The offset (a number of single-precision floating-point values) between
        ///     points on the curve.
        /// </param>
        /// <param name="type">
        ///     The type of curve.  Must be either <see cref="GLU_MAP1_TRIM_2" /> or
        ///     <see cref="GLU_MAP1_TRIM_3" />.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluPwlCurve</b> describes a piecewise linear trimming curve for a NURBS
        ///         surface.  A piecewise linear curve consists of a list of coordinates of
        ///         points in the parameter space for the NURBS surface to be trimmed.  These
        ///         points are connected with line segments to form a curve.  If the curve is an
        ///         approximation to a curve that is not piecewise linear, the points should be
        ///         close enough in parameter space that the resulting path appears curved at the
        ///         resolution used in the application.
        ///     </para>
        ///     <para>
        ///         If type is <see cref="GLU_MAP1_TRIM_2" />, then it describes a curve in
        ///         two-dimensional (u and v) parameter space.  If it is
        ///         <see cref="GLU_MAP1_TRIM_3" />, then it describes a curve in two-dimensional
        ///         homogeneous (u, v, and w) parameter space.  See the
        ///         <see cref="gluBeginTrim" /> reference page for more information about
        ///         trimming curves.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         To describe a trim curve that closely follows the contours of a NURBS
        ///         surface, call <see cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluBeginCurve" />
        /// <seealso cref="gluBeginTrim" />
        /// <seealso cref="gluNewNurbsRenderer" />
        /// <seealso cref="gluNurbsCurve(Tao.OpenGl.Glu.GLUnurbs, int, float[], int, float[], int, int)" />
        // void APIENTRY gluPwlCurve(GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluPwlCurve([In] GLUnurbs nurb, int count, [In] float[,] data, int stride, int type);
        #endregion gluPwlCurve([In] GLUnurbs nurb, int count, [In] float[ , ] data, int stride, int type)

        #region gluQuadricCallback([In] GLUquadric quad, int which, [In] QuadricErrorCallback func)
        /// <summary>
        ///     Defines a callback for a quadric object.
        /// </summary>
        /// <param name="quad">
        ///     The quadric object (created with <see cref="gluNewQuadric" />).
        /// </param>
        /// <param name="which">
        ///     The callback being defined.  The only valid value is
        ///     <see cref="GLU_ERROR" />.
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluQuadricCallback</b> is used to define a new callback to be used by a
        ///         quadrics object.  If the specified callback is already defined, then it is
        ///         replaced.  If <i>func</i> is <c>null</c>, then any existing callback is
        ///         erased.
        ///     </para>
        ///     <para>
        ///         The one legal callback is <see cref="GLU_ERROR" />:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_ERROR" /></term>
        ///                 <description>
        ///                     The function is called when an error is encountered.  Its single
        ///                     argument is of type <see cref="int" />, and it indicates the
        ///                     specific error that occurred.  Character strings describing these
        ///                     errors can be retrieved with the <see cref="gluErrorString" />
        ///                     call.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </remarks>
        /// <seealso cref="QuadricErrorCallback" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewQuadric" />
        // void APIENTRY gluQuadricCallback(GLUquadric *qobj, GLenum which, void (CALLBACK* fn)());
        public static void gluQuadricCallback([In] GLUquadric quad, int which, [In] QuadricErrorCallback func)
        {
            quadricErrorCallback = func;
            __gluQuadricCallback(quad, which, quadricErrorCallback);

        }
        #endregion gluQuadricCallback([In] GLUquadric quad, int which, [In] QuadricErrorCallback func)

        #region gluQuadricDrawStyle([In] GLUquadric quad, int drawStyle)
        /// <summary>
        ///     Specifies the draw style desired for quadrics.
        /// </summary>
        /// <param name="quad">
        ///     The quadric object (created with <see cref="gluNewQuadric" />).
        /// </param>
        /// <param name="drawStyle">
        ///     <para>
        ///         The desired draw style.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_FILL" /></term>
        ///                 <description>
        ///                     Quadrics are rendered with polygon primitives.  The polygons are
        ///                     drawn in a counterclockwise fashion with respect to their normals
        ///                     (as defined with <see cref="gluQuadricOrientation" />).
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_LINE" /></term>
        ///                 <description>
        ///                     Quadrics are rendered as a set of lines.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_SILHOUETTE" /></term>
        ///                 <description>
        ///                     Quadrics are rendered as a set of lines, except that edges
        ///                     separating coplanar faces will not be drawn.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_POINT" /></term>
        ///                 <description>
        ///                     Quadrics are rendered as a set of points.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <remarks>
        ///     <b>gluQuadricDrawStyle</b> specifies the draw style for quadrics rendered
        ///     with <i>quad</i>.
        /// </remarks>
        /// <seealso cref="gluNewQuadric" />
        /// <seealso cref="gluQuadricNormals" />
        /// <seealso cref="gluQuadricOrientation" />
        /// <seealso cref="gluQuadricTexture" />
        // void APIENTRY gluQuadricDrawStyle(GLUquadric *quadObject, GLenum drawStyle);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluQuadricDrawStyle([In] GLUquadric quad, int drawStyle);
        #endregion gluQuadricDrawStyle([In] GLUquadric quad, int drawStyle)

        #region gluQuadricNormals([In] GLUquadric quad, int normal)
        /// <summary>
        ///     Specifies what kind of normals are to be used for quadrics.
        /// </summary>
        /// <param name="quad">
        ///     The quadric object (created with <see cref="gluNewQuadric" />).
        /// </param>
        /// <param name="normal">
        ///     <para>
        ///         The desired type of normals.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_NONE" /></term>
        ///                 <description>
        ///                     No normals are generated.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_FLAT" /></term>
        ///                 <description>
        ///                     One normal is generated for every facet of a quadric.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_SMOOTH" /></term>
        ///                 <description>
        ///                     One normal is generated for every vertex of a quadric.  This is
        ///                     the default value.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <remarks>
        ///     <b>gluQuadricNormals</b> specifies what kind of normals are desired for
        ///     quadrics rendered with <i>quad</i>.
        /// </remarks>
        /// <seealso cref="gluNewQuadric" />
        /// <seealso cref="gluQuadricDrawStyle" />
        /// <seealso cref="gluQuadricOrientation" />
        /// <seealso cref="gluQuadricTexture" />
        // void APIENTRY gluQuadricNormals(GLUquadric *quadObject, GLenum normals);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluQuadricNormals([In] GLUquadric quad, int normal);
        #endregion gluQuadricNormals([In] GLUquadric quad, int normal)

        #region gluQuadricOrientation([In] GLUquadric quad, int orientation)
        /// <summary>
        ///     Specifies inside or outside orientation for quadrics.
        /// </summary>
        /// <param name="quad">
        ///     The quadric object (created with <see cref="gluNewQuadric" />).
        /// </param>
        /// <param name="orientation">
        ///     <para>
        ///         The desired orientation.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_OUTSIDE" /></term>
        ///                 <description>
        ///                     Draw quadrics with normals pointing outward.  This is the default
        ///                     value.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_INSIDE" /></term>
        ///                 <description>
        ///                     Draw quadrics with normals pointing inward.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluQuadricOrientation</b> specifies what kind of orientation is desired
        ///         for quadrics rendered with <i>quad</i>.
        ///     </para>
        ///     <para>
        ///         The interpretation of outward and inward depends on the quadric being drawn.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewQuadric" />
        /// <seealso cref="gluQuadricDrawStyle" />
        /// <seealso cref="gluQuadricNormals" />
        /// <seealso cref="gluQuadricTexture" />
        // void APIENTRY gluQuadricOrientation(GLUquadric *quadObject, GLenum orientation);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluQuadricOrientation([In] GLUquadric quad, int orientation);
        #endregion gluQuadricOrientation([In] GLUquadric quad, int orientation)

        #region gluQuadricTexture([In] GLUquadric quad, int texture)
        /// <summary>
        ///     Specifies whether quadrics are to be textured.
        /// </summary>
        /// <param name="quad">
        ///     The quadric object (created with <see cref="gluNewQuadric" />).
        /// </param>
        /// <param name="texture">
        ///     <para>
        ///         A flag indicating whether texture coordinates are to be generated.  The
        ///         following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="Gl.GL_TRUE" /></term>
        ///                 <description>
        ///                     Generate texture coordinates.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="Gl.GL_FALSE" /></term>
        ///                 <description>
        ///                     Do not generate texture coordinates.  This is the default value.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluQuadricTexture</b> specifies if texture coordinates should be generated
        ///         for quadrics rendered with <i>quad</i>.
        ///     </para>
        ///     <para>
        ///         The manner in which texture coordinates are generated depends upon the
        ///         specific quadric rendered.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewQuadric" />
        /// <seealso cref="gluQuadricDrawStyle" />
        /// <seealso cref="gluQuadricNormals" />
        /// <seealso cref="gluQuadricOrientation" />
        // void APIENTRY gluQuadricTexture(GLUquadric *quadObject, GLboolean textureCoords);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluQuadricTexture([In] GLUquadric quad, int texture);
        #endregion gluQuadricTexture([In] GLUquadric quad, int texture)

        #region int gluScaleImage(int format, int widthIn, int heightIn, int typeIn, [In] IntPtr dataIn, int widthOut, int heightOut, int typeOut, [Out] IntPtr dataOut)
        /// <summary>
        ///     Scales an image to an arbitrary size.
        /// </summary>
        /// <param name="format">
        ///     The format of the pixel data.  The following symbolic values are valid:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_STENCIL_INDEX" />,
        ///     <see cref="Gl.GL_DEPTH_COMPONENT" />, <see cref="Gl.GL_RED" />,
        ///     <see cref="Gl.GL_GREEN" />, <see cref="Gl.GL_BLUE" />,
        ///     <see cref="Gl.GL_ALPHA" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_BGR_EXT" />,
        ///     <see cref="Gl.GL_BGRA_EXT" />, <see cref="Gl.GL_LUMINANCE" />, and
        ///     <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="widthIn">
        ///     The width of the source image that is scaled.
        /// </param>
        /// <param name="heightIn">
        ///     The height of the source image that is scaled.
        /// </param>
        /// <param name="typeIn">
        ///     The data type for <i>dataIn</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="dataIn">
        ///     A pointer to the source image.
        /// </param>
        /// <param name="widthOut">
        ///     The width of the destination image.
        /// </param>
        /// <param name="heightOut">
        ///     The height of the destination image.
        /// </param>
        /// <param name="typeOut">
        ///     The data type for <i>dataOut</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="dataOut">
        ///     A pointer to the destination image.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluScaleImage</b> scales a pixel image using the appropriate pixel store
        ///         modes to unpack data from the source image and pack data into the
        ///         destination image.
        ///     </para>
        ///     <para>
        ///         When shrinking an image, <b>gluScaleImage</b> uses a box filter to sample the
        ///         source image and create pixels for the destination image.  When magnifying an
        ///         image, the pixels from the source image are linearly interpolated to create
        ///         the destination image.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glReadPixels(int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>format</i>, <i>typeIn</i>, and
        ///         <i>typeOut</i> parameters.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>widthIn</i>,
        ///         <i>heightIn</i>, <i>widthOut</i>, or <i>heightOut</i> is negative.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i>, <i>typeIn</i>,
        ///         or <i>typeOut</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>typeIn</i> or
        ///         <i>typeOut</i> is <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>typeIn</i> or
        ///         <i>typeOut</i> is <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>typeIn</i> or
        ///         <i>typeOut</i> is <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>typeIn</i> or
        ///         <i>typeOut</i> is <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>typeIn</i> or
        ///         <i>typeOut</i> is <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>typeIn</i> or
        ///         <i>typeOut</i> is <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glReadPixels(int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // int APIENTRY gluScaleImage(GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluScaleImage(int format, int widthIn, int heightIn, int typeIn, [In] IntPtr dataIn, int widthOut, int heightOut, int typeOut, [Out] IntPtr dataOut);
        #endregion int gluScaleImage(int format, int widthIn, int heightIn, int typeIn, [In] IntPtr dataIn, int widthOut, int heightOut, int typeOut, [Out] IntPtr dataOut)

        #region int gluScaleImage(int format, int widthIn, int heightIn, int typeIn, [In] byte[] dataIn, int widthOut, int heightOut, int typeOut, [Out] byte[] dataOut)
        /// <summary>
        ///     Scales an image to an arbitrary size.
        /// </summary>
        /// <param name="format">
        ///     The format of the pixel data.  The following symbolic values are valid:
        ///     <see cref="Gl.GL_COLOR_INDEX" />, <see cref="Gl.GL_STENCIL_INDEX" />,
        ///     <see cref="Gl.GL_DEPTH_COMPONENT" />, <see cref="Gl.GL_RED" />,
        ///     <see cref="Gl.GL_GREEN" />, <see cref="Gl.GL_BLUE" />,
        ///     <see cref="Gl.GL_ALPHA" />, <see cref="Gl.GL_RGB" />,
        ///     <see cref="Gl.GL_RGBA" />, <see cref="Gl.GL_BGR_EXT" />,
        ///     <see cref="Gl.GL_BGRA_EXT" />, <see cref="Gl.GL_LUMINANCE" />, and
        ///     <see cref="Gl.GL_LUMINANCE_ALPHA" />.
        /// </param>
        /// <param name="widthIn">
        ///     The width of the source image that is scaled.
        /// </param>
        /// <param name="heightIn">
        ///     The height of the source image that is scaled.
        /// </param>
        /// <param name="typeIn">
        ///     The data type for <i>dataIn</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="dataIn">
        ///     A pointer to the source image.
        /// </param>
        /// <param name="widthOut">
        ///     The width of the destination image.
        /// </param>
        /// <param name="heightOut">
        ///     The height of the destination image.
        /// </param>
        /// <param name="typeOut">
        ///     The data type for <i>dataOut</i>.  Must be one of
        ///     <see cref="Gl.GL_UNSIGNED_BYTE" />, <see cref="Gl.GL_BYTE" />,
        ///     <see cref="Gl.GL_BITMAP" />, <see cref="Gl.GL_UNSIGNED_SHORT" />,
        ///     <see cref="Gl.GL_SHORT" />, <see cref="Gl.GL_UNSIGNED_INT" />,
        ///     <see cref="Gl.GL_INT" />, <see cref="Gl.GL_FLOAT" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///     <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///     <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///     <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, or
        ///     <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" />.
        /// </param>
        /// <param name="dataOut">
        ///     A pointer to the destination image.
        /// </param>
        /// <returns>
        ///     A return value of zero indicates success, otherwise a GLU error code is
        ///     returned (see <see cref="gluErrorString" />).
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluScaleImage</b> scales a pixel image using the appropriate pixel store
        ///         modes to unpack data from the source image and pack data into the
        ///         destination image.
        ///     </para>
        ///     <para>
        ///         When shrinking an image, <b>gluScaleImage</b> uses a box filter to sample the
        ///         source image and create pixels for the destination image.  When magnifying an
        ///         image, the pixels from the source image are linearly interpolated to create
        ///         the destination image.
        ///     </para>
        ///     <para>
        ///         A return value of zero indicates success, otherwise a GLU error code is
        ///         returned (see <see cref="gluErrorString" />).
        ///     </para>
        ///     <para>
        ///         See the <see cref="Gl.glReadPixels(int, int, int, int, int, int, object)" /> reference page for a description of
        ///         the acceptable values for the <i>format</i>, <i>typeIn</i>, and
        ///         <i>typeOut</i> parameters.
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         Formats <see cref="Gl.GL_BGR" />, and <see cref="Gl.GL_BGRA" />, and types
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" />,
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" />,
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" />,
        ///         <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" />, and
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> are only available if the GL
        ///         version is 1.2 or greater.
        ///     </para>
        ///     <para>
        ///         <b>ERRORS</b>
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_VALUE" /> is returned if <i>widthIn</i>,
        ///         <i>heightIn</i>, <i>widthOut</i>, or <i>heightOut</i> is negative.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_ENUM" /> is returned if <i>format</i>, <i>typeIn</i>,
        ///         or <i>typeOut</i> is not legal.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>typeIn</i> or
        ///         <i>typeOut</i> is <see cref="Gl.GL_UNSIGNED_BYTE_3_3_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_BYTE_2_3_3_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>typeIn</i> or
        ///         <i>typeOut</i> is <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_5_6_5_REV" /> and <i>format</i> is not
        ///         <see cref="Gl.GL_RGB" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>typeIn</i> or
        ///         <i>typeOut</i> is <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_4_4_4_4_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>typeIn</i> or
        ///         <i>typeOut</i> is <see cref="Gl.GL_UNSIGNED_SHORT_5_5_5_1" /> or
        ///         <see cref="Gl.GL_UNSIGNED_SHORT_1_5_5_5_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>typeIn</i> or
        ///         <i>typeOut</i> is <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_8_8_8_8_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        ///     <para>
        ///         <see cref="GLU_INVALID_OPERATION" /> is returned if <i>typeIn</i> or
        ///         <i>typeOut</i> is <see cref="Gl.GL_UNSIGNED_INT_10_10_10_2" /> or
        ///         <see cref="Gl.GL_UNSIGNED_INT_2_10_10_10_REV" /> and <i>format</i> is neither
        ///         <see cref="Gl.GL_RGBA" /> nor <see cref="Gl.GL_BGRA" />.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glDrawPixels(int, int, int, int, object)" />
        /// <seealso cref="Gl.glReadPixels(int, int, int, int, int, int, object)" />
        /// <seealso cref="gluBuild1DMipmaps(int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild2DMipmaps(int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluBuild3DMipmaps(int, int, int, int, int, int, int, byte[])" />
        /// <seealso cref="gluErrorString" />
        // int APIENTRY gluScaleImage(GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluScaleImage(int format, int widthIn, int heightIn, int typeIn, [In] byte[] dataIn, int widthOut, int heightOut, int typeOut, [Out] byte[] dataOut);
        #endregion int gluScaleImage(int format, int widthIn, int heightIn, int typeIn, [In] byte[] dataIn, int widthOut, int heightOut, int typeOut, [Out] byte[] dataOut)

        #region gluSphere([In] GLUquadric quad, double radius, int slices, int stacks)
        /// <summary>
        ///     Draws a sphere.
        /// </summary>
        /// <param name="quad">
        ///     The quadric object (created with <see cref="gluNewQuadric" />).
        /// </param>
        /// <param name="radius">
        ///     The radius of the sphere.
        /// </param>
        /// <param name="slices">
        ///     The number of subdivisions around the z-axis (similar to lines of longitude.
        /// </param>
        /// <param name="stacks">
        ///     The number of subdivisions along the z-axis (similar to lines of latitude).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluSphere</b> draws a sphere of the given radius centered around the
        ///         origin.  The sphere is subdivided around the z axis into slices and along the
        ///         z axis into stacks (similar to lines of longitude and latitude).
        ///     </para>
        ///     <para>
        ///         If the orientation is set to <see cref="GLU_OUTSIDE" /> (with
        ///         <see cref="gluQuadricOrientation" />), then any normals generated point away
        ///         from the center of the sphere.  Otherwise, they point toward the center of
        ///         the sphere.
        ///     </para>
        ///     <para>
        ///         If texturing is turned on (with <see cref="gluQuadricTexture" />), then
        ///         texture coordinates are generated so that t ranges from 0.0 at z = -radius
        ///         to 1.0 at z = radius (t increases linearly along longitudinal lines), and
        ///         s ranges from 0.0 at the +y axis, to 0.25 at the +x axis, to 0.5 at the -y
        ///         axis, to 0.75 at the -x axis, and back to 1.0 at the +y axis.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluCylinder" />
        /// <seealso cref="gluDisk" />
        /// <seealso cref="gluNewQuadric" />
        /// <seealso cref="gluPartialDisk" />
        /// <seealso cref="gluQuadricOrientation" />
        /// <seealso cref="gluQuadricTexture" />
        // void APIENTRY gluSphere(GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluSphere([In] GLUquadric quad, double radius, int slices, int stacks);
        #endregion gluSphere([In] GLUquadric quad, double radius, int slices, int stacks)

        #region gluTessBeginContour([In] GLUtesselator tess)
        /// <summary>
        ///     Delimits a contour description.
        /// </summary>
        /// <param name="tess">
        ///         The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <remarks>
        ///     <b>gluTessBeginContour</b> and <see cref="gluTessEndContour" /> delimit the
        ///     definition of a polygon contour.  Within each
        ///     <b>gluTessBeginContour</b>/<see cref="gluTessEndContour" /> pair, there can
        ///     be zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.  The vertices specify
        ///     a closed contour (the last vertex of each contour is automatically linked to
        ///     the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" /> reference page for more
        ///     details.  <b>gluTessBeginContour</b> can only be called between
        ///     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> and <see cref="gluTessEndPolygon" />.
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndContour" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginContour(GLUtesselator *tess);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginContour([In] GLUtesselator tess);
        #endregion gluTessBeginContour([In] GLUtesselator tess)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] byte[] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] byte[] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] byte[] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] byte[ , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] byte[,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] byte[ , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] byte[ , , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] byte[, ,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] byte[ , , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] double[] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] double[] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] double[] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] double[ , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] double[,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] double[ , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] double[ , , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] double[, ,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] double[ , , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] short[] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] short[] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] short[] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] short[ , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] short[,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] short[ , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] short[ , , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] short[, ,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] short[ , , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] int[] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] int[] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] int[] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] int[ , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] int[,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] int[ , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] int[ , , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] int[, ,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] int[ , , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] float[] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] float[] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] float[] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] float[ , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] float[,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] float[ , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] float[ , , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] float[, ,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] float[ , , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] ushort[] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] ushort[] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] ushort[] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] ushort[ , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] ushort[,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] ushort[ , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] ushort[ , , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] ushort[, ,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] ushort[ , , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] uint[] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] uint[] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] uint[] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] uint[ , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] uint[,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] uint[ , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] uint[ , , ] data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] uint[, ,] data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] uint[ , , ] data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] IntPtr data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] IntPtr data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] IntPtr data)

        #region gluTessBeginPolygon([In] GLUtesselator tess, [In] void *data)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="data">
        ///     A pointer to a programmer definedpolygon data structure.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessBeginPolygon</b> and <see cref="gluTessEndPolygon" /> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <b>gluTessBeginPolygon</b>/<see cref="gluTessEndPolygon" /> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         <i>data</i> is a pointer to a user-defined data structure.  If the
        ///         appropriate callback(s) are specified (see <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />),
        ///         then this pointer is returned to the callback function(s).  Thus, it is a
        ///         convenient way to store per-polygon information.
        ///     </para>
        ///     <para>
        ///         Once <see cref="gluTessEndPolygon" /> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public unsafe static extern void gluTessBeginPolygon([In] GLUtesselator tess, [In] void* data);
        #endregion gluTessBeginPolygon([In] GLUtesselator tess, [In] void *data)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessBeginCallback func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessBeginCallback func)
        {
            tessBeginCallback = func;
            __gluTessCallback(tess, which, tessBeginCallback);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessBeginCallback func)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessBeginDataCallback func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessBeginDataCallback func)
        {
            tessBeginDataCallback = func;
            __gluTessCallback(tess, which, tessBeginDataCallback);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessBeginDataCallback func)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineCallback func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineCallback func)
        {
            tessCombineCallback = func;
            __gluTessCallback(tess, which, tessCombineCallback);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineCallback func)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineCallback1 func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineCallback1 func)
        {
            tessCombineCallback1 = func;
            __gluTessCallback(tess, which, tessCombineCallback1);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineCallback1 func)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineDataCallback func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineDataCallback func)
        {
            tessCombineDataCallback = func;
            __gluTessCallback(tess, which, tessCombineDataCallback);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessCombineDataCallback func)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessEdgeFlagCallback func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessEdgeFlagCallback func)
        {
            tessEdgeFlagCallback = func;
            __gluTessCallback(tess, which, tessEdgeFlagCallback);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessEdgeFlagCallback func)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessEdgeFlagDataCallback func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessEdgeFlagDataCallback func)
        {
            tessEdgeFlagDataCallback = func;
            __gluTessCallback(tess, which, tessEdgeFlagDataCallback);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessEdgeFlagDataCallback func)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessEndCallback func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessEndCallback func)
        {
            tessEndCallback = func;
            __gluTessCallback(tess, which, tessEndCallback);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessEndCallback func)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessEndDataCallback func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessEndDataCallback func)
        {
            tessEndDataCallback = func;
            __gluTessCallback(tess, which, tessEndDataCallback);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessEndDataCallback func)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessErrorCallback func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessErrorCallback func)
        {
            tessErrorCallback = func;
            __gluTessCallback(tess, which, tessErrorCallback);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessErrorCallback func)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessErrorDataCallback func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessErrorDataCallback func)
        {
            tessErrorDataCallback = func;
            __gluTessCallback(tess, which, tessErrorDataCallback);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessErrorDataCallback func)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexCallback func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexCallback func)
        {
            tessVertexCallback = func;
            __gluTessCallback(tess, which, tessVertexCallback);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexCallback func)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexCallback1 func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexCallback1 func)
        {
            tessVertexCallback1 = func;
            __gluTessCallback(tess, which, tessVertexCallback1);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexCallback1 func)

        #region gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexDataCallback func)
        /// <summary>
        ///     Defines a callback for a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The callback being defined.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN" /></term>
        ///                 <description>
        ///                     The begin callback is invoked like <see cref="Gl.glBegin" /> to
        ///                     indicate the start of a (triangle) primitive.  The function takes
        ///                     a single argument of type <see cref="int" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_FALSE" />, then the argument is set to either
        ///                     <see cref="Gl.GL_TRIANGLE_FAN" />,
        ///                     <see cref="Gl.GL_TRIANGLE_STRIP" />, or
        ///                     <see cref="Gl.GL_TRIANGLES" />.  If the
        ///                     <see cref="GLU_TESS_BOUNDARY_ONLY" /> property is set to
        ///                     <see cref="Gl.GL_TRUE" />, then the argument will be set to
        ///                     <see cref="Gl.GL_LINE_LOOP" />.  The delegate prototype for this
        ///                     callback is <see cref="TessBeginCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BEGIN_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_BEGIN" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessBeginDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The combine callback is called to create a new vertex when
        ///                         the tessellation detects an intersection, or wishes to merge
        ///                         features.  The function takes four arguments: an array of
        ///                         three elements each of type <see cref="double" />, an
        ///                         array of four pointers, an array of four elements each of
        ///                         type <see cref="float" />, and a pointer to a pointer.  The
        ///                         delegate prototype for this callback is
        ///                         <see cref="TessCombineCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The vertex is defined as a linear combination of up to four
        ///                         existing vertices, stored in <i>vertexData</i>.  The
        ///                         coefficients of the linear combination are given by
        ///                         <i>weight</i>; these weights always add up to 1.  All
        ///                         vertex pointers are valid even when some of the weights are
        ///                         0.  <i>coordinates</i> gives the location of the new vertex.
        ///                     </para>
        ///                     <para>
        ///                         The user must allocate another vertex, interpolate parameters
        ///                         using <i>vertexData</i> and <i>weight</i>, and return the new
        ///                         vertex pointer in <i>outData</i>.  This handle is supplied
        ///                         during rendering callbacks.  The user is responsible for
        ///                         freeing the memory some time after
        ///                         <see cref="gluTessEndPolygon" /> is called.
        ///                     </para>
        ///                     <para>
        ///                         For example, if the polygon lies in an arbitrary plane in
        ///                         3-space, and a color is associated with each vertex, the
        ///                         <b>GLU_TESS_COMBINE</b> callback might look like this:
        ///                     </para>
        ///                     <para>
        ///                         <code>
        ///                             void myCombine(GLdouble coords[3], VERTEX *d[4], GLfloat w[4], VERTEX **dataOut) { 
        ///                                 VERTEX *newVertex = new_vertex(); 
        ///                                 newVertex->x = coords[0]; 
        ///                                 newVertex->y = coords[1]; 
        ///                                 newVertex->z = coords[2]; 
        ///                                 newVertex->r = w[0]*d[0]->r + w[1]*d[1]->r + w[2]*d[2]->r + 
        ///                                 w[3]*d[3]->r; 
        ///                                 newVertex->g = w[0]*d[0]->g + w[1]*d[1]->g + w[2]*d[2]->g + 
        ///                                 w[3]*d[3]->g; 
        ///                                 newVertex->b = w[0]*d[0]->b + w[1]*d[1]->b + w[2]*d[2]->b + 
        ///                                 w[3]*d[3]->b; 
        ///                                 newVertex->a = w[0]*d[0]->a + w[1]*d[1]->a + w[2]*d[2]->a + 
        ///                                 w[3]*d[3]->a; 
        ///                                 *dataOut = newVertex; 
        ///                             } 
        ///                         </code>
        ///                     </para>
        ///                     <para>
        ///                         If the tessellation detects an intersection, then the
        ///                         <b>GLU_TESS_COMBINE</b> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback (see below)
        ///                         must be defined, and it must write a non-NULL pointer into
        ///                         <i>outData</i>.  Otherwise the
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error occurs,
        ///                         and no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_COMBINE_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_COMBINE" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessCombineDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The edge flag callback is similar to
        ///                         <see cref="Gl.glEdgeFlag" />.  The function takes a single
        ///                         boolean flag that indicates which edges lie on the polygon
        ///                         boundary.  If the flag is <see cref="Gl.GL_TRUE" />, then
        ///                         each vertex that follows begins an edge that lies on the
        ///                         polygon boundary, that is, an edge that separates an interior
        ///                         region from an exterior one.  If the flag is
        ///                         <see cref="Gl.GL_FALSE" />, then each vertex that follows
        ///                         begins an edge that lies in the polygon interior.  The edge
        ///                         flag callback (if defined) is invoked before the first
        ///                         vertex callback.
        ///                     </para>
        ///                     <para>
        ///                         Since triangle fans and triangle strips do not support edge
        ///                         flags, the begin callback is not called with
        ///                         <see cref="Gl.GL_TRIANGLE_FAN" /> or
        ///                         <see cref="Gl.GL_TRIANGLE_STRIP" /> if a non-NULL edge flag
        ///                         callback is provided.  (If the callback is initialized to
        ///                         <c>null</c>, there is no impact on performance).  Instead,
        ///                         the fans and strips are converted to independent triangles.
        ///                         The delegate prototype for this callback is
        ///                         <see cref="TessEdgeFlagCallback" />.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_EDGE_FLAG_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_EDGE_FLAG" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEdgeFlagDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END" /></term>
        ///                 <description>
        ///                     The end callback serves the same purpose as
        ///                     <see cref="Gl.glEnd" />.  It indicates the end of a primitive and
        ///                     it takes no arguments.  The delegate prototype for this callback
        ///                     is <see cref="TessEndCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_END_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_END" /> callback except that
        ///                     it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessEndDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR" /></term>
        ///                 <description>
        ///                     <para>
        ///                         The error callback is called when an error is encountered.
        ///                         The one argument is of type <see cref="int" />; it
        ///                         indicates the specific error that occurred and will be set to
        ///                         one of <see cref="GLU_TESS_MISSING_BEGIN_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_END_POLYGON" />,
        ///                         <see cref="GLU_TESS_MISSING_BEGIN_CONTOUR" />,
        ///                         <see cref="GLU_TESS_MISSING_END_CONTOUR" />,
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" />,
        ///                         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> or
        ///                         <see cref="GLU_OUT_OF_MEMORY" />.  Character strings
        ///                         describing these errors can be retrieved with the
        ///                         <see cref="gluErrorString" /> call.  The delegate prototype
        ///                         for this callback is <see cref="TessErrorCallback" />.
        ///                     </para>
        ///                     <para>
        ///                         The GLU library will recover from the first four errors by
        ///                         inserting the missing call(s).
        ///                         <see cref="GLU_TESS_COORD_TOO_LARGE" /> indicates that some
        ///                         vertex coordinate exceeded the predefined constant
        ///                         <see cref="GLU_TESS_MAX_COORD" /> in absolute value, and that
        ///                         the value has been clamped.  (Coordinate values must be small
        ///                         enough so that two can be multiplied together without
        ///                         overflow.)  <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" />
        ///                         indicates that the tessellation detected an intersection
        ///                         between two edges in the input data, and the
        ///                         <see cref="GLU_TESS_COMBINE" /> or
        ///                         <see cref="GLU_TESS_COMBINE_DATA" /> callback was not
        ///                         provided.  No output is generated.
        ///                         <see cref="GLU_OUT_OF_MEMORY" /> indicates that there is not
        ///                         enough memory so no output is generated.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_ERROR_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_ERROR" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessErrorDataCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX" /></term>
        ///                 <description>
        ///                     The vertex callback is invoked between the begin and end
        ///                     callbacks.  It is similar to Gl.glVertex*, and it defines the
        ///                     vertices of the triangles created by the tessellation process.
        ///                     The function takes a pointer as its only argument.  This pointer
        ///                     is identical to the opaque pointer provided by the user when the
        ///                     vertex was described (see <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />).  The
        ///                     delegate prototype for this callback is
        ///                     <see cref="TessVertexCallback" />.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_VERTEX_DATA" /></term>
        ///                 <description>
        ///                     The same as the <see cref="GLU_TESS_VERTEX" /> callback except
        ///                     that it takes an additional pointer argument.  This pointer is
        ///                     identical to the opaque pointer provided when
        ///                     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was called.  The delegate
        ///                     prototype for this callback is
        ///                     <see cref="TessVertexDataCallback" />.
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="func">
        ///     The function to be called.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessCallback</b> is used to indicate a callback to be used by a
        ///         tessellation object.  If the specified callback is already defined, then it
        ///         is replaced.  If <i>func</i> is <c>null</c>, then the existing callback
        ///         becomes undefined.
        ///     </para>
        ///     <para>
        ///         These callbacks are used by the tessellation object to describe how a polygon
        ///         specified by the user is broken into triangles.  Note that there are two
        ///         versions of each callback: one with user-specified polygon data and one
        ///         without.  If both versions of a particular callback are specified, then the
        ///         callback with user-specified polygon data will be used.  Note that the
        ///         <i>polygonData</i> parameter used by some of the functions is a copy of the
        ///         pointer that was specified when <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> was
        ///         called.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         You can directly render tessallated polygons as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_BEGIN, new Glu.TessBeginCallback(Gl.glBegin));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_VERTEX, new Glu.TessVertexCallback(Gl.glVertex3dv));
        ///             Glu.gluTessCallback(tess, Glu.GLU_TESS_END, new Glu.TessEndCallback(Gl.glEnd));
        ///
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v, v);
        ///                     . . .
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="TessBeginCallback" />
        /// <seealso cref="TessBeginDataCallback" />
        /// <seealso cref="TessCombineCallback" />
        /// <seealso cref="TessCombineDataCallback" />
        /// <seealso cref="TessEdgeFlagCallback" />
        /// <seealso cref="TessEdgeFlagDataCallback" />
        /// <seealso cref="TessEndCallback" />
        /// <seealso cref="TessEndDataCallback" />
        /// <seealso cref="TessErrorCallback" />
        /// <seealso cref="TessErrorDataCallback" />
        /// <seealso cref="TessVertexCallback" />
        /// <seealso cref="TessVertexDataCallback" />
        /// <seealso cref="Gl.glBegin" />
        /// <seealso cref="Gl.glEdgeFlag" />
        /// <seealso cref="gluErrorString" />
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessCallback(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)());
        public static void gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexDataCallback func)
        {
            tessVertexDataCallback = func;
            __gluTessCallback(tess, which, tessVertexDataCallback);
        }
        #endregion gluTessCallback([In] GLUtesselator tess, int which, [In] TessVertexDataCallback func)

        #region gluTessEndContour([In] GLUtesselator tess)
        /// <summary>
        ///     Delimits a contour description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <remarks>
        ///     <see cref="gluTessBeginContour" /> and <b>gluTessEndContour</b> delimit the
        ///     definition of a polygon contour.  Within each
        ///     <see cref="gluTessBeginContour" />/<b>gluTessEndContour</b> pair, there can
        ///     be zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.  The vertices specify
        ///     a closed contour (the last vertex of each contour is automatically linked to
        ///     the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" /> reference page for more
        ///     details.  <see cref="gluTessBeginContour" /> can only be called between
        ///     <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> and <see cref="gluTessEndPolygon" />.
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessEndContour(GLUtesselator *tess);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessEndContour([In] GLUtesselator tess);
        #endregion gluTessEndContour([In] GLUtesselator tess)

        #region gluTessEndPolygon([In] GLUtesselator tess)
        /// <summary>
        ///     Delimits a polygon description.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" /> and <b>gluTessEndPolygon</b> delimit the
        ///         definition of a convex, concave or self-intersecting polygon.  Within each
        ///         <see cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />/<b>gluTessEndPolygon</b> pair, there must
        ///         be one or more calls to
        ///         <see cref="gluTessBeginContour" />/<see cref="gluTessEndContour" />.  Within
        ///         each contour, there are zero or more calls to <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />.
        ///         The vertices specify a closed contour (the last vertex of each contour is
        ///         automatically linked to the first).  See the <see cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />,
        ///         <see cref="gluTessBeginContour" />, and <see cref="gluTessEndContour" />
        ///         reference pages for more details.
        ///     </para>
        ///     <para>
        ///         Once <b>gluTessEndPolygon</b> is called, the polygon is tessellated,
        ///         and the resulting triangles are described through callbacks.  See
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> for descriptions of the callback functions.
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tobj, null);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v1, v1);
        ///                     Glu.gluTessVertex(tobj, v2, v2);
        ///                     Glu.gluTessVertex(tobj, v3, v3);
        ///                     Glu.gluTessVertex(tobj, v4, v4);
        ///                 Glu.gluTessEndContour(tobj);
        ///                 Glu.gluTessBeginContour(tobj);
        ///                     Glu.gluTessVertex(tobj, v5, v5);
        ///                     Glu.gluTessVertex(tobj, v6, v6);
        ///                     Glu.gluTessVertex(tobj, v7, v7);
        ///                 Glu.gluTessEndContour(tobj);
        ///             Glu.gluTessEndPolygon(tobj);
        ///         </code>
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        /// <seealso cref="gluTessVertex(Tao.OpenGl.Glu.GLUtesselator, double[], byte[])" />
        // void APIENTRY gluTessEndPolygon(GLUtesselator *tess);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessEndPolygon([In] GLUtesselator tess);
        #endregion gluTessEndPolygon([In] GLUtesselator tess)

        #region gluTessNormal([In] GLUtesselator tess, double x, double y, double z)
        /// <summary>
        ///     Specifies a normal for a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="x">
        ///     The x-coordinate component of a normal.
        /// </param>
        /// <param name="y">
        ///     The y-coordinate component of a normal.
        /// </param>
        /// <param name="z">
        ///     The z-coordinate component of a normal.
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessNormal</b> describes a normal for a polygon that the program is
        ///         defining.  All input data will be projected onto a plane perpendicular to one
        ///         of the three coordinate axes before tessellation and all output triangles
        ///         will be oriented CCW with respect to the normal (CW orientation can be
        ///         obtained by reversing the sign of the supplied normal).  For example, if you
        ///         know that all polygons lie in the x-y plane, call
        ///         <c>Glu.gluTessNormal(tess, 0.0, 0.0, 1.0)</c> before rendering any polygons.
        ///     </para>
        ///     <para>
        ///         If the supplied normal is (0.0, 0.0, 0.0) (the initial value), the normal is
        ///         determined as follows.  The direction of the normal, up to its sign, is found
        ///         by fitting a plane to the vertices, without regard to how the vertices are
        ///         connected.  It is expected that the input data lies approximately in the
        ///         plane; otherwise, projection perpendicular to one of the three coordinate
        ///         axes may substantially change the geometry.  The sign of the normal is chosen
        ///         so that the sum of the signed areas of all input contours is nonnegative
        ///         (where a CCW contour has positive area).
        ///     </para>
        ///     <para>
        ///         The supplied normal persists until it is changed by another call to
        ///         <b>gluTessNormal</b>.
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessEndPolygon" />
        // void APIENTRY gluTessNormal(GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessNormal([In] GLUtesselator tess, double x, double y, double z);
        #endregion gluTessNormal([In] GLUtesselator tess, double x, double y, double z)

        #region gluTessProperty([In] GLUtesselator tess, int which, double data)
        /// <summary>
        ///     Sets the property of a tessellation object.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="which">
        ///     <para>
        ///         The property value to set.  The following values are valid:
        ///     </para>
        ///     <para>
        ///         <list type="table">
        ///             <listheader>
        ///                 <term>Value</term>
        ///                 <description>Description</description>
        ///             </listheader>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_WINDING_RULE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         Determines which parts of the polygon are on the "interior".
        ///                         <i>data</i> may be set to one of
        ///                         <see cref="GLU_TESS_WINDING_ODD" />,
        ///                         <see cref="GLU_TESS_WINDING_NONZERO" />,
        ///                         <see cref="GLU_TESS_WINDING_POSITIVE" />, or
        ///                         <see cref="GLU_TESS_WINDING_NEGATIVE" />, or
        ///                         <see cref="GLU_TESS_WINDING_ABS_GEQ_TWO" />.
        ///                     </para>
        ///                     <para>
        ///                         To understand how the winding rule works, consider that the
        ///                         input contours partition the plane into regions.  The winding
        ///                         rule determines which of these regions are inside the
        ///                         polygon.
        ///                     </para>
        ///                     <para>
        ///                         For a single contour C, the winding number of a point x is
        ///                         simply the signed number of revolutions we make around x as
        ///                         we travel once around C (where CCW is positive).  When there
        ///                         are several contours, the individual winding numbers are
        ///                         summed.  This procedure associates a signed integer value
        ///                         with each point x in the plane.  Note that the winding number
        ///                         is the same for all points in a single region.
        ///                     </para>
        ///                     <para>
        ///                         The winding rule classifies a region as "inside" if its
        ///                         winding number belongs to the chosen category (odd, nonzero,
        ///                         positive, negative, or absolute value of at least two).  The
        ///                         previous GLU tessellator (prior to GLU 1.2) used the "odd"
        ///                         rule.  The "nonzero" rule is another common way to define the
        ///                         interior.  The other three rules are useful for polygon CSG
        ///                         operations.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_BOUNDARY_ONLY" /></term>
        ///                 <description>
        ///                     Is a boolean value ("value" should be set to
        ///                     <see cref="Gl.GL_TRUE" /> or <see cref="Gl.GL_FALSE" />).  When
        ///                     set to <see cref="Gl.GL_TRUE" />, a set of closed contours
        ///                     separating the polygon interior and exterior are returned instead
        ///                     of a tessellation.  Exterior contours are oriented CCW with
        ///                     respect to the normal; interior contours are oriented CW.  The
        ///                     <see cref="GLU_TESS_BEGIN" /> and
        ///                     <see cref="GLU_TESS_BEGIN_DATA" /> callbacks use the type
        ///                     <see cref="Gl.GL_LINE_LOOP" /> for each contour.
        ///                 </description>
        ///             </item>
        ///             <item>
        ///                 <term><see cref="GLU_TESS_TOLERANCE" /></term>
        ///                 <description>
        ///                     <para>
        ///                         Specifies a tolerance for merging features to reduce the size
        ///                         of the output.  For example, two vertices that are very close
        ///                         to each other might be replaced by a single vertex.  The
        ///                         tolerance is multiplied by the largest coordinate magnitude
        ///                         of any input vertex; this specifies the maximum distance that
        ///                         any feature can move as the result of a single merge
        ///                         operation.  If a single feature takes part in several merge
        ///                         operations, the total distance moved could be larger.
        ///                     </para>
        ///                     <para>
        ///                         Feature merging is completely optional; the tolerance is only
        ///                         a hint.  The implementation is free to merge in some cases
        ///                         and not in others, or to never merge features at all.  The
        ///                         initial tolerance is 0.
        ///                     </para>
        ///                     <para>
        ///                         The current implementation merges vertices only if they are
        ///                         exactly coincident, regardless of the current tolerance.  A
        ///                         vertex is spliced into an edge only if the implementation is
        ///                         unable to distinguish which side of the edge the vertex lies
        ///                         on.  Two edges are merged only when both endpoints are
        ///                         identical.
        ///                     </para>
        ///                 </description>
        ///             </item>
        ///         </list>
        ///     </para>
        /// </param>
        /// <param name="data">
        ///     The value of the indicated property.
        /// </param>
        /// <remarks>
        ///     <b>gluTessProperty</b> is used to control properties stored in a tessellation
        ///     object.  These properties affect the way that the polygons are interpreted
        ///     and rendered.
        /// </remarks>
        /// <seealso cref="gluGetTessProperty(Tao.OpenGl.Glu.GLUtesselator, int, double[])" />
        /// <seealso cref="gluNewTess" />
        // void APIENTRY gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble value);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessProperty([In] GLUtesselator tess, int which, double data);
        #endregion gluTessProperty([In] GLUtesselator tess, int which, double data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] byte[] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] byte[] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] byte[] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] byte[ , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] byte[,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] byte[ , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] byte[ , , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] byte[, ,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] byte[ , , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] double[] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] double[] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] double[] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] double[ , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] double[,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] double[ , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] double[ , , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] double[, ,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] double[ , , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] short[] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] short[] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] short[] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] short[ , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] short[,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] short[ , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] short[ , , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] short[, ,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] short[ , , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] int[] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] int[] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] int[] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] int[ , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] int[,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] int[ , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] int[ , , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] int[, ,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] int[ , , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] float[] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] float[] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] float[] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] float[ , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] float[,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] float[ , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] float[ , , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] float[, ,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] float[ , , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] ushort[] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] ushort[] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] ushort[] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] ushort[ , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] ushort[,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] ushort[ , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] ushort[ , , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] ushort[, ,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] ushort[ , , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] uint[] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] uint[] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] uint[] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] uint[ , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] uint[,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] uint[ , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] uint[ , , ] data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] uint[, ,] data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] uint[ , , ] data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] IntPtr data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] IntPtr data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] IntPtr data)

        #region gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] void *data)
        /// <summary>
        ///     Specifies a vertex on a polygon.
        /// </summary>
        /// <param name="tess">
        ///     The tessellation object (created with <see cref="gluNewTess" />).
        /// </param>
        /// <param name="location">
        ///     The location of the vertex.
        /// </param>
        /// <param name="data">
        ///     A pointer passed back to the program with the vertex callback (as specified
        ///     by <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />).
        /// </param>
        /// <remarks>
        ///     <para>
        ///         <b>gluTessVertex</b> describes a vertex on a polygon that the program
        ///         defines.  Successive <b>gluTessVertex</b> calls describe a closed contour.
        ///         For example, to describe a quadrilateral <b>gluTessVertex</b> should be
        ///         called four times.  <b>gluTessVertex</b> can only be called between
        ///         <see cref="gluTessBeginContour" /> and <see cref="gluTessEndContour" />.
        ///     </para>
        ///     <para>
        ///         <i>data</i> normally points to a structure containing the vertex location,
        ///         as well as other per-vertex attributes such as color and normal.  This
        ///         pointer is passed back to the user through the <see cref="GLU_TESS_VERTEX" />
        ///         or <see cref="GLU_TESS_VERTEX_DATA" /> callback after tessellation (see the
        ///         <see cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" /> reference page).
        ///     </para>
        ///     <para>
        ///         <b>EXAMPLE</b>
        ///     </para>
        ///     <para>
        ///         The following describes a quadrilateral with a triangular hole:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             Glu.gluTessBeginPolygon(tess, null);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v1, v1);
        ///                     Glu.gluTessVertex(tess, v2, v2);
        ///                     Glu.gluTessVertex(tess, v3, v3);
        ///                     Glu.gluTessVertex(tess, v4, v4);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluNextContour(tess, Glu.GLU_INTERIOR);
        ///                 Glu.gluTessBeginContour(tess);
        ///                     Glu.gluTessVertex(tess, v5, v5);
        ///                     Glu.gluTessVertex(tess, v6, v6);
        ///                     Glu.gluTessVertex(tess, v7, v7);
        ///                 Glu.gluTessEndContour(tess);
        ///             Glu.gluTessEndPolygon(tess);
        ///         </code>
        ///     </para>
        ///     <para>
        ///         <b>NOTES</b>
        ///     </para>
        ///     <para>
        ///         It is a common error to use a local variable for <i>location</i> or
        ///         <i>data</i> and store values into it as part of a loop.  For example:
        ///     </para>
        ///     <para>
        ///         <code>
        ///             for(int i = 0; i &lt; NVERTICES; ++i) { 
        ///                 double data[3];
        ///                 data[0] = vertex[i, 0];
        ///                 data[1] = vertex[i, 1];
        ///                 data[2] = vertex[i, 2];
        ///                 Glu.gluTessVertex(tobj, data, data);
        ///             } 
        ///         </code>
        ///     </para>
        ///     <para>
        ///         This doesn't work.  Because the pointers specified by <i>location</i> and
        ///         <i>data</i> might not be dereferenced until <see cref="gluTessEndPolygon" />
        ///         is executed, all the vertex coordinates but the very last set could be
        ///         overwritten before tessellation begins.
        ///     </para>
        ///     <para>
        ///         Two common symptoms of this problem are consists of a single point (when a
        ///         local variable is used for <i>data</i>) and a
        ///         <see cref="GLU_TESS_NEED_COMBINE_CALLBACK" /> error (when a local variable
        ///         is used for <i>location</i>).
        ///     </para>
        /// </remarks>
        /// <seealso cref="gluNewTess" />
        /// <seealso cref="gluTessBeginPolygon(Tao.OpenGl.Glu.GLUtesselator, byte[])" />
        /// <seealso cref="gluTessBeginContour" />
        /// <seealso cref="gluTessCallback(Tao.OpenGl.Glu.GLUtesselator, int, Tao.OpenGl.Glu.TessBeginCallback)" />
        /// <seealso cref="gluTessEndPolygon" />
        /// <seealso cref="gluTessNormal" />
        /// <seealso cref="gluTessProperty" />
        // void APIENTRY gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), CLSCompliant(false), SuppressUnmanagedCodeSecurity]
        public unsafe static extern void gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] void* data);
        #endregion gluTessVertex([In] GLUtesselator tess, [In] double[] location, [In] void *data)

        #region int gluUnProject(double winX, double winY, double winZ, [In] double[] modelMatrix, [In] double[] projectionMatrix, [In] int[] viewport, out double objX, out double objY, out double objZ)
        /// <summary>
        ///     Maps window coordinates to object coordinates.
        /// </summary>
        /// <param name="winX">
        ///     The window's x axis coordinate to be mapped.
        /// </param>
        /// <param name="winY">
        ///     The window's y axis coordinate to be mapped.
        /// </param>
        /// <param name="winZ">
        ///     The window's z axis coordinate to be mapped.
        /// </param>
        /// <param name="modelMatrix">
        ///     The modelview matrix (as from a <see cref="Gl.glGetDoublev(int, IntPtr)" /> call).
        /// </param>
        /// <param name="projectionMatrix">
        ///     The projection matrix (as from a <see cref="Gl.glGetDoublev(int, IntPtr)" /> call).
        /// </param>
        /// <param name="viewport">
        ///     The viewport (as from a <see cref="Gl.glGetIntegerv(int, IntPtr)" /> call).
        /// </param>
        /// <param name="objX">
        ///     The computed object's x axis coordinate.
        /// </param>
        /// <param name="objY">
        ///     The computed object's y axis coordinate.
        /// </param>
        /// <param name="objZ">
        ///     The computed object's z axis coordinate.
        /// </param>
        /// <returns>
        ///     A return value of <see cref="Gl.GL_TRUE" /> indicates success; a return value
        ///     of <see cref="Gl.GL_FALSE" /> indicates failure.
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluUnProject</b> maps the specified window coordinates into object
        ///         coordinates using <i>modelMatrix</i>, <i>projectionMatrix</i>, and
        ///         <i>viewport</i>.  The result is stored in <i>objX</i>, <i>objY</i>, and
        ///         <i>objZ</i>.  A return value of <see cref="Gl.GL_TRUE" /> indicates success;
        ///         a return value of <see cref="Gl.GL_FALSE" /> indicates failure.
        ///     </para>
        ///     <para>
        ///         To compute the coordinates (<i>objX</i>, <i>objY</i>, and <i>objZ</i>),
        ///         <b>gluUnProject</b> multiplies the normalized device coordinates by the
        ///         inverse of <i>modelMatrix</i> multiplied by <i>projectionMatrix</i> as
        ///         follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///                               (  2(winX - viewport[0])  )
        ///                               |  ----------------- - 1  |
        ///                               |       viewport[2]       |
        ///             (      )          |                         |
        ///             | objX |          |  2(winY - viewport[1])  |
        ///             | objY | = INV(PM)|  ----------------- - 1  |
        ///             | objZ |          |       viewport[3]       |
        ///             (  W   )          |                         |
        ///                               |       2(winZ) - 1       |
        ///                               |                         |
        ///                               (            1            )
        ///         </code>
        ///     </para>
        ///     <para>
        ///         INV() denotes matrix inversion.  W is an unused variable, included for
        ///         consistent matrix notation. 
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glGetDoublev(int, IntPtr)" />
        /// <seealso cref="Gl.glGetIntegerv(int, IntPtr)" />
        /// <seealso cref="gluProject" />
        // int APIENTRY gluUnProject(GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluUnProject(double winX, double winY, double winZ, [In] double[] modelMatrix, [In] double[] projectionMatrix, [In] int[] viewport, out double objX, out double objY, out double objZ);
        #endregion int gluUnProject(double winX, double winY, double winZ, [In] double[] modelMatrix, [In] double[] projectionMatrix, [In] int[] viewport, out double objX, out double objY, out double objZ)

        #region int gluUnProject4(double winX, double winY, double winZ, double clipW, [In] double[] modelMatrix, [In] double[] projectionMatrix, [In] int[] viewport, double nearVal, double farVal, out double objX, out double objY, out double objZ, out double objW)
        /// <summary>
        ///     Maps window and clip coordinates to object coordinates.
        /// </summary>
        /// <param name="winX">
        ///     The window's x axis coordinate to be mapped.
        /// </param>
        /// <param name="winY">
        ///     The window's y axis coordinate to be mapped.
        /// </param>
        /// <param name="winZ">
        ///     The window's z axis coordinate to be mapped.
        /// </param>
        /// <param name="clipW">
        ///     The clip w coordinate to be mapped.
        /// </param>
        /// <param name="modelMatrix">
        ///     The modelview matrix (as from a <see cref="Gl.glGetDoublev(int, IntPtr)" /> call).
        /// </param>
        /// <param name="projectionMatrix">
        ///     The projection matrix (as from a <see cref="Gl.glGetDoublev(int, IntPtr)" /> call).
        /// </param>
        /// <param name="viewport">
        ///     The viewport (as from a <see cref="Gl.glGetIntegerv(int, IntPtr)" /> call).
        /// </param>
        /// <param name="nearVal">
        ///     The near plane (as from a <see cref="Gl.glGetDoublev(int, IntPtr)" /> call).
        /// </param>
        /// <param name="farVal">
        ///     The far plane (as from a <see cref="Gl.glGetDoublev(int, IntPtr)" /> call).
        /// </param>
        /// <param name="objX">
        ///     The computed object's x axis coordinate.
        /// </param>
        /// <param name="objY">
        ///     The computed object's y axis coordinate.
        /// </param>
        /// <param name="objZ">
        ///     The computed object's z axis coordinate.
        /// </param>
        /// <param name="objW">
        ///     The computed object's clip w coordinate.
        /// </param>
        /// <returns>
        ///     A return value of <see cref="Gl.GL_TRUE" /> indicates success; a return
        ///     value of <see cref="Gl.GL_FALSE" /> indicates failure.
        /// </returns>
        /// <remarks>
        ///     <para>
        ///         <b>gluUnProject4</b> maps the specified window coordinates <i>winX</i>,
        ///         <i>winY</i> and <i>winZ</i> and its clip w coordinate <i>clipW</i> into
        ///         object coordinates (<i>objX</i>, <i>objY</i>, <i>objZ</i>, <i>objW</i>)
        ///         using <i>modelMatrix</i>, <i>projectionMatrix</i> and <i>viewport</i>.
        ///         <i>clipW</i> can be other than 1 as for vertices in
        ///         <see cref="Gl.glFeedbackBuffer(int, int, IntPtr)" /> when data type
        ///         <see cref="Gl.GL_4D_COLOR_TEXTURE" /> is returned.  This also handles the
        ///         case where the <i>nearVal</i> and <i>farVal</i> planes are different from the
        ///         default, 0 and 1, respectively.  A return value of <see cref="Gl.GL_TRUE" />
        ///         indicates success; a return value of <see cref="Gl.GL_FALSE" /> indicates
        ///         failure.
        ///     </para>
        ///     <para>
        ///         To compute the coordinates (<i>objX</i>, <i>objY</i>, <i>objZ</i> and
        ///         <i>objW</i>), <b>gluUnProject4</b> multiplies the normalized device
        ///         coordinates by the inverse of <i>modelMatrix</i> multiplied by
        ///         <i>projectionMatrix</i> as follows:
        ///     </para>
        ///     <para>
        ///         <code>
        ///                               ( 2(winX - viewport[0]  )
        ///                               | ---------------- - 1  |
        ///                               |     viewport[2]       |
        ///                               |                       |
        ///                               | 2(winY - viewport[1]  |
        ///         ( objX  )             | ---------------- - 1  |
        ///         | objY  | = INV(PM) * |     viewport[3]       |
        ///         | objZ  |             |                       |
        ///         ( objW  )             |  2(winZ - nearVal)    |
        ///                               |  -------------- - 1   |
        ///                               |    farVal - nearVal   |
        ///                               |                       |
        ///                               (        clipW          )
        ///         </code>
        ///     </para>
        ///     <para>
        ///         INV() denotes matrix inversion.
        ///     </para>
        ///     <para>
        ///         <b>gluUnProject4</b> is equivalent to <see cref="gluUnProject" /> when
        ///         <i>clipW</i> is 1, <i>nearVal</i> is 0 and <i>farVal</i> is 1.
        ///     </para>
        ///     <para>
        ///         <b>gluUnProject4</b> is available only if the GLU version is 1.3 or greater.
        ///     </para>
        /// </remarks>
        /// <seealso cref="Gl.glFeedbackBuffer(int, int, IntPtr)" />
        /// <seealso cref="Gl.glGetDoublev(int, IntPtr)" />
        /// <seealso cref="Gl.glGetIntegerv(int, IntPtr)" />
        /// <seealso cref="gluProject" />
        /// <seealso cref="gluUnProject" />
        // GLAPI GLint GLAPIENTRY gluUnProject4 (GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearVal, GLdouble farVal, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW);
        [DllImport("glu32.dll", CallingConvention = CALLING_CONVENTION), SuppressUnmanagedCodeSecurity]
        public static extern int gluUnProject4(double winX, double winY, double winZ, double clipW, [In] double[] modelMatrix, [In] double[] projectionMatrix, [In] int[] viewport, double nearVal, double farVal, out double objX, out double objY, out double objZ, out double objW);
        #endregion int gluUnProject4(double winX, double winY, double winZ, double clipW, [In] double[] modelMatrix, [In] double[] projectionMatrix, [In] int[] viewport, double nearVal, double farVal, out double objX, out double objY, out double objZ, out double objW)
    }
}