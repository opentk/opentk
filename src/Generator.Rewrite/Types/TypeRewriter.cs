using System;
using System.Collections.Generic;
using System.Linq;
using Mono.Cecil;
using Mono.Cecil.Rocks;
using OpenTK.Rewrite.Extensions;
using OpenTK.Rewrite.Methods;

namespace OpenTK.Rewrite.Types
{
    /// <summary>
    /// Rewrites all wrapper methods in a type according to a supplied <see cref="IMethodRewriter"/> implementation.
    /// </summary>
    public sealed class TypeRewriter : ITypeRewriter
    {
        private readonly TypeDefinition _boolType;

        private readonly IMethodRewriter _methodRewriter;
        private readonly bool _useDllImport;

        /// <summary>
        /// Initializes a new instance of the <see cref="TypeRewriter"/> class.
        /// </summary>
        /// <param name="mscorlib">The mscorlib assembly definition used for setting up.</param>
        /// <param name="useDllImport">Whether to use DllImport instead of GetProcAddress for native calls.</param>
        /// <param name="methodRewriter">
        /// The <see cref="IMethodRewriter"/> implementation to use for rewriting methods inside a type.
        /// </param>
        public TypeRewriter
        (
            AssemblyDefinition mscorlib,
            bool useDllImport,
            IMethodRewriter methodRewriter
        )
        {
            _boolType = mscorlib.MainModule.GetType(typeof(bool).FullName);
            _useDllImport = useDllImport;

            _methodRewriter = methodRewriter ?? throw new ArgumentNullException(nameof(methodRewriter));
        }

        /// <summary>
        /// Rewrites a type definition by rewriting all wrapper methods.
        /// </summary>
        /// <param name="type">The type definition to rewrite.</param>
        /// <returns>The rewritten type definition.</returns>
        public TypeDefinition Rewrite(TypeDefinition type)
        {
            var entryPoints = type.Fields.FirstOrDefault(f => f.Name == "EntryPoints");
            if (entryPoints != null)
            {
                // Build list of entry point signatures (one per entry point)
                var entrySignatures = type.Methods.Where(t =>
                {
                    return t.CustomAttributes.Any(a => a.AttributeType.Name == AttributeNames.Slot);
                }).ToList();

                RewriteWrapperMethods(type, entryPoints, entrySignatures);

                RemoveNativeSignatures(type, entrySignatures);
            }
            else if (type.Name == AttributeNames.Rewritten)
            {
                var rewrittenConstructor = type.GetConstructors().First();
                var rewritten = new CustomAttribute(rewrittenConstructor);
                var attributeArg = new CustomAttributeArgument(type.Module.ImportReference(_boolType), true);
                rewritten.ConstructorArguments.Add(attributeArg);
                type.Module.Assembly.CustomAttributes.Add(rewritten);
            }

            return type;
        }

        private void RewriteWrapperMethods
        (
            TypeDefinition type,
            FieldDefinition entryPoints,
            IEnumerable<MethodDefinition> entrySignatures
        )
        {
            var wrapperSignatures = type.Methods.Where(m =>
                m.IsPublic &&
                m.CustomAttributes.Any(a => a.AttributeType.Name == AttributeNames.AutoGenerated)
            ).ToList();

            foreach (var wrapper in wrapperSignatures)
            {
                var autoGenerated = wrapper.GetCustomAttribute(AttributeNames.AutoGenerated, throwIfNoneFound: false);
                if (autoGenerated is null)
                {
                    continue;
                }

                string signatureName = (string)autoGenerated
                    .Fields
                    .First(f => f.Name == "EntryPoint")
                    .Argument
                    .Value;

                var nativeSignature = entrySignatures.FirstOrDefault(s => s.Name == signatureName);

                _methodRewriter.Rewrite(wrapper, nativeSignature);
            }

            RemoveSupportingAttributes(type);

            foreach (var nestedType in type.NestedTypes)
            {
                RewriteWrapperMethods(nestedType, entryPoints, entrySignatures);
            }
        }

        private void RemoveSupportingAttributes(TypeDefinition type)
        {
            foreach (var method in type.Methods)
            {
                var attr = method.CustomAttributes;
                for (int i = 0; i < attr.Count; i++)
                {
                    if (attr[i].AttributeType.Name == AttributeNames.AutoGenerated)
                    {
                        attr.RemoveAt(i--);
                    }
                }

                foreach (var parameter in method.Parameters)
                {
                    var paramAttr = parameter.CustomAttributes;
                    for (var i = 0; i < paramAttr.Count; i++)
                    {
                        if (paramAttr[i].AttributeType.Name == AttributeNames.Count)
                        {
                            paramAttr.RemoveAt(i--);
                        }
                    }
                }
            }
        }

        private void RemoveNativeSignatures(TypeDefinition type, IEnumerable<MethodDefinition> methods)
        {
            if (_useDllImport)
            {
                return;
            }

            // Remove all DllImports for functions called through calli, since
            // their signatures are embedded directly into the calli callsite.
            // This reduces dll size by ~400KB.
            foreach (var m in methods.Where(s => s.GetSlot() != -1))
            {
                type.Methods.Remove(m);
            }
        }
    }
}
