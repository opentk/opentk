using System;
using System.Collections.Generic;
using System.Linq;
using Mono.Cecil;
using Mono.Cecil.Rocks;
using OpenTK.Rewrite.Extensions;
using OpenTK.Rewrite.Method;
using OpenTK.Rewrite.Method.Processors;

namespace OpenTK.Rewrite
{
    public sealed class TypeRewriter
    {
        private readonly AssemblyDefinition _mscorlib;
        private readonly TypeDefinition _boolType;
        private readonly TypeDefinition _bindingsBaseType;

        private readonly bool _enableDebugCalls;
        private readonly bool _useDllImport;

        public TypeRewriter
        (
            AssemblyDefinition mscorlib,
            TypeDefinition bindingsBaseType,
            bool enableDebugCalls,
            bool useDllImport
        )
        {
            _mscorlib = mscorlib ?? throw new ArgumentNullException(nameof(mscorlib));
            _boolType = mscorlib.MainModule.GetType(typeof(bool).FullName);

            _bindingsBaseType = bindingsBaseType ?? throw new ArgumentNullException(nameof(bindingsBaseType));

            _enableDebugCalls = enableDebugCalls;
            _useDllImport = useDllImport;
        }

        public TypeDefinition Rewrite(TypeDefinition type)
        {
            var entryPoints = type.Fields.FirstOrDefault(f => f.Name == "EntryPoints");
            if (entryPoints != null)
            {
                // Build list of entry point signatures (one per entry point)
                var entrySignatures = type.Methods.Where(t =>
                {
                    return t.CustomAttributes.Any(a => a.AttributeType.Name == AttributeNames.Slot);
                }).ToList();

                RewriteWrapperMethods(type, entryPoints, entrySignatures);

                RemoveNativeSignatures(type, entrySignatures);
            }

            if (type.Name == AttributeNames.Rewritten)
            {
                var rewrittenConstructor = type.GetConstructors().First();
                var rewritten = new CustomAttribute(rewrittenConstructor);
                var attributeArg = new CustomAttributeArgument(type.Module.ImportReference(_boolType), true);
                rewritten.ConstructorArguments.Add(attributeArg);
                type.Module.Assembly.CustomAttributes.Add(rewritten);
            }

            return type;
        }

        private int GetSlot(MethodDefinition signature)
        {
            if (_useDllImport)
            {
                return -1;
            }

            var slotAttribute = signature.CustomAttributes.FirstOrDefault(a =>
            {
                return a.AttributeType.Name == AttributeNames.Slot;
            });
            return (int)(slotAttribute?.ConstructorArguments[0].Value ?? -1);
        }

        private void RewriteWrapperMethods
        (
            TypeDefinition type,
            FieldDefinition entryPoints,
            IEnumerable<MethodDefinition> entrySignatures
        )
        {
            var wrapperSignatures = type.Methods.Where(m =>
                m.IsPublic &&
                m.CustomAttributes.Any(a => a.AttributeType.Name == AttributeNames.AutoGenerated)
            ).ToList();

            foreach (var wrapper in wrapperSignatures)
            {
                var autoGenerated = wrapper.GetCustomAttribute(AttributeNames.AutoGenerated, throwIfNoneFound: false);
                if (autoGenerated != null)
                {
                    string signatureName = (string)autoGenerated
                        .Fields
                        .First(f => f.Name == "EntryPoint")
                        .Argument
                        .Value;

                    var nativeSignature = entrySignatures.FirstOrDefault(s => s.Name == signatureName);
                    int slot = GetSlot(nativeSignature);

                    var processors = new IMethodProcessor[]
                    {
                        new ParameterProcessor(_mscorlib, _bindingsBaseType),
                        new NativeCallProcessor(slot, entryPoints),
                        new ReturnTypeProcessor(_mscorlib),
                    };

                    if (_enableDebugCalls)
                    {
                        processors = processors.Prepend(new DebugPrologueProcessor()).ToArray();
                    }

                    var methodRewriter = new MethodRewriter(processors);
                    methodRewriter.RewriteWrapper(nativeSignature, wrapper);
                }
            }

            RemoveSupportingAttributes(type);

            foreach (var nestedType in type.NestedTypes)
            {
                RewriteWrapperMethods(nestedType, entryPoints, entrySignatures);
            }
        }

        private void RemoveSupportingAttributes(TypeDefinition type)
        {
            foreach (var method in type.Methods)
            {
                var attr = method.CustomAttributes;
                for (int i = 0; i < attr.Count; i++)
                {
                    if (attr[i].AttributeType.Name == AttributeNames.AutoGenerated)
                    {
                        attr.RemoveAt(i--);
                    }
                }

                foreach (var parameter in method.Parameters)
                {
                    var paramAttr = parameter.CustomAttributes;
                    for (var i = 0; i < paramAttr.Count; i++)
                    {
                        if (paramAttr[i].AttributeType.Name == AttributeNames.Count)
                        {
                            paramAttr.RemoveAt(i--);
                        }
                    }
                }
            }
        }

        private void RemoveNativeSignatures(TypeDefinition type, IEnumerable<MethodDefinition> methods)
        {
            // Remove all DllImports for functions called through calli, since
            // their signatures are embedded directly into the calli callsite.
            // This reduces dll size by ~400KB.
            foreach (var m in methods.Where(s => GetSlot(s) != -1))
            {
                type.Methods.Remove(m);
            }
        }
    }
}
