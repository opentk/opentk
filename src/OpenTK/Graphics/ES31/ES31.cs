//
// The Open Toolkit Library License
//
// Copyright (c) 2006 - 2015 Stefanos Apostolopoulos for the Open Toolkit Library
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//



namespace OpenTK.Graphics.ES31
{
    using System;
    using System.Text;
    using System.Runtime.InteropServices;
    #pragma warning disable 3019
    #pragma warning disable 1591
    #pragma warning disable 1572
    #pragma warning disable 1573
    #pragma warning disable 626

    partial class GL
    {
        static GL()
        {
            EntryPointNames = new byte[]
            {
                103, 108, 65, 99, 113, 117, 105, 114, 101, 75, 101, 121, 101, 100, 77, 117, 116, 101, 120, 87, 105, 110, 51, 50, 69, 88, 84, 0,
                103, 108, 65, 99, 116, 105, 118, 101, 80, 114, 111, 103, 114, 97, 109, 69, 88, 84, 0,
                103, 108, 65, 99, 116, 105, 118, 101, 83, 104, 97, 100, 101, 114, 80, 114, 111, 103, 114, 97, 109, 0,
                103, 108, 65, 99, 116, 105, 118, 101, 83, 104, 97, 100, 101, 114, 80, 114, 111, 103, 114, 97, 109, 69, 88, 84, 0,
                103, 108, 65, 99, 116, 105, 118, 101, 84, 101, 120, 116, 117, 114, 101, 0,
                103, 108, 65, 108, 112, 104, 97, 70, 117, 110, 99, 81, 67, 79, 77, 0,
                103, 108, 65, 112, 112, 108, 121, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 65, 116, 116, 97, 99, 104, 109, 101, 110, 116, 67, 77, 65, 65, 73, 78, 84, 69, 76, 0,
                103, 108, 65, 116, 116, 97, 99, 104, 83, 104, 97, 100, 101, 114, 0,
                103, 108, 66, 101, 103, 105, 110, 67, 111, 110, 100, 105, 116, 105, 111, 110, 97, 108, 82, 101, 110, 100, 101, 114, 78, 86, 0,
                103, 108, 66, 101, 103, 105, 110, 80, 101, 114, 102, 77, 111, 110, 105, 116, 111, 114, 65, 77, 68, 0,
                103, 108, 66, 101, 103, 105, 110, 80, 101, 114, 102, 81, 117, 101, 114, 121, 73, 78, 84, 69, 76, 0,
                103, 108, 66, 101, 103, 105, 110, 81, 117, 101, 114, 121, 0,
                103, 108, 66, 101, 103, 105, 110, 81, 117, 101, 114, 121, 69, 88, 84, 0,
                103, 108, 66, 101, 103, 105, 110, 84, 114, 97, 110, 115, 102, 111, 114, 109, 70, 101, 101, 100, 98, 97, 99, 107, 0,
                103, 108, 66, 105, 110, 100, 65, 116, 116, 114, 105, 98, 76, 111, 99, 97, 116, 105, 111, 110, 0,
                103, 108, 66, 105, 110, 100, 66, 117, 102, 102, 101, 114, 0,
                103, 108, 66, 105, 110, 100, 66, 117, 102, 102, 101, 114, 66, 97, 115, 101, 0,
                103, 108, 66, 105, 110, 100, 66, 117, 102, 102, 101, 114, 82, 97, 110, 103, 101, 0,
                103, 108, 66, 105, 110, 100, 70, 114, 97, 103, 68, 97, 116, 97, 76, 111, 99, 97, 116, 105, 111, 110, 69, 88, 84, 0,
                103, 108, 66, 105, 110, 100, 70, 114, 97, 103, 68, 97, 116, 97, 76, 111, 99, 97, 116, 105, 111, 110, 73, 110, 100, 101, 120, 101, 100, 69, 88, 84, 0,
                103, 108, 66, 105, 110, 100, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 0,
                103, 108, 66, 105, 110, 100, 73, 109, 97, 103, 101, 84, 101, 120, 116, 117, 114, 101, 0,
                103, 108, 66, 105, 110, 100, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 0,
                103, 108, 66, 105, 110, 100, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 69, 88, 84, 0,
                103, 108, 66, 105, 110, 100, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 0,
                103, 108, 66, 105, 110, 100, 83, 97, 109, 112, 108, 101, 114, 0,
                103, 108, 66, 105, 110, 100, 84, 101, 120, 116, 117, 114, 101, 0,
                103, 108, 66, 105, 110, 100, 84, 114, 97, 110, 115, 102, 111, 114, 109, 70, 101, 101, 100, 98, 97, 99, 107, 0,
                103, 108, 66, 105, 110, 100, 86, 101, 114, 116, 101, 120, 65, 114, 114, 97, 121, 0,
                103, 108, 66, 105, 110, 100, 86, 101, 114, 116, 101, 120, 65, 114, 114, 97, 121, 79, 69, 83, 0,
                103, 108, 66, 105, 110, 100, 86, 101, 114, 116, 101, 120, 66, 117, 102, 102, 101, 114, 0,
                103, 108, 66, 108, 101, 110, 100, 66, 97, 114, 114, 105, 101, 114, 75, 72, 82, 0,
                103, 108, 66, 108, 101, 110, 100, 66, 97, 114, 114, 105, 101, 114, 78, 86, 0,
                103, 108, 66, 108, 101, 110, 100, 67, 111, 108, 111, 114, 0,
                103, 108, 66, 108, 101, 110, 100, 69, 113, 117, 97, 116, 105, 111, 110, 0,
                103, 108, 66, 108, 101, 110, 100, 69, 113, 117, 97, 116, 105, 111, 110, 69, 88, 84, 0,
                103, 108, 66, 108, 101, 110, 100, 69, 113, 117, 97, 116, 105, 111, 110, 105, 69, 88, 84, 0,
                103, 108, 66, 108, 101, 110, 100, 69, 113, 117, 97, 116, 105, 111, 110, 105, 79, 69, 83, 0,
                103, 108, 66, 108, 101, 110, 100, 69, 113, 117, 97, 116, 105, 111, 110, 83, 101, 112, 97, 114, 97, 116, 101, 0,
                103, 108, 66, 108, 101, 110, 100, 69, 113, 117, 97, 116, 105, 111, 110, 83, 101, 112, 97, 114, 97, 116, 101, 105, 69, 88, 84, 0,
                103, 108, 66, 108, 101, 110, 100, 69, 113, 117, 97, 116, 105, 111, 110, 83, 101, 112, 97, 114, 97, 116, 101, 105, 79, 69, 83, 0,
                103, 108, 66, 108, 101, 110, 100, 70, 117, 110, 99, 0,
                103, 108, 66, 108, 101, 110, 100, 70, 117, 110, 99, 105, 69, 88, 84, 0,
                103, 108, 66, 108, 101, 110, 100, 70, 117, 110, 99, 105, 79, 69, 83, 0,
                103, 108, 66, 108, 101, 110, 100, 70, 117, 110, 99, 83, 101, 112, 97, 114, 97, 116, 101, 0,
                103, 108, 66, 108, 101, 110, 100, 70, 117, 110, 99, 83, 101, 112, 97, 114, 97, 116, 101, 105, 69, 88, 84, 0,
                103, 108, 66, 108, 101, 110, 100, 70, 117, 110, 99, 83, 101, 112, 97, 114, 97, 116, 101, 105, 79, 69, 83, 0,
                103, 108, 66, 108, 101, 110, 100, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 78, 86, 0,
                103, 108, 66, 108, 105, 116, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 0,
                103, 108, 66, 108, 105, 116, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 65, 78, 71, 76, 69, 0,
                103, 108, 66, 108, 105, 116, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 78, 86, 0,
                103, 108, 66, 117, 102, 102, 101, 114, 68, 97, 116, 97, 0,
                103, 108, 66, 117, 102, 102, 101, 114, 83, 116, 111, 114, 97, 103, 101, 69, 88, 84, 0,
                103, 108, 66, 117, 102, 102, 101, 114, 83, 116, 111, 114, 97, 103, 101, 69, 120, 116, 101, 114, 110, 97, 108, 69, 88, 84, 0,
                103, 108, 66, 117, 102, 102, 101, 114, 83, 116, 111, 114, 97, 103, 101, 77, 101, 109, 69, 88, 84, 0,
                103, 108, 66, 117, 102, 102, 101, 114, 83, 117, 98, 68, 97, 116, 97, 0,
                103, 108, 67, 104, 101, 99, 107, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 83, 116, 97, 116, 117, 115, 0,
                103, 108, 67, 108, 101, 97, 114, 0,
                103, 108, 67, 108, 101, 97, 114, 66, 117, 102, 102, 101, 114, 102, 105, 0,
                103, 108, 67, 108, 101, 97, 114, 66, 117, 102, 102, 101, 114, 102, 118, 0,
                103, 108, 67, 108, 101, 97, 114, 66, 117, 102, 102, 101, 114, 105, 118, 0,
                103, 108, 67, 108, 101, 97, 114, 66, 117, 102, 102, 101, 114, 117, 105, 118, 0,
                103, 108, 67, 108, 101, 97, 114, 67, 111, 108, 111, 114, 0,
                103, 108, 67, 108, 101, 97, 114, 68, 101, 112, 116, 104, 102, 0,
                103, 108, 67, 108, 101, 97, 114, 80, 105, 120, 101, 108, 76, 111, 99, 97, 108, 83, 116, 111, 114, 97, 103, 101, 117, 105, 69, 88, 84, 0,
                103, 108, 67, 108, 101, 97, 114, 83, 116, 101, 110, 99, 105, 108, 0,
                103, 108, 67, 108, 101, 97, 114, 84, 101, 120, 73, 109, 97, 103, 101, 69, 88, 84, 0,
                103, 108, 67, 108, 101, 97, 114, 84, 101, 120, 83, 117, 98, 73, 109, 97, 103, 101, 69, 88, 84, 0,
                103, 108, 67, 108, 105, 101, 110, 116, 87, 97, 105, 116, 83, 121, 110, 99, 0,
                103, 108, 67, 108, 105, 101, 110, 116, 87, 97, 105, 116, 83, 121, 110, 99, 65, 80, 80, 76, 69, 0,
                103, 108, 67, 111, 108, 111, 114, 77, 97, 115, 107, 0,
                103, 108, 67, 111, 108, 111, 114, 77, 97, 115, 107, 105, 69, 88, 84, 0,
                103, 108, 67, 111, 108, 111, 114, 77, 97, 115, 107, 105, 79, 69, 83, 0,
                103, 108, 67, 111, 109, 112, 105, 108, 101, 83, 104, 97, 100, 101, 114, 0,
                103, 108, 67, 111, 109, 112, 114, 101, 115, 115, 101, 100, 84, 101, 120, 73, 109, 97, 103, 101, 50, 68, 0,
                103, 108, 67, 111, 109, 112, 114, 101, 115, 115, 101, 100, 84, 101, 120, 73, 109, 97, 103, 101, 51, 68, 0,
                103, 108, 67, 111, 109, 112, 114, 101, 115, 115, 101, 100, 84, 101, 120, 73, 109, 97, 103, 101, 51, 68, 79, 69, 83, 0,
                103, 108, 67, 111, 109, 112, 114, 101, 115, 115, 101, 100, 84, 101, 120, 83, 117, 98, 73, 109, 97, 103, 101, 50, 68, 0,
                103, 108, 67, 111, 109, 112, 114, 101, 115, 115, 101, 100, 84, 101, 120, 83, 117, 98, 73, 109, 97, 103, 101, 51, 68, 0,
                103, 108, 67, 111, 109, 112, 114, 101, 115, 115, 101, 100, 84, 101, 120, 83, 117, 98, 73, 109, 97, 103, 101, 51, 68, 79, 69, 83, 0,
                103, 108, 67, 111, 110, 115, 101, 114, 118, 97, 116, 105, 118, 101, 82, 97, 115, 116, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 78, 86, 0,
                103, 108, 67, 111, 112, 121, 66, 117, 102, 102, 101, 114, 83, 117, 98, 68, 97, 116, 97, 0,
                103, 108, 67, 111, 112, 121, 66, 117, 102, 102, 101, 114, 83, 117, 98, 68, 97, 116, 97, 78, 86, 0,
                103, 108, 67, 111, 112, 121, 73, 109, 97, 103, 101, 83, 117, 98, 68, 97, 116, 97, 69, 88, 84, 0,
                103, 108, 67, 111, 112, 121, 73, 109, 97, 103, 101, 83, 117, 98, 68, 97, 116, 97, 79, 69, 83, 0,
                103, 108, 67, 111, 112, 121, 80, 97, 116, 104, 78, 86, 0,
                103, 108, 67, 111, 112, 121, 84, 101, 120, 73, 109, 97, 103, 101, 50, 68, 0,
                103, 108, 67, 111, 112, 121, 84, 101, 120, 83, 117, 98, 73, 109, 97, 103, 101, 50, 68, 0,
                103, 108, 67, 111, 112, 121, 84, 101, 120, 83, 117, 98, 73, 109, 97, 103, 101, 51, 68, 0,
                103, 108, 67, 111, 112, 121, 84, 101, 120, 83, 117, 98, 73, 109, 97, 103, 101, 51, 68, 79, 69, 83, 0,
                103, 108, 67, 111, 112, 121, 84, 101, 120, 116, 117, 114, 101, 76, 101, 118, 101, 108, 115, 65, 80, 80, 76, 69, 0,
                103, 108, 67, 111, 118, 101, 114, 97, 103, 101, 77, 97, 115, 107, 78, 86, 0,
                103, 108, 67, 111, 118, 101, 114, 97, 103, 101, 77, 111, 100, 117, 108, 97, 116, 105, 111, 110, 78, 86, 0,
                103, 108, 67, 111, 118, 101, 114, 97, 103, 101, 77, 111, 100, 117, 108, 97, 116, 105, 111, 110, 84, 97, 98, 108, 101, 78, 86, 0,
                103, 108, 67, 111, 118, 101, 114, 97, 103, 101, 79, 112, 101, 114, 97, 116, 105, 111, 110, 78, 86, 0,
                103, 108, 67, 111, 118, 101, 114, 70, 105, 108, 108, 80, 97, 116, 104, 73, 110, 115, 116, 97, 110, 99, 101, 100, 78, 86, 0,
                103, 108, 67, 111, 118, 101, 114, 70, 105, 108, 108, 80, 97, 116, 104, 78, 86, 0,
                103, 108, 67, 111, 118, 101, 114, 83, 116, 114, 111, 107, 101, 80, 97, 116, 104, 73, 110, 115, 116, 97, 110, 99, 101, 100, 78, 86, 0,
                103, 108, 67, 111, 118, 101, 114, 83, 116, 114, 111, 107, 101, 80, 97, 116, 104, 78, 86, 0,
                103, 108, 67, 114, 101, 97, 116, 101, 77, 101, 109, 111, 114, 121, 79, 98, 106, 101, 99, 116, 115, 69, 88, 84, 0,
                103, 108, 67, 114, 101, 97, 116, 101, 80, 101, 114, 102, 81, 117, 101, 114, 121, 73, 78, 84, 69, 76, 0,
                103, 108, 67, 114, 101, 97, 116, 101, 80, 114, 111, 103, 114, 97, 109, 0,
                103, 108, 67, 114, 101, 97, 116, 101, 83, 104, 97, 100, 101, 114, 0,
                103, 108, 67, 114, 101, 97, 116, 101, 83, 104, 97, 100, 101, 114, 80, 114, 111, 103, 114, 97, 109, 69, 88, 84, 0,
                103, 108, 67, 114, 101, 97, 116, 101, 83, 104, 97, 100, 101, 114, 80, 114, 111, 103, 114, 97, 109, 118, 0,
                103, 108, 67, 114, 101, 97, 116, 101, 83, 104, 97, 100, 101, 114, 80, 114, 111, 103, 114, 97, 109, 118, 69, 88, 84, 0,
                103, 108, 67, 117, 108, 108, 70, 97, 99, 101, 0,
                103, 108, 68, 101, 98, 117, 103, 77, 101, 115, 115, 97, 103, 101, 67, 97, 108, 108, 98, 97, 99, 107, 0,
                103, 108, 68, 101, 98, 117, 103, 77, 101, 115, 115, 97, 103, 101, 67, 97, 108, 108, 98, 97, 99, 107, 75, 72, 82, 0,
                103, 108, 68, 101, 98, 117, 103, 77, 101, 115, 115, 97, 103, 101, 67, 111, 110, 116, 114, 111, 108, 0,
                103, 108, 68, 101, 98, 117, 103, 77, 101, 115, 115, 97, 103, 101, 67, 111, 110, 116, 114, 111, 108, 75, 72, 82, 0,
                103, 108, 68, 101, 98, 117, 103, 77, 101, 115, 115, 97, 103, 101, 73, 110, 115, 101, 114, 116, 0,
                103, 108, 68, 101, 98, 117, 103, 77, 101, 115, 115, 97, 103, 101, 73, 110, 115, 101, 114, 116, 75, 72, 82, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 66, 117, 102, 102, 101, 114, 115, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 70, 101, 110, 99, 101, 115, 78, 86, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 115, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 77, 101, 109, 111, 114, 121, 79, 98, 106, 101, 99, 116, 115, 69, 88, 84, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 80, 97, 116, 104, 115, 78, 86, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 80, 101, 114, 102, 77, 111, 110, 105, 116, 111, 114, 115, 65, 77, 68, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 80, 101, 114, 102, 81, 117, 101, 114, 121, 73, 78, 84, 69, 76, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 80, 114, 111, 103, 114, 97, 109, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 115, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 115, 69, 88, 84, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 81, 117, 101, 114, 105, 101, 115, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 81, 117, 101, 114, 105, 101, 115, 69, 88, 84, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 115, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 83, 97, 109, 112, 108, 101, 114, 115, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 83, 101, 109, 97, 112, 104, 111, 114, 101, 115, 69, 88, 84, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 83, 104, 97, 100, 101, 114, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 83, 121, 110, 99, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 83, 121, 110, 99, 65, 80, 80, 76, 69, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 84, 101, 120, 116, 117, 114, 101, 115, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 84, 114, 97, 110, 115, 102, 111, 114, 109, 70, 101, 101, 100, 98, 97, 99, 107, 115, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 86, 101, 114, 116, 101, 120, 65, 114, 114, 97, 121, 115, 0,
                103, 108, 68, 101, 108, 101, 116, 101, 86, 101, 114, 116, 101, 120, 65, 114, 114, 97, 121, 115, 79, 69, 83, 0,
                103, 108, 68, 101, 112, 116, 104, 70, 117, 110, 99, 0,
                103, 108, 68, 101, 112, 116, 104, 77, 97, 115, 107, 0,
                103, 108, 68, 101, 112, 116, 104, 82, 97, 110, 103, 101, 65, 114, 114, 97, 121, 102, 118, 78, 86, 0,
                103, 108, 68, 101, 112, 116, 104, 82, 97, 110, 103, 101, 65, 114, 114, 97, 121, 102, 118, 79, 69, 83, 0,
                103, 108, 68, 101, 112, 116, 104, 82, 97, 110, 103, 101, 102, 0,
                103, 108, 68, 101, 112, 116, 104, 82, 97, 110, 103, 101, 73, 110, 100, 101, 120, 101, 100, 102, 78, 86, 0,
                103, 108, 68, 101, 112, 116, 104, 82, 97, 110, 103, 101, 73, 110, 100, 101, 120, 101, 100, 102, 79, 69, 83, 0,
                103, 108, 68, 101, 116, 97, 99, 104, 83, 104, 97, 100, 101, 114, 0,
                103, 108, 68, 105, 115, 97, 98, 108, 101, 0,
                103, 108, 68, 105, 115, 97, 98, 108, 101, 68, 114, 105, 118, 101, 114, 67, 111, 110, 116, 114, 111, 108, 81, 67, 79, 77, 0,
                103, 108, 68, 105, 115, 97, 98, 108, 101, 105, 69, 88, 84, 0,
                103, 108, 68, 105, 115, 97, 98, 108, 101, 105, 78, 86, 0,
                103, 108, 68, 105, 115, 97, 98, 108, 101, 105, 79, 69, 83, 0,
                103, 108, 68, 105, 115, 97, 98, 108, 101, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 65, 114, 114, 97, 121, 0,
                103, 108, 68, 105, 115, 99, 97, 114, 100, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 69, 88, 84, 0,
                103, 108, 68, 105, 115, 112, 97, 116, 99, 104, 67, 111, 109, 112, 117, 116, 101, 0,
                103, 108, 68, 105, 115, 112, 97, 116, 99, 104, 67, 111, 109, 112, 117, 116, 101, 73, 110, 100, 105, 114, 101, 99, 116, 0,
                103, 108, 68, 114, 97, 119, 65, 114, 114, 97, 121, 115, 0,
                103, 108, 68, 114, 97, 119, 65, 114, 114, 97, 121, 115, 73, 110, 100, 105, 114, 101, 99, 116, 0,
                103, 108, 68, 114, 97, 119, 65, 114, 114, 97, 121, 115, 73, 110, 115, 116, 97, 110, 99, 101, 100, 0,
                103, 108, 68, 114, 97, 119, 65, 114, 114, 97, 121, 115, 73, 110, 115, 116, 97, 110, 99, 101, 100, 65, 78, 71, 76, 69, 0,
                103, 108, 68, 114, 97, 119, 65, 114, 114, 97, 121, 115, 73, 110, 115, 116, 97, 110, 99, 101, 100, 66, 97, 115, 101, 73, 110, 115, 116, 97, 110, 99, 101, 69, 88, 84, 0,
                103, 108, 68, 114, 97, 119, 65, 114, 114, 97, 121, 115, 73, 110, 115, 116, 97, 110, 99, 101, 100, 69, 88, 84, 0,
                103, 108, 68, 114, 97, 119, 65, 114, 114, 97, 121, 115, 73, 110, 115, 116, 97, 110, 99, 101, 100, 78, 86, 0,
                103, 108, 68, 114, 97, 119, 66, 117, 102, 102, 101, 114, 115, 0,
                103, 108, 68, 114, 97, 119, 66, 117, 102, 102, 101, 114, 115, 69, 88, 84, 0,
                103, 108, 68, 114, 97, 119, 66, 117, 102, 102, 101, 114, 115, 73, 110, 100, 101, 120, 101, 100, 69, 88, 84, 0,
                103, 108, 68, 114, 97, 119, 66, 117, 102, 102, 101, 114, 115, 78, 86, 0,
                103, 108, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 0,
                103, 108, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 66, 97, 115, 101, 86, 101, 114, 116, 101, 120, 69, 88, 84, 0,
                103, 108, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 66, 97, 115, 101, 86, 101, 114, 116, 101, 120, 79, 69, 83, 0,
                103, 108, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 73, 110, 100, 105, 114, 101, 99, 116, 0,
                103, 108, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 73, 110, 115, 116, 97, 110, 99, 101, 100, 0,
                103, 108, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 73, 110, 115, 116, 97, 110, 99, 101, 100, 65, 78, 71, 76, 69, 0,
                103, 108, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 73, 110, 115, 116, 97, 110, 99, 101, 100, 66, 97, 115, 101, 73, 110, 115, 116, 97, 110, 99, 101, 69, 88, 84, 0,
                103, 108, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 73, 110, 115, 116, 97, 110, 99, 101, 100, 66, 97, 115, 101, 86, 101, 114, 116, 101, 120, 66, 97, 115, 101, 73, 110, 115, 116, 97, 110, 99, 101, 69, 88, 84, 0,
                103, 108, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 73, 110, 115, 116, 97, 110, 99, 101, 100, 66, 97, 115, 101, 86, 101, 114, 116, 101, 120, 69, 88, 84, 0,
                103, 108, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 73, 110, 115, 116, 97, 110, 99, 101, 100, 66, 97, 115, 101, 86, 101, 114, 116, 101, 120, 79, 69, 83, 0,
                103, 108, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 73, 110, 115, 116, 97, 110, 99, 101, 100, 69, 88, 84, 0,
                103, 108, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 73, 110, 115, 116, 97, 110, 99, 101, 100, 78, 86, 0,
                103, 108, 68, 114, 97, 119, 82, 97, 110, 103, 101, 69, 108, 101, 109, 101, 110, 116, 115, 0,
                103, 108, 68, 114, 97, 119, 82, 97, 110, 103, 101, 69, 108, 101, 109, 101, 110, 116, 115, 66, 97, 115, 101, 86, 101, 114, 116, 101, 120, 69, 88, 84, 0,
                103, 108, 68, 114, 97, 119, 82, 97, 110, 103, 101, 69, 108, 101, 109, 101, 110, 116, 115, 66, 97, 115, 101, 86, 101, 114, 116, 101, 120, 79, 69, 83, 0,
                103, 108, 68, 114, 97, 119, 84, 114, 97, 110, 115, 102, 111, 114, 109, 70, 101, 101, 100, 98, 97, 99, 107, 69, 88, 84, 0,
                103, 108, 68, 114, 97, 119, 84, 114, 97, 110, 115, 102, 111, 114, 109, 70, 101, 101, 100, 98, 97, 99, 107, 73, 110, 115, 116, 97, 110, 99, 101, 100, 69, 88, 84, 0,
                103, 108, 68, 114, 97, 119, 86, 107, 73, 109, 97, 103, 101, 78, 86, 0,
                103, 108, 69, 71, 76, 73, 109, 97, 103, 101, 84, 97, 114, 103, 101, 116, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 83, 116, 111, 114, 97, 103, 101, 79, 69, 83, 0,
                103, 108, 69, 71, 76, 73, 109, 97, 103, 101, 84, 97, 114, 103, 101, 116, 84, 101, 120, 116, 117, 114, 101, 50, 68, 79, 69, 83, 0,
                103, 108, 69, 110, 97, 98, 108, 101, 0,
                103, 108, 69, 110, 97, 98, 108, 101, 68, 114, 105, 118, 101, 114, 67, 111, 110, 116, 114, 111, 108, 81, 67, 79, 77, 0,
                103, 108, 69, 110, 97, 98, 108, 101, 105, 69, 88, 84, 0,
                103, 108, 69, 110, 97, 98, 108, 101, 105, 78, 86, 0,
                103, 108, 69, 110, 97, 98, 108, 101, 105, 79, 69, 83, 0,
                103, 108, 69, 110, 97, 98, 108, 101, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 65, 114, 114, 97, 121, 0,
                103, 108, 69, 110, 100, 67, 111, 110, 100, 105, 116, 105, 111, 110, 97, 108, 82, 101, 110, 100, 101, 114, 78, 86, 0,
                103, 108, 69, 110, 100, 80, 101, 114, 102, 77, 111, 110, 105, 116, 111, 114, 65, 77, 68, 0,
                103, 108, 69, 110, 100, 80, 101, 114, 102, 81, 117, 101, 114, 121, 73, 78, 84, 69, 76, 0,
                103, 108, 69, 110, 100, 81, 117, 101, 114, 121, 0,
                103, 108, 69, 110, 100, 81, 117, 101, 114, 121, 69, 88, 84, 0,
                103, 108, 69, 110, 100, 84, 105, 108, 105, 110, 103, 81, 67, 79, 77, 0,
                103, 108, 69, 110, 100, 84, 114, 97, 110, 115, 102, 111, 114, 109, 70, 101, 101, 100, 98, 97, 99, 107, 0,
                103, 108, 69, 120, 116, 71, 101, 116, 66, 117, 102, 102, 101, 114, 80, 111, 105, 110, 116, 101, 114, 118, 81, 67, 79, 77, 0,
                103, 108, 69, 120, 116, 71, 101, 116, 66, 117, 102, 102, 101, 114, 115, 81, 67, 79, 77, 0,
                103, 108, 69, 120, 116, 71, 101, 116, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 115, 81, 67, 79, 77, 0,
                103, 108, 69, 120, 116, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 66, 105, 110, 97, 114, 121, 83, 111, 117, 114, 99, 101, 81, 67, 79, 77, 0,
                103, 108, 69, 120, 116, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 115, 81, 67, 79, 77, 0,
                103, 108, 69, 120, 116, 71, 101, 116, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 115, 81, 67, 79, 77, 0,
                103, 108, 69, 120, 116, 71, 101, 116, 83, 104, 97, 100, 101, 114, 115, 81, 67, 79, 77, 0,
                103, 108, 69, 120, 116, 71, 101, 116, 84, 101, 120, 76, 101, 118, 101, 108, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 81, 67, 79, 77, 0,
                103, 108, 69, 120, 116, 71, 101, 116, 84, 101, 120, 83, 117, 98, 73, 109, 97, 103, 101, 81, 67, 79, 77, 0,
                103, 108, 69, 120, 116, 71, 101, 116, 84, 101, 120, 116, 117, 114, 101, 115, 81, 67, 79, 77, 0,
                103, 108, 69, 120, 116, 73, 115, 80, 114, 111, 103, 114, 97, 109, 66, 105, 110, 97, 114, 121, 81, 67, 79, 77, 0,
                103, 108, 69, 120, 116, 84, 101, 120, 79, 98, 106, 101, 99, 116, 83, 116, 97, 116, 101, 79, 118, 101, 114, 114, 105, 100, 101, 105, 81, 67, 79, 77, 0,
                103, 108, 70, 101, 110, 99, 101, 83, 121, 110, 99, 0,
                103, 108, 70, 101, 110, 99, 101, 83, 121, 110, 99, 65, 80, 80, 76, 69, 0,
                103, 108, 70, 105, 110, 105, 115, 104, 0,
                103, 108, 70, 105, 110, 105, 115, 104, 70, 101, 110, 99, 101, 78, 86, 0,
                103, 108, 70, 108, 117, 115, 104, 0,
                103, 108, 70, 108, 117, 115, 104, 77, 97, 112, 112, 101, 100, 66, 117, 102, 102, 101, 114, 82, 97, 110, 103, 101, 0,
                103, 108, 70, 108, 117, 115, 104, 77, 97, 112, 112, 101, 100, 66, 117, 102, 102, 101, 114, 82, 97, 110, 103, 101, 69, 88, 84, 0,
                103, 108, 70, 114, 97, 103, 109, 101, 110, 116, 67, 111, 118, 101, 114, 97, 103, 101, 67, 111, 108, 111, 114, 78, 86, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 70, 101, 116, 99, 104, 66, 97, 114, 114, 105, 101, 114, 81, 67, 79, 77, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 70, 111, 118, 101, 97, 116, 105, 111, 110, 67, 111, 110, 102, 105, 103, 81, 67, 79, 77, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 70, 111, 118, 101, 97, 116, 105, 111, 110, 80, 97, 114, 97, 109, 101, 116, 101, 114, 115, 81, 67, 79, 77, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 80, 105, 120, 101, 108, 76, 111, 99, 97, 108, 83, 116, 111, 114, 97, 103, 101, 83, 105, 122, 101, 69, 88, 84, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 83, 97, 109, 112, 108, 101, 76, 111, 99, 97, 116, 105, 111, 110, 115, 102, 118, 78, 86, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 84, 101, 120, 116, 117, 114, 101, 50, 68, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 84, 101, 120, 116, 117, 114, 101, 50, 68, 68, 111, 119, 110, 115, 97, 109, 112, 108, 101, 73, 77, 71, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 84, 101, 120, 116, 117, 114, 101, 50, 68, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 69, 88, 84, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 84, 101, 120, 116, 117, 114, 101, 50, 68, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 73, 77, 71, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 84, 101, 120, 116, 117, 114, 101, 51, 68, 79, 69, 83, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 84, 101, 120, 116, 117, 114, 101, 69, 88, 84, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 84, 101, 120, 116, 117, 114, 101, 76, 97, 121, 101, 114, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 84, 101, 120, 116, 117, 114, 101, 76, 97, 121, 101, 114, 68, 111, 119, 110, 115, 97, 109, 112, 108, 101, 73, 77, 71, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 84, 101, 120, 116, 117, 114, 101, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 77, 117, 108, 116, 105, 118, 105, 101, 119, 79, 86, 82, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 84, 101, 120, 116, 117, 114, 101, 77, 117, 108, 116, 105, 118, 105, 101, 119, 79, 86, 82, 0,
                103, 108, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 84, 101, 120, 116, 117, 114, 101, 79, 69, 83, 0,
                103, 108, 70, 114, 111, 110, 116, 70, 97, 99, 101, 0,
                103, 108, 71, 101, 110, 66, 117, 102, 102, 101, 114, 115, 0,
                103, 108, 71, 101, 110, 101, 114, 97, 116, 101, 77, 105, 112, 109, 97, 112, 0,
                103, 108, 71, 101, 110, 70, 101, 110, 99, 101, 115, 78, 86, 0,
                103, 108, 71, 101, 110, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 115, 0,
                103, 108, 71, 101, 110, 80, 97, 116, 104, 115, 78, 86, 0,
                103, 108, 71, 101, 110, 80, 101, 114, 102, 77, 111, 110, 105, 116, 111, 114, 115, 65, 77, 68, 0,
                103, 108, 71, 101, 110, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 115, 0,
                103, 108, 71, 101, 110, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 115, 69, 88, 84, 0,
                103, 108, 71, 101, 110, 81, 117, 101, 114, 105, 101, 115, 0,
                103, 108, 71, 101, 110, 81, 117, 101, 114, 105, 101, 115, 69, 88, 84, 0,
                103, 108, 71, 101, 110, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 115, 0,
                103, 108, 71, 101, 110, 83, 97, 109, 112, 108, 101, 114, 115, 0,
                103, 108, 71, 101, 110, 83, 101, 109, 97, 112, 104, 111, 114, 101, 115, 69, 88, 84, 0,
                103, 108, 71, 101, 110, 84, 101, 120, 116, 117, 114, 101, 115, 0,
                103, 108, 71, 101, 110, 84, 114, 97, 110, 115, 102, 111, 114, 109, 70, 101, 101, 100, 98, 97, 99, 107, 115, 0,
                103, 108, 71, 101, 110, 86, 101, 114, 116, 101, 120, 65, 114, 114, 97, 121, 115, 0,
                103, 108, 71, 101, 110, 86, 101, 114, 116, 101, 120, 65, 114, 114, 97, 121, 115, 79, 69, 83, 0,
                103, 108, 71, 101, 116, 65, 99, 116, 105, 118, 101, 65, 116, 116, 114, 105, 98, 0,
                103, 108, 71, 101, 116, 65, 99, 116, 105, 118, 101, 85, 110, 105, 102, 111, 114, 109, 0,
                103, 108, 71, 101, 116, 65, 99, 116, 105, 118, 101, 85, 110, 105, 102, 111, 114, 109, 66, 108, 111, 99, 107, 105, 118, 0,
                103, 108, 71, 101, 116, 65, 99, 116, 105, 118, 101, 85, 110, 105, 102, 111, 114, 109, 66, 108, 111, 99, 107, 78, 97, 109, 101, 0,
                103, 108, 71, 101, 116, 65, 99, 116, 105, 118, 101, 85, 110, 105, 102, 111, 114, 109, 115, 105, 118, 0,
                103, 108, 71, 101, 116, 65, 116, 116, 97, 99, 104, 101, 100, 83, 104, 97, 100, 101, 114, 115, 0,
                103, 108, 71, 101, 116, 65, 116, 116, 114, 105, 98, 76, 111, 99, 97, 116, 105, 111, 110, 0,
                103, 108, 71, 101, 116, 66, 111, 111, 108, 101, 97, 110, 105, 95, 118, 0,
                103, 108, 71, 101, 116, 66, 111, 111, 108, 101, 97, 110, 118, 0,
                103, 108, 71, 101, 116, 66, 117, 102, 102, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 54, 52, 118, 0,
                103, 108, 71, 101, 116, 66, 117, 102, 102, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 0,
                103, 108, 71, 101, 116, 66, 117, 102, 102, 101, 114, 80, 111, 105, 110, 116, 101, 114, 118, 0,
                103, 108, 71, 101, 116, 66, 117, 102, 102, 101, 114, 80, 111, 105, 110, 116, 101, 114, 118, 79, 69, 83, 0,
                103, 108, 71, 101, 116, 67, 111, 118, 101, 114, 97, 103, 101, 77, 111, 100, 117, 108, 97, 116, 105, 111, 110, 84, 97, 98, 108, 101, 78, 86, 0,
                103, 108, 71, 101, 116, 68, 101, 98, 117, 103, 77, 101, 115, 115, 97, 103, 101, 76, 111, 103, 0,
                103, 108, 71, 101, 116, 68, 101, 98, 117, 103, 77, 101, 115, 115, 97, 103, 101, 76, 111, 103, 75, 72, 82, 0,
                103, 108, 71, 101, 116, 68, 114, 105, 118, 101, 114, 67, 111, 110, 116, 114, 111, 108, 115, 81, 67, 79, 77, 0,
                103, 108, 71, 101, 116, 68, 114, 105, 118, 101, 114, 67, 111, 110, 116, 114, 111, 108, 83, 116, 114, 105, 110, 103, 81, 67, 79, 77, 0,
                103, 108, 71, 101, 116, 69, 114, 114, 111, 114, 0,
                103, 108, 71, 101, 116, 70, 101, 110, 99, 101, 105, 118, 78, 86, 0,
                103, 108, 71, 101, 116, 70, 105, 114, 115, 116, 80, 101, 114, 102, 81, 117, 101, 114, 121, 73, 100, 73, 78, 84, 69, 76, 0,
                103, 108, 71, 101, 116, 70, 108, 111, 97, 116, 105, 95, 118, 78, 86, 0,
                103, 108, 71, 101, 116, 70, 108, 111, 97, 116, 105, 95, 118, 79, 69, 83, 0,
                103, 108, 71, 101, 116, 70, 108, 111, 97, 116, 118, 0,
                103, 108, 71, 101, 116, 70, 114, 97, 103, 68, 97, 116, 97, 73, 110, 100, 101, 120, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 70, 114, 97, 103, 68, 97, 116, 97, 76, 111, 99, 97, 116, 105, 111, 110, 0,
                103, 108, 71, 101, 116, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 65, 116, 116, 97, 99, 104, 109, 101, 110, 116, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 0,
                103, 108, 71, 101, 116, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 0,
                103, 108, 71, 101, 116, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 80, 105, 120, 101, 108, 76, 111, 99, 97, 108, 83, 116, 111, 114, 97, 103, 101, 83, 105, 122, 101, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 71, 114, 97, 112, 104, 105, 99, 115, 82, 101, 115, 101, 116, 83, 116, 97, 116, 117, 115, 0,
                103, 108, 71, 101, 116, 71, 114, 97, 112, 104, 105, 99, 115, 82, 101, 115, 101, 116, 83, 116, 97, 116, 117, 115, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 71, 114, 97, 112, 104, 105, 99, 115, 82, 101, 115, 101, 116, 83, 116, 97, 116, 117, 115, 75, 72, 82, 0,
                103, 108, 71, 101, 116, 73, 109, 97, 103, 101, 72, 97, 110, 100, 108, 101, 78, 86, 0,
                103, 108, 71, 101, 116, 73, 110, 116, 101, 103, 101, 114, 54, 52, 105, 95, 118, 0,
                103, 108, 71, 101, 116, 73, 110, 116, 101, 103, 101, 114, 54, 52, 118, 0,
                103, 108, 71, 101, 116, 73, 110, 116, 101, 103, 101, 114, 54, 52, 118, 65, 80, 80, 76, 69, 0,
                103, 108, 71, 101, 116, 73, 110, 116, 101, 103, 101, 114, 105, 95, 118, 0,
                103, 108, 71, 101, 116, 73, 110, 116, 101, 103, 101, 114, 105, 95, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 73, 110, 116, 101, 103, 101, 114, 118, 0,
                103, 108, 71, 101, 116, 73, 110, 116, 101, 114, 110, 97, 108, 102, 111, 114, 109, 97, 116, 105, 118, 0,
                103, 108, 71, 101, 116, 73, 110, 116, 101, 114, 110, 97, 108, 102, 111, 114, 109, 97, 116, 83, 97, 109, 112, 108, 101, 105, 118, 78, 86, 0,
                103, 108, 71, 101, 116, 77, 101, 109, 111, 114, 121, 79, 98, 106, 101, 99, 116, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 102, 118, 0,
                103, 108, 71, 101, 116, 78, 101, 120, 116, 80, 101, 114, 102, 81, 117, 101, 114, 121, 73, 100, 73, 78, 84, 69, 76, 0,
                103, 108, 71, 101, 116, 110, 85, 110, 105, 102, 111, 114, 109, 102, 118, 0,
                103, 108, 71, 101, 116, 110, 85, 110, 105, 102, 111, 114, 109, 102, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 110, 85, 110, 105, 102, 111, 114, 109, 102, 118, 75, 72, 82, 0,
                103, 108, 71, 101, 116, 110, 85, 110, 105, 102, 111, 114, 109, 105, 118, 0,
                103, 108, 71, 101, 116, 110, 85, 110, 105, 102, 111, 114, 109, 105, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 110, 85, 110, 105, 102, 111, 114, 109, 105, 118, 75, 72, 82, 0,
                103, 108, 71, 101, 116, 110, 85, 110, 105, 102, 111, 114, 109, 117, 105, 118, 0,
                103, 108, 71, 101, 116, 110, 85, 110, 105, 102, 111, 114, 109, 117, 105, 118, 75, 72, 82, 0,
                103, 108, 71, 101, 116, 79, 98, 106, 101, 99, 116, 76, 97, 98, 101, 108, 0,
                103, 108, 71, 101, 116, 79, 98, 106, 101, 99, 116, 76, 97, 98, 101, 108, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 79, 98, 106, 101, 99, 116, 76, 97, 98, 101, 108, 75, 72, 82, 0,
                103, 108, 71, 101, 116, 79, 98, 106, 101, 99, 116, 80, 116, 114, 76, 97, 98, 101, 108, 0,
                103, 108, 71, 101, 116, 79, 98, 106, 101, 99, 116, 80, 116, 114, 76, 97, 98, 101, 108, 75, 72, 82, 0,
                103, 108, 71, 101, 116, 80, 97, 116, 104, 67, 111, 108, 111, 114, 71, 101, 110, 102, 118, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 97, 116, 104, 67, 111, 108, 111, 114, 71, 101, 110, 105, 118, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 97, 116, 104, 67, 111, 109, 109, 97, 110, 100, 115, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 97, 116, 104, 67, 111, 111, 114, 100, 115, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 97, 116, 104, 68, 97, 115, 104, 65, 114, 114, 97, 121, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 97, 116, 104, 76, 101, 110, 103, 116, 104, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 97, 116, 104, 77, 101, 116, 114, 105, 99, 82, 97, 110, 103, 101, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 97, 116, 104, 77, 101, 116, 114, 105, 99, 115, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 97, 116, 104, 80, 97, 114, 97, 109, 101, 116, 101, 114, 102, 118, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 97, 116, 104, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 97, 116, 104, 83, 112, 97, 99, 105, 110, 103, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 97, 116, 104, 84, 101, 120, 71, 101, 110, 102, 118, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 97, 116, 104, 84, 101, 120, 71, 101, 110, 105, 118, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 101, 114, 102, 67, 111, 117, 110, 116, 101, 114, 73, 110, 102, 111, 73, 78, 84, 69, 76, 0,
                103, 108, 71, 101, 116, 80, 101, 114, 102, 77, 111, 110, 105, 116, 111, 114, 67, 111, 117, 110, 116, 101, 114, 68, 97, 116, 97, 65, 77, 68, 0,
                103, 108, 71, 101, 116, 80, 101, 114, 102, 77, 111, 110, 105, 116, 111, 114, 67, 111, 117, 110, 116, 101, 114, 73, 110, 102, 111, 65, 77, 68, 0,
                103, 108, 71, 101, 116, 80, 101, 114, 102, 77, 111, 110, 105, 116, 111, 114, 67, 111, 117, 110, 116, 101, 114, 115, 65, 77, 68, 0,
                103, 108, 71, 101, 116, 80, 101, 114, 102, 77, 111, 110, 105, 116, 111, 114, 67, 111, 117, 110, 116, 101, 114, 83, 116, 114, 105, 110, 103, 65, 77, 68, 0,
                103, 108, 71, 101, 116, 80, 101, 114, 102, 77, 111, 110, 105, 116, 111, 114, 71, 114, 111, 117, 112, 115, 65, 77, 68, 0,
                103, 108, 71, 101, 116, 80, 101, 114, 102, 77, 111, 110, 105, 116, 111, 114, 71, 114, 111, 117, 112, 83, 116, 114, 105, 110, 103, 65, 77, 68, 0,
                103, 108, 71, 101, 116, 80, 101, 114, 102, 81, 117, 101, 114, 121, 68, 97, 116, 97, 73, 78, 84, 69, 76, 0,
                103, 108, 71, 101, 116, 80, 101, 114, 102, 81, 117, 101, 114, 121, 73, 100, 66, 121, 78, 97, 109, 101, 73, 78, 84, 69, 76, 0,
                103, 108, 71, 101, 116, 80, 101, 114, 102, 81, 117, 101, 114, 121, 73, 110, 102, 111, 73, 78, 84, 69, 76, 0,
                103, 108, 71, 101, 116, 80, 111, 105, 110, 116, 101, 114, 118, 0,
                103, 108, 71, 101, 116, 80, 111, 105, 110, 116, 101, 114, 118, 75, 72, 82, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 66, 105, 110, 97, 114, 121, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 66, 105, 110, 97, 114, 121, 79, 69, 83, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 73, 110, 102, 111, 76, 111, 103, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 73, 110, 116, 101, 114, 102, 97, 99, 101, 105, 118, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 105, 118, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 73, 110, 102, 111, 76, 111, 103, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 73, 110, 102, 111, 76, 111, 103, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 105, 118, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 105, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 82, 101, 115, 111, 117, 114, 99, 101, 102, 118, 78, 86, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 82, 101, 115, 111, 117, 114, 99, 101, 73, 110, 100, 101, 120, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 82, 101, 115, 111, 117, 114, 99, 101, 105, 118, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 82, 101, 115, 111, 117, 114, 99, 101, 76, 111, 99, 97, 116, 105, 111, 110, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 82, 101, 115, 111, 117, 114, 99, 101, 76, 111, 99, 97, 116, 105, 111, 110, 73, 110, 100, 101, 120, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 80, 114, 111, 103, 114, 97, 109, 82, 101, 115, 111, 117, 114, 99, 101, 78, 97, 109, 101, 0,
                103, 108, 71, 101, 116, 81, 117, 101, 114, 121, 105, 118, 0,
                103, 108, 71, 101, 116, 81, 117, 101, 114, 121, 105, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 81, 117, 101, 114, 121, 79, 98, 106, 101, 99, 116, 105, 54, 52, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 81, 117, 101, 114, 121, 79, 98, 106, 101, 99, 116, 105, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 81, 117, 101, 114, 121, 79, 98, 106, 101, 99, 116, 117, 105, 54, 52, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 81, 117, 101, 114, 121, 79, 98, 106, 101, 99, 116, 117, 105, 118, 0,
                103, 108, 71, 101, 116, 81, 117, 101, 114, 121, 79, 98, 106, 101, 99, 116, 117, 105, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 0,
                103, 108, 71, 101, 116, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 102, 118, 0,
                103, 108, 71, 101, 116, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 105, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 105, 118, 79, 69, 83, 0,
                103, 108, 71, 101, 116, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 117, 105, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 117, 105, 118, 79, 69, 83, 0,
                103, 108, 71, 101, 116, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 0,
                103, 108, 71, 101, 116, 83, 101, 109, 97, 112, 104, 111, 114, 101, 80, 97, 114, 97, 109, 101, 116, 101, 114, 117, 105, 54, 52, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 83, 104, 97, 100, 101, 114, 73, 110, 102, 111, 76, 111, 103, 0,
                103, 108, 71, 101, 116, 83, 104, 97, 100, 101, 114, 105, 118, 0,
                103, 108, 71, 101, 116, 83, 104, 97, 100, 101, 114, 80, 114, 101, 99, 105, 115, 105, 111, 110, 70, 111, 114, 109, 97, 116, 0,
                103, 108, 71, 101, 116, 83, 104, 97, 100, 101, 114, 83, 111, 117, 114, 99, 101, 0,
                103, 108, 71, 101, 116, 83, 116, 114, 105, 110, 103, 0,
                103, 108, 71, 101, 116, 83, 116, 114, 105, 110, 103, 105, 0,
                103, 108, 71, 101, 116, 83, 121, 110, 99, 105, 118, 0,
                103, 108, 71, 101, 116, 83, 121, 110, 99, 105, 118, 65, 80, 80, 76, 69, 0,
                103, 108, 71, 101, 116, 84, 101, 120, 76, 101, 118, 101, 108, 80, 97, 114, 97, 109, 101, 116, 101, 114, 102, 118, 0,
                103, 108, 71, 101, 116, 84, 101, 120, 76, 101, 118, 101, 108, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 0,
                103, 108, 71, 101, 116, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 102, 118, 0,
                103, 108, 71, 101, 116, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 105, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 105, 118, 79, 69, 83, 0,
                103, 108, 71, 101, 116, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 117, 105, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 117, 105, 118, 79, 69, 83, 0,
                103, 108, 71, 101, 116, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 0,
                103, 108, 71, 101, 116, 84, 101, 120, 116, 117, 114, 101, 72, 97, 110, 100, 108, 101, 73, 77, 71, 0,
                103, 108, 71, 101, 116, 84, 101, 120, 116, 117, 114, 101, 72, 97, 110, 100, 108, 101, 78, 86, 0,
                103, 108, 71, 101, 116, 84, 101, 120, 116, 117, 114, 101, 83, 97, 109, 112, 108, 101, 114, 72, 97, 110, 100, 108, 101, 73, 77, 71, 0,
                103, 108, 71, 101, 116, 84, 101, 120, 116, 117, 114, 101, 83, 97, 109, 112, 108, 101, 114, 72, 97, 110, 100, 108, 101, 78, 86, 0,
                103, 108, 71, 101, 116, 84, 114, 97, 110, 115, 102, 111, 114, 109, 70, 101, 101, 100, 98, 97, 99, 107, 86, 97, 114, 121, 105, 110, 103, 0,
                103, 108, 71, 101, 116, 84, 114, 97, 110, 115, 108, 97, 116, 101, 100, 83, 104, 97, 100, 101, 114, 83, 111, 117, 114, 99, 101, 65, 78, 71, 76, 69, 0,
                103, 108, 71, 101, 116, 85, 110, 105, 102, 111, 114, 109, 66, 108, 111, 99, 107, 73, 110, 100, 101, 120, 0,
                103, 108, 71, 101, 116, 85, 110, 105, 102, 111, 114, 109, 102, 118, 0,
                103, 108, 71, 101, 116, 85, 110, 105, 102, 111, 114, 109, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 71, 101, 116, 85, 110, 105, 102, 111, 114, 109, 73, 110, 100, 105, 99, 101, 115, 0,
                103, 108, 71, 101, 116, 85, 110, 105, 102, 111, 114, 109, 105, 118, 0,
                103, 108, 71, 101, 116, 85, 110, 105, 102, 111, 114, 109, 76, 111, 99, 97, 116, 105, 111, 110, 0,
                103, 108, 71, 101, 116, 85, 110, 105, 102, 111, 114, 109, 117, 105, 118, 0,
                103, 108, 71, 101, 116, 85, 110, 115, 105, 103, 110, 101, 100, 66, 121, 116, 101, 105, 95, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 85, 110, 115, 105, 103, 110, 101, 100, 66, 121, 116, 101, 118, 69, 88, 84, 0,
                103, 108, 71, 101, 116, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 102, 118, 0,
                103, 108, 71, 101, 116, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 73, 105, 118, 0,
                103, 108, 71, 101, 116, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 73, 117, 105, 118, 0,
                103, 108, 71, 101, 116, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 105, 118, 0,
                103, 108, 71, 101, 116, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 80, 111, 105, 110, 116, 101, 114, 118, 0,
                103, 108, 71, 101, 116, 86, 107, 80, 114, 111, 99, 65, 100, 100, 114, 78, 86, 0,
                103, 108, 72, 105, 110, 116, 0,
                103, 108, 73, 109, 112, 111, 114, 116, 77, 101, 109, 111, 114, 121, 70, 100, 69, 88, 84, 0,
                103, 108, 73, 109, 112, 111, 114, 116, 77, 101, 109, 111, 114, 121, 87, 105, 110, 51, 50, 72, 97, 110, 100, 108, 101, 69, 88, 84, 0,
                103, 108, 73, 109, 112, 111, 114, 116, 77, 101, 109, 111, 114, 121, 87, 105, 110, 51, 50, 78, 97, 109, 101, 69, 88, 84, 0,
                103, 108, 73, 109, 112, 111, 114, 116, 83, 101, 109, 97, 112, 104, 111, 114, 101, 70, 100, 69, 88, 84, 0,
                103, 108, 73, 109, 112, 111, 114, 116, 83, 101, 109, 97, 112, 104, 111, 114, 101, 87, 105, 110, 51, 50, 72, 97, 110, 100, 108, 101, 69, 88, 84, 0,
                103, 108, 73, 109, 112, 111, 114, 116, 83, 101, 109, 97, 112, 104, 111, 114, 101, 87, 105, 110, 51, 50, 78, 97, 109, 101, 69, 88, 84, 0,
                103, 108, 73, 110, 115, 101, 114, 116, 69, 118, 101, 110, 116, 77, 97, 114, 107, 101, 114, 69, 88, 84, 0,
                103, 108, 73, 110, 116, 101, 114, 112, 111, 108, 97, 116, 101, 80, 97, 116, 104, 115, 78, 86, 0,
                103, 108, 73, 110, 118, 97, 108, 105, 100, 97, 116, 101, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 0,
                103, 108, 73, 110, 118, 97, 108, 105, 100, 97, 116, 101, 83, 117, 98, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 0,
                103, 108, 73, 115, 66, 117, 102, 102, 101, 114, 0,
                103, 108, 73, 115, 69, 110, 97, 98, 108, 101, 100, 0,
                103, 108, 73, 115, 69, 110, 97, 98, 108, 101, 100, 105, 69, 88, 84, 0,
                103, 108, 73, 115, 69, 110, 97, 98, 108, 101, 100, 105, 78, 86, 0,
                103, 108, 73, 115, 69, 110, 97, 98, 108, 101, 100, 105, 79, 69, 83, 0,
                103, 108, 73, 115, 70, 101, 110, 99, 101, 78, 86, 0,
                103, 108, 73, 115, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 0,
                103, 108, 73, 115, 73, 109, 97, 103, 101, 72, 97, 110, 100, 108, 101, 82, 101, 115, 105, 100, 101, 110, 116, 78, 86, 0,
                103, 108, 73, 115, 77, 101, 109, 111, 114, 121, 79, 98, 106, 101, 99, 116, 69, 88, 84, 0,
                103, 108, 73, 115, 80, 97, 116, 104, 78, 86, 0,
                103, 108, 73, 115, 80, 111, 105, 110, 116, 73, 110, 70, 105, 108, 108, 80, 97, 116, 104, 78, 86, 0,
                103, 108, 73, 115, 80, 111, 105, 110, 116, 73, 110, 83, 116, 114, 111, 107, 101, 80, 97, 116, 104, 78, 86, 0,
                103, 108, 73, 115, 80, 114, 111, 103, 114, 97, 109, 0,
                103, 108, 73, 115, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 0,
                103, 108, 73, 115, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 69, 88, 84, 0,
                103, 108, 73, 115, 81, 117, 101, 114, 121, 0,
                103, 108, 73, 115, 81, 117, 101, 114, 121, 69, 88, 84, 0,
                103, 108, 73, 115, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 0,
                103, 108, 73, 115, 83, 97, 109, 112, 108, 101, 114, 0,
                103, 108, 73, 115, 83, 101, 109, 97, 112, 104, 111, 114, 101, 69, 88, 84, 0,
                103, 108, 73, 115, 83, 104, 97, 100, 101, 114, 0,
                103, 108, 73, 115, 83, 121, 110, 99, 0,
                103, 108, 73, 115, 83, 121, 110, 99, 65, 80, 80, 76, 69, 0,
                103, 108, 73, 115, 84, 101, 120, 116, 117, 114, 101, 0,
                103, 108, 73, 115, 84, 101, 120, 116, 117, 114, 101, 72, 97, 110, 100, 108, 101, 82, 101, 115, 105, 100, 101, 110, 116, 78, 86, 0,
                103, 108, 73, 115, 84, 114, 97, 110, 115, 102, 111, 114, 109, 70, 101, 101, 100, 98, 97, 99, 107, 0,
                103, 108, 73, 115, 86, 101, 114, 116, 101, 120, 65, 114, 114, 97, 121, 0,
                103, 108, 73, 115, 86, 101, 114, 116, 101, 120, 65, 114, 114, 97, 121, 79, 69, 83, 0,
                103, 108, 76, 97, 98, 101, 108, 79, 98, 106, 101, 99, 116, 69, 88, 84, 0,
                103, 108, 76, 105, 110, 101, 87, 105, 100, 116, 104, 0,
                103, 108, 76, 105, 110, 107, 80, 114, 111, 103, 114, 97, 109, 0,
                103, 108, 77, 97, 107, 101, 73, 109, 97, 103, 101, 72, 97, 110, 100, 108, 101, 78, 111, 110, 82, 101, 115, 105, 100, 101, 110, 116, 78, 86, 0,
                103, 108, 77, 97, 107, 101, 73, 109, 97, 103, 101, 72, 97, 110, 100, 108, 101, 82, 101, 115, 105, 100, 101, 110, 116, 78, 86, 0,
                103, 108, 77, 97, 107, 101, 84, 101, 120, 116, 117, 114, 101, 72, 97, 110, 100, 108, 101, 78, 111, 110, 82, 101, 115, 105, 100, 101, 110, 116, 78, 86, 0,
                103, 108, 77, 97, 107, 101, 84, 101, 120, 116, 117, 114, 101, 72, 97, 110, 100, 108, 101, 82, 101, 115, 105, 100, 101, 110, 116, 78, 86, 0,
                103, 108, 77, 97, 112, 66, 117, 102, 102, 101, 114, 79, 69, 83, 0,
                103, 108, 77, 97, 112, 66, 117, 102, 102, 101, 114, 82, 97, 110, 103, 101, 0,
                103, 108, 77, 97, 112, 66, 117, 102, 102, 101, 114, 82, 97, 110, 103, 101, 69, 88, 84, 0,
                103, 108, 77, 97, 116, 114, 105, 120, 76, 111, 97, 100, 51, 120, 50, 102, 78, 86, 0,
                103, 108, 77, 97, 116, 114, 105, 120, 76, 111, 97, 100, 51, 120, 51, 102, 78, 86, 0,
                103, 108, 77, 97, 116, 114, 105, 120, 76, 111, 97, 100, 84, 114, 97, 110, 115, 112, 111, 115, 101, 51, 120, 51, 102, 78, 86, 0,
                103, 108, 77, 97, 116, 114, 105, 120, 77, 117, 108, 116, 51, 120, 50, 102, 78, 86, 0,
                103, 108, 77, 97, 116, 114, 105, 120, 77, 117, 108, 116, 51, 120, 51, 102, 78, 86, 0,
                103, 108, 77, 97, 116, 114, 105, 120, 77, 117, 108, 116, 84, 114, 97, 110, 115, 112, 111, 115, 101, 51, 120, 51, 102, 78, 86, 0,
                103, 108, 77, 101, 109, 111, 114, 121, 66, 97, 114, 114, 105, 101, 114, 0,
                103, 108, 77, 101, 109, 111, 114, 121, 66, 97, 114, 114, 105, 101, 114, 66, 121, 82, 101, 103, 105, 111, 110, 0,
                103, 108, 77, 101, 109, 111, 114, 121, 79, 98, 106, 101, 99, 116, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 69, 88, 84, 0,
                103, 108, 77, 105, 110, 83, 97, 109, 112, 108, 101, 83, 104, 97, 100, 105, 110, 103, 79, 69, 83, 0,
                103, 108, 77, 117, 108, 116, 105, 68, 114, 97, 119, 65, 114, 114, 97, 121, 115, 69, 88, 84, 0,
                103, 108, 77, 117, 108, 116, 105, 68, 114, 97, 119, 65, 114, 114, 97, 121, 115, 73, 110, 100, 105, 114, 101, 99, 116, 69, 88, 84, 0,
                103, 108, 77, 117, 108, 116, 105, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 66, 97, 115, 101, 86, 101, 114, 116, 101, 120, 69, 88, 84, 0,
                103, 108, 77, 117, 108, 116, 105, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 69, 88, 84, 0,
                103, 108, 77, 117, 108, 116, 105, 68, 114, 97, 119, 69, 108, 101, 109, 101, 110, 116, 115, 73, 110, 100, 105, 114, 101, 99, 116, 69, 88, 84, 0,
                103, 108, 78, 97, 109, 101, 100, 66, 117, 102, 102, 101, 114, 83, 116, 111, 114, 97, 103, 101, 69, 120, 116, 101, 114, 110, 97, 108, 69, 88, 84, 0,
                103, 108, 78, 97, 109, 101, 100, 66, 117, 102, 102, 101, 114, 83, 116, 111, 114, 97, 103, 101, 77, 101, 109, 69, 88, 84, 0,
                103, 108, 78, 97, 109, 101, 100, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 83, 97, 109, 112, 108, 101, 76, 111, 99, 97, 116, 105, 111, 110, 115, 102, 118, 78, 86, 0,
                103, 108, 79, 98, 106, 101, 99, 116, 76, 97, 98, 101, 108, 0,
                103, 108, 79, 98, 106, 101, 99, 116, 76, 97, 98, 101, 108, 75, 72, 82, 0,
                103, 108, 79, 98, 106, 101, 99, 116, 80, 116, 114, 76, 97, 98, 101, 108, 0,
                103, 108, 79, 98, 106, 101, 99, 116, 80, 116, 114, 76, 97, 98, 101, 108, 75, 72, 82, 0,
                103, 108, 80, 97, 116, 99, 104, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 69, 88, 84, 0,
                103, 108, 80, 97, 116, 99, 104, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 79, 69, 83, 0,
                103, 108, 80, 97, 116, 104, 67, 111, 108, 111, 114, 71, 101, 110, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 67, 111, 109, 109, 97, 110, 100, 115, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 67, 111, 111, 114, 100, 115, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 67, 111, 118, 101, 114, 68, 101, 112, 116, 104, 70, 117, 110, 99, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 68, 97, 115, 104, 65, 114, 114, 97, 121, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 70, 111, 103, 71, 101, 110, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 71, 108, 121, 112, 104, 73, 110, 100, 101, 120, 65, 114, 114, 97, 121, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 71, 108, 121, 112, 104, 73, 110, 100, 101, 120, 82, 97, 110, 103, 101, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 71, 108, 121, 112, 104, 82, 97, 110, 103, 101, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 71, 108, 121, 112, 104, 115, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 77, 101, 109, 111, 114, 121, 71, 108, 121, 112, 104, 73, 110, 100, 101, 120, 65, 114, 114, 97, 121, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 80, 97, 114, 97, 109, 101, 116, 101, 114, 102, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 80, 97, 114, 97, 109, 101, 116, 101, 114, 102, 118, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 83, 116, 101, 110, 99, 105, 108, 68, 101, 112, 116, 104, 79, 102, 102, 115, 101, 116, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 83, 116, 101, 110, 99, 105, 108, 70, 117, 110, 99, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 83, 116, 114, 105, 110, 103, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 83, 117, 98, 67, 111, 109, 109, 97, 110, 100, 115, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 83, 117, 98, 67, 111, 111, 114, 100, 115, 78, 86, 0,
                103, 108, 80, 97, 116, 104, 84, 101, 120, 71, 101, 110, 78, 86, 0,
                103, 108, 80, 97, 117, 115, 101, 84, 114, 97, 110, 115, 102, 111, 114, 109, 70, 101, 101, 100, 98, 97, 99, 107, 0,
                103, 108, 80, 105, 120, 101, 108, 83, 116, 111, 114, 101, 105, 0,
                103, 108, 80, 111, 105, 110, 116, 65, 108, 111, 110, 103, 80, 97, 116, 104, 78, 86, 0,
                103, 108, 80, 111, 108, 121, 103, 111, 110, 77, 111, 100, 101, 78, 86, 0,
                103, 108, 80, 111, 108, 121, 103, 111, 110, 79, 102, 102, 115, 101, 116, 0,
                103, 108, 80, 111, 108, 121, 103, 111, 110, 79, 102, 102, 115, 101, 116, 67, 108, 97, 109, 112, 69, 88, 84, 0,
                103, 108, 80, 111, 112, 68, 101, 98, 117, 103, 71, 114, 111, 117, 112, 0,
                103, 108, 80, 111, 112, 68, 101, 98, 117, 103, 71, 114, 111, 117, 112, 75, 72, 82, 0,
                103, 108, 80, 111, 112, 71, 114, 111, 117, 112, 77, 97, 114, 107, 101, 114, 69, 88, 84, 0,
                103, 108, 80, 114, 105, 109, 105, 116, 105, 118, 101, 66, 111, 117, 110, 100, 105, 110, 103, 66, 111, 120, 69, 88, 84, 0,
                103, 108, 80, 114, 105, 109, 105, 116, 105, 118, 101, 66, 111, 117, 110, 100, 105, 110, 103, 66, 111, 120, 79, 69, 83, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 66, 105, 110, 97, 114, 121, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 66, 105, 110, 97, 114, 121, 79, 69, 83, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 80, 97, 116, 104, 70, 114, 97, 103, 109, 101, 110, 116, 73, 110, 112, 117, 116, 71, 101, 110, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 102, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 102, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 102, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 102, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 105, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 105, 54, 52, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 105, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 105, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 105, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 117, 105, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 117, 105, 54, 52, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 117, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 117, 105, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 117, 105, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 49, 117, 105, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 102, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 102, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 102, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 102, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 105, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 105, 54, 52, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 105, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 105, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 105, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 117, 105, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 117, 105, 54, 52, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 117, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 117, 105, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 117, 105, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 50, 117, 105, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 102, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 102, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 102, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 102, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 105, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 105, 54, 52, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 105, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 105, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 105, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 117, 105, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 117, 105, 54, 52, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 117, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 117, 105, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 117, 105, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 51, 117, 105, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 102, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 102, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 102, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 102, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 105, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 105, 54, 52, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 105, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 105, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 105, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 117, 105, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 117, 105, 54, 52, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 117, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 117, 105, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 117, 105, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 52, 117, 105, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 72, 97, 110, 100, 108, 101, 117, 105, 54, 52, 73, 77, 71, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 72, 97, 110, 100, 108, 101, 117, 105, 54, 52, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 72, 97, 110, 100, 108, 101, 117, 105, 54, 52, 118, 73, 77, 71, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 72, 97, 110, 100, 108, 101, 117, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 50, 102, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 50, 102, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 50, 120, 51, 102, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 50, 120, 51, 102, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 50, 120, 52, 102, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 50, 120, 52, 102, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 51, 102, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 51, 102, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 51, 120, 50, 102, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 51, 120, 50, 102, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 51, 120, 52, 102, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 51, 120, 52, 102, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 52, 102, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 52, 102, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 52, 120, 50, 102, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 52, 120, 50, 102, 118, 69, 88, 84, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 52, 120, 51, 102, 118, 0,
                103, 108, 80, 114, 111, 103, 114, 97, 109, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 52, 120, 51, 102, 118, 69, 88, 84, 0,
                103, 108, 80, 117, 115, 104, 68, 101, 98, 117, 103, 71, 114, 111, 117, 112, 0,
                103, 108, 80, 117, 115, 104, 68, 101, 98, 117, 103, 71, 114, 111, 117, 112, 75, 72, 82, 0,
                103, 108, 80, 117, 115, 104, 71, 114, 111, 117, 112, 77, 97, 114, 107, 101, 114, 69, 88, 84, 0,
                103, 108, 81, 117, 101, 114, 121, 67, 111, 117, 110, 116, 101, 114, 69, 88, 84, 0,
                103, 108, 82, 97, 115, 116, 101, 114, 83, 97, 109, 112, 108, 101, 115, 69, 88, 84, 0,
                103, 108, 82, 101, 97, 100, 66, 117, 102, 102, 101, 114, 0,
                103, 108, 82, 101, 97, 100, 66, 117, 102, 102, 101, 114, 73, 110, 100, 101, 120, 101, 100, 69, 88, 84, 0,
                103, 108, 82, 101, 97, 100, 66, 117, 102, 102, 101, 114, 78, 86, 0,
                103, 108, 82, 101, 97, 100, 110, 80, 105, 120, 101, 108, 115, 0,
                103, 108, 82, 101, 97, 100, 110, 80, 105, 120, 101, 108, 115, 69, 88, 84, 0,
                103, 108, 82, 101, 97, 100, 110, 80, 105, 120, 101, 108, 115, 75, 72, 82, 0,
                103, 108, 82, 101, 97, 100, 80, 105, 120, 101, 108, 115, 0,
                103, 108, 82, 101, 108, 101, 97, 115, 101, 75, 101, 121, 101, 100, 77, 117, 116, 101, 120, 87, 105, 110, 51, 50, 69, 88, 84, 0,
                103, 108, 82, 101, 108, 101, 97, 115, 101, 83, 104, 97, 100, 101, 114, 67, 111, 109, 112, 105, 108, 101, 114, 0,
                103, 108, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 83, 116, 111, 114, 97, 103, 101, 0,
                103, 108, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 83, 116, 111, 114, 97, 103, 101, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 0,
                103, 108, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 83, 116, 111, 114, 97, 103, 101, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 65, 78, 71, 76, 69, 0,
                103, 108, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 83, 116, 111, 114, 97, 103, 101, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 65, 80, 80, 76, 69, 0,
                103, 108, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 83, 116, 111, 114, 97, 103, 101, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 69, 88, 84, 0,
                103, 108, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 83, 116, 111, 114, 97, 103, 101, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 73, 77, 71, 0,
                103, 108, 82, 101, 110, 100, 101, 114, 98, 117, 102, 102, 101, 114, 83, 116, 111, 114, 97, 103, 101, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 78, 86, 0,
                103, 108, 82, 101, 115, 111, 108, 118, 101, 68, 101, 112, 116, 104, 86, 97, 108, 117, 101, 115, 78, 86, 0,
                103, 108, 82, 101, 115, 111, 108, 118, 101, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 70, 114, 97, 109, 101, 98, 117, 102, 102, 101, 114, 65, 80, 80, 76, 69, 0,
                103, 108, 82, 101, 115, 117, 109, 101, 84, 114, 97, 110, 115, 102, 111, 114, 109, 70, 101, 101, 100, 98, 97, 99, 107, 0,
                103, 108, 83, 97, 109, 112, 108, 101, 67, 111, 118, 101, 114, 97, 103, 101, 0,
                103, 108, 83, 97, 109, 112, 108, 101, 77, 97, 115, 107, 105, 0,
                103, 108, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 102, 0,
                103, 108, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 102, 118, 0,
                103, 108, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 0,
                103, 108, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 105, 118, 69, 88, 84, 0,
                103, 108, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 105, 118, 79, 69, 83, 0,
                103, 108, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 117, 105, 118, 69, 88, 84, 0,
                103, 108, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 117, 105, 118, 79, 69, 83, 0,
                103, 108, 83, 97, 109, 112, 108, 101, 114, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 0,
                103, 108, 83, 99, 105, 115, 115, 111, 114, 0,
                103, 108, 83, 99, 105, 115, 115, 111, 114, 65, 114, 114, 97, 121, 118, 78, 86, 0,
                103, 108, 83, 99, 105, 115, 115, 111, 114, 65, 114, 114, 97, 121, 118, 79, 69, 83, 0,
                103, 108, 83, 99, 105, 115, 115, 111, 114, 73, 110, 100, 101, 120, 101, 100, 78, 86, 0,
                103, 108, 83, 99, 105, 115, 115, 111, 114, 73, 110, 100, 101, 120, 101, 100, 79, 69, 83, 0,
                103, 108, 83, 99, 105, 115, 115, 111, 114, 73, 110, 100, 101, 120, 101, 100, 118, 78, 86, 0,
                103, 108, 83, 99, 105, 115, 115, 111, 114, 73, 110, 100, 101, 120, 101, 100, 118, 79, 69, 83, 0,
                103, 108, 83, 101, 108, 101, 99, 116, 80, 101, 114, 102, 77, 111, 110, 105, 116, 111, 114, 67, 111, 117, 110, 116, 101, 114, 115, 65, 77, 68, 0,
                103, 108, 83, 101, 109, 97, 112, 104, 111, 114, 101, 80, 97, 114, 97, 109, 101, 116, 101, 114, 117, 105, 54, 52, 118, 69, 88, 84, 0,
                103, 108, 83, 101, 116, 70, 101, 110, 99, 101, 78, 86, 0,
                103, 108, 83, 104, 97, 100, 101, 114, 66, 105, 110, 97, 114, 121, 0,
                103, 108, 83, 104, 97, 100, 101, 114, 83, 111, 117, 114, 99, 101, 0,
                103, 108, 83, 105, 103, 110, 97, 108, 83, 101, 109, 97, 112, 104, 111, 114, 101, 69, 88, 84, 0,
                103, 108, 83, 105, 103, 110, 97, 108, 86, 107, 70, 101, 110, 99, 101, 78, 86, 0,
                103, 108, 83, 105, 103, 110, 97, 108, 86, 107, 83, 101, 109, 97, 112, 104, 111, 114, 101, 78, 86, 0,
                103, 108, 83, 116, 97, 114, 116, 84, 105, 108, 105, 110, 103, 81, 67, 79, 77, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 70, 105, 108, 108, 80, 97, 116, 104, 73, 110, 115, 116, 97, 110, 99, 101, 100, 78, 86, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 70, 105, 108, 108, 80, 97, 116, 104, 78, 86, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 70, 117, 110, 99, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 70, 117, 110, 99, 83, 101, 112, 97, 114, 97, 116, 101, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 77, 97, 115, 107, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 77, 97, 115, 107, 83, 101, 112, 97, 114, 97, 116, 101, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 79, 112, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 79, 112, 83, 101, 112, 97, 114, 97, 116, 101, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 83, 116, 114, 111, 107, 101, 80, 97, 116, 104, 73, 110, 115, 116, 97, 110, 99, 101, 100, 78, 86, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 83, 116, 114, 111, 107, 101, 80, 97, 116, 104, 78, 86, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 84, 104, 101, 110, 67, 111, 118, 101, 114, 70, 105, 108, 108, 80, 97, 116, 104, 73, 110, 115, 116, 97, 110, 99, 101, 100, 78, 86, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 84, 104, 101, 110, 67, 111, 118, 101, 114, 70, 105, 108, 108, 80, 97, 116, 104, 78, 86, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 84, 104, 101, 110, 67, 111, 118, 101, 114, 83, 116, 114, 111, 107, 101, 80, 97, 116, 104, 73, 110, 115, 116, 97, 110, 99, 101, 100, 78, 86, 0,
                103, 108, 83, 116, 101, 110, 99, 105, 108, 84, 104, 101, 110, 67, 111, 118, 101, 114, 83, 116, 114, 111, 107, 101, 80, 97, 116, 104, 78, 86, 0,
                103, 108, 83, 117, 98, 112, 105, 120, 101, 108, 80, 114, 101, 99, 105, 115, 105, 111, 110, 66, 105, 97, 115, 78, 86, 0,
                103, 108, 84, 101, 115, 116, 70, 101, 110, 99, 101, 78, 86, 0,
                103, 108, 84, 101, 120, 66, 117, 102, 102, 101, 114, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 66, 117, 102, 102, 101, 114, 79, 69, 83, 0,
                103, 108, 84, 101, 120, 66, 117, 102, 102, 101, 114, 82, 97, 110, 103, 101, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 66, 117, 102, 102, 101, 114, 82, 97, 110, 103, 101, 79, 69, 83, 0,
                103, 108, 84, 101, 120, 73, 109, 97, 103, 101, 50, 68, 0,
                103, 108, 84, 101, 120, 73, 109, 97, 103, 101, 51, 68, 0,
                103, 108, 84, 101, 120, 73, 109, 97, 103, 101, 51, 68, 79, 69, 83, 0,
                103, 108, 84, 101, 120, 80, 97, 103, 101, 67, 111, 109, 109, 105, 116, 109, 101, 110, 116, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 102, 0,
                103, 108, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 102, 118, 0,
                103, 108, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 0,
                103, 108, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 105, 118, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 105, 118, 79, 69, 83, 0,
                103, 108, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 117, 105, 118, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 73, 117, 105, 118, 79, 69, 83, 0,
                103, 108, 84, 101, 120, 80, 97, 114, 97, 109, 101, 116, 101, 114, 105, 118, 0,
                103, 108, 84, 101, 120, 83, 116, 111, 114, 97, 103, 101, 49, 68, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 83, 116, 111, 114, 97, 103, 101, 50, 68, 0,
                103, 108, 84, 101, 120, 83, 116, 111, 114, 97, 103, 101, 50, 68, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 83, 116, 111, 114, 97, 103, 101, 50, 68, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 0,
                103, 108, 84, 101, 120, 83, 116, 111, 114, 97, 103, 101, 51, 68, 0,
                103, 108, 84, 101, 120, 83, 116, 111, 114, 97, 103, 101, 51, 68, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 83, 116, 111, 114, 97, 103, 101, 51, 68, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 79, 69, 83, 0,
                103, 108, 84, 101, 120, 83, 116, 111, 114, 97, 103, 101, 77, 101, 109, 49, 68, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 83, 116, 111, 114, 97, 103, 101, 77, 101, 109, 50, 68, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 83, 116, 111, 114, 97, 103, 101, 77, 101, 109, 50, 68, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 83, 116, 111, 114, 97, 103, 101, 77, 101, 109, 51, 68, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 83, 116, 111, 114, 97, 103, 101, 77, 101, 109, 51, 68, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 83, 117, 98, 73, 109, 97, 103, 101, 50, 68, 0,
                103, 108, 84, 101, 120, 83, 117, 98, 73, 109, 97, 103, 101, 51, 68, 0,
                103, 108, 84, 101, 120, 83, 117, 98, 73, 109, 97, 103, 101, 51, 68, 79, 69, 83, 0,
                103, 108, 84, 101, 120, 116, 117, 114, 101, 83, 116, 111, 114, 97, 103, 101, 49, 68, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 116, 117, 114, 101, 83, 116, 111, 114, 97, 103, 101, 50, 68, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 116, 117, 114, 101, 83, 116, 111, 114, 97, 103, 101, 51, 68, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 116, 117, 114, 101, 83, 116, 111, 114, 97, 103, 101, 77, 101, 109, 49, 68, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 116, 117, 114, 101, 83, 116, 111, 114, 97, 103, 101, 77, 101, 109, 50, 68, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 116, 117, 114, 101, 83, 116, 111, 114, 97, 103, 101, 77, 101, 109, 50, 68, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 116, 117, 114, 101, 83, 116, 111, 114, 97, 103, 101, 77, 101, 109, 51, 68, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 116, 117, 114, 101, 83, 116, 111, 114, 97, 103, 101, 77, 101, 109, 51, 68, 77, 117, 108, 116, 105, 115, 97, 109, 112, 108, 101, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 116, 117, 114, 101, 86, 105, 101, 119, 69, 88, 84, 0,
                103, 108, 84, 101, 120, 116, 117, 114, 101, 86, 105, 101, 119, 79, 69, 83, 0,
                103, 108, 84, 114, 97, 110, 115, 102, 111, 114, 109, 70, 101, 101, 100, 98, 97, 99, 107, 86, 97, 114, 121, 105, 110, 103, 115, 0,
                103, 108, 84, 114, 97, 110, 115, 102, 111, 114, 109, 80, 97, 116, 104, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 49, 102, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 49, 102, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 49, 105, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 49, 105, 54, 52, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 49, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 49, 105, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 49, 117, 105, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 49, 117, 105, 54, 52, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 49, 117, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 49, 117, 105, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 50, 102, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 50, 102, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 50, 105, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 50, 105, 54, 52, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 50, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 50, 105, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 50, 117, 105, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 50, 117, 105, 54, 52, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 50, 117, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 50, 117, 105, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 51, 102, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 51, 102, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 51, 105, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 51, 105, 54, 52, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 51, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 51, 105, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 51, 117, 105, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 51, 117, 105, 54, 52, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 51, 117, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 51, 117, 105, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 52, 102, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 52, 102, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 52, 105, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 52, 105, 54, 52, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 52, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 52, 105, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 52, 117, 105, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 52, 117, 105, 54, 52, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 52, 117, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 52, 117, 105, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 66, 108, 111, 99, 107, 66, 105, 110, 100, 105, 110, 103, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 72, 97, 110, 100, 108, 101, 117, 105, 54, 52, 73, 77, 71, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 72, 97, 110, 100, 108, 101, 117, 105, 54, 52, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 72, 97, 110, 100, 108, 101, 117, 105, 54, 52, 118, 73, 77, 71, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 72, 97, 110, 100, 108, 101, 117, 105, 54, 52, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 50, 102, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 50, 120, 51, 102, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 50, 120, 51, 102, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 50, 120, 52, 102, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 50, 120, 52, 102, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 51, 102, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 51, 120, 50, 102, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 51, 120, 50, 102, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 51, 120, 52, 102, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 51, 120, 52, 102, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 52, 102, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 52, 120, 50, 102, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 52, 120, 50, 102, 118, 78, 86, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 52, 120, 51, 102, 118, 0,
                103, 108, 85, 110, 105, 102, 111, 114, 109, 77, 97, 116, 114, 105, 120, 52, 120, 51, 102, 118, 78, 86, 0,
                103, 108, 85, 110, 109, 97, 112, 66, 117, 102, 102, 101, 114, 0,
                103, 108, 85, 110, 109, 97, 112, 66, 117, 102, 102, 101, 114, 79, 69, 83, 0,
                103, 108, 85, 115, 101, 80, 114, 111, 103, 114, 97, 109, 0,
                103, 108, 85, 115, 101, 80, 114, 111, 103, 114, 97, 109, 83, 116, 97, 103, 101, 115, 0,
                103, 108, 85, 115, 101, 80, 114, 111, 103, 114, 97, 109, 83, 116, 97, 103, 101, 115, 69, 88, 84, 0,
                103, 108, 85, 115, 101, 83, 104, 97, 100, 101, 114, 80, 114, 111, 103, 114, 97, 109, 69, 88, 84, 0,
                103, 108, 86, 97, 108, 105, 100, 97, 116, 101, 80, 114, 111, 103, 114, 97, 109, 0,
                103, 108, 86, 97, 108, 105, 100, 97, 116, 101, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 0,
                103, 108, 86, 97, 108, 105, 100, 97, 116, 101, 80, 114, 111, 103, 114, 97, 109, 80, 105, 112, 101, 108, 105, 110, 101, 69, 88, 84, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 49, 102, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 49, 102, 118, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 50, 102, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 50, 102, 118, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 51, 102, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 51, 102, 118, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 52, 102, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 52, 102, 118, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 66, 105, 110, 100, 105, 110, 103, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 68, 105, 118, 105, 115, 111, 114, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 68, 105, 118, 105, 115, 111, 114, 65, 78, 71, 76, 69, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 68, 105, 118, 105, 115, 111, 114, 69, 88, 84, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 68, 105, 118, 105, 115, 111, 114, 78, 86, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 70, 111, 114, 109, 97, 116, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 73, 52, 105, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 73, 52, 105, 118, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 73, 52, 117, 105, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 73, 52, 117, 105, 118, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 73, 70, 111, 114, 109, 97, 116, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 73, 80, 111, 105, 110, 116, 101, 114, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 65, 116, 116, 114, 105, 98, 80, 111, 105, 110, 116, 101, 114, 0,
                103, 108, 86, 101, 114, 116, 101, 120, 66, 105, 110, 100, 105, 110, 103, 68, 105, 118, 105, 115, 111, 114, 0,
                103, 108, 86, 105, 101, 119, 112, 111, 114, 116, 0,
                103, 108, 86, 105, 101, 119, 112, 111, 114, 116, 65, 114, 114, 97, 121, 118, 78, 86, 0,
                103, 108, 86, 105, 101, 119, 112, 111, 114, 116, 65, 114, 114, 97, 121, 118, 79, 69, 83, 0,
                103, 108, 86, 105, 101, 119, 112, 111, 114, 116, 73, 110, 100, 101, 120, 101, 100, 102, 78, 86, 0,
                103, 108, 86, 105, 101, 119, 112, 111, 114, 116, 73, 110, 100, 101, 120, 101, 100, 102, 79, 69, 83, 0,
                103, 108, 86, 105, 101, 119, 112, 111, 114, 116, 73, 110, 100, 101, 120, 101, 100, 102, 118, 78, 86, 0,
                103, 108, 86, 105, 101, 119, 112, 111, 114, 116, 73, 110, 100, 101, 120, 101, 100, 102, 118, 79, 69, 83, 0,
                103, 108, 86, 105, 101, 119, 112, 111, 114, 116, 83, 119, 105, 122, 122, 108, 101, 78, 86, 0,
                103, 108, 87, 97, 105, 116, 83, 101, 109, 97, 112, 104, 111, 114, 101, 69, 88, 84, 0,
                103, 108, 87, 97, 105, 116, 83, 121, 110, 99, 0,
                103, 108, 87, 97, 105, 116, 83, 121, 110, 99, 65, 80, 80, 76, 69, 0,
                103, 108, 87, 97, 105, 116, 86, 107, 83, 101, 109, 97, 112, 104, 111, 114, 101, 78, 86, 0,
                103, 108, 87, 101, 105, 103, 104, 116, 80, 97, 116, 104, 115, 78, 86, 0,
                103, 108, 87, 105, 110, 100, 111, 119, 82, 101, 99, 116, 97, 110, 103, 108, 101, 115, 69, 88, 84, 0,
            };
            EntryPointNameOffsets = new int[]
            {
                0,
                28,
                47,
                69,
                94,
                110,
                126,
                164,
                179,
                206,
                228,
                250,
                263,
                279,
                304,
                325,
                338,
                355,
                373,
                399,
                432,
                450,
                469,
                491,
                516,
                535,
                549,
                563,
                587,
                605,
                626,
                645,
                663,
                680,
                693,
                709,
                728,
                748,
                768,
                792,
                820,
                848,
                860,
                876,
                892,
                912,
                936,
                960,
                980,
                998,
                1021,
                1041,
                1054,
                1073,
                1100,
                1122,
                1138,
                1163,
                1171,
                1187,
                1203,
                1219,
                1236,
                1249,
                1263,
                1293,
                1308,
                1327,
                1349,
                1366,
                1388,
                1400,
                1416,
                1432,
                1448,
                1471,
                1494,
                1520,
                1546,
                1572,
                1601,
                1634,
                1654,
                1676,
                1698,
                1720,
                1733,
                1750,
                1770,
                1790,
                1813,
                1838,
                1855,
                1878,
                1906,
                1928,
                1955,
                1973,
                2002,
                2022,
                2047,
                2070,
                2086,
                2101,
                2126,
                2149,
                2175,
                2186,
                2209,
                2235,
                2257,
                2282,
                2303,
                2327,
                2343,
                2360,
                2381,
                2406,
                2422,
                2446,
                2469,
                2485,
                2510,
                2538,
                2554,
                2573,
                2595,
                2612,
                2634,
                2649,
                2662,
                2680,
                2697,
                2724,
                2745,
                2769,
                2781,
                2793,
                2815,
                2838,
                2852,
                2875,
                2899,
                2914,
                2924,
                2951,
                2965,
                2978,
                2992,
                3019,
                3043,
                3061,
                3087,
                3100,
                3121,
                3143,
                3170,
                3207,
                3232,
                3256,
                3270,
                3287,
                3311,
                3327,
                3342,
                3370,
                3398,
                3421,
                3445,
                3474,
                3513,
                3562,
                3599,
                3636,
                3663,
                3689,
                3709,
                3742,
                3775,
                3802,
                3838,
                3854,
                3893,
                3922,
                3931,
                3957,
                3970,
                3982,
                3995,
                4021,
                4046,
                4066,
                4086,
                4097,
                4111,
                4127,
                4150,
                4177,
                4197,
                4222,
                4254,
                4275,
                4301,
                4321,
                4353,
                4377,
                4398,
                4423,
                4456,
                4468,
                4485,
                4494,
                4510,
                4518,
                4543,
                4571,
                4597,
                4627,
                4660,
                4697,
                4721,
                4759,
                4785,
                4818,
                4841,
                4877,
                4914,
                4951,
                4977,
                5001,
                5027,
                5066,
                5110,
                5143,
                5167,
                5179,
                5192,
                5209,
                5223,
                5241,
                5254,
                5275,
                5297,
                5322,
                5335,
                5351,
                5370,
                5384,
                5403,
                5417,
                5441,
                5459,
                5480,
                5498,
                5517,
                5543,
                5571,
                5593,
                5614,
                5634,
                5650,
                5664,
                5689,
                5712,
                5732,
                5755,
                5786,
                5807,
                5831,
                5855,
                5884,
                5895,
                5910,
                5937,
                5953,
                5970,
                5982,
                6004,
                6026,
                6064,
                6092,
                6133,
                6158,
                6186,
                6214,
                6233,
                6251,
                6267,
                6288,
                6304,
                6323,
                6337,
                6359,
                6389,
                6421,
                6440,
                6466,
                6482,
                6501,
                6520,
                6536,
                6555,
                6574,
                6591,
                6611,
                6628,
                6648,
                6668,
                6688,
                6711,
                6733,
                6755,
                6775,
                6793,
                6814,
                6832,
                6855,
                6874,
                6897,
                6920,
                6939,
                6959,
                6979,
                7005,
                7036,
                7067,
                7095,
                7128,
                7154,
                7185,
                7209,
                7237,
                7261,
                7275,
                7292,
                7311,
                7333,
                7353,
                7377,
                7392,
                7420,
                7451,
                7474,
                7500,
                7525,
                7551,
                7574,
                7603,
                7640,
                7665,
                7678,
                7694,
                7718,
                7740,
                7765,
                7785,
                7808,
                7837,
                7861,
                7889,
                7917,
                7946,
                7975,
                7999,
                8031,
                8050,
                8064,
                8091,
                8109,
                8121,
                8134,
                8146,
                8163,
                8188,
                8213,
                8233,
                8257,
                8281,
                8306,
                8331,
                8351,
                8373,
                8394,
                8423,
                8451,
                8481,
                8514,
                8537,
                8552,
                8571,
                8591,
                8606,
                8627,
                8643,
                8667,
                8689,
                8709,
                8730,
                8752,
                8772,
                8798,
                8816,
                8823,
                8843,
                8872,
                8899,
                8922,
                8954,
                8984,
                9007,
                9028,
                9052,
                9079,
                9090,
                9102,
                9118,
                9133,
                9149,
                9161,
                9177,
                9203,
                9223,
                9234,
                9256,
                9280,
                9292,
                9312,
                9335,
                9345,
                9358,
                9375,
                9387,
                9404,
                9415,
                9424,
                9438,
                9450,
                9478,
                9500,
                9516,
                9535,
                9552,
                9564,
                9578,
                9609,
                9637,
                9670,
                9700,
                9715,
                9732,
                9752,
                9771,
                9790,
                9818,
                9837,
                9856,
                9884,
                9900,
                9924,
                9953,
                9975,
                9996,
                10025,
                10058,
                10081,
                10112,
                10144,
                10171,
                10209,
                10223,
                10240,
                10257,
                10277,
                10298,
                10319,
                10336,
                10353,
                10368,
                10391,
                10409,
                10424,
                10448,
                10472,
                10491,
                10506,
                10536,
                10555,
                10575,
                10594,
                10614,
                10641,
                10661,
                10676,
                10696,
                10714,
                10729,
                10754,
                10768,
                10787,
                10803,
                10819,
                10843,
                10859,
                10878,
                10898,
                10924,
                10950,
                10966,
                10985,
                11005,
                11028,
                11060,
                11079,
                11101,
                11121,
                11144,
                11163,
                11186,
                11210,
                11232,
                11252,
                11275,
                11295,
                11319,
                11344,
                11367,
                11388,
                11412,
                11431,
                11453,
                11473,
                11496,
                11515,
                11538,
                11562,
                11584,
                11604,
                11627,
                11647,
                11671,
                11696,
                11719,
                11740,
                11764,
                11783,
                11805,
                11825,
                11848,
                11867,
                11890,
                11914,
                11936,
                11956,
                11979,
                11999,
                12023,
                12048,
                12071,
                12092,
                12116,
                12135,
                12157,
                12177,
                12200,
                12219,
                12242,
                12266,
                12288,
                12308,
                12331,
                12351,
                12375,
                12400,
                12423,
                12444,
                12468,
                12498,
                12527,
                12558,
                12588,
                12614,
                12643,
                12671,
                12702,
                12730,
                12761,
                12787,
                12816,
                12844,
                12875,
                12903,
                12934,
                12960,
                12989,
                13017,
                13048,
                13076,
                13107,
                13124,
                13144,
                13165,
                13183,
                13202,
                13215,
                13238,
                13253,
                13267,
                13284,
                13301,
                13314,
                13342,
                13366,
                13388,
                13421,
                13459,
                13497,
                13533,
                13569,
                13604,
                13627,
                13664,
                13690,
                13707,
                13721,
                13741,
                13762,
                13782,
                13807,
                13832,
                13858,
                13884,
                13905,
                13915,
                13933,
                13952,
                13971,
                13991,
                14011,
                14032,
                14063,
                14092,
                14105,
                14120,
                14135,
                14156,
                14174,
                14196,
                14214,
                14243,
                14263,
                14277,
                14299,
                14313,
                14335,
                14347,
                14367,
                14398,
                14420,
                14458,
                14487,
                14527,
                14558,
                14584,
                14598,
                14613,
                14628,
                14648,
                14668,
                14681,
                14694,
                14710,
                14733,
                14749,
                14766,
                14782,
                14803,
                14824,
                14846,
                14868,
                14885,
                14903,
                14918,
                14936,
                14962,
                14977,
                14995,
                15024,
                15045,
                15066,
                15098,
                15119,
                15151,
                15167,
                15183,
                15202,
                15224,
                15246,
                15268,
                15293,
                15318,
                15354,
                15379,
                15415,
                15432,
                15449,
                15477,
                15495,
                15507,
                15520,
                15532,
                15548,
                15565,
                15578,
                15591,
                15608,
                15626,
                15640,
                15652,
                15665,
                15677,
                15693,
                15710,
                15723,
                15736,
                15753,
                15771,
                15785,
                15797,
                15810,
                15822,
                15838,
                15855,
                15868,
                15881,
                15898,
                15916,
                15930,
                15942,
                15955,
                15967,
                15983,
                16000,
                16013,
                16026,
                16043,
                16061,
                16075,
                16097,
                16120,
                16142,
                16166,
                16189,
                16208,
                16229,
                16252,
                16273,
                16296,
                16315,
                16336,
                16359,
                16380,
                16403,
                16422,
                16443,
                16466,
                16487,
                16510,
                16524,
                16541,
                16554,
                16573,
                16595,
                16617,
                16635,
                16661,
                16690,
                16707,
                16725,
                16742,
                16760,
                16777,
                16795,
                16812,
                16830,
                16852,
                16874,
                16901,
                16926,
                16950,
                16971,
                16989,
                17008,
                17027,
                17047,
                17069,
                17092,
                17114,
                17137,
                17148,
                17167,
                17187,
                17208,
                17230,
                17252,
                17275,
                17295,
                17314,
                17325,
                17341,
                17361,
                17377,
            };
            EntryPoints = new IntPtr[EntryPointNameOffsets.Length];
        }

        public static partial class Amd
        {
            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glBeginPerfMonitorAMD")]
            [CLSCompliant(false)]
            public static void BeginPerfMonitor(Int32 monitor) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glBeginPerfMonitorAMD")]
            [CLSCompliant(false)]
            public static void BeginPerfMonitor(UInt32 monitor) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static Int32 DeletePerfMonitor() { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="n"></param>
            /// <param name="monitors">[length: n]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static void DeletePerfMonitors(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] monitors) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="n"></param>
            /// <param name="monitors">[length: n]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static void DeletePerfMonitors(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 monitors) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="n"></param>
            /// <param name="monitors">[length: n]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static unsafe void DeletePerfMonitors(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* monitors) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="n"></param>
            /// <param name="monitors">[length: n]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static void DeletePerfMonitors(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] monitors) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="n"></param>
            /// <param name="monitors">[length: n]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static void DeletePerfMonitors(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 monitors) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="n"></param>
            /// <param name="monitors">[length: n]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static unsafe void DeletePerfMonitors(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* monitors) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glEndPerfMonitorAMD")]
            [CLSCompliant(false)]
            public static void EndPerfMonitor(Int32 monitor) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glEndPerfMonitorAMD")]
            [CLSCompliant(false)]
            public static void EndPerfMonitor(UInt32 monitor) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static Int32 GenPerfMonitor() { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="n"></param>
            /// <param name="monitors">[length: n]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static void GenPerfMonitors(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] monitors) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="n"></param>
            /// <param name="monitors">[length: n]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static void GenPerfMonitors(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 monitors) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="n"></param>
            /// <param name="monitors">[length: n]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static unsafe void GenPerfMonitors(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* monitors) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="n"></param>
            /// <param name="monitors">[length: n]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static void GenPerfMonitors(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] monitors) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="n"></param>
            /// <param name="monitors">[length: n]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static void GenPerfMonitors(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 monitors) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="n"></param>
            /// <param name="monitors">[length: n]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            [CLSCompliant(false)]
            public static unsafe void GenPerfMonitors(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* monitors) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            /// <param name="pname"></param>
            /// <param name="dataSize"></param>
            /// <param name="data">[length: dataSize]</param>
            /// <param name="bytesWritten">[length: 1]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterData(Int32 monitor, OpenTK.Graphics.ES31.All pname, Int32 dataSize, [OutAttribute, CountAttribute(Parameter = "dataSize")] Int32[] data, [OutAttribute, CountAttribute(Count = 1)] out Int32 bytesWritten) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            /// <param name="pname"></param>
            /// <param name="dataSize"></param>
            /// <param name="data">[length: dataSize]</param>
            /// <param name="bytesWritten">[length: 1]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterData(Int32 monitor, OpenTK.Graphics.ES31.All pname, Int32 dataSize, [OutAttribute, CountAttribute(Parameter = "dataSize")] out Int32 data, [OutAttribute, CountAttribute(Count = 1)] out Int32 bytesWritten) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            /// <param name="pname"></param>
            /// <param name="dataSize"></param>
            /// <param name="data">[length: dataSize]</param>
            /// <param name="bytesWritten">[length: 1]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfMonitorCounterData(Int32 monitor, OpenTK.Graphics.ES31.All pname, Int32 dataSize, [OutAttribute, CountAttribute(Parameter = "dataSize")] Int32* data, [OutAttribute, CountAttribute(Count = 1)] Int32* bytesWritten) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            /// <param name="pname"></param>
            /// <param name="dataSize"></param>
            /// <param name="data">[length: dataSize]</param>
            /// <param name="bytesWritten">[length: 1]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterData(UInt32 monitor, OpenTK.Graphics.ES31.All pname, Int32 dataSize, [OutAttribute, CountAttribute(Parameter = "dataSize")] UInt32[] data, [OutAttribute, CountAttribute(Count = 1)] out Int32 bytesWritten) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            /// <param name="pname"></param>
            /// <param name="dataSize"></param>
            /// <param name="data">[length: dataSize]</param>
            /// <param name="bytesWritten">[length: 1]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterData(UInt32 monitor, OpenTK.Graphics.ES31.All pname, Int32 dataSize, [OutAttribute, CountAttribute(Parameter = "dataSize")] out UInt32 data, [OutAttribute, CountAttribute(Count = 1)] out Int32 bytesWritten) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            /// <param name="pname"></param>
            /// <param name="dataSize"></param>
            /// <param name="data">[length: dataSize]</param>
            /// <param name="bytesWritten">[length: 1]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfMonitorCounterData(UInt32 monitor, OpenTK.Graphics.ES31.All pname, Int32 dataSize, [OutAttribute, CountAttribute(Parameter = "dataSize")] UInt32* data, [OutAttribute, CountAttribute(Count = 1)] Int32* bytesWritten) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterInfo(Int32 group, Int32 counter, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] IntPtr data) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterInfo<T3>(Int32 group, Int32 counter, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Computed = "pname")] T3[] data)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterInfo<T3>(Int32 group, Int32 counter, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Computed = "pname")] T3[,] data)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterInfo<T3>(Int32 group, Int32 counter, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Computed = "pname")] T3[,,] data)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterInfo<T3>(Int32 group, Int32 counter, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Computed = "pname")] ref T3 data)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterInfo(UInt32 group, UInt32 counter, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] IntPtr data) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterInfo<T3>(UInt32 group, UInt32 counter, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Computed = "pname")] T3[] data)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterInfo<T3>(UInt32 group, UInt32 counter, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Computed = "pname")] T3[,] data)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterInfo<T3>(UInt32 group, UInt32 counter, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Computed = "pname")] T3[,,] data)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterInfo<T3>(UInt32 group, UInt32 counter, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Computed = "pname")] ref T3 data)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="numCounters">[length: 1]</param>
            /// <param name="maxActiveCounters">[length: 1]</param>
            /// <param name="counterSize"></param>
            /// <param name="counters">[length: counterSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCountersAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounters(Int32 group, [OutAttribute, CountAttribute(Count = 1)] out Int32 numCounters, [OutAttribute, CountAttribute(Count = 1)] out Int32 maxActiveCounters, Int32 counterSize, [OutAttribute, CountAttribute(Parameter = "counterSize")] Int32[] counters) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="numCounters">[length: 1]</param>
            /// <param name="maxActiveCounters">[length: 1]</param>
            /// <param name="counterSize"></param>
            /// <param name="counters">[length: counterSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCountersAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounters(Int32 group, [OutAttribute, CountAttribute(Count = 1)] out Int32 numCounters, [OutAttribute, CountAttribute(Count = 1)] out Int32 maxActiveCounters, Int32 counterSize, [OutAttribute, CountAttribute(Parameter = "counterSize")] out Int32 counters) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="numCounters">[length: 1]</param>
            /// <param name="maxActiveCounters">[length: 1]</param>
            /// <param name="counterSize"></param>
            /// <param name="counters">[length: counterSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCountersAMD")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfMonitorCounters(Int32 group, [OutAttribute, CountAttribute(Count = 1)] Int32* numCounters, [OutAttribute, CountAttribute(Count = 1)] Int32* maxActiveCounters, Int32 counterSize, [OutAttribute, CountAttribute(Parameter = "counterSize")] Int32* counters) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="numCounters">[length: 1]</param>
            /// <param name="maxActiveCounters">[length: 1]</param>
            /// <param name="counterSize"></param>
            /// <param name="counters">[length: counterSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCountersAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounters(UInt32 group, [OutAttribute, CountAttribute(Count = 1)] out Int32 numCounters, [OutAttribute, CountAttribute(Count = 1)] out Int32 maxActiveCounters, Int32 counterSize, [OutAttribute, CountAttribute(Parameter = "counterSize")] UInt32[] counters) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="numCounters">[length: 1]</param>
            /// <param name="maxActiveCounters">[length: 1]</param>
            /// <param name="counterSize"></param>
            /// <param name="counters">[length: counterSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCountersAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounters(UInt32 group, [OutAttribute, CountAttribute(Count = 1)] out Int32 numCounters, [OutAttribute, CountAttribute(Count = 1)] out Int32 maxActiveCounters, Int32 counterSize, [OutAttribute, CountAttribute(Parameter = "counterSize")] out UInt32 counters) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="numCounters">[length: 1]</param>
            /// <param name="maxActiveCounters">[length: 1]</param>
            /// <param name="counterSize"></param>
            /// <param name="counters">[length: counterSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCountersAMD")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfMonitorCounters(UInt32 group, [OutAttribute, CountAttribute(Count = 1)] Int32* numCounters, [OutAttribute, CountAttribute(Count = 1)] Int32* maxActiveCounters, Int32 counterSize, [OutAttribute, CountAttribute(Parameter = "counterSize")] UInt32* counters) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="bufSize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="counterString">[length: bufSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterStringAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterString(Int32 group, Int32 counter, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String counterString) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="bufSize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="counterString">[length: bufSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterStringAMD")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfMonitorCounterString(Int32 group, Int32 counter, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String counterString) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="bufSize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="counterString">[length: bufSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterStringAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorCounterString(UInt32 group, UInt32 counter, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String counterString) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="counter"></param>
            /// <param name="bufSize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="counterString">[length: bufSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterStringAMD")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfMonitorCounterString(UInt32 group, UInt32 counter, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String counterString) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="numGroups">[length: 1]</param>
            /// <param name="groupsSize"></param>
            /// <param name="groups">[length: groupsSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorGroups([OutAttribute, CountAttribute(Count = 1)] out Int32 numGroups, Int32 groupsSize, [OutAttribute, CountAttribute(Parameter = "groupsSize")] Int32[] groups) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="numGroups">[length: 1]</param>
            /// <param name="groupsSize"></param>
            /// <param name="groups">[length: groupsSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorGroups([OutAttribute, CountAttribute(Count = 1)] out Int32 numGroups, Int32 groupsSize, [OutAttribute, CountAttribute(Parameter = "groupsSize")] out Int32 groups) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="numGroups">[length: 1]</param>
            /// <param name="groupsSize"></param>
            /// <param name="groups">[length: groupsSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorGroups([OutAttribute, CountAttribute(Count = 1)] out Int32 numGroups, Int32 groupsSize, [OutAttribute, CountAttribute(Parameter = "groupsSize")] UInt32[] groups) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="numGroups">[length: 1]</param>
            /// <param name="groupsSize"></param>
            /// <param name="groups">[length: groupsSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorGroups([OutAttribute, CountAttribute(Count = 1)] out Int32 numGroups, Int32 groupsSize, [OutAttribute, CountAttribute(Parameter = "groupsSize")] out UInt32 groups) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="numGroups">[length: 1]</param>
            /// <param name="groupsSize"></param>
            /// <param name="groups">[length: groupsSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfMonitorGroups([OutAttribute, CountAttribute(Count = 1)] Int32* numGroups, Int32 groupsSize, [OutAttribute, CountAttribute(Parameter = "groupsSize")] Int32* groups) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="numGroups">[length: 1]</param>
            /// <param name="groupsSize"></param>
            /// <param name="groups">[length: groupsSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfMonitorGroups([OutAttribute, CountAttribute(Count = 1)] Int32* numGroups, Int32 groupsSize, [OutAttribute, CountAttribute(Parameter = "groupsSize")] UInt32* groups) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="bufSize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="groupString">[length: bufSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupStringAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorGroupString(Int32 group, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String groupString) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="bufSize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="groupString">[length: bufSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupStringAMD")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfMonitorGroupString(Int32 group, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String groupString) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="bufSize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="groupString">[length: bufSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupStringAMD")]
            [CLSCompliant(false)]
            public static void GetPerfMonitorGroupString(UInt32 group, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String groupString) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="group"></param>
            /// <param name="bufSize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="groupString">[length: bufSize]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupStringAMD")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfMonitorGroupString(UInt32 group, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String groupString) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            /// <param name="enable"></param>
            /// <param name="group"></param>
            /// <param name="numCounters"></param>
            /// <param name="counterList">[length: numCounters]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            [CLSCompliant(false)]
            public static void SelectPerfMonitorCounters(Int32 monitor, bool enable, Int32 group, Int32 numCounters, [OutAttribute, CountAttribute(Parameter = "numCounters")] Int32[] counterList) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            /// <param name="enable"></param>
            /// <param name="group"></param>
            /// <param name="numCounters"></param>
            /// <param name="counterList">[length: numCounters]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            [CLSCompliant(false)]
            public static void SelectPerfMonitorCounters(Int32 monitor, bool enable, Int32 group, Int32 numCounters, [OutAttribute, CountAttribute(Parameter = "numCounters")] out Int32 counterList) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            /// <param name="enable"></param>
            /// <param name="group"></param>
            /// <param name="numCounters"></param>
            /// <param name="counterList">[length: numCounters]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            [CLSCompliant(false)]
            public static unsafe void SelectPerfMonitorCounters(Int32 monitor, bool enable, Int32 group, Int32 numCounters, [OutAttribute, CountAttribute(Parameter = "numCounters")] Int32* counterList) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            /// <param name="enable"></param>
            /// <param name="group"></param>
            /// <param name="numCounters"></param>
            /// <param name="counterList">[length: numCounters]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            [CLSCompliant(false)]
            public static void SelectPerfMonitorCounters(UInt32 monitor, bool enable, UInt32 group, Int32 numCounters, [OutAttribute, CountAttribute(Parameter = "numCounters")] UInt32[] counterList) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            /// <param name="enable"></param>
            /// <param name="group"></param>
            /// <param name="numCounters"></param>
            /// <param name="counterList">[length: numCounters]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            [CLSCompliant(false)]
            public static void SelectPerfMonitorCounters(UInt32 monitor, bool enable, UInt32 group, Int32 numCounters, [OutAttribute, CountAttribute(Parameter = "numCounters")] out UInt32 counterList) { throw new NotImplementedException(); }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            /// <param name="monitor"></param>
            /// <param name="enable"></param>
            /// <param name="group"></param>
            /// <param name="numCounters"></param>
            /// <param name="counterList">[length: numCounters]</param>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            [CLSCompliant(false)]
            public static unsafe void SelectPerfMonitorCounters(UInt32 monitor, bool enable, UInt32 group, Int32 numCounters, [OutAttribute, CountAttribute(Parameter = "numCounters")] UInt32* counterList) { throw new NotImplementedException(); }
        }

        public static partial class Angle
        {
            /// <summary>[requires: ANGLE_framebuffer_blit]
            /// Copy a block of pixels from the read framebuffer to the draw framebuffer
            /// </summary>
            /// <param name="srcX0">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="srcY0">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="srcX1">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="srcY1">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="dstX0">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="dstY0">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="dstX1">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="dstY1">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="mask">
            /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are ColorBufferBit, DepthBufferBit and StencilBufferBit.
            /// </param>
            /// <param name="filter">
            /// Specifies the interpolation to be applied if the image is stretched. Must be Nearest or Linear.
            /// </param>
            [AutoGenerated(Category = "ANGLE_framebuffer_blit", Version = "", EntryPoint = "glBlitFramebufferANGLE")]
            [CLSCompliant(false)]
            public static void BlitFramebuffer(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, Int32 mask, OpenTK.Graphics.ES31.All filter) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_framebuffer_blit]
            /// Copy a block of pixels from the read framebuffer to the draw framebuffer
            /// </summary>
            /// <param name="srcX0">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="srcY0">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="srcX1">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="srcY1">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="dstX0">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="dstY0">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="dstX1">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="dstY1">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="mask">
            /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are ColorBufferBit, DepthBufferBit and StencilBufferBit.
            /// </param>
            /// <param name="filter">
            /// Specifies the interpolation to be applied if the image is stretched. Must be Nearest or Linear.
            /// </param>
            [AutoGenerated(Category = "ANGLE_framebuffer_blit", Version = "", EntryPoint = "glBlitFramebufferANGLE")]
            [CLSCompliant(false)]
            public static void BlitFramebuffer(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, UInt32 mask, OpenTK.Graphics.ES31.All filter) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a range of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="first">
            /// Specifies the starting index in the enabled arrays.
            /// </param>
            /// <param name="count">
            /// Specifies the number of indices to be rendered.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawArraysInstancedANGLE")]
            public static void DrawArraysInstanced(OpenTK.Graphics.ES31.All mode, Int32 first, Int32 count, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a range of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="first">
            /// Specifies the starting index in the enabled arrays.
            /// </param>
            /// <param name="count">
            /// Specifies the number of indices to be rendered.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawArraysInstancedANGLE")]
            public static void DrawArraysInstanced(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 first, Int32 count, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static void DrawElementsInstanced(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static void DrawElementsInstanced(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_translated_shader_source]</summary>
            /// <param name="shader"></param>
            /// <param name="bufsize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="source"></param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "ANGLE_translated_shader_source", Version = "", EntryPoint = "glGetTranslatedShaderSourceANGLE")]
            [CLSCompliant(false)]
            public static void GetTranslatedShaderSource(Int32 shader, Int32 bufsize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute] out String source) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_translated_shader_source]</summary>
            /// <param name="shader"></param>
            /// <param name="bufsize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="source"></param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "ANGLE_translated_shader_source", Version = "", EntryPoint = "glGetTranslatedShaderSourceANGLE")]
            [CLSCompliant(false)]
            public static void GetTranslatedShaderSource(Int32 shader, Int32 bufsize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute] out String source) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_translated_shader_source]</summary>
            /// <param name="shader"></param>
            /// <param name="bufsize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="source"></param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "ANGLE_translated_shader_source", Version = "", EntryPoint = "glGetTranslatedShaderSourceANGLE")]
            [CLSCompliant(false)]
            public static unsafe void GetTranslatedShaderSource(Int32 shader, Int32 bufsize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute] out String source) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_translated_shader_source]</summary>
            /// <param name="shader"></param>
            /// <param name="bufsize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="source"></param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "ANGLE_translated_shader_source", Version = "", EntryPoint = "glGetTranslatedShaderSourceANGLE")]
            [CLSCompliant(false)]
            public static void GetTranslatedShaderSource(UInt32 shader, Int32 bufsize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute] out String source) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_translated_shader_source]</summary>
            /// <param name="shader"></param>
            /// <param name="bufsize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="source"></param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "ANGLE_translated_shader_source", Version = "", EntryPoint = "glGetTranslatedShaderSourceANGLE")]
            [CLSCompliant(false)]
            public static void GetTranslatedShaderSource(UInt32 shader, Int32 bufsize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute] out String source) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_translated_shader_source]</summary>
            /// <param name="shader"></param>
            /// <param name="bufsize"></param>
            /// <param name="length">[length: 1]</param>
            /// <param name="source"></param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "ANGLE_translated_shader_source", Version = "", EntryPoint = "glGetTranslatedShaderSourceANGLE")]
            [CLSCompliant(false)]
            public static unsafe void GetTranslatedShaderSource(UInt32 shader, Int32 bufsize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute] out String source) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_framebuffer_multisample]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// Specifies a binding to which the target of the allocation and must be Renderbuffer.
            /// </param>
            /// <param name="samples">
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the renderbuffer, in pixels.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the renderbuffer, in pixels.
            /// </param>
            [AutoGenerated(Category = "ANGLE_framebuffer_multisample", Version = "", EntryPoint = "glRenderbufferStorageMultisampleANGLE")]
            public static void RenderbufferStorageMultisample(OpenTK.Graphics.ES31.All target, Int32 samples, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Modify the rate at which generic vertex attributes advance during instanced rendering
            /// </summary>
            /// <param name="index">
            /// Specify the index of the generic vertex attribute.
            /// </param>
            /// <param name="divisor">
            /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glVertexAttribDivisorANGLE")]
            [CLSCompliant(false)]
            public static void VertexAttribDivisor(Int32 index, Int32 divisor) { throw new NotImplementedException(); }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Modify the rate at which generic vertex attributes advance during instanced rendering
            /// </summary>
            /// <param name="index">
            /// Specify the index of the generic vertex attribute.
            /// </param>
            /// <param name="divisor">
            /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glVertexAttribDivisorANGLE")]
            [CLSCompliant(false)]
            public static void VertexAttribDivisor(UInt32 index, UInt32 divisor) { throw new NotImplementedException(); }
        }

        public static partial class Apple
        {
            /// <summary>[requires: APPLE_sync]
            /// Block and wait for a sync object to become signaled
            /// </summary>
            /// <param name="sync">
            /// The sync object whose status to wait on.
            /// </param>
            /// <param name="flags">
            /// A bitfield controlling the command flushing behavior. flags may be SyncFlushCommandsBit.
            /// </param>
            /// <param name="timeout">
            /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glClientWaitSyncAPPLE")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All ClientWaitSync(IntPtr sync, Int32 flags, Int64 timeout) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]
            /// Block and wait for a sync object to become signaled
            /// </summary>
            /// <param name="sync">
            /// The sync object whose status to wait on.
            /// </param>
            /// <param name="flags">
            /// A bitfield controlling the command flushing behavior. flags may be SyncFlushCommandsBit.
            /// </param>
            /// <param name="timeout">
            /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glClientWaitSyncAPPLE")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All ClientWaitSync(IntPtr sync, UInt32 flags, UInt64 timeout) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_copy_texture_levels]</summary>
            /// <param name="destinationTexture"></param>
            /// <param name="sourceTexture"></param>
            /// <param name="sourceBaseLevel"></param>
            /// <param name="sourceLevelCount"></param>
            [AutoGenerated(Category = "APPLE_copy_texture_levels", Version = "", EntryPoint = "glCopyTextureLevelsAPPLE")]
            [CLSCompliant(false)]
            public static void CopyTextureLevel(Int32 destinationTexture, Int32 sourceTexture, Int32 sourceBaseLevel, Int32 sourceLevelCount) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_copy_texture_levels]</summary>
            /// <param name="destinationTexture"></param>
            /// <param name="sourceTexture"></param>
            /// <param name="sourceBaseLevel"></param>
            /// <param name="sourceLevelCount"></param>
            [AutoGenerated(Category = "APPLE_copy_texture_levels", Version = "", EntryPoint = "glCopyTextureLevelsAPPLE")]
            [CLSCompliant(false)]
            public static void CopyTextureLevel(UInt32 destinationTexture, UInt32 sourceTexture, Int32 sourceBaseLevel, Int32 sourceLevelCount) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]
            /// Delete a sync object
            /// </summary>
            /// <param name="sync">
            /// The sync object to be deleted.
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glDeleteSyncAPPLE")]
            public static void DeleteSync(IntPtr sync) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]
            /// Create a new sync object and insert it into the GL command stream
            /// </summary>
            /// <param name="condition">
            /// Specifies the condition that must be met to set the sync object's state to signaled. condition must be SyncGpuCommandsComplete.
            /// </param>
            /// <param name="flags">
            /// Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero.flags is a placeholder for anticipated future extensions of fence sync object capabilities.
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glFenceSyncAPPLE")]
            [CLSCompliant(false)]
            public static IntPtr FenceSync(OpenTK.Graphics.ES31.All condition, Int32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]
            /// Create a new sync object and insert it into the GL command stream
            /// </summary>
            /// <param name="condition">
            /// Specifies the condition that must be met to set the sync object's state to signaled. condition must be SyncGpuCommandsComplete.
            /// </param>
            /// <param name="flags">
            /// Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero.flags is a placeholder for anticipated future extensions of fence sync object capabilities.
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glFenceSyncAPPLE")]
            [CLSCompliant(false)]
            public static IntPtr FenceSync(OpenTK.Graphics.ES31.All condition, UInt32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]</summary>
            /// <param name="pname"></param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetInteger64vAPPLE")]
            [CLSCompliant(false)]
            public static Int64 GetInteger64(OpenTK.Graphics.ES31.All pname) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]</summary>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetInteger64vAPPLE")]
            [CLSCompliant(false)]
            public static void GetInteger64(OpenTK.Graphics.ES31.All pname, [OutAttribute] Int64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]</summary>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetInteger64vAPPLE")]
            [CLSCompliant(false)]
            public static void GetInteger64(OpenTK.Graphics.ES31.All pname, [OutAttribute] out Int64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]</summary>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetInteger64vAPPLE")]
            [CLSCompliant(false)]
            public static unsafe void GetInteger64(OpenTK.Graphics.ES31.All pname, [OutAttribute] Int64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]
            /// Query the properties of a sync object
            /// </summary>
            /// <param name="sync">
            /// Specifies the sync object whose properties to query.
            /// </param>
            /// <param name="pname">
            /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given in values.
            /// </param>
            /// <param name="length">
            /// Specifies the address of an variable to receive the number of integers placed in values.
            /// </param>
            /// <param name="values">[length: bufSize]
            /// Specifies the address of an array to receive the values of the queried parameter.
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetSyncivAPPLE")]
            [CLSCompliant(false)]
            public static void GetSync(IntPtr sync, OpenTK.Graphics.ES31.All pname, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32[] values) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]
            /// Query the properties of a sync object
            /// </summary>
            /// <param name="sync">
            /// Specifies the sync object whose properties to query.
            /// </param>
            /// <param name="pname">
            /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given in values.
            /// </param>
            /// <param name="length">
            /// Specifies the address of an variable to receive the number of integers placed in values.
            /// </param>
            /// <param name="values">[length: bufSize]
            /// Specifies the address of an array to receive the values of the queried parameter.
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetSyncivAPPLE")]
            [CLSCompliant(false)]
            public static void GetSync(IntPtr sync, OpenTK.Graphics.ES31.All pname, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out Int32 values) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]
            /// Query the properties of a sync object
            /// </summary>
            /// <param name="sync">
            /// Specifies the sync object whose properties to query.
            /// </param>
            /// <param name="pname">
            /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given in values.
            /// </param>
            /// <param name="length">
            /// Specifies the address of an variable to receive the number of integers placed in values.
            /// </param>
            /// <param name="values">[length: bufSize]
            /// Specifies the address of an array to receive the values of the queried parameter.
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetSyncivAPPLE")]
            [CLSCompliant(false)]
            public static unsafe void GetSync(IntPtr sync, OpenTK.Graphics.ES31.All pname, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* values) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]
            /// Determine if a name corresponds to a sync object
            /// </summary>
            /// <param name="sync">
            /// Specifies a value that may be the name of a sync object.
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glIsSyncAPPLE")]
            public static bool IsSync(IntPtr sync) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_framebuffer_multisample]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// Specifies a binding to which the target of the allocation and must be Renderbuffer.
            /// </param>
            /// <param name="samples">
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the renderbuffer, in pixels.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the renderbuffer, in pixels.
            /// </param>
            [AutoGenerated(Category = "APPLE_framebuffer_multisample", Version = "", EntryPoint = "glRenderbufferStorageMultisampleAPPLE")]
            public static void RenderbufferStorageMultisample(OpenTK.Graphics.ES31.All target, Int32 samples, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_framebuffer_multisample]</summary>
            [AutoGenerated(Category = "APPLE_framebuffer_multisample", Version = "", EntryPoint = "glResolveMultisampleFramebufferAPPLE")]
            public static void ResolveMultisampleFramebuffer() { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]
            /// Instruct the GL server to block until the specified sync object becomes signaled
            /// </summary>
            /// <param name="sync">
            /// Specifies the sync object whose status to wait on.
            /// </param>
            /// <param name="flags">
            /// A bitfield controlling the command flushing behavior. flags must be zero.
            /// </param>
            /// <param name="timeout">
            /// Specifies the timeout that the server should wait before continuing. timeout must be TimeoutIgnored.
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glWaitSyncAPPLE")]
            [CLSCompliant(false)]
            public static void WaitSync(IntPtr sync, Int32 flags, Int64 timeout) { throw new NotImplementedException(); }

            /// <summary>[requires: APPLE_sync]
            /// Instruct the GL server to block until the specified sync object becomes signaled
            /// </summary>
            /// <param name="sync">
            /// Specifies the sync object whose status to wait on.
            /// </param>
            /// <param name="flags">
            /// A bitfield controlling the command flushing behavior. flags must be zero.
            /// </param>
            /// <param name="timeout">
            /// Specifies the timeout that the server should wait before continuing. timeout must be TimeoutIgnored.
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glWaitSyncAPPLE")]
            [CLSCompliant(false)]
            public static void WaitSync(IntPtr sync, UInt32 flags, UInt64 timeout) { throw new NotImplementedException(); }
        }

        public static partial class Cmaaintel
        {
            /// <summary>[requires: INTEL_framebuffer_CMAA]</summary>
            [AutoGenerated(Category = "INTEL_framebuffer_CMAA", Version = "", EntryPoint = "glApplyFramebufferAttachmentCMAAINTEL")]
            public static void ApplyFramebufferAttachment() { throw new NotImplementedException(); }

        }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Set the active program object for a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the program pipeline object to set the active program object for.
        /// </param>
        /// <param name="program">
        /// Specifies the program object to set as the active program pipeline object pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glActiveShaderProgram")]
        [CLSCompliant(false)]
        public static void ActiveShaderProgram(Int32 pipeline, Int32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Set the active program object for a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the program pipeline object to set the active program object for.
        /// </param>
        /// <param name="program">
        /// Specifies the program object to set as the active program pipeline object pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glActiveShaderProgram")]
        [CLSCompliant(false)]
        public static void ActiveShaderProgram(UInt32 pipeline, UInt32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Select active texture unit
        /// </summary>
        /// <param name="texture">
        /// Specifies which texture unit to make active. The number of texture units is implementation-dependent, but must be at least 32. texture must be one of Texturei, where i ranges from zero to the value of MaxCombinedTextureImageUnits minus one. The initial value is Texture0.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glActiveTexture")]
        public static void ActiveTexture(OpenTK.Graphics.ES31.All texture) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Select active texture unit
        /// </summary>
        /// <param name="texture">
        /// Specifies which texture unit to make active. The number of texture units is implementation-dependent, but must be at least 32. texture must be one of Texturei, where i ranges from zero to the value of MaxCombinedTextureImageUnits minus one. The initial value is Texture0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glActiveTexture")]
        public static void ActiveTexture(OpenTK.Graphics.ES31.TextureUnit texture) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Attaches a shader object to a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to which a shader object will be attached.
        /// </param>
        /// <param name="shader">
        /// Specifies the shader object that is to be attached.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glAttachShader")]
        [CLSCompliant(false)]
        public static void AttachShader(Int32 program, Int32 shader) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Attaches a shader object to a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to which a shader object will be attached.
        /// </param>
        /// <param name="shader">
        /// Specifies the shader object that is to be attached.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glAttachShader")]
        [CLSCompliant(false)]
        public static void AttachShader(UInt32 program, UInt32 shader) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delimit the boundaries of a query object
        /// </summary>
        /// <param name="target">
        /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of AnySamplesPassed, AnySamplesPassedConservative, or TransformFeedbackPrimitivesWritten.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBeginQuery")]
        [CLSCompliant(false)]
        public static void BeginQuery(OpenTK.Graphics.ES31.All target, Int32 id) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delimit the boundaries of a query object
        /// </summary>
        /// <param name="target">
        /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of AnySamplesPassed, AnySamplesPassedConservative, or TransformFeedbackPrimitivesWritten.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBeginQuery")]
        [CLSCompliant(false)]
        public static void BeginQuery(OpenTK.Graphics.ES31.All target, UInt32 id) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Start transform feedback operation
        /// </summary>
        /// <param name="primitiveMode">
        /// Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBeginTransformFeedback")]
        public static void BeginTransformFeedback(OpenTK.Graphics.ES31.All primitiveMode) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Associates a generic vertex attribute index with a named attribute variable
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object in which the association is to be made.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be bound.
        /// </param>
        /// <param name="name">
        /// Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindAttribLocation")]
        [CLSCompliant(false)]
        public static void BindAttribLocation(Int32 program, Int32 index, String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Associates a generic vertex attribute index with a named attribute variable
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object in which the association is to be made.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be bound.
        /// </param>
        /// <param name="name">
        /// Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindAttribLocation")]
        [CLSCompliant(false)]
        public static void BindAttribLocation(UInt32 program, UInt32 index, String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a named buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of a buffer object.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindBuffer")]
        [CLSCompliant(false)]
        public static void BindBuffer(OpenTK.Graphics.ES31.All target, Int32 buffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a named buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of a buffer object.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindBuffer")]
        [CLSCompliant(false)]
        public static void BindBuffer(OpenTK.Graphics.ES31.All target, UInt32 buffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a named buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of a buffer object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindBuffer")]
        [CLSCompliant(false)]
        public static void BindBuffer(OpenTK.Graphics.ES31.BufferTargetArb target, Int32 buffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a named buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of a buffer object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindBuffer")]
        [CLSCompliant(false)]
        public static void BindBuffer(OpenTK.Graphics.ES31.BufferTargetArb target, UInt32 buffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Bind a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of AtomicCounterBuffer, ShaderStorageBuffer, TransformFeedbackBuffer or UniformBuffer.
        /// </param>
        /// <param name="index">
        /// Specify the index of the binding point within the array specified by target.
        /// </param>
        /// <param name="buffer">
        /// The name of a buffer object to bind to the specified binding point.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferBase")]
        [CLSCompliant(false)]
        public static void BindBufferBase(OpenTK.Graphics.ES31.All target, Int32 index, Int32 buffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Bind a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of AtomicCounterBuffer, ShaderStorageBuffer, TransformFeedbackBuffer or UniformBuffer.
        /// </param>
        /// <param name="index">
        /// Specify the index of the binding point within the array specified by target.
        /// </param>
        /// <param name="buffer">
        /// The name of a buffer object to bind to the specified binding point.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferBase")]
        [CLSCompliant(false)]
        public static void BindBufferBase(OpenTK.Graphics.ES31.All target, UInt32 index, UInt32 buffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Bind a range within a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of AtomicCounterBuffer, ShaderStorageBuffer, TransformFeedbackBuffer or UniformBuffer.
        /// </param>
        /// <param name="index">
        /// Specify the index of the binding point within the array specified by target.
        /// </param>
        /// <param name="buffer">
        /// The name of a buffer object to bind to the specified binding point.
        /// </param>
        /// <param name="offset">
        /// The starting offset in basic machine units into the buffer object buffer.
        /// </param>
        /// <param name="size">
        /// The amount of data in machine units that can be read from the buffet object while used as an indexed target.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferRange")]
        [CLSCompliant(false)]
        public static void BindBufferRange(OpenTK.Graphics.ES31.All target, Int32 index, Int32 buffer, IntPtr offset, Int32 size) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Bind a range within a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of AtomicCounterBuffer, ShaderStorageBuffer, TransformFeedbackBuffer or UniformBuffer.
        /// </param>
        /// <param name="index">
        /// Specify the index of the binding point within the array specified by target.
        /// </param>
        /// <param name="buffer">
        /// The name of a buffer object to bind to the specified binding point.
        /// </param>
        /// <param name="offset">
        /// The starting offset in basic machine units into the buffer object buffer.
        /// </param>
        /// <param name="size">
        /// The amount of data in machine units that can be read from the buffet object while used as an indexed target.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferRange")]
        [CLSCompliant(false)]
        public static void BindBufferRange(OpenTK.Graphics.ES31.All target, Int32 index, Int32 buffer, IntPtr offset, IntPtr size) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Bind a range within a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of AtomicCounterBuffer, ShaderStorageBuffer, TransformFeedbackBuffer or UniformBuffer.
        /// </param>
        /// <param name="index">
        /// Specify the index of the binding point within the array specified by target.
        /// </param>
        /// <param name="buffer">
        /// The name of a buffer object to bind to the specified binding point.
        /// </param>
        /// <param name="offset">
        /// The starting offset in basic machine units into the buffer object buffer.
        /// </param>
        /// <param name="size">
        /// The amount of data in machine units that can be read from the buffet object while used as an indexed target.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferRange")]
        [CLSCompliant(false)]
        public static void BindBufferRange(OpenTK.Graphics.ES31.All target, UInt32 index, UInt32 buffer, IntPtr offset, Int32 size) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Bind a range within a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of AtomicCounterBuffer, ShaderStorageBuffer, TransformFeedbackBuffer or UniformBuffer.
        /// </param>
        /// <param name="index">
        /// Specify the index of the binding point within the array specified by target.
        /// </param>
        /// <param name="buffer">
        /// The name of a buffer object to bind to the specified binding point.
        /// </param>
        /// <param name="offset">
        /// The starting offset in basic machine units into the buffer object buffer.
        /// </param>
        /// <param name="size">
        /// The amount of data in machine units that can be read from the buffet object while used as an indexed target.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferRange")]
        [CLSCompliant(false)]
        public static void BindBufferRange(OpenTK.Graphics.ES31.All target, UInt32 index, UInt32 buffer, IntPtr offset, IntPtr size) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a framebuffer to a framebuffer target
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target of the binding operation.
        /// </param>
        /// <param name="framebuffer">
        /// Specifies the name of the framebuffer object to bind.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindFramebuffer")]
        [CLSCompliant(false)]
        public static void BindFramebuffer(OpenTK.Graphics.ES31.All target, Int32 framebuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a framebuffer to a framebuffer target
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target of the binding operation.
        /// </param>
        /// <param name="framebuffer">
        /// Specifies the name of the framebuffer object to bind.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindFramebuffer")]
        [CLSCompliant(false)]
        public static void BindFramebuffer(OpenTK.Graphics.ES31.All target, UInt32 framebuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a framebuffer to a framebuffer target
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target of the binding operation.
        /// </param>
        /// <param name="framebuffer">
        /// Specifies the name of the framebuffer object to bind.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindFramebuffer")]
        [CLSCompliant(false)]
        public static void BindFramebuffer(OpenTK.Graphics.ES31.FramebufferTarget target, Int32 framebuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a framebuffer to a framebuffer target
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target of the binding operation.
        /// </param>
        /// <param name="framebuffer">
        /// Specifies the name of the framebuffer object to bind.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindFramebuffer")]
        [CLSCompliant(false)]
        public static void BindFramebuffer(OpenTK.Graphics.ES31.FramebufferTarget target, UInt32 framebuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Bind a level of a texture to an image unit
        /// </summary>
        /// <param name="unit">
        /// Specifies the index of the image unit to which to bind the texture
        /// </param>
        /// <param name="texture">
        /// Specifies the name of the texture to bind to the image unit.
        /// </param>
        /// <param name="level">
        /// Specifies the level of the texture that is to be bound.
        /// </param>
        /// <param name="layered">
        /// Specifies whether a layered texture binding is to be established.
        /// </param>
        /// <param name="layer">
        /// If layered is False, specifies the layer of texture to be bound to the image unit. Ignored otherwise.
        /// </param>
        /// <param name="access">
        /// Specifies a token indicating the type of access that will be performed on the image.
        /// </param>
        /// <param name="format">
        /// Specifies the format that the elements of the image will be treated as for the purposes of formatted loads and stores.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glBindImageTexture")]
        [CLSCompliant(false)]
        public static void BindImageTexture(Int32 unit, Int32 texture, Int32 level, bool layered, Int32 layer, OpenTK.Graphics.ES31.All access, OpenTK.Graphics.ES31.All format) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Bind a level of a texture to an image unit
        /// </summary>
        /// <param name="unit">
        /// Specifies the index of the image unit to which to bind the texture
        /// </param>
        /// <param name="texture">
        /// Specifies the name of the texture to bind to the image unit.
        /// </param>
        /// <param name="level">
        /// Specifies the level of the texture that is to be bound.
        /// </param>
        /// <param name="layered">
        /// Specifies whether a layered texture binding is to be established.
        /// </param>
        /// <param name="layer">
        /// If layered is False, specifies the layer of texture to be bound to the image unit. Ignored otherwise.
        /// </param>
        /// <param name="access">
        /// Specifies a token indicating the type of access that will be performed on the image.
        /// </param>
        /// <param name="format">
        /// Specifies the format that the elements of the image will be treated as for the purposes of formatted loads and stores.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glBindImageTexture")]
        [CLSCompliant(false)]
        public static void BindImageTexture(UInt32 unit, UInt32 texture, Int32 level, bool layered, Int32 layer, OpenTK.Graphics.ES31.All access, OpenTK.Graphics.ES31.All format) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Bind a program pipeline to the current context
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of the pipeline object to bind to the context.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glBindProgramPipeline")]
        [CLSCompliant(false)]
        public static void BindProgramPipeline(Int32 pipeline) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Bind a program pipeline to the current context
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of the pipeline object to bind to the context.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glBindProgramPipeline")]
        [CLSCompliant(false)]
        public static void BindProgramPipeline(UInt32 pipeline) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a renderbuffer to a renderbuffer target
        /// </summary>
        /// <param name="target">
        /// Specifies the renderbuffer target of the binding operation. target must be Renderbuffer.
        /// </param>
        /// <param name="renderbuffer">
        /// Specifies the name of the renderbuffer object to bind.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindRenderbuffer")]
        [CLSCompliant(false)]
        public static void BindRenderbuffer(OpenTK.Graphics.ES31.All target, Int32 renderbuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a renderbuffer to a renderbuffer target
        /// </summary>
        /// <param name="target">
        /// Specifies the renderbuffer target of the binding operation. target must be Renderbuffer.
        /// </param>
        /// <param name="renderbuffer">
        /// Specifies the name of the renderbuffer object to bind.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindRenderbuffer")]
        [CLSCompliant(false)]
        public static void BindRenderbuffer(OpenTK.Graphics.ES31.All target, UInt32 renderbuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a renderbuffer to a renderbuffer target
        /// </summary>
        /// <param name="target">
        /// Specifies the renderbuffer target of the binding operation. target must be Renderbuffer.
        /// </param>
        /// <param name="renderbuffer">
        /// Specifies the name of the renderbuffer object to bind.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindRenderbuffer")]
        [CLSCompliant(false)]
        public static void BindRenderbuffer(OpenTK.Graphics.ES31.RenderbufferTarget target, Int32 renderbuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a renderbuffer to a renderbuffer target
        /// </summary>
        /// <param name="target">
        /// Specifies the renderbuffer target of the binding operation. target must be Renderbuffer.
        /// </param>
        /// <param name="renderbuffer">
        /// Specifies the name of the renderbuffer object to bind.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindRenderbuffer")]
        [CLSCompliant(false)]
        public static void BindRenderbuffer(OpenTK.Graphics.ES31.RenderbufferTarget target, UInt32 renderbuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Bind a named sampler to a texturing target
        /// </summary>
        /// <param name="unit">
        /// Specifies the index of the texture unit to which the sampler is bound.
        /// </param>
        /// <param name="sampler">
        /// Specifies the name of a sampler.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindSampler")]
        [CLSCompliant(false)]
        public static void BindSampler(Int32 unit, Int32 sampler) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Bind a named sampler to a texturing target
        /// </summary>
        /// <param name="unit">
        /// Specifies the index of the texture unit to which the sampler is bound.
        /// </param>
        /// <param name="sampler">
        /// Specifies the name of a sampler.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindSampler")]
        [CLSCompliant(false)]
        public static void BindSampler(UInt32 unit, UInt32 sampler) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a named texture to a texturing target
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound. Must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap,
        /// </param>
        /// <param name="texture">
        /// Specifies the name of a texture.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindTexture")]
        [CLSCompliant(false)]
        public static void BindTexture(OpenTK.Graphics.ES31.All target, Int32 texture) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a named texture to a texturing target
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound. Must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap,
        /// </param>
        /// <param name="texture">
        /// Specifies the name of a texture.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindTexture")]
        [CLSCompliant(false)]
        public static void BindTexture(OpenTK.Graphics.ES31.All target, UInt32 texture) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a named texture to a texturing target
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound. Must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap,
        /// </param>
        /// <param name="texture">
        /// Specifies the name of a texture.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindTexture")]
        [CLSCompliant(false)]
        public static void BindTexture(OpenTK.Graphics.ES31.TextureTarget target, Int32 texture) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Bind a named texture to a texturing target
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound. Must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap,
        /// </param>
        /// <param name="texture">
        /// Specifies the name of a texture.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindTexture")]
        [CLSCompliant(false)]
        public static void BindTexture(OpenTK.Graphics.ES31.TextureTarget target, UInt32 texture) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Bind a transform feedback object
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which to bind the transform feedback object id. target must be TransformFeedback.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindTransformFeedback")]
        [CLSCompliant(false)]
        public static void BindTransformFeedback(OpenTK.Graphics.ES31.All target, Int32 id) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Bind a transform feedback object
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which to bind the transform feedback object id. target must be TransformFeedback.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindTransformFeedback")]
        [CLSCompliant(false)]
        public static void BindTransformFeedback(OpenTK.Graphics.ES31.All target, UInt32 id) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Bind a vertex array object
        /// </summary>
        /// <param name="array">
        /// Specifies the name of the vertex array to bind.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindVertexArray")]
        [CLSCompliant(false)]
        public static void BindVertexArray(Int32 array) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Bind a vertex array object
        /// </summary>
        /// <param name="array">
        /// Specifies the name of the vertex array to bind.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindVertexArray")]
        [CLSCompliant(false)]
        public static void BindVertexArray(UInt32 array) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Bind a buffer to a vertex buffer bind point
        /// </summary>
        /// <param name="bindingindex">
        /// The index of the vertex buffer binding point to which to bind the buffer.
        /// </param>
        /// <param name="buffer">
        /// The name of an existing buffer to bind to the vertex buffer binding point.
        /// </param>
        /// <param name="offset">
        /// The offset of the first element of the buffer.
        /// </param>
        /// <param name="stride">
        /// The distance between elements within the buffer.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glBindVertexBuffer")]
        [CLSCompliant(false)]
        public static void BindVertexBuffer(Int32 bindingindex, Int32 buffer, IntPtr offset, Int32 stride) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Bind a buffer to a vertex buffer bind point
        /// </summary>
        /// <param name="bindingindex">
        /// The index of the vertex buffer binding point to which to bind the buffer.
        /// </param>
        /// <param name="buffer">
        /// The name of an existing buffer to bind to the vertex buffer binding point.
        /// </param>
        /// <param name="offset">
        /// The offset of the first element of the buffer.
        /// </param>
        /// <param name="stride">
        /// The distance between elements within the buffer.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glBindVertexBuffer")]
        [CLSCompliant(false)]
        public static void BindVertexBuffer(UInt32 bindingindex, UInt32 buffer, IntPtr offset, Int32 stride) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set the blend color
        /// </summary>
        /// <param name="red">
        /// specify the components of BlendColor
        /// </param>
        /// <param name="green">
        /// specify the components of BlendColor
        /// </param>
        /// <param name="blue">
        /// specify the components of BlendColor
        /// </param>
        /// <param name="alpha">
        /// specify the components of BlendColor
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendColor")]
        public static void BlendColor(Single red, Single green, Single blue, Single alpha) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the equation used for both the RGB blend equation and the Alpha blend equation
        /// </summary>
        /// <param name="mode">
        /// specifies how source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendEquation")]
        public static void BlendEquation(OpenTK.Graphics.ES31.All mode) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the equation used for both the RGB blend equation and the Alpha blend equation
        /// </summary>
        /// <param name="mode">
        /// specifies how source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendEquation")]
        public static void BlendEquation(OpenTK.Graphics.ES31.BlendEquationMode mode) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set the RGB blend equation and the alpha blend equation separately
        /// </summary>
        /// <param name="modeRGB">
        /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
        /// </param>
        /// <param name="modeAlpha">
        /// specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendEquationSeparate")]
        public static void BlendEquationSeparate(OpenTK.Graphics.ES31.All modeRGB, OpenTK.Graphics.ES31.All modeAlpha) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set the RGB blend equation and the alpha blend equation separately
        /// </summary>
        /// <param name="modeRGB">
        /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
        /// </param>
        /// <param name="modeAlpha">
        /// specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendEquationSeparate")]
        public static void BlendEquationSeparate(OpenTK.Graphics.ES31.BlendEquationModeExt modeRGB, OpenTK.Graphics.ES31.BlendEquationModeExt modeAlpha) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify pixel arithmetic
        /// </summary>
        /// <param name="sfactor">
        /// Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is One.
        /// </param>
        /// <param name="dfactor">
        /// Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: Zero, One, SrcColor, OneMinusSrcColor, DstColor, OneMinusDstColor, SrcAlpha, OneMinusSrcAlpha, DstAlpha, OneMinusDstAlpha. ConstantColor, OneMinusConstantColor, ConstantAlpha, and OneMinusConstantAlpha. The initial value is Zero.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendFunc")]
        public static void BlendFunc(OpenTK.Graphics.ES31.All sfactor, OpenTK.Graphics.ES31.All dfactor) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify pixel arithmetic
        /// </summary>
        /// <param name="sfactor">
        /// Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is One.
        /// </param>
        /// <param name="dfactor">
        /// Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: Zero, One, SrcColor, OneMinusSrcColor, DstColor, OneMinusDstColor, SrcAlpha, OneMinusSrcAlpha, DstAlpha, OneMinusDstAlpha. ConstantColor, OneMinusConstantColor, ConstantAlpha, and OneMinusConstantAlpha. The initial value is Zero.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendFunc")]
        public static void BlendFunc(OpenTK.Graphics.ES31.BlendingFactorSrc sfactor, OpenTK.Graphics.ES31.BlendingFactorDest dfactor) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify pixel arithmetic for RGB and alpha components separately
        /// </summary>
        /// <param name="sfactorRGB">
        /// Specifies how the red, green, and blue blending factors are computed. The initial value is One.
        /// </param>
        /// <param name="dfactorRGB">
        /// Specifies how the red, green, and blue destination blending factors are computed. The initial value is Zero.
        /// </param>
        /// <param name="sfactorAlpha">
        /// Specified how the alpha source blending factor is computed. The initial value is One.
        /// </param>
        /// <param name="dfactorAlpha">
        /// Specified how the alpha destination blending factor is computed. The initial value is Zero.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendFuncSeparate")]
        public static void BlendFuncSeparate(OpenTK.Graphics.ES31.All sfactorRGB, OpenTK.Graphics.ES31.All dfactorRGB, OpenTK.Graphics.ES31.All sfactorAlpha, OpenTK.Graphics.ES31.All dfactorAlpha) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Copy a block of pixels from the read framebuffer to the draw framebuffer
        /// </summary>
        /// <param name="srcX0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcX1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="dstX0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstX1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="mask">
        /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are ColorBufferBit, DepthBufferBit and StencilBufferBit.
        /// </param>
        /// <param name="filter">
        /// Specifies the interpolation to be applied if the image is stretched. Must be Nearest or Linear.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBlitFramebuffer")]
        public static void BlitFramebuffer(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, OpenTK.Graphics.ES31.All mask, OpenTK.Graphics.ES31.All filter) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Copy a block of pixels from the read framebuffer to the draw framebuffer
        /// </summary>
        /// <param name="srcX0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcX1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="dstX0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstX1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="mask">
        /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are ColorBufferBit, DepthBufferBit and StencilBufferBit.
        /// </param>
        /// <param name="filter">
        /// Specifies the interpolation to be applied if the image is stretched. Must be Nearest or Linear.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBlitFramebuffer")]
        public static void BlitFramebuffer(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, OpenTK.Graphics.ES31.ClearBufferMask mask, OpenTK.Graphics.ES31.All filter) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static void BufferData(OpenTK.Graphics.ES31.All target, Int32 size, [CountAttribute(Parameter = "size")] IntPtr data, OpenTK.Graphics.ES31.All usage) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        [CLSCompliant(false)]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.All target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[] data, OpenTK.Graphics.ES31.All usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        [CLSCompliant(false)]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.All target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,] data, OpenTK.Graphics.ES31.All usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        [CLSCompliant(false)]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.All target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,,] data, OpenTK.Graphics.ES31.All usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.All target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] ref T2 data, OpenTK.Graphics.ES31.All usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static void BufferData(OpenTK.Graphics.ES31.All target, IntPtr size, [CountAttribute(Parameter = "size")] IntPtr data, OpenTK.Graphics.ES31.All usage) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        [CLSCompliant(false)]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.All target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[] data, OpenTK.Graphics.ES31.All usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        [CLSCompliant(false)]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.All target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,] data, OpenTK.Graphics.ES31.All usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        [CLSCompliant(false)]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.All target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,,] data, OpenTK.Graphics.ES31.All usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.All target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] ref T2 data, OpenTK.Graphics.ES31.All usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static void BufferData(OpenTK.Graphics.ES31.BufferTargetArb target, Int32 size, [CountAttribute(Parameter = "size")] IntPtr data, OpenTK.Graphics.ES31.BufferUsageArb usage) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        [CLSCompliant(false)]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.BufferTargetArb target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[] data, OpenTK.Graphics.ES31.BufferUsageArb usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        [CLSCompliant(false)]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.BufferTargetArb target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,] data, OpenTK.Graphics.ES31.BufferUsageArb usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        [CLSCompliant(false)]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.BufferTargetArb target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,,] data, OpenTK.Graphics.ES31.BufferUsageArb usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.BufferTargetArb target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] ref T2 data, OpenTK.Graphics.ES31.BufferUsageArb usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static void BufferData(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr size, [CountAttribute(Parameter = "size")] IntPtr data, OpenTK.Graphics.ES31.BufferUsageArb usage) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        [CLSCompliant(false)]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[] data, OpenTK.Graphics.ES31.BufferUsageArb usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        [CLSCompliant(false)]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,] data, OpenTK.Graphics.ES31.BufferUsageArb usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        [CLSCompliant(false)]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,,] data, OpenTK.Graphics.ES31.BufferUsageArb usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be StreamDraw, StreamRead, StreamCopy, StaticDraw, StaticRead, StaticCopy, DynamicDraw, DynamicRead, or DynamicCopy.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static void BufferData<T2>(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] ref T2 data, OpenTK.Graphics.ES31.BufferUsageArb usage)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static void BufferSubData(OpenTK.Graphics.ES31.All target, IntPtr offset, Int32 size, [CountAttribute(Parameter = "size")] IntPtr data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        [CLSCompliant(false)]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.All target, IntPtr offset, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T3[] data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        [CLSCompliant(false)]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.All target, IntPtr offset, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T3[,] data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        [CLSCompliant(false)]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.All target, IntPtr offset, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T3[,,] data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.All target, IntPtr offset, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] ref T3 data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static void BufferSubData(OpenTK.Graphics.ES31.All target, IntPtr offset, IntPtr size, [CountAttribute(Parameter = "size")] IntPtr data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        [CLSCompliant(false)]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.All target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T3[] data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        [CLSCompliant(false)]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.All target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T3[,] data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        [CLSCompliant(false)]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.All target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T3[,,] data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.All target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] ref T3 data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static void BufferSubData(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, Int32 size, [CountAttribute(Parameter = "size")] IntPtr data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        [CLSCompliant(false)]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T3[] data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        [CLSCompliant(false)]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T3[,] data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        [CLSCompliant(false)]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T3[,,] data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] ref T3 data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static void BufferSubData(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, IntPtr size, [CountAttribute(Parameter = "size")] IntPtr data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        [CLSCompliant(false)]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T3[] data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        [CLSCompliant(false)]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T3[,] data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        [CLSCompliant(false)]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T3[,,] data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, ShaderStorageBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">[length: size]
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static void BufferSubData<T3>(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] ref T3 data)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Check the completeness status of a framebuffer
        /// </summary>
        /// <param name="target">
        /// Specify the target of the framebuffer completeness check.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCheckFramebufferStatus")]
        public static OpenTK.Graphics.ES31.All CheckFramebufferStatus(OpenTK.Graphics.ES31.All target) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Check the completeness status of a framebuffer
        /// </summary>
        /// <param name="target">
        /// Specify the target of the framebuffer completeness check.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCheckFramebufferStatus")]
        public static OpenTK.Graphics.ES31.All CheckFramebufferStatus(OpenTK.Graphics.ES31.FramebufferTarget target) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Clear buffers to preset values
        /// </summary>
        /// <param name="mask">
        /// Bitwise OR of masks that indicate the buffers to be cleared. The three masks are ColorBufferBit, DepthBufferBit, and StencilBufferBit.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glClear")]
        public static void Clear(OpenTK.Graphics.ES31.All mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Clear buffers to preset values
        /// </summary>
        /// <param name="mask">
        /// Bitwise OR of masks that indicate the buffers to be cleared. The three masks are ColorBufferBit, DepthBufferBit, and StencilBufferBit.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glClear")]
        public static void Clear(OpenTK.Graphics.ES31.ClearBufferMask mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// Specify the buffer to clear.
        /// </param>
        /// <param name="drawbuffer">
        /// Specify a particular draw buffer to clear.
        /// </param>
        /// <param name="depth">
        /// The value to clear a depth render buffer to.
        /// </param>
        /// <param name="stencil">
        /// The value to clear a stencil render buffer to.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferfi")]
        public static void ClearBuffer(OpenTK.Graphics.ES31.All buffer, Int32 drawbuffer, Single depth, Int32 stencil) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// Specify the buffer to clear.
        /// </param>
        /// <param name="drawbuffer">
        /// Specify a particular draw buffer to clear.
        /// </param>
        /// <param name="value">[length: COMPSIZE(buffer)]
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferfv")]
        [CLSCompliant(false)]
        public static void ClearBuffer(OpenTK.Graphics.ES31.All buffer, Int32 drawbuffer, [CountAttribute(Computed = "buffer")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// Specify the buffer to clear.
        /// </param>
        /// <param name="drawbuffer">
        /// Specify a particular draw buffer to clear.
        /// </param>
        /// <param name="value">[length: COMPSIZE(buffer)]
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferfv")]
        [CLSCompliant(false)]
        public static void ClearBuffer(OpenTK.Graphics.ES31.All buffer, Int32 drawbuffer, [CountAttribute(Computed = "buffer")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// Specify the buffer to clear.
        /// </param>
        /// <param name="drawbuffer">
        /// Specify a particular draw buffer to clear.
        /// </param>
        /// <param name="value">[length: COMPSIZE(buffer)]
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferfv")]
        [CLSCompliant(false)]
        public static unsafe void ClearBuffer(OpenTK.Graphics.ES31.All buffer, Int32 drawbuffer, [CountAttribute(Computed = "buffer")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// Specify the buffer to clear.
        /// </param>
        /// <param name="drawbuffer">
        /// Specify a particular draw buffer to clear.
        /// </param>
        /// <param name="value">[length: COMPSIZE(buffer)]
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferiv")]
        [CLSCompliant(false)]
        public static void ClearBuffer(OpenTK.Graphics.ES31.All buffer, Int32 drawbuffer, [CountAttribute(Computed = "buffer")] Int32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// Specify the buffer to clear.
        /// </param>
        /// <param name="drawbuffer">
        /// Specify a particular draw buffer to clear.
        /// </param>
        /// <param name="value">[length: COMPSIZE(buffer)]
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferiv")]
        [CLSCompliant(false)]
        public static void ClearBuffer(OpenTK.Graphics.ES31.All buffer, Int32 drawbuffer, [CountAttribute(Computed = "buffer")] ref Int32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// Specify the buffer to clear.
        /// </param>
        /// <param name="drawbuffer">
        /// Specify a particular draw buffer to clear.
        /// </param>
        /// <param name="value">[length: COMPSIZE(buffer)]
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferiv")]
        [CLSCompliant(false)]
        public static unsafe void ClearBuffer(OpenTK.Graphics.ES31.All buffer, Int32 drawbuffer, [CountAttribute(Computed = "buffer")] Int32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// Specify the buffer to clear.
        /// </param>
        /// <param name="drawbuffer">
        /// Specify a particular draw buffer to clear.
        /// </param>
        /// <param name="value">[length: COMPSIZE(buffer)]
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferuiv")]
        [CLSCompliant(false)]
        public static void ClearBuffer(OpenTK.Graphics.ES31.All buffer, Int32 drawbuffer, [CountAttribute(Computed = "buffer")] UInt32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// Specify the buffer to clear.
        /// </param>
        /// <param name="drawbuffer">
        /// Specify a particular draw buffer to clear.
        /// </param>
        /// <param name="value">[length: COMPSIZE(buffer)]
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferuiv")]
        [CLSCompliant(false)]
        public static void ClearBuffer(OpenTK.Graphics.ES31.All buffer, Int32 drawbuffer, [CountAttribute(Computed = "buffer")] ref UInt32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// Specify the buffer to clear.
        /// </param>
        /// <param name="drawbuffer">
        /// Specify a particular draw buffer to clear.
        /// </param>
        /// <param name="value">[length: COMPSIZE(buffer)]
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferuiv")]
        [CLSCompliant(false)]
        public static unsafe void ClearBuffer(OpenTK.Graphics.ES31.All buffer, Int32 drawbuffer, [CountAttribute(Computed = "buffer")] UInt32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify clear values for the color buffers
        /// </summary>
        /// <param name="red">
        /// Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.
        /// </param>
        /// <param name="green">
        /// Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.
        /// </param>
        /// <param name="blue">
        /// Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.
        /// </param>
        /// <param name="alpha">
        /// Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glClearColor")]
        public static void ClearColor(Single red, Single green, Single blue, Single alpha) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the clear value for the depth buffer
        /// </summary>
        /// <param name="d">
        /// Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glClearDepthf")]
        public static void ClearDepth(Single d) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the clear value for the stencil buffer
        /// </summary>
        /// <param name="s">
        /// Specifies the index used when the stencil buffer is cleared. The initial value is 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glClearStencil")]
        public static void ClearStencil(Int32 s) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Block and wait for a sync object to become signaled
        /// </summary>
        /// <param name="sync">
        /// The sync object whose status to wait on.
        /// </param>
        /// <param name="flags">
        /// A bitfield controlling the command flushing behavior. flags may be SyncFlushCommandsBit.
        /// </param>
        /// <param name="timeout">
        /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClientWaitSync")]
        [CLSCompliant(false)]
        public static OpenTK.Graphics.ES31.All ClientWaitSync(IntPtr sync, Int32 flags, Int64 timeout) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Block and wait for a sync object to become signaled
        /// </summary>
        /// <param name="sync">
        /// The sync object whose status to wait on.
        /// </param>
        /// <param name="flags">
        /// A bitfield controlling the command flushing behavior. flags may be SyncFlushCommandsBit.
        /// </param>
        /// <param name="timeout">
        /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClientWaitSync")]
        [CLSCompliant(false)]
        public static OpenTK.Graphics.ES31.All ClientWaitSync(IntPtr sync, UInt32 flags, UInt64 timeout) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Enable and disable writing of frame buffer color components
        /// </summary>
        /// <param name="red">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
        /// </param>
        /// <param name="green">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
        /// </param>
        /// <param name="blue">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
        /// </param>
        /// <param name="alpha">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glColorMask")]
        public static void ColorMask(bool red, bool green, bool blue, bool alpha) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Compiles a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be compiled.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompileShader")]
        [CLSCompliant(false)]
        public static void CompileShader(Int32 shader) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Compiles a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be compiled.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompileShader")]
        [CLSCompliant(false)]
        public static void CompileShader(UInt32 shader) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static void CompressedTexImage2D(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        [CLSCompliant(false)]
        public static void CompressedTexImage2D<T7>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T7[] data)
            where T7 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        [CLSCompliant(false)]
        public static void CompressedTexImage2D<T7>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T7[,] data)
            where T7 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        [CLSCompliant(false)]
        public static void CompressedTexImage2D<T7>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T7[,,] data)
            where T7 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static void CompressedTexImage2D<T7>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] ref T7 data)
            where T7 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static void CompressedTexImage2D(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        [CLSCompliant(false)]
        public static void CompressedTexImage2D<T7>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T7[] data)
            where T7 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        [CLSCompliant(false)]
        public static void CompressedTexImage2D<T7>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T7[,] data)
            where T7 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        [CLSCompliant(false)]
        public static void CompressedTexImage2D<T7>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T7[,,] data)
            where T7 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 2D and cube-mapped texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static void CompressedTexImage2D<T7>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] ref T7 data)
            where T7 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static void CompressedTexImage3D(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        [CLSCompliant(false)]
        public static void CompressedTexImage3D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[] data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        [CLSCompliant(false)]
        public static void CompressedTexImage3D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[,] data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        [CLSCompliant(false)]
        public static void CompressedTexImage3D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[,,] data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static void CompressedTexImage3D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] ref T8 data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static void CompressedTexImage3D(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        [CLSCompliant(false)]
        public static void CompressedTexImage3D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[] data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        [CLSCompliant(false)]
        public static void CompressedTexImage3D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[,] data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        [CLSCompliant(false)]
        public static void CompressedTexImage3D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[,,] data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static void CompressedTexImage3D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] ref T8 data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static void CompressedTexSubImage2D(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        [CLSCompliant(false)]
        public static void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[] data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        [CLSCompliant(false)]
        public static void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[,] data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        [CLSCompliant(false)]
        public static void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[,,] data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] ref T8 data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static void CompressedTexSubImage2D(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        [CLSCompliant(false)]
        public static void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[] data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        [CLSCompliant(false)]
        public static void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[,] data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        [CLSCompliant(false)]
        public static void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[,,] data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] ref T8 data)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static void CompressedTexSubImage3D(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        [CLSCompliant(false)]
        public static void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T10[] data)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        [CLSCompliant(false)]
        public static void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T10[,] data)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        [CLSCompliant(false)]
        public static void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T10[,,] data)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] ref T10 data)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static void CompressedTexSubImage3D(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.PixelFormat format, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        [CLSCompliant(false)]
        public static void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T10[] data)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        [CLSCompliant(false)]
        public static void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T10[,] data)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        [CLSCompliant(false)]
        public static void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T10[,,] data)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">[length: imageSize]
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] ref T10 data)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Copy part of the data store of a buffer object to the data store of another buffer object
        /// </summary>
        /// <param name="readTarget">
        /// Specifies the target from whose data store data should be read.
        /// </param>
        /// <param name="writeTarget">
        /// Specifies the target to whose data store data should be written.
        /// </param>
        /// <param name="readOffset">
        /// Specifies the offset, in basic machine units, within the data store of readtarget from which data should be read.
        /// </param>
        /// <param name="writeOffset">
        /// Specifies the offset, in basic machine units, within the data store of writetarget to which data should be written.
        /// </param>
        /// <param name="size">
        /// Specifies the size, in basic machine units, of the data to be copied from readtarget to writetarget.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCopyBufferSubData")]
        public static void CopyBufferSubData(OpenTK.Graphics.ES31.All readTarget, OpenTK.Graphics.ES31.All writeTarget, IntPtr readOffset, IntPtr writeOffset, Int32 size) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Copy part of the data store of a buffer object to the data store of another buffer object
        /// </summary>
        /// <param name="readTarget">
        /// Specifies the target from whose data store data should be read.
        /// </param>
        /// <param name="writeTarget">
        /// Specifies the target to whose data store data should be written.
        /// </param>
        /// <param name="readOffset">
        /// Specifies the offset, in basic machine units, within the data store of readtarget from which data should be read.
        /// </param>
        /// <param name="writeOffset">
        /// Specifies the offset, in basic machine units, within the data store of writetarget to which data should be written.
        /// </param>
        /// <param name="size">
        /// Specifies the size, in basic machine units, of the data to be copied from readtarget to writetarget.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCopyBufferSubData")]
        public static void CopyBufferSubData(OpenTK.Graphics.ES31.All readTarget, OpenTK.Graphics.ES31.All writeTarget, IntPtr readOffset, IntPtr writeOffset, IntPtr size) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Copy pixels into a 2D texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format of the texture. Must be one of the following symbolic constants: Alpha, Luminance, LuminanceAlpha, Rgb, Rgba, R8, Rg8, Rgb565, Rgb8, Rgba4, Rgb5A1, Rgba8, Rgb10A2, Srgb8, Srgb8Alpha8, R8i, R8ui, R16i, R16ui, R32i, R32ui, Rg8i, Rg8ui, Rg16i, Rg16ui, Rg32i, Rg32ui, Rgba8i, Rgba8ui, Rgb10A2ui, Rgba16i, Rgba16ui, Rgba32i, Rgba32ui.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="border">
        /// Specifies the width of the border. Must be 0.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCopyTexImage2D")]
        public static void CopyTexImage2D(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 x, Int32 y, Int32 width, Int32 height, Int32 border) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Copy pixels into a 2D texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format of the texture. Must be one of the following symbolic constants: Alpha, Luminance, LuminanceAlpha, Rgb, Rgba, R8, Rg8, Rgb565, Rgb8, Rgba4, Rgb5A1, Rgba8, Rgb10A2, Srgb8, Srgb8Alpha8, R8i, R8ui, R16i, R16ui, R32i, R32ui, Rg8i, Rg8ui, Rg16i, Rg16ui, Rg32i, Rg32ui, Rgba8i, Rgba8ui, Rgb10A2ui, Rgba16i, Rgba16ui, Rgba32i, Rgba32ui.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="border">
        /// Specifies the width of the border. Must be 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCopyTexImage2D")]
        public static void CopyTexImage2D(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.PixelInternalFormat internalformat, Int32 x, Int32 y, Int32 width, Int32 height, Int32 border) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Copy a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCopyTexSubImage2D")]
        public static void CopyTexSubImage2D(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 x, Int32 y, Int32 width, Int32 height) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Copy a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCopyTexSubImage2D")]
        public static void CopyTexSubImage2D(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 x, Int32 y, Int32 width, Int32 height) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Copy a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCopyTexSubImage3D")]
        public static void CopyTexSubImage3D(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Copy a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCopyTexSubImage3D")]
        public static void CopyTexSubImage3D(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates a program object
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCreateProgram")]
        public static Int32 CreateProgram() { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Creates a shader object
        /// </summary>
        /// <param name="type">
        /// Specifies the type of shader to be created. VertexShader, FragmentShader, or ComputeShader,
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCreateShader")]
        public static Int32 CreateShader(OpenTK.Graphics.ES31.All type) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Create a stand-alone program from an array of null-terminated source code strings
        /// </summary>
        /// <param name="type">
        /// Specifies the type of shader to create.
        /// </param>
        /// <param name="count">
        /// Specifies the number of source code strings in the array strings.
        /// </param>
        /// <param name="strings">[length: count]
        /// Specifies the address of an array of pointers to source code strings from which to create the program object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glCreateShaderProgramv")]
        public static Int32 CreateShaderProgram(OpenTK.Graphics.ES31.All type, Int32 count, [CountAttribute(Parameter = "count")] String[] strings) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify whether front- or back-facing polygons can be culled
        /// </summary>
        /// <param name="mode">
        /// Specifies whether front- or back-facing polygons are candidates for culling. Symbolic constants Front, Back, and FrontAndBack are accepted. The initial value is Back.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCullFace")]
        public static void CullFace(OpenTK.Graphics.ES31.All mode) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify whether front- or back-facing polygons can be culled
        /// </summary>
        /// <param name="mode">
        /// Specifies whether front- or back-facing polygons are candidates for culling. Symbolic constants Front, Back, and FrontAndBack are accepted. The initial value is Back.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCullFace")]
        public static void CullFace(OpenTK.Graphics.ES31.CullFaceMode mode) { throw new NotImplementedException(); }

        /// <summary>
        /// Specify a callback to receive debugging messages from the GL
        /// </summary>
        /// <param name="callback">
        /// The address of a callback function that will be called when a debug message is generated.
        /// </param>
        /// <param name="userParam">
        /// A user supplied pointer that will be passed on each invocation of callback.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallback")]
        public static void DebugMessageCallback(DebugProc callback, IntPtr userParam) { throw new NotImplementedException(); }

        /// <summary>
        /// Specify a callback to receive debugging messages from the GL
        /// </summary>
        /// <param name="callback">
        /// The address of a callback function that will be called when a debug message is generated.
        /// </param>
        /// <param name="userParam">
        /// A user supplied pointer that will be passed on each invocation of callback.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallback")]
        [CLSCompliant(false)]
        public static void DebugMessageCallback<T1>(DebugProc callback, [InAttribute, OutAttribute] T1[] userParam)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Specify a callback to receive debugging messages from the GL
        /// </summary>
        /// <param name="callback">
        /// The address of a callback function that will be called when a debug message is generated.
        /// </param>
        /// <param name="userParam">
        /// A user supplied pointer that will be passed on each invocation of callback.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallback")]
        [CLSCompliant(false)]
        public static void DebugMessageCallback<T1>(DebugProc callback, [InAttribute, OutAttribute] T1[,] userParam)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Specify a callback to receive debugging messages from the GL
        /// </summary>
        /// <param name="callback">
        /// The address of a callback function that will be called when a debug message is generated.
        /// </param>
        /// <param name="userParam">
        /// A user supplied pointer that will be passed on each invocation of callback.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallback")]
        [CLSCompliant(false)]
        public static void DebugMessageCallback<T1>(DebugProc callback, [InAttribute, OutAttribute] T1[,,] userParam)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Specify a callback to receive debugging messages from the GL
        /// </summary>
        /// <param name="callback">
        /// The address of a callback function that will be called when a debug message is generated.
        /// </param>
        /// <param name="userParam">
        /// A user supplied pointer that will be passed on each invocation of callback.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallback")]
        public static void DebugMessageCallback<T1>(DebugProc callback, [InAttribute, OutAttribute] ref T1 userParam)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// The source of debug messages to enable or disable.
        /// </param>
        /// <param name="type">
        /// The type of debug messages to enable or disable.
        /// </param>
        /// <param name="severity">
        /// The severity of debug messages to enable or disable.
        /// </param>
        /// <param name="count">
        /// The length of the array ids.
        /// </param>
        /// <param name="ids">[length: count]
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </param>
        /// <param name="enabled">
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        [CLSCompliant(false)]
        public static void DebugMessageControl(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, OpenTK.Graphics.ES31.All severity, Int32 count, [CountAttribute(Parameter = "count")] Int32[] ids, bool enabled) { throw new NotImplementedException(); }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// The source of debug messages to enable or disable.
        /// </param>
        /// <param name="type">
        /// The type of debug messages to enable or disable.
        /// </param>
        /// <param name="severity">
        /// The severity of debug messages to enable or disable.
        /// </param>
        /// <param name="count">
        /// The length of the array ids.
        /// </param>
        /// <param name="ids">[length: count]
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </param>
        /// <param name="enabled">
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        [CLSCompliant(false)]
        public static void DebugMessageControl(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, OpenTK.Graphics.ES31.All severity, Int32 count, [CountAttribute(Parameter = "count")] ref Int32 ids, bool enabled) { throw new NotImplementedException(); }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// The source of debug messages to enable or disable.
        /// </param>
        /// <param name="type">
        /// The type of debug messages to enable or disable.
        /// </param>
        /// <param name="severity">
        /// The severity of debug messages to enable or disable.
        /// </param>
        /// <param name="count">
        /// The length of the array ids.
        /// </param>
        /// <param name="ids">[length: count]
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </param>
        /// <param name="enabled">
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        [CLSCompliant(false)]
        public static unsafe void DebugMessageControl(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, OpenTK.Graphics.ES31.All severity, Int32 count, [CountAttribute(Parameter = "count")] Int32* ids, bool enabled) { throw new NotImplementedException(); }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// The source of debug messages to enable or disable.
        /// </param>
        /// <param name="type">
        /// The type of debug messages to enable or disable.
        /// </param>
        /// <param name="severity">
        /// The severity of debug messages to enable or disable.
        /// </param>
        /// <param name="count">
        /// The length of the array ids.
        /// </param>
        /// <param name="ids">[length: count]
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </param>
        /// <param name="enabled">
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        [CLSCompliant(false)]
        public static void DebugMessageControl(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, OpenTK.Graphics.ES31.All severity, Int32 count, [CountAttribute(Parameter = "count")] UInt32[] ids, bool enabled) { throw new NotImplementedException(); }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// The source of debug messages to enable or disable.
        /// </param>
        /// <param name="type">
        /// The type of debug messages to enable or disable.
        /// </param>
        /// <param name="severity">
        /// The severity of debug messages to enable or disable.
        /// </param>
        /// <param name="count">
        /// The length of the array ids.
        /// </param>
        /// <param name="ids">[length: count]
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </param>
        /// <param name="enabled">
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        [CLSCompliant(false)]
        public static void DebugMessageControl(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, OpenTK.Graphics.ES31.All severity, Int32 count, [CountAttribute(Parameter = "count")] ref UInt32 ids, bool enabled) { throw new NotImplementedException(); }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// The source of debug messages to enable or disable.
        /// </param>
        /// <param name="type">
        /// The type of debug messages to enable or disable.
        /// </param>
        /// <param name="severity">
        /// The severity of debug messages to enable or disable.
        /// </param>
        /// <param name="count">
        /// The length of the array ids.
        /// </param>
        /// <param name="ids">[length: count]
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </param>
        /// <param name="enabled">
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        [CLSCompliant(false)]
        public static unsafe void DebugMessageControl(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, OpenTK.Graphics.ES31.All severity, Int32 count, [CountAttribute(Parameter = "count")] UInt32* ids, bool enabled) { throw new NotImplementedException(); }

        /// <summary>
        /// Inject an application-supplied message into the debug message queue
        /// </summary>
        /// <param name="source">
        /// The source of the debug message to insert.
        /// </param>
        /// <param name="type">
        /// The type of the debug message insert.
        /// </param>
        /// <param name="id">
        /// The user-supplied identifier of the message to insert.
        /// </param>
        /// <param name="severity">
        /// The severity of the debug messages to insert.
        /// </param>
        /// <param name="length">
        /// The length string contained in the character array whose address is given by message.
        /// </param>
        /// <param name="buf">[length: COMPSIZE(buf,length)]
        /// The address of a character array containing the message to insert.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageInsert")]
        [CLSCompliant(false)]
        public static void DebugMessageInsert(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, Int32 id, OpenTK.Graphics.ES31.All severity, Int32 length, [CountAttribute(Computed = "buf,length")] String buf) { throw new NotImplementedException(); }

        /// <summary>
        /// Inject an application-supplied message into the debug message queue
        /// </summary>
        /// <param name="source">
        /// The source of the debug message to insert.
        /// </param>
        /// <param name="type">
        /// The type of the debug message insert.
        /// </param>
        /// <param name="id">
        /// The user-supplied identifier of the message to insert.
        /// </param>
        /// <param name="severity">
        /// The severity of the debug messages to insert.
        /// </param>
        /// <param name="length">
        /// The length string contained in the character array whose address is given by message.
        /// </param>
        /// <param name="buf">[length: COMPSIZE(buf,length)]
        /// The address of a character array containing the message to insert.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageInsert")]
        [CLSCompliant(false)]
        public static void DebugMessageInsert(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, UInt32 id, OpenTK.Graphics.ES31.All severity, Int32 length, [CountAttribute(Computed = "buf,length")] String buf) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="buffers">[length: n]
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        [CLSCompliant(false)]
        public static void DeleteBuffer([CountAttribute(Parameter = "n")] Int32 buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="buffers">[length: n]
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        [CLSCompliant(false)]
        public static void DeleteBuffer([CountAttribute(Parameter = "n")] UInt32 buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to be deleted.
        /// </param>
        /// <param name="buffers">[length: n]
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        [CLSCompliant(false)]
        public static void DeleteBuffers(Int32 n, [CountAttribute(Parameter = "n")] Int32[] buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to be deleted.
        /// </param>
        /// <param name="buffers">[length: n]
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        [CLSCompliant(false)]
        public static void DeleteBuffers(Int32 n, [CountAttribute(Parameter = "n")] ref Int32 buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to be deleted.
        /// </param>
        /// <param name="buffers">[length: n]
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        [CLSCompliant(false)]
        public static unsafe void DeleteBuffers(Int32 n, [CountAttribute(Parameter = "n")] Int32* buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to be deleted.
        /// </param>
        /// <param name="buffers">[length: n]
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        [CLSCompliant(false)]
        public static void DeleteBuffers(Int32 n, [CountAttribute(Parameter = "n")] UInt32[] buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to be deleted.
        /// </param>
        /// <param name="buffers">[length: n]
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        [CLSCompliant(false)]
        public static void DeleteBuffers(Int32 n, [CountAttribute(Parameter = "n")] ref UInt32 buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to be deleted.
        /// </param>
        /// <param name="buffers">[length: n]
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        [CLSCompliant(false)]
        public static unsafe void DeleteBuffers(Int32 n, [CountAttribute(Parameter = "n")] UInt32* buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="framebuffers">[length: n]
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        [CLSCompliant(false)]
        public static void DeleteFramebuffer([CountAttribute(Parameter = "n")] Int32 framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="framebuffers">[length: n]
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        [CLSCompliant(false)]
        public static void DeleteFramebuffer([CountAttribute(Parameter = "n")] UInt32 framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer objects to be deleted.
        /// </param>
        /// <param name="framebuffers">[length: n]
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        [CLSCompliant(false)]
        public static void DeleteFramebuffers(Int32 n, [CountAttribute(Parameter = "n")] Int32[] framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer objects to be deleted.
        /// </param>
        /// <param name="framebuffers">[length: n]
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        [CLSCompliant(false)]
        public static void DeleteFramebuffers(Int32 n, [CountAttribute(Parameter = "n")] ref Int32 framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer objects to be deleted.
        /// </param>
        /// <param name="framebuffers">[length: n]
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        [CLSCompliant(false)]
        public static unsafe void DeleteFramebuffers(Int32 n, [CountAttribute(Parameter = "n")] Int32* framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer objects to be deleted.
        /// </param>
        /// <param name="framebuffers">[length: n]
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        [CLSCompliant(false)]
        public static void DeleteFramebuffers(Int32 n, [CountAttribute(Parameter = "n")] UInt32[] framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer objects to be deleted.
        /// </param>
        /// <param name="framebuffers">[length: n]
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        [CLSCompliant(false)]
        public static void DeleteFramebuffers(Int32 n, [CountAttribute(Parameter = "n")] ref UInt32 framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer objects to be deleted.
        /// </param>
        /// <param name="framebuffers">[length: n]
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        [CLSCompliant(false)]
        public static unsafe void DeleteFramebuffers(Int32 n, [CountAttribute(Parameter = "n")] UInt32* framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Deletes a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteProgram")]
        [CLSCompliant(false)]
        public static void DeleteProgram(Int32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Deletes a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteProgram")]
        [CLSCompliant(false)]
        public static void DeleteProgram(UInt32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Delete program pipeline objects
        /// </summary>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of names of program pipeline objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDeleteProgramPipelines")]
        [CLSCompliant(false)]
        public static void DeleteProgramPipeline([CountAttribute(Parameter = "n")] Int32 pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Delete program pipeline objects
        /// </summary>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of names of program pipeline objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDeleteProgramPipelines")]
        [CLSCompliant(false)]
        public static void DeleteProgramPipeline([CountAttribute(Parameter = "n")] UInt32 pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Delete program pipeline objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline objects to delete.
        /// </param>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of names of program pipeline objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDeleteProgramPipelines")]
        [CLSCompliant(false)]
        public static void DeleteProgramPipelines(Int32 n, [CountAttribute(Parameter = "n")] Int32[] pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Delete program pipeline objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline objects to delete.
        /// </param>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of names of program pipeline objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDeleteProgramPipelines")]
        [CLSCompliant(false)]
        public static void DeleteProgramPipelines(Int32 n, [CountAttribute(Parameter = "n")] ref Int32 pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Delete program pipeline objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline objects to delete.
        /// </param>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of names of program pipeline objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDeleteProgramPipelines")]
        [CLSCompliant(false)]
        public static unsafe void DeleteProgramPipelines(Int32 n, [CountAttribute(Parameter = "n")] Int32* pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Delete program pipeline objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline objects to delete.
        /// </param>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of names of program pipeline objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDeleteProgramPipelines")]
        [CLSCompliant(false)]
        public static void DeleteProgramPipelines(Int32 n, [CountAttribute(Parameter = "n")] UInt32[] pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Delete program pipeline objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline objects to delete.
        /// </param>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of names of program pipeline objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDeleteProgramPipelines")]
        [CLSCompliant(false)]
        public static void DeleteProgramPipelines(Int32 n, [CountAttribute(Parameter = "n")] ref UInt32 pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Delete program pipeline objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline objects to delete.
        /// </param>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of names of program pipeline objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDeleteProgramPipelines")]
        [CLSCompliant(false)]
        public static unsafe void DeleteProgramPipelines(Int32 n, [CountAttribute(Parameter = "n")] UInt32* pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="ids">[length: n]
        /// Specifies an array of query objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        [CLSCompliant(false)]
        public static void DeleteQuery([CountAttribute(Parameter = "n")] Int32 ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="ids">[length: n]
        /// Specifies an array of query objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        [CLSCompliant(false)]
        public static void DeleteQuery([CountAttribute(Parameter = "n")] UInt32 ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query objects to be deleted.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of query objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        [CLSCompliant(false)]
        public static void DeleteQueries(Int32 n, [CountAttribute(Parameter = "n")] Int32[] ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query objects to be deleted.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of query objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        [CLSCompliant(false)]
        public static void DeleteQueries(Int32 n, [CountAttribute(Parameter = "n")] ref Int32 ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query objects to be deleted.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of query objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        [CLSCompliant(false)]
        public static unsafe void DeleteQueries(Int32 n, [CountAttribute(Parameter = "n")] Int32* ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query objects to be deleted.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of query objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        [CLSCompliant(false)]
        public static void DeleteQueries(Int32 n, [CountAttribute(Parameter = "n")] UInt32[] ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query objects to be deleted.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of query objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        [CLSCompliant(false)]
        public static void DeleteQueries(Int32 n, [CountAttribute(Parameter = "n")] ref UInt32 ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query objects to be deleted.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of query objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        [CLSCompliant(false)]
        public static unsafe void DeleteQueries(Int32 n, [CountAttribute(Parameter = "n")] UInt32* ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="renderbuffers">[length: n]
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        [CLSCompliant(false)]
        public static void DeleteRenderbuffer([CountAttribute(Parameter = "n")] Int32 renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="renderbuffers">[length: n]
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        [CLSCompliant(false)]
        public static void DeleteRenderbuffer([CountAttribute(Parameter = "n")] UInt32 renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </param>
        /// <param name="renderbuffers">[length: n]
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        [CLSCompliant(false)]
        public static void DeleteRenderbuffers(Int32 n, [CountAttribute(Parameter = "n")] Int32[] renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </param>
        /// <param name="renderbuffers">[length: n]
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        [CLSCompliant(false)]
        public static void DeleteRenderbuffers(Int32 n, [CountAttribute(Parameter = "n")] ref Int32 renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </param>
        /// <param name="renderbuffers">[length: n]
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        [CLSCompliant(false)]
        public static unsafe void DeleteRenderbuffers(Int32 n, [CountAttribute(Parameter = "n")] Int32* renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </param>
        /// <param name="renderbuffers">[length: n]
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        [CLSCompliant(false)]
        public static void DeleteRenderbuffers(Int32 n, [CountAttribute(Parameter = "n")] UInt32[] renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </param>
        /// <param name="renderbuffers">[length: n]
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        [CLSCompliant(false)]
        public static void DeleteRenderbuffers(Int32 n, [CountAttribute(Parameter = "n")] ref UInt32 renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </param>
        /// <param name="renderbuffers">[length: n]
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        [CLSCompliant(false)]
        public static unsafe void DeleteRenderbuffers(Int32 n, [CountAttribute(Parameter = "n")] UInt32* renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="samplers">[length: count]
        /// Specifies an array of sampler objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        [CLSCompliant(false)]
        public static void DeleteSampler([CountAttribute(Parameter = "count")] Int32 samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="samplers">[length: count]
        /// Specifies an array of sampler objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        [CLSCompliant(false)]
        public static void DeleteSampler([CountAttribute(Parameter = "count")] UInt32 samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler objects to be deleted.
        /// </param>
        /// <param name="samplers">[length: count]
        /// Specifies an array of sampler objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        [CLSCompliant(false)]
        public static void DeleteSamplers(Int32 count, [CountAttribute(Parameter = "count")] Int32[] samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler objects to be deleted.
        /// </param>
        /// <param name="samplers">[length: count]
        /// Specifies an array of sampler objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        [CLSCompliant(false)]
        public static void DeleteSamplers(Int32 count, [CountAttribute(Parameter = "count")] ref Int32 samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler objects to be deleted.
        /// </param>
        /// <param name="samplers">[length: count]
        /// Specifies an array of sampler objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        [CLSCompliant(false)]
        public static unsafe void DeleteSamplers(Int32 count, [CountAttribute(Parameter = "count")] Int32* samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler objects to be deleted.
        /// </param>
        /// <param name="samplers">[length: count]
        /// Specifies an array of sampler objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        [CLSCompliant(false)]
        public static void DeleteSamplers(Int32 count, [CountAttribute(Parameter = "count")] UInt32[] samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler objects to be deleted.
        /// </param>
        /// <param name="samplers">[length: count]
        /// Specifies an array of sampler objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        [CLSCompliant(false)]
        public static void DeleteSamplers(Int32 count, [CountAttribute(Parameter = "count")] ref UInt32 samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler objects to be deleted.
        /// </param>
        /// <param name="samplers">[length: count]
        /// Specifies an array of sampler objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        [CLSCompliant(false)]
        public static unsafe void DeleteSamplers(Int32 count, [CountAttribute(Parameter = "count")] UInt32* samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Deletes a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteShader")]
        [CLSCompliant(false)]
        public static void DeleteShader(Int32 shader) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Deletes a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteShader")]
        [CLSCompliant(false)]
        public static void DeleteShader(UInt32 shader) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete a sync object
        /// </summary>
        /// <param name="sync">
        /// The sync object to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSync")]
        public static void DeleteSync(IntPtr sync) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="textures">[length: n]
        /// Specifies an array of textures to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        [CLSCompliant(false)]
        public static void DeleteTexture([CountAttribute(Parameter = "n")] Int32 textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="textures">[length: n]
        /// Specifies an array of textures to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        [CLSCompliant(false)]
        public static void DeleteTexture([CountAttribute(Parameter = "n")] UInt32 textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be deleted.
        /// </param>
        /// <param name="textures">[length: n]
        /// Specifies an array of textures to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        [CLSCompliant(false)]
        public static void DeleteTextures(Int32 n, [CountAttribute(Parameter = "n")] Int32[] textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be deleted.
        /// </param>
        /// <param name="textures">[length: n]
        /// Specifies an array of textures to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        [CLSCompliant(false)]
        public static void DeleteTextures(Int32 n, [CountAttribute(Parameter = "n")] ref Int32 textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be deleted.
        /// </param>
        /// <param name="textures">[length: n]
        /// Specifies an array of textures to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        [CLSCompliant(false)]
        public static unsafe void DeleteTextures(Int32 n, [CountAttribute(Parameter = "n")] Int32* textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be deleted.
        /// </param>
        /// <param name="textures">[length: n]
        /// Specifies an array of textures to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        [CLSCompliant(false)]
        public static void DeleteTextures(Int32 n, [CountAttribute(Parameter = "n")] UInt32[] textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be deleted.
        /// </param>
        /// <param name="textures">[length: n]
        /// Specifies an array of textures to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        [CLSCompliant(false)]
        public static void DeleteTextures(Int32 n, [CountAttribute(Parameter = "n")] ref UInt32 textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be deleted.
        /// </param>
        /// <param name="textures">[length: n]
        /// Specifies an array of textures to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        [CLSCompliant(false)]
        public static unsafe void DeleteTextures(Int32 n, [CountAttribute(Parameter = "n")] UInt32* textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="ids">[length: n]
        /// Specifies an array of names of transform feedback objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        [CLSCompliant(false)]
        public static void DeleteTransformFeedback([CountAttribute(Parameter = "n")] Int32 ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="ids">[length: n]
        /// Specifies an array of names of transform feedback objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        [CLSCompliant(false)]
        public static void DeleteTransformFeedback([CountAttribute(Parameter = "n")] UInt32 ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback objects to delete.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of names of transform feedback objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        [CLSCompliant(false)]
        public static void DeleteTransformFeedbacks(Int32 n, [CountAttribute(Parameter = "n")] Int32[] ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback objects to delete.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of names of transform feedback objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        [CLSCompliant(false)]
        public static void DeleteTransformFeedbacks(Int32 n, [CountAttribute(Parameter = "n")] ref Int32 ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback objects to delete.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of names of transform feedback objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        [CLSCompliant(false)]
        public static unsafe void DeleteTransformFeedbacks(Int32 n, [CountAttribute(Parameter = "n")] Int32* ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback objects to delete.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of names of transform feedback objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        [CLSCompliant(false)]
        public static void DeleteTransformFeedbacks(Int32 n, [CountAttribute(Parameter = "n")] UInt32[] ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback objects to delete.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of names of transform feedback objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        [CLSCompliant(false)]
        public static void DeleteTransformFeedbacks(Int32 n, [CountAttribute(Parameter = "n")] ref UInt32 ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback objects to delete.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of names of transform feedback objects to delete.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        [CLSCompliant(false)]
        public static unsafe void DeleteTransformFeedbacks(Int32 n, [CountAttribute(Parameter = "n")] UInt32* ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="arrays">[length: n]
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        [CLSCompliant(false)]
        public static void DeleteVertexArray([CountAttribute(Parameter = "n")] Int32 arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="arrays">[length: n]
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        [CLSCompliant(false)]
        public static void DeleteVertexArray([CountAttribute(Parameter = "n")] UInt32 arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array objects to be deleted.
        /// </param>
        /// <param name="arrays">[length: n]
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        [CLSCompliant(false)]
        public static void DeleteVertexArrays(Int32 n, [CountAttribute(Parameter = "n")] Int32[] arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array objects to be deleted.
        /// </param>
        /// <param name="arrays">[length: n]
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        [CLSCompliant(false)]
        public static void DeleteVertexArrays(Int32 n, [CountAttribute(Parameter = "n")] ref Int32 arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array objects to be deleted.
        /// </param>
        /// <param name="arrays">[length: n]
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        [CLSCompliant(false)]
        public static unsafe void DeleteVertexArrays(Int32 n, [CountAttribute(Parameter = "n")] Int32* arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array objects to be deleted.
        /// </param>
        /// <param name="arrays">[length: n]
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        [CLSCompliant(false)]
        public static void DeleteVertexArrays(Int32 n, [CountAttribute(Parameter = "n")] UInt32[] arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array objects to be deleted.
        /// </param>
        /// <param name="arrays">[length: n]
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        [CLSCompliant(false)]
        public static void DeleteVertexArrays(Int32 n, [CountAttribute(Parameter = "n")] ref UInt32 arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array objects to be deleted.
        /// </param>
        /// <param name="arrays">[length: n]
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        [CLSCompliant(false)]
        public static unsafe void DeleteVertexArrays(Int32 n, [CountAttribute(Parameter = "n")] UInt32* arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value used for depth buffer comparisons
        /// </summary>
        /// <param name="func">
        /// Specifies the depth comparison function. Symbolic constants Never, Less, Equal, Lequal, Greater, Notequal, Gequal, and Always are accepted. The initial value is Less.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDepthFunc")]
        public static void DepthFunc(OpenTK.Graphics.ES31.All func) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value used for depth buffer comparisons
        /// </summary>
        /// <param name="func">
        /// Specifies the depth comparison function. Symbolic constants Never, Less, Equal, Lequal, Greater, Notequal, Gequal, and Always are accepted. The initial value is Less.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDepthFunc")]
        public static void DepthFunc(OpenTK.Graphics.ES31.DepthFunction func) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Enable or disable writing into the depth buffer
        /// </summary>
        /// <param name="flag">
        /// Specifies whether the depth buffer is enabled for writing. If flag is False, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDepthMask")]
        public static void DepthMask(bool flag) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify mapping of depth values from normalized device coordinates to window coordinates
        /// </summary>
        /// <param name="n">
        /// Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
        /// </param>
        /// <param name="f">
        /// Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDepthRangef")]
        public static void DepthRange(Single n, Single f) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Detaches a shader object from a program object to which it is attached
        /// </summary>
        /// <param name="program">
        /// Specifies the program object from which to detach the shader object.
        /// </param>
        /// <param name="shader">
        /// Specifies the shader object to be detached.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDetachShader")]
        [CLSCompliant(false)]
        public static void DetachShader(Int32 program, Int32 shader) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Detaches a shader object from a program object to which it is attached
        /// </summary>
        /// <param name="program">
        /// Specifies the program object from which to detach the shader object.
        /// </param>
        /// <param name="shader">
        /// Specifies the shader object to be detached.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDetachShader")]
        [CLSCompliant(false)]
        public static void DetachShader(UInt32 program, UInt32 shader) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="cap"></param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDisable")]
        public static void Disable(OpenTK.Graphics.ES31.All cap) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="cap"></param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDisable")]
        public static void Disable(OpenTK.Graphics.ES31.EnableCap cap) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="index"></param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDisableVertexAttribArray")]
        [CLSCompliant(false)]
        public static void DisableVertexAttribArray(Int32 index) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="index"></param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDisableVertexAttribArray")]
        [CLSCompliant(false)]
        public static void DisableVertexAttribArray(UInt32 index) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Launch one or more compute work groups
        /// </summary>
        /// <param name="num_groups_x">
        /// The number of work groups to be launched in the X dimension.
        /// </param>
        /// <param name="num_groups_y">
        /// The number of work groups to be launched in the Y dimension.
        /// </param>
        /// <param name="num_groups_z">
        /// The number of work groups to be launched in the Z dimension.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDispatchCompute")]
        [CLSCompliant(false)]
        public static void DispatchCompute(Int32 num_groups_x, Int32 num_groups_y, Int32 num_groups_z) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Launch one or more compute work groups
        /// </summary>
        /// <param name="num_groups_x">
        /// The number of work groups to be launched in the X dimension.
        /// </param>
        /// <param name="num_groups_y">
        /// The number of work groups to be launched in the Y dimension.
        /// </param>
        /// <param name="num_groups_z">
        /// The number of work groups to be launched in the Z dimension.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDispatchCompute")]
        [CLSCompliant(false)]
        public static void DispatchCompute(UInt32 num_groups_x, UInt32 num_groups_y, UInt32 num_groups_z) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Launch one or more compute work groups using parameters stored in a buffer
        /// </summary>
        /// <param name="indirect">
        /// The offset into the buffer object currently bound to the DispatchIndirectBuffer buffer target at which the dispatch parameters are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDispatchComputeIndirect")]
        public static void DispatchComputeIndirect(IntPtr indirect) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawArrays")]
        public static void DrawArrays(OpenTK.Graphics.ES31.All mode, Int32 first, Int32 count) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawArrays")]
        public static void DrawArrays(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 first, Int32 count) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawArraysIndirect")]
        public static void DrawArraysIndirect(OpenTK.Graphics.ES31.All mode, IntPtr indirect) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawArraysIndirect")]
        [CLSCompliant(false)]
        public static void DrawArraysIndirect<T1>(OpenTK.Graphics.ES31.All mode, [InAttribute, OutAttribute] T1[] indirect)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawArraysIndirect")]
        [CLSCompliant(false)]
        public static void DrawArraysIndirect<T1>(OpenTK.Graphics.ES31.All mode, [InAttribute, OutAttribute] T1[,] indirect)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawArraysIndirect")]
        [CLSCompliant(false)]
        public static void DrawArraysIndirect<T1>(OpenTK.Graphics.ES31.All mode, [InAttribute, OutAttribute] T1[,,] indirect)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawArraysIndirect")]
        public static void DrawArraysIndirect<T1>(OpenTK.Graphics.ES31.All mode, [InAttribute, OutAttribute] ref T1 indirect)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawArraysIndirect")]
        public static void DrawArraysIndirect(OpenTK.Graphics.ES31.PrimitiveType mode, IntPtr indirect) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawArraysIndirect")]
        [CLSCompliant(false)]
        public static void DrawArraysIndirect<T1>(OpenTK.Graphics.ES31.PrimitiveType mode, [InAttribute, OutAttribute] T1[] indirect)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawArraysIndirect")]
        [CLSCompliant(false)]
        public static void DrawArraysIndirect<T1>(OpenTK.Graphics.ES31.PrimitiveType mode, [InAttribute, OutAttribute] T1[,] indirect)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawArraysIndirect")]
        [CLSCompliant(false)]
        public static void DrawArraysIndirect<T1>(OpenTK.Graphics.ES31.PrimitiveType mode, [InAttribute, OutAttribute] T1[,,] indirect)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawArraysIndirect")]
        public static void DrawArraysIndirect<T1>(OpenTK.Graphics.ES31.PrimitiveType mode, [InAttribute, OutAttribute] ref T1 indirect)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Draw multiple instances of a range of elements
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawArraysInstanced")]
        public static void DrawArraysInstanced(OpenTK.Graphics.ES31.All mode, Int32 first, Int32 count, Int32 instancecount) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Draw multiple instances of a range of elements
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawArraysInstanced")]
        public static void DrawArraysInstanced(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 first, Int32 count, Int32 instancecount) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specifies a list of color buffers to be drawn into
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffers in bufs.
        /// </param>
        /// <param name="bufs">[length: n]
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawBuffers")]
        [CLSCompliant(false)]
        public static void DrawBuffers(Int32 n, [CountAttribute(Parameter = "n")] OpenTK.Graphics.ES31.All[] bufs) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specifies a list of color buffers to be drawn into
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffers in bufs.
        /// </param>
        /// <param name="bufs">[length: n]
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawBuffers")]
        [CLSCompliant(false)]
        public static void DrawBuffers(Int32 n, [CountAttribute(Parameter = "n")] ref OpenTK.Graphics.ES31.All bufs) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specifies a list of color buffers to be drawn into
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffers in bufs.
        /// </param>
        /// <param name="bufs">[length: n]
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawBuffers")]
        [CLSCompliant(false)]
        public static unsafe void DrawBuffers(Int32 n, [CountAttribute(Parameter = "n")] OpenTK.Graphics.ES31.All* bufs) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static void DrawElements(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        [CLSCompliant(false)]
        public static void DrawElements<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        [CLSCompliant(false)]
        public static void DrawElements<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        [CLSCompliant(false)]
        public static void DrawElements<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static void DrawElements<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static void DrawElements(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "count,type")] IntPtr indices) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        [CLSCompliant(false)]
        public static void DrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        [CLSCompliant(false)]
        public static void DrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        [CLSCompliant(false)]
        public static void DrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static void DrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render indexed primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles, are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawElementsIndirect")]
        public static void DrawElementsIndirect(OpenTK.Graphics.ES31.All mode, OpenTK.Graphics.ES31.All type, IntPtr indirect) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render indexed primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles, are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawElementsIndirect")]
        [CLSCompliant(false)]
        public static void DrawElementsIndirect<T2>(OpenTK.Graphics.ES31.All mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute] T2[] indirect)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render indexed primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles, are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawElementsIndirect")]
        [CLSCompliant(false)]
        public static void DrawElementsIndirect<T2>(OpenTK.Graphics.ES31.All mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute] T2[,] indirect)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render indexed primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles, are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawElementsIndirect")]
        [CLSCompliant(false)]
        public static void DrawElementsIndirect<T2>(OpenTK.Graphics.ES31.All mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute] T2[,,] indirect)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render indexed primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles, are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawElementsIndirect")]
        public static void DrawElementsIndirect<T2>(OpenTK.Graphics.ES31.All mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute] ref T2 indirect)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render indexed primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles, are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawElementsIndirect")]
        public static void DrawElementsIndirect(OpenTK.Graphics.ES31.PrimitiveType mode, OpenTK.Graphics.ES31.All type, IntPtr indirect) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render indexed primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles, are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawElementsIndirect")]
        [CLSCompliant(false)]
        public static void DrawElementsIndirect<T2>(OpenTK.Graphics.ES31.PrimitiveType mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute] T2[] indirect)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render indexed primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles, are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawElementsIndirect")]
        [CLSCompliant(false)]
        public static void DrawElementsIndirect<T2>(OpenTK.Graphics.ES31.PrimitiveType mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute] T2[,] indirect)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render indexed primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles, are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawElementsIndirect")]
        [CLSCompliant(false)]
        public static void DrawElementsIndirect<T2>(OpenTK.Graphics.ES31.PrimitiveType mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute] T2[,,] indirect)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Render indexed primitives from array data, taking parameters from memory
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, and Triangles, are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glDrawElementsIndirect")]
        public static void DrawElementsIndirect<T2>(OpenTK.Graphics.ES31.PrimitiveType mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute] ref T2 indirect)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static void DrawElementsInstanced(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 instancecount) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        [CLSCompliant(false)]
        public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 instancecount)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        [CLSCompliant(false)]
        public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 instancecount)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        [CLSCompliant(false)]
        public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 instancecount)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 instancecount)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static void DrawElementsInstanced(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 instancecount) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        [CLSCompliant(false)]
        public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 instancecount)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        [CLSCompliant(false)]
        public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 instancecount)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        [CLSCompliant(false)]
        public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 instancecount)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 instancecount)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[] indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,] indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,,] indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T5 indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[] indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,] indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,,] indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T5 indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "count,type")] IntPtr indices) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[] indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,] indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,,] indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T5 indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "count,type")] IntPtr indices) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[] indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,] indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,,] indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
        /// </param>
        /// <param name="indices">[length: COMPSIZE(count,type)]
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        [CLSCompliant(false)]
        public static void DrawRangeElements<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T5 indices)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Enable or disable server-side GL capabilities
        /// </summary>
        /// <param name="cap">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glEnable")]
        public static void Enable(OpenTK.Graphics.ES31.All cap) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Enable or disable server-side GL capabilities
        /// </summary>
        /// <param name="cap">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glEnable")]
        public static void Enable(OpenTK.Graphics.ES31.EnableCap cap) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Enable or disable a generic vertex attribute array
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be enabled or disabled.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glEnableVertexAttribArray")]
        [CLSCompliant(false)]
        public static void EnableVertexAttribArray(Int32 index) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Enable or disable a generic vertex attribute array
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be enabled or disabled.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glEnableVertexAttribArray")]
        [CLSCompliant(false)]
        public static void EnableVertexAttribArray(UInt32 index) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glEndQuery")]
        public static void EndQuery(OpenTK.Graphics.ES31.All target) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glEndTransformFeedback")]
        public static void EndTransformFeedback() { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Create a new sync object and insert it into the GL command stream
        /// </summary>
        /// <param name="condition">
        /// Specifies the condition that must be met to set the sync object's state to signaled. condition must be SyncGpuCommandsComplete.
        /// </param>
        /// <param name="flags">
        /// Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero.flags is a placeholder for anticipated future extensions of fence sync object capabilities.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFenceSync")]
        [CLSCompliant(false)]
        public static IntPtr FenceSync(OpenTK.Graphics.ES31.All condition, Int32 flags) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Create a new sync object and insert it into the GL command stream
        /// </summary>
        /// <param name="condition">
        /// Specifies the condition that must be met to set the sync object's state to signaled. condition must be SyncGpuCommandsComplete.
        /// </param>
        /// <param name="flags">
        /// Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero.flags is a placeholder for anticipated future extensions of fence sync object capabilities.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFenceSync")]
        [CLSCompliant(false)]
        public static IntPtr FenceSync(OpenTK.Graphics.ES31.All condition, UInt32 flags) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Block until all GL execution is complete
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFinish")]
        public static void Finish() { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Force execution of GL commands in finite time
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFlush")]
        public static void Flush() { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Indicate modifications to a range of a mapped buffer
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the flush operation. target must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the start of the buffer subrange, in basic machine units.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the buffer subrange, in basic machine units.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFlushMappedBufferRange")]
        public static void FlushMappedBufferRange(OpenTK.Graphics.ES31.All target, IntPtr offset, Int32 length) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Indicate modifications to a range of a mapped buffer
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the flush operation. target must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the start of the buffer subrange, in basic machine units.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the buffer subrange, in basic machine units.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFlushMappedBufferRange")]
        public static void FlushMappedBufferRange(OpenTK.Graphics.ES31.All target, IntPtr offset, IntPtr length) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Indicate modifications to a range of a mapped buffer
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the flush operation. target must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the start of the buffer subrange, in basic machine units.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the buffer subrange, in basic machine units.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFlushMappedBufferRange")]
        public static void FlushMappedBufferRange(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, Int32 length) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Indicate modifications to a range of a mapped buffer
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the flush operation. target must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="offset">
        /// Specifies the start of the buffer subrange, in basic machine units.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the buffer subrange, in basic machine units.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFlushMappedBufferRange")]
        public static void FlushMappedBufferRange(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, IntPtr length) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Set a named parameter of a framebuffer
        /// </summary>
        /// <param name="target">
        /// The target of the operation, which must be ReadFramebuffer, DrawFramebuffer or Framebuffer.
        /// </param>
        /// <param name="pname">
        /// A token indicating the parameter to be modified.
        /// </param>
        /// <param name="param">
        /// The new value for the parameter named pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glFramebufferParameteri")]
        public static void FramebufferParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, Int32 param) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Attach a renderbuffer as a logical buffer to the currently bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer.
        /// </param>
        /// <param name="renderbuffertarget">
        /// Specifies the renderbuffer target and must be Renderbuffer.
        /// </param>
        /// <param name="renderbuffer">
        /// Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferRenderbuffer")]
        [CLSCompliant(false)]
        public static void FramebufferRenderbuffer(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All renderbuffertarget, Int32 renderbuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Attach a renderbuffer as a logical buffer to the currently bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer.
        /// </param>
        /// <param name="renderbuffertarget">
        /// Specifies the renderbuffer target and must be Renderbuffer.
        /// </param>
        /// <param name="renderbuffer">
        /// Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferRenderbuffer")]
        [CLSCompliant(false)]
        public static void FramebufferRenderbuffer(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All renderbuffertarget, UInt32 renderbuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Attach a renderbuffer as a logical buffer to the currently bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer.
        /// </param>
        /// <param name="renderbuffertarget">
        /// Specifies the renderbuffer target and must be Renderbuffer.
        /// </param>
        /// <param name="renderbuffer">
        /// Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferRenderbuffer")]
        [CLSCompliant(false)]
        public static void FramebufferRenderbuffer(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, OpenTK.Graphics.ES31.RenderbufferTarget renderbuffertarget, Int32 renderbuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Attach a renderbuffer as a logical buffer to the currently bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer.
        /// </param>
        /// <param name="renderbuffertarget">
        /// Specifies the renderbuffer target and must be Renderbuffer.
        /// </param>
        /// <param name="renderbuffer">
        /// Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferRenderbuffer")]
        [CLSCompliant(false)]
        public static void FramebufferRenderbuffer(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, OpenTK.Graphics.ES31.RenderbufferTarget renderbuffertarget, UInt32 renderbuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Attach a level of a texture object as a logical buffer to the currently bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachment.
        /// </param>
        /// <param name="textarget">
        /// Specifies a 2D texture target, or for cube map textures, which face is to be attached.
        /// </param>
        /// <param name="texture">
        /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of texture to attach.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferTexture2D")]
        [CLSCompliant(false)]
        public static void FramebufferTexture2D(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All textarget, Int32 texture, Int32 level) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Attach a level of a texture object as a logical buffer to the currently bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachment.
        /// </param>
        /// <param name="textarget">
        /// Specifies a 2D texture target, or for cube map textures, which face is to be attached.
        /// </param>
        /// <param name="texture">
        /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of texture to attach.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferTexture2D")]
        [CLSCompliant(false)]
        public static void FramebufferTexture2D(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All textarget, UInt32 texture, Int32 level) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Attach a level of a texture object as a logical buffer to the currently bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachment.
        /// </param>
        /// <param name="textarget">
        /// Specifies a 2D texture target, or for cube map textures, which face is to be attached.
        /// </param>
        /// <param name="texture">
        /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of texture to attach.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferTexture2D")]
        [CLSCompliant(false)]
        public static void FramebufferTexture2D(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, OpenTK.Graphics.ES31.All textarget, Int32 texture, Int32 level) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Attach a level of a texture object as a logical buffer to the currently bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachment.
        /// </param>
        /// <param name="textarget">
        /// Specifies a 2D texture target, or for cube map textures, which face is to be attached.
        /// </param>
        /// <param name="texture">
        /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of texture to attach.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferTexture2D")]
        [CLSCompliant(false)]
        public static void FramebufferTexture2D(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, OpenTK.Graphics.ES31.All textarget, UInt32 texture, Int32 level) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Attach a single layer of a texture to a framebuffer
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachmment.
        /// </param>
        /// <param name="texture">
        /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of texture to attach.
        /// </param>
        /// <param name="layer">
        /// Specifies the layer of texture to attach.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFramebufferTextureLayer")]
        [CLSCompliant(false)]
        public static void FramebufferTextureLayer(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, Int32 texture, Int32 level, Int32 layer) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Attach a single layer of a texture to a framebuffer
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachmment.
        /// </param>
        /// <param name="texture">
        /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of texture to attach.
        /// </param>
        /// <param name="layer">
        /// Specifies the layer of texture to attach.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFramebufferTextureLayer")]
        [CLSCompliant(false)]
        public static void FramebufferTextureLayer(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, UInt32 texture, Int32 level, Int32 layer) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Attach a single layer of a texture to a framebuffer
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachmment.
        /// </param>
        /// <param name="texture">
        /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of texture to attach.
        /// </param>
        /// <param name="layer">
        /// Specifies the layer of texture to attach.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFramebufferTextureLayer")]
        [CLSCompliant(false)]
        public static void FramebufferTextureLayer(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, Int32 texture, Int32 level, Int32 layer) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Attach a single layer of a texture to a framebuffer
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachmment.
        /// </param>
        /// <param name="texture">
        /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of texture to attach.
        /// </param>
        /// <param name="layer">
        /// Specifies the layer of texture to attach.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFramebufferTextureLayer")]
        [CLSCompliant(false)]
        public static void FramebufferTextureLayer(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, UInt32 texture, Int32 level, Int32 layer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define front- and back-facing polygons
        /// </summary>
        /// <param name="mode">
        /// Specifies the orientation of front-facing polygons. Cw and Ccw are accepted. The initial value is Ccw.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFrontFace")]
        public static void FrontFace(OpenTK.Graphics.ES31.All mode) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define front- and back-facing polygons
        /// </summary>
        /// <param name="mode">
        /// Specifies the orientation of front-facing polygons. Cw and Ccw are accepted. The initial value is Ccw.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFrontFace")]
        public static void FrontFace(OpenTK.Graphics.ES31.FrontFaceDirection mode) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        [CLSCompliant(false)]
        public static Int32 GenBuffer() { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer object names to be generated.
        /// </param>
        /// <param name="buffers">[length: n]
        /// Specifies an array in which the generated buffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        [CLSCompliant(false)]
        public static void GenBuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer object names to be generated.
        /// </param>
        /// <param name="buffers">[length: n]
        /// Specifies an array in which the generated buffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        [CLSCompliant(false)]
        public static void GenBuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer object names to be generated.
        /// </param>
        /// <param name="buffers">[length: n]
        /// Specifies an array in which the generated buffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        [CLSCompliant(false)]
        public static unsafe void GenBuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer object names to be generated.
        /// </param>
        /// <param name="buffers">[length: n]
        /// Specifies an array in which the generated buffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        [CLSCompliant(false)]
        public static void GenBuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer object names to be generated.
        /// </param>
        /// <param name="buffers">[length: n]
        /// Specifies an array in which the generated buffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        [CLSCompliant(false)]
        public static void GenBuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer object names to be generated.
        /// </param>
        /// <param name="buffers">[length: n]
        /// Specifies an array in which the generated buffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        [CLSCompliant(false)]
        public static unsafe void GenBuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* buffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate mipmaps for a specified texture target
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture whose mimaps to generate is bound. target must be Texture2D, Texture3D, Texture2DArray or TextureCubeMap.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenerateMipmap")]
        public static void GenerateMipmap(OpenTK.Graphics.ES31.All target) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        [CLSCompliant(false)]
        public static Int32 GenFramebuffer() { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer object names to generate.
        /// </param>
        /// <param name="framebuffers">[length: n]
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        [CLSCompliant(false)]
        public static void GenFramebuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer object names to generate.
        /// </param>
        /// <param name="framebuffers">[length: n]
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        [CLSCompliant(false)]
        public static void GenFramebuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer object names to generate.
        /// </param>
        /// <param name="framebuffers">[length: n]
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        [CLSCompliant(false)]
        public static unsafe void GenFramebuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer object names to generate.
        /// </param>
        /// <param name="framebuffers">[length: n]
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        [CLSCompliant(false)]
        public static void GenFramebuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer object names to generate.
        /// </param>
        /// <param name="framebuffers">[length: n]
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        [CLSCompliant(false)]
        public static void GenFramebuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer object names to generate.
        /// </param>
        /// <param name="framebuffers">[length: n]
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        [CLSCompliant(false)]
        public static unsafe void GenFramebuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* framebuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Reserve program pipeline object names
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGenProgramPipelines")]
        [CLSCompliant(false)]
        public static Int32 GenProgramPipeline() { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Reserve program pipeline object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline object names to reserve.
        /// </param>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGenProgramPipelines")]
        [CLSCompliant(false)]
        public static void GenProgramPipelines(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Reserve program pipeline object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline object names to reserve.
        /// </param>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGenProgramPipelines")]
        [CLSCompliant(false)]
        public static void GenProgramPipelines(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Reserve program pipeline object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline object names to reserve.
        /// </param>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGenProgramPipelines")]
        [CLSCompliant(false)]
        public static unsafe void GenProgramPipelines(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Reserve program pipeline object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline object names to reserve.
        /// </param>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGenProgramPipelines")]
        [CLSCompliant(false)]
        public static void GenProgramPipelines(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Reserve program pipeline object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline object names to reserve.
        /// </param>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGenProgramPipelines")]
        [CLSCompliant(false)]
        public static void GenProgramPipelines(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Reserve program pipeline object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline object names to reserve.
        /// </param>
        /// <param name="pipelines">[length: n]
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGenProgramPipelines")]
        [CLSCompliant(false)]
        public static unsafe void GenProgramPipelines(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* pipelines) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        [CLSCompliant(false)]
        public static Int32 GenQuery() { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query object names to be generated.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array in which the generated query object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        [CLSCompliant(false)]
        public static void GenQueries(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query object names to be generated.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array in which the generated query object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        [CLSCompliant(false)]
        public static void GenQueries(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query object names to be generated.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array in which the generated query object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        [CLSCompliant(false)]
        public static unsafe void GenQueries(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query object names to be generated.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array in which the generated query object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        [CLSCompliant(false)]
        public static void GenQueries(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query object names to be generated.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array in which the generated query object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        [CLSCompliant(false)]
        public static void GenQueries(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query object names to be generated.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array in which the generated query object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        [CLSCompliant(false)]
        public static unsafe void GenQueries(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        [CLSCompliant(false)]
        public static Int32 GenRenderbuffer() { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer object names to generate.
        /// </param>
        /// <param name="renderbuffers">[length: n]
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        [CLSCompliant(false)]
        public static void GenRenderbuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer object names to generate.
        /// </param>
        /// <param name="renderbuffers">[length: n]
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        [CLSCompliant(false)]
        public static void GenRenderbuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer object names to generate.
        /// </param>
        /// <param name="renderbuffers">[length: n]
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        [CLSCompliant(false)]
        public static unsafe void GenRenderbuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer object names to generate.
        /// </param>
        /// <param name="renderbuffers">[length: n]
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        [CLSCompliant(false)]
        public static void GenRenderbuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer object names to generate.
        /// </param>
        /// <param name="renderbuffers">[length: n]
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        [CLSCompliant(false)]
        public static void GenRenderbuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer object names to generate.
        /// </param>
        /// <param name="renderbuffers">[length: n]
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        [CLSCompliant(false)]
        public static unsafe void GenRenderbuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* renderbuffers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        [CLSCompliant(false)]
        public static Int32 GenSampler() { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler object names to generate.
        /// </param>
        /// <param name="samplers">[length: count]
        /// Specifies an array in which the generated sampler object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        [CLSCompliant(false)]
        public static void GenSamplers(Int32 count, [OutAttribute, CountAttribute(Parameter = "count")] Int32[] samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler object names to generate.
        /// </param>
        /// <param name="samplers">[length: count]
        /// Specifies an array in which the generated sampler object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        [CLSCompliant(false)]
        public static void GenSamplers(Int32 count, [OutAttribute, CountAttribute(Parameter = "count")] out Int32 samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler object names to generate.
        /// </param>
        /// <param name="samplers">[length: count]
        /// Specifies an array in which the generated sampler object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        [CLSCompliant(false)]
        public static unsafe void GenSamplers(Int32 count, [OutAttribute, CountAttribute(Parameter = "count")] Int32* samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler object names to generate.
        /// </param>
        /// <param name="samplers">[length: count]
        /// Specifies an array in which the generated sampler object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        [CLSCompliant(false)]
        public static void GenSamplers(Int32 count, [OutAttribute, CountAttribute(Parameter = "count")] UInt32[] samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler object names to generate.
        /// </param>
        /// <param name="samplers">[length: count]
        /// Specifies an array in which the generated sampler object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        [CLSCompliant(false)]
        public static void GenSamplers(Int32 count, [OutAttribute, CountAttribute(Parameter = "count")] out UInt32 samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler object names to generate.
        /// </param>
        /// <param name="samplers">[length: count]
        /// Specifies an array in which the generated sampler object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        [CLSCompliant(false)]
        public static unsafe void GenSamplers(Int32 count, [OutAttribute, CountAttribute(Parameter = "count")] UInt32* samplers) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        [CLSCompliant(false)]
        public static Int32 GenTexture() { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of texture names to be generated.
        /// </param>
        /// <param name="textures">[length: n]
        /// Specifies an array in which the generated texture names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        [CLSCompliant(false)]
        public static void GenTextures(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of texture names to be generated.
        /// </param>
        /// <param name="textures">[length: n]
        /// Specifies an array in which the generated texture names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        [CLSCompliant(false)]
        public static void GenTextures(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of texture names to be generated.
        /// </param>
        /// <param name="textures">[length: n]
        /// Specifies an array in which the generated texture names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        [CLSCompliant(false)]
        public static unsafe void GenTextures(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of texture names to be generated.
        /// </param>
        /// <param name="textures">[length: n]
        /// Specifies an array in which the generated texture names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        [CLSCompliant(false)]
        public static void GenTextures(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of texture names to be generated.
        /// </param>
        /// <param name="textures">[length: n]
        /// Specifies an array in which the generated texture names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        [CLSCompliant(false)]
        public static void GenTextures(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of texture names to be generated.
        /// </param>
        /// <param name="textures">[length: n]
        /// Specifies an array in which the generated texture names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        [CLSCompliant(false)]
        public static unsafe void GenTextures(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* textures) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        [CLSCompliant(false)]
        public static Int32 GenTransformFeedback() { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback object names to reserve.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        [CLSCompliant(false)]
        public static void GenTransformFeedbacks(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback object names to reserve.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        [CLSCompliant(false)]
        public static void GenTransformFeedbacks(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback object names to reserve.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        [CLSCompliant(false)]
        public static unsafe void GenTransformFeedbacks(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback object names to reserve.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        [CLSCompliant(false)]
        public static void GenTransformFeedbacks(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback object names to reserve.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        [CLSCompliant(false)]
        public static void GenTransformFeedbacks(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback object names to reserve.
        /// </param>
        /// <param name="ids">[length: n]
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        [CLSCompliant(false)]
        public static unsafe void GenTransformFeedbacks(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* ids) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        [CLSCompliant(false)]
        public static Int32 GenVertexArray() { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array object names to generate.
        /// </param>
        /// <param name="arrays">[length: n]
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        [CLSCompliant(false)]
        public static void GenVertexArrays(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array object names to generate.
        /// </param>
        /// <param name="arrays">[length: n]
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        [CLSCompliant(false)]
        public static void GenVertexArrays(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array object names to generate.
        /// </param>
        /// <param name="arrays">[length: n]
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        [CLSCompliant(false)]
        public static unsafe void GenVertexArrays(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array object names to generate.
        /// </param>
        /// <param name="arrays">[length: n]
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        [CLSCompliant(false)]
        public static void GenVertexArrays(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array object names to generate.
        /// </param>
        /// <param name="arrays">[length: n]
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        [CLSCompliant(false)]
        public static void GenVertexArrays(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array object names to generate.
        /// </param>
        /// <param name="arrays">[length: n]
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        [CLSCompliant(false)]
        public static unsafe void GenVertexArrays(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* arrays) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns information about an active attribute variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than Null is passed.
        /// </param>
        /// <param name="size">[length: 1]
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">[length: 1]
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// Returns a null terminated string containing the name of the attribute variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveAttrib")]
        [CLSCompliant(false)]
        public static void GetActiveAttrib(Int32 program, Int32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out Int32 size, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All type, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns information about an active attribute variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than Null is passed.
        /// </param>
        /// <param name="size">[length: 1]
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">[length: 1]
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// Returns a null terminated string containing the name of the attribute variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveAttrib")]
        [CLSCompliant(false)]
        public static unsafe void GetActiveAttrib(Int32 program, Int32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] Int32* size, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* type, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns information about an active attribute variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than Null is passed.
        /// </param>
        /// <param name="size">[length: 1]
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">[length: 1]
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// Returns a null terminated string containing the name of the attribute variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveAttrib")]
        [CLSCompliant(false)]
        public static void GetActiveAttrib(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out Int32 size, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All type, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns information about an active attribute variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than Null is passed.
        /// </param>
        /// <param name="size">[length: 1]
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">[length: 1]
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// Returns a null terminated string containing the name of the attribute variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveAttrib")]
        [CLSCompliant(false)]
        public static unsafe void GetActiveAttrib(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] Int32* size, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* type, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns information about an active uniform variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than Null is passed.
        /// </param>
        /// <param name="size">[length: 1]
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">[length: 1]
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// Returns a null terminated string containing the name of the uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveUniform")]
        [CLSCompliant(false)]
        public static void GetActiveUniform(Int32 program, Int32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out Int32 size, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All type, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns information about an active uniform variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than Null is passed.
        /// </param>
        /// <param name="size">[length: 1]
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">[length: 1]
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// Returns a null terminated string containing the name of the uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveUniform")]
        [CLSCompliant(false)]
        public static unsafe void GetActiveUniform(Int32 program, Int32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] Int32* size, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* type, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns information about an active uniform variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than Null is passed.
        /// </param>
        /// <param name="size">[length: 1]
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">[length: 1]
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// Returns a null terminated string containing the name of the uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveUniform")]
        [CLSCompliant(false)]
        public static void GetActiveUniform(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out Int32 size, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All type, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns information about an active uniform variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than Null is passed.
        /// </param>
        /// <param name="size">[length: 1]
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">[length: 1]
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// Returns a null terminated string containing the name of the uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveUniform")]
        [CLSCompliant(false)]
        public static unsafe void GetActiveUniform(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] Int32* size, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* type, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,uniformBlockIndex,pname)]
        /// Specifies the address of a variable to receive the result of the query.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        [CLSCompliant(false)]
        public static void GetActiveUniformBlock(Int32 program, Int32 uniformBlockIndex, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "program,uniformBlockIndex,pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,uniformBlockIndex,pname)]
        /// Specifies the address of a variable to receive the result of the query.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        [CLSCompliant(false)]
        public static void GetActiveUniformBlock(Int32 program, Int32 uniformBlockIndex, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "program,uniformBlockIndex,pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,uniformBlockIndex,pname)]
        /// Specifies the address of a variable to receive the result of the query.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        [CLSCompliant(false)]
        public static unsafe void GetActiveUniformBlock(Int32 program, Int32 uniformBlockIndex, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "program,uniformBlockIndex,pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,uniformBlockIndex,pname)]
        /// Specifies the address of a variable to receive the result of the query.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        [CLSCompliant(false)]
        public static void GetActiveUniformBlock(UInt32 program, UInt32 uniformBlockIndex, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "program,uniformBlockIndex,pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,uniformBlockIndex,pname)]
        /// Specifies the address of a variable to receive the result of the query.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        [CLSCompliant(false)]
        public static void GetActiveUniformBlock(UInt32 program, UInt32 uniformBlockIndex, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "program,uniformBlockIndex,pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,uniformBlockIndex,pname)]
        /// Specifies the address of a variable to receive the result of the query.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        [CLSCompliant(false)]
        public static unsafe void GetActiveUniformBlock(UInt32 program, UInt32 uniformBlockIndex, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "program,uniformBlockIndex,pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve the name of an active uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer addressed by uniformBlockName.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of characters that were written to uniformBlockName.
        /// </param>
        /// <param name="uniformBlockName">[length: bufSize]
        /// Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockName")]
        [CLSCompliant(false)]
        public static void GetActiveUniformBlockName(Int32 program, Int32 uniformBlockIndex, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String uniformBlockName) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve the name of an active uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer addressed by uniformBlockName.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of characters that were written to uniformBlockName.
        /// </param>
        /// <param name="uniformBlockName">[length: bufSize]
        /// Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockName")]
        [CLSCompliant(false)]
        public static unsafe void GetActiveUniformBlockName(Int32 program, Int32 uniformBlockIndex, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String uniformBlockName) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve the name of an active uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer addressed by uniformBlockName.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of characters that were written to uniformBlockName.
        /// </param>
        /// <param name="uniformBlockName">[length: bufSize]
        /// Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockName")]
        [CLSCompliant(false)]
        public static void GetActiveUniformBlockName(UInt32 program, UInt32 uniformBlockIndex, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String uniformBlockName) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve the name of an active uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer addressed by uniformBlockName.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of characters that were written to uniformBlockName.
        /// </param>
        /// <param name="uniformBlockName">[length: bufSize]
        /// Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockName")]
        [CLSCompliant(false)]
        public static unsafe void GetActiveUniformBlockName(UInt32 program, UInt32 uniformBlockIndex, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String uniformBlockName) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </param>
        /// <param name="uniformIndices">[length: uniformCount]
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(uniformCount,pname)]
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        [CLSCompliant(false)]
        public static void GetActiveUniforms(Int32 program, Int32 uniformCount, [CountAttribute(Parameter = "uniformCount")] Int32[] uniformIndices, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "uniformCount,pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </param>
        /// <param name="uniformIndices">[length: uniformCount]
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(uniformCount,pname)]
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        [CLSCompliant(false)]
        public static void GetActiveUniforms(Int32 program, Int32 uniformCount, [CountAttribute(Parameter = "uniformCount")] ref Int32 uniformIndices, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "uniformCount,pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </param>
        /// <param name="uniformIndices">[length: uniformCount]
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(uniformCount,pname)]
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        [CLSCompliant(false)]
        public static unsafe void GetActiveUniforms(Int32 program, Int32 uniformCount, [CountAttribute(Parameter = "uniformCount")] Int32* uniformIndices, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "uniformCount,pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </param>
        /// <param name="uniformIndices">[length: uniformCount]
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(uniformCount,pname)]
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        [CLSCompliant(false)]
        public static void GetActiveUniforms(UInt32 program, Int32 uniformCount, [CountAttribute(Parameter = "uniformCount")] UInt32[] uniformIndices, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "uniformCount,pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </param>
        /// <param name="uniformIndices">[length: uniformCount]
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(uniformCount,pname)]
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        [CLSCompliant(false)]
        public static void GetActiveUniforms(UInt32 program, Int32 uniformCount, [CountAttribute(Parameter = "uniformCount")] ref UInt32 uniformIndices, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "uniformCount,pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </param>
        /// <param name="uniformIndices">[length: uniformCount]
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(uniformCount,pname)]
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        [CLSCompliant(false)]
        public static unsafe void GetActiveUniforms(UInt32 program, Int32 uniformCount, [CountAttribute(Parameter = "uniformCount")] UInt32* uniformIndices, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "uniformCount,pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the handles of the shader objects attached to a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="maxCount">
        /// Specifies the size of the array for storing the returned object names.
        /// </param>
        /// <param name="count">[length: 1]
        /// Returns the number of names actually returned in shaders.
        /// </param>
        /// <param name="shaders">[length: maxCount]
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
        [CLSCompliant(false)]
        public static void GetAttachedShaders(Int32 program, Int32 maxCount, [OutAttribute, CountAttribute(Count = 1)] out Int32 count, [OutAttribute, CountAttribute(Parameter = "maxCount")] Int32[] shaders) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the handles of the shader objects attached to a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="maxCount">
        /// Specifies the size of the array for storing the returned object names.
        /// </param>
        /// <param name="count">[length: 1]
        /// Returns the number of names actually returned in shaders.
        /// </param>
        /// <param name="shaders">[length: maxCount]
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
        [CLSCompliant(false)]
        public static void GetAttachedShaders(Int32 program, Int32 maxCount, [OutAttribute, CountAttribute(Count = 1)] out Int32 count, [OutAttribute, CountAttribute(Parameter = "maxCount")] out Int32 shaders) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the handles of the shader objects attached to a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="maxCount">
        /// Specifies the size of the array for storing the returned object names.
        /// </param>
        /// <param name="count">[length: 1]
        /// Returns the number of names actually returned in shaders.
        /// </param>
        /// <param name="shaders">[length: maxCount]
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
        [CLSCompliant(false)]
        public static unsafe void GetAttachedShaders(Int32 program, Int32 maxCount, [OutAttribute, CountAttribute(Count = 1)] Int32* count, [OutAttribute, CountAttribute(Parameter = "maxCount")] Int32* shaders) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the handles of the shader objects attached to a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="maxCount">
        /// Specifies the size of the array for storing the returned object names.
        /// </param>
        /// <param name="count">[length: 1]
        /// Returns the number of names actually returned in shaders.
        /// </param>
        /// <param name="shaders">[length: maxCount]
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
        [CLSCompliant(false)]
        public static void GetAttachedShaders(UInt32 program, Int32 maxCount, [OutAttribute, CountAttribute(Count = 1)] out Int32 count, [OutAttribute, CountAttribute(Parameter = "maxCount")] UInt32[] shaders) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the handles of the shader objects attached to a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="maxCount">
        /// Specifies the size of the array for storing the returned object names.
        /// </param>
        /// <param name="count">[length: 1]
        /// Returns the number of names actually returned in shaders.
        /// </param>
        /// <param name="shaders">[length: maxCount]
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
        [CLSCompliant(false)]
        public static void GetAttachedShaders(UInt32 program, Int32 maxCount, [OutAttribute, CountAttribute(Count = 1)] out Int32 count, [OutAttribute, CountAttribute(Parameter = "maxCount")] out UInt32 shaders) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the handles of the shader objects attached to a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="maxCount">
        /// Specifies the size of the array for storing the returned object names.
        /// </param>
        /// <param name="count">[length: 1]
        /// Returns the number of names actually returned in shaders.
        /// </param>
        /// <param name="shaders">[length: maxCount]
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
        [CLSCompliant(false)]
        public static unsafe void GetAttachedShaders(UInt32 program, Int32 maxCount, [OutAttribute, CountAttribute(Count = 1)] Int32* count, [OutAttribute, CountAttribute(Parameter = "maxCount")] UInt32* shaders) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the location of an attribute variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="name">
        /// Points to a null terminated string containing the name of the attribute variable whose location is to be queried.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttribLocation")]
        [CLSCompliant(false)]
        public static Int32 GetAttribLocation(Int32 program, String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the location of an attribute variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="name">
        /// Points to a null terminated string containing the name of the attribute variable whose location is to be queried.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttribLocation")]
        [CLSCompliant(false)]
        public static Int32 GetAttribLocation(UInt32 program, String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetBooleani_v")]
        [CLSCompliant(false)]
        public static void GetBoolean(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] bool[] data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetBooleani_v")]
        [CLSCompliant(false)]
        public static void GetBoolean(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] out bool data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetBooleani_v")]
        [CLSCompliant(false)]
        public static unsafe void GetBoolean(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] bool* data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetBooleani_v")]
        [CLSCompliant(false)]
        public static void GetBoolean(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] bool[] data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetBooleani_v")]
        [CLSCompliant(false)]
        public static void GetBoolean(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] out bool data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetBooleani_v")]
        [CLSCompliant(false)]
        public static unsafe void GetBoolean(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] bool* data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        [CLSCompliant(false)]
        public static bool GetBoolean(OpenTK.Graphics.ES31.All pname) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        [CLSCompliant(false)]
        public static bool GetBoolean(OpenTK.Graphics.ES31.GetPName pname) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        [CLSCompliant(false)]
        public static void GetBoolean(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] bool[] data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        [CLSCompliant(false)]
        public static void GetBoolean(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out bool data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        [CLSCompliant(false)]
        public static unsafe void GetBoolean(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] bool* data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        [CLSCompliant(false)]
        public static void GetBoolean(OpenTK.Graphics.ES31.GetPName pname, [OutAttribute, CountAttribute(Computed = "pname")] bool[] data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        [CLSCompliant(false)]
        public static void GetBoolean(OpenTK.Graphics.ES31.GetPName pname, [OutAttribute, CountAttribute(Computed = "pname")] out bool data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        [CLSCompliant(false)]
        public static unsafe void GetBoolean(OpenTK.Graphics.ES31.GetPName pname, [OutAttribute, CountAttribute(Computed = "pname")] bool* data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are BufferAccessFlags, BufferMapped, BufferMapLength, BufferMapOffset, BufferSize, or BufferUsage.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested parameter.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferParameteri64v")]
        [CLSCompliant(false)]
        public static void GetBufferParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int64[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are BufferAccessFlags, BufferMapped, BufferMapLength, BufferMapOffset, BufferSize, or BufferUsage.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested parameter.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferParameteri64v")]
        [CLSCompliant(false)]
        public static void GetBufferParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int64 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are BufferAccessFlags, BufferMapped, BufferMapLength, BufferMapOffset, BufferSize, or BufferUsage.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested parameter.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferParameteri64v")]
        [CLSCompliant(false)]
        public static unsafe void GetBufferParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int64* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are BufferAccessFlags, BufferMapped, BufferMapLength, BufferMapOffset, BufferSize, or BufferUsage.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferParameteri64v")]
        [CLSCompliant(false)]
        public static void GetBufferParameter(OpenTK.Graphics.ES31.BufferTargetArb target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int64[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are BufferAccessFlags, BufferMapped, BufferMapLength, BufferMapOffset, BufferSize, or BufferUsage.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferParameteri64v")]
        [CLSCompliant(false)]
        public static void GetBufferParameter(OpenTK.Graphics.ES31.BufferTargetArb target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int64 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are BufferAccessFlags, BufferMapped, BufferMapLength, BufferMapOffset, BufferSize, or BufferUsage.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferParameteri64v")]
        [CLSCompliant(false)]
        public static unsafe void GetBufferParameter(OpenTK.Graphics.ES31.BufferTargetArb target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int64* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, ElementArrayBuffer, PixelPackBuffer, or PixelUnpackBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are BufferAccess, BufferMapped, BufferSize, or BufferUsage.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested parameter.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBufferParameteriv")]
        [CLSCompliant(false)]
        public static void GetBufferParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, ElementArrayBuffer, PixelPackBuffer, or PixelUnpackBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are BufferAccess, BufferMapped, BufferSize, or BufferUsage.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested parameter.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBufferParameteriv")]
        [CLSCompliant(false)]
        public static void GetBufferParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, ElementArrayBuffer, PixelPackBuffer, or PixelUnpackBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are BufferAccess, BufferMapped, BufferSize, or BufferUsage.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested parameter.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBufferParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void GetBufferParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, ElementArrayBuffer, PixelPackBuffer, or PixelUnpackBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are BufferAccess, BufferMapped, BufferSize, or BufferUsage.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBufferParameteriv")]
        [CLSCompliant(false)]
        public static void GetBufferParameter(OpenTK.Graphics.ES31.BufferTargetArb target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, ElementArrayBuffer, PixelPackBuffer, or PixelUnpackBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are BufferAccess, BufferMapped, BufferSize, or BufferUsage.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBufferParameteriv")]
        [CLSCompliant(false)]
        public static void GetBufferParameter(OpenTK.Graphics.ES31.BufferTargetArb target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, ElementArrayBuffer, PixelPackBuffer, or PixelUnpackBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are BufferAccess, BufferMapped, BufferSize, or BufferUsage.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBufferParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void GetBufferParameter(OpenTK.Graphics.ES31.BufferTargetArb target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the pointer to be returned.  The symbolic constant must be BufferMapPointer.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static void GetBufferPointer(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 1)] IntPtr @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the pointer to be returned.  The symbolic constant must be BufferMapPointer.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        [CLSCompliant(false)]
        public static void GetBufferPointer<T2>(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T2[] @params)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the pointer to be returned.  The symbolic constant must be BufferMapPointer.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        [CLSCompliant(false)]
        public static void GetBufferPointer<T2>(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T2[,] @params)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the pointer to be returned.  The symbolic constant must be BufferMapPointer.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        [CLSCompliant(false)]
        public static void GetBufferPointer<T2>(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T2[,,] @params)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the pointer to be returned.  The symbolic constant must be BufferMapPointer.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static void GetBufferPointer<T2>(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] ref T2 @params)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the pointer to be returned.  The symbolic constant must be BufferMapPointer.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static void GetBufferPointer(OpenTK.Graphics.ES31.BufferTargetArb target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 1)] IntPtr @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the pointer to be returned.  The symbolic constant must be BufferMapPointer.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        [CLSCompliant(false)]
        public static void GetBufferPointer<T2>(OpenTK.Graphics.ES31.BufferTargetArb target, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T2[] @params)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the pointer to be returned.  The symbolic constant must be BufferMapPointer.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        [CLSCompliant(false)]
        public static void GetBufferPointer<T2>(OpenTK.Graphics.ES31.BufferTargetArb target, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T2[,] @params)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the pointer to be returned.  The symbolic constant must be BufferMapPointer.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        [CLSCompliant(false)]
        public static void GetBufferPointer<T2>(OpenTK.Graphics.ES31.BufferTargetArb target, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T2[,,] @params)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the pointer to be returned.  The symbolic constant must be BufferMapPointer.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static void GetBufferPointer<T2>(OpenTK.Graphics.ES31.BufferTargetArb target, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] ref T2 @params)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">[length: count]
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">[length: count]
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">[length: count]
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">[length: count]
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">[length: count]
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">[length: bufSize]
        /// The address of an array of characters that will receive the messages.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        [CLSCompliant(false)]
        public static Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All[] sources, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All[] types, [OutAttribute, CountAttribute(Parameter = "count")] Int32[] ids, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All[] severities, [OutAttribute, CountAttribute(Parameter = "count")] Int32[] lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String messageLog) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">[length: count]
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">[length: count]
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">[length: count]
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">[length: count]
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">[length: count]
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">[length: bufSize]
        /// The address of an array of characters that will receive the messages.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        [CLSCompliant(false)]
        public static Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] out OpenTK.Graphics.ES31.All sources, [OutAttribute, CountAttribute(Parameter = "count")] out OpenTK.Graphics.ES31.All types, [OutAttribute, CountAttribute(Parameter = "count")] out Int32 ids, [OutAttribute, CountAttribute(Parameter = "count")] out OpenTK.Graphics.ES31.All severities, [OutAttribute, CountAttribute(Parameter = "count")] out Int32 lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String messageLog) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">[length: count]
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">[length: count]
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">[length: count]
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">[length: count]
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">[length: count]
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">[length: bufSize]
        /// The address of an array of characters that will receive the messages.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        [CLSCompliant(false)]
        public static unsafe Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All* sources, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All* types, [OutAttribute, CountAttribute(Parameter = "count")] Int32* ids, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All* severities, [OutAttribute, CountAttribute(Parameter = "count")] Int32* lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String messageLog) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">[length: count]
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">[length: count]
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">[length: count]
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">[length: count]
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">[length: count]
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">[length: bufSize]
        /// The address of an array of characters that will receive the messages.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        [CLSCompliant(false)]
        public static Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All[] sources, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All[] types, [OutAttribute, CountAttribute(Parameter = "count")] UInt32[] ids, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All[] severities, [OutAttribute, CountAttribute(Parameter = "count")] Int32[] lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String messageLog) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">[length: count]
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">[length: count]
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">[length: count]
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">[length: count]
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">[length: count]
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">[length: bufSize]
        /// The address of an array of characters that will receive the messages.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        [CLSCompliant(false)]
        public static Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] out OpenTK.Graphics.ES31.All sources, [OutAttribute, CountAttribute(Parameter = "count")] out OpenTK.Graphics.ES31.All types, [OutAttribute, CountAttribute(Parameter = "count")] out UInt32 ids, [OutAttribute, CountAttribute(Parameter = "count")] out OpenTK.Graphics.ES31.All severities, [OutAttribute, CountAttribute(Parameter = "count")] out Int32 lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String messageLog) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">[length: count]
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">[length: count]
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">[length: count]
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">[length: count]
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">[length: count]
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">[length: bufSize]
        /// The address of an array of characters that will receive the messages.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        [CLSCompliant(false)]
        public static unsafe Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All* sources, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All* types, [OutAttribute, CountAttribute(Parameter = "count")] UInt32* ids, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All* severities, [OutAttribute, CountAttribute(Parameter = "count")] Int32* lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String messageLog) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return error information
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetError")]
        public static OpenTK.Graphics.ES31.ErrorCode GetError() { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        [CLSCompliant(false)]
        public static Single GetFloat(OpenTK.Graphics.ES31.All pname) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        [CLSCompliant(false)]
        public static Single GetFloat(OpenTK.Graphics.ES31.GetPName pname) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        [CLSCompliant(false)]
        public static void GetFloat(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single[] data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        [CLSCompliant(false)]
        public static void GetFloat(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Single data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        [CLSCompliant(false)]
        public static unsafe void GetFloat(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        [CLSCompliant(false)]
        public static void GetFloat(OpenTK.Graphics.ES31.GetPName pname, [OutAttribute, CountAttribute(Computed = "pname")] Single[] data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        [CLSCompliant(false)]
        public static void GetFloat(OpenTK.Graphics.ES31.GetPName pname, [OutAttribute, CountAttribute(Computed = "pname")] out Single data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        [CLSCompliant(false)]
        public static unsafe void GetFloat(OpenTK.Graphics.ES31.GetPName pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Query the bindings of color numbers to user-defined varying out variables
        /// </summary>
        /// <param name="program">
        /// The name of the program containing varying out variable whose binding to query
        /// </param>
        /// <param name="name">[length: COMPSIZE(name)]
        /// The name of the user-defined varying out variable whose binding to query
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetFragDataLocation")]
        [CLSCompliant(false)]
        public static Int32 GetFragDataLocation(Int32 program, [CountAttribute(Computed = "name")] String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Query the bindings of color numbers to user-defined varying out variables
        /// </summary>
        /// <param name="program">
        /// The name of the program containing varying out variable whose binding to query
        /// </param>
        /// <param name="name">[length: COMPSIZE(name)]
        /// The name of the user-defined varying out variable whose binding to query
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetFragDataLocation")]
        [CLSCompliant(false)]
        public static Int32 GetFragDataLocation(UInt32 program, [CountAttribute(Computed = "name")] String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve information about attachments of a bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the query operation.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment within target
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of attachment to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of a variable receive the value of pname for attachment.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFramebufferAttachmentParameteriv")]
        [CLSCompliant(false)]
        public static void GetFramebufferAttachmentParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve information about attachments of a bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the query operation.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment within target
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of attachment to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of a variable receive the value of pname for attachment.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFramebufferAttachmentParameteriv")]
        [CLSCompliant(false)]
        public static void GetFramebufferAttachmentParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve information about attachments of a bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the query operation.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment within target
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of attachment to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of a variable receive the value of pname for attachment.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFramebufferAttachmentParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void GetFramebufferAttachmentParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve information about attachments of a bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the query operation.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment within target
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of attachment to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of a variable receive the value of pname for attachment.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFramebufferAttachmentParameteriv")]
        [CLSCompliant(false)]
        public static void GetFramebufferAttachmentParameter(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve information about attachments of a bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the query operation.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment within target
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of attachment to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of a variable receive the value of pname for attachment.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFramebufferAttachmentParameteriv")]
        [CLSCompliant(false)]
        public static void GetFramebufferAttachmentParameter(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve information about attachments of a bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the query operation.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment within target
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of attachment to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of a variable receive the value of pname for attachment.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFramebufferAttachmentParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void GetFramebufferAttachmentParameter(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve a named parameter from a framebuffer
        /// </summary>
        /// <param name="target">
        /// The target of the operation, which must be ReadFramebuffer, DrawFramebuffer or Framebuffer.
        /// </param>
        /// <param name="pname">
        /// A token indicating the parameter to be retrieved.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// The address of a variable to receive the value of the parameter named pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetFramebufferParameteriv")]
        [CLSCompliant(false)]
        public static void GetFramebufferParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve a named parameter from a framebuffer
        /// </summary>
        /// <param name="target">
        /// The target of the operation, which must be ReadFramebuffer, DrawFramebuffer or Framebuffer.
        /// </param>
        /// <param name="pname">
        /// A token indicating the parameter to be retrieved.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// The address of a variable to receive the value of the parameter named pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetFramebufferParameteriv")]
        [CLSCompliant(false)]
        public static void GetFramebufferParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve a named parameter from a framebuffer
        /// </summary>
        /// <param name="target">
        /// The target of the operation, which must be ReadFramebuffer, DrawFramebuffer or Framebuffer.
        /// </param>
        /// <param name="pname">
        /// A token indicating the parameter to be retrieved.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// The address of a variable to receive the value of the parameter named pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetFramebufferParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void GetFramebufferParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetGraphicsResetStatus")]
        public static OpenTK.Graphics.ES31.All GetGraphicsResetStatus() { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        [CLSCompliant(false)]
        public static void GetInteger64(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] Int64[] data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        [CLSCompliant(false)]
        public static void GetInteger64(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] out Int64 data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        [CLSCompliant(false)]
        public static unsafe void GetInteger64(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] Int64* data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        [CLSCompliant(false)]
        public static void GetInteger64(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Int64[] data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        [CLSCompliant(false)]
        public static void GetInteger64(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] out Int64 data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        [CLSCompliant(false)]
        public static unsafe void GetInteger64(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Int64* data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="pname"></param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64v")]
        [CLSCompliant(false)]
        public static Int64 GetInteger64(OpenTK.Graphics.ES31.All pname) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64v")]
        [CLSCompliant(false)]
        public static void GetInteger64(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int64[] data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64v")]
        [CLSCompliant(false)]
        public static void GetInteger64(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int64 data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64v")]
        [CLSCompliant(false)]
        public static unsafe void GetInteger64(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int64* data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        [CLSCompliant(false)]
        public static void GetInteger(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] Int32[] data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        [CLSCompliant(false)]
        public static void GetInteger(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] out Int32 data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        [CLSCompliant(false)]
        public static unsafe void GetInteger(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] Int32* data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        [CLSCompliant(false)]
        public static void GetInteger(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Int32[] data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        [CLSCompliant(false)]
        public static void GetInteger(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] out Int32 data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        /// <param name="index"></param>
        /// <param name="data">[length: COMPSIZE(target)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        [CLSCompliant(false)]
        public static unsafe void GetInteger(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Int32* data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        [CLSCompliant(false)]
        public static Int32 GetInteger(OpenTK.Graphics.ES31.All pname) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        [CLSCompliant(false)]
        public static Int32 GetInteger(OpenTK.Graphics.ES31.GetPName pname) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        [CLSCompliant(false)]
        public static void GetInteger(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        [CLSCompliant(false)]
        public static void GetInteger(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        [CLSCompliant(false)]
        public static unsafe void GetInteger(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        [CLSCompliant(false)]
        public static void GetInteger(OpenTK.Graphics.ES31.GetPName pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        [CLSCompliant(false)]
        public static void GetInteger(OpenTK.Graphics.ES31.GetPName pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 data) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="pname"></param>
        /// <param name="data">[length: COMPSIZE(pname)]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        [CLSCompliant(false)]
        public static unsafe void GetInteger(OpenTK.Graphics.ES31.GetPName pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* data) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve information about implementation-dependent support for internal formats
        /// </summary>
        /// <param name="target">
        /// Indicates the usage of the internal format. target must be Renderbuffer.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format about which to retrieve information.
        /// </param>
        /// <param name="pname">
        /// Specifies the type of information to query.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of integers that may be written to params by the function.
        /// </param>
        /// <param name="@params">[length: bufSize]
        /// Specifies the address of a variable into which to write the retrieved information.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInternalformativ")]
        [CLSCompliant(false)]
        public static void GetInternalformat(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, OpenTK.Graphics.ES31.All pname, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve information about implementation-dependent support for internal formats
        /// </summary>
        /// <param name="target">
        /// Indicates the usage of the internal format. target must be Renderbuffer.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format about which to retrieve information.
        /// </param>
        /// <param name="pname">
        /// Specifies the type of information to query.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of integers that may be written to params by the function.
        /// </param>
        /// <param name="@params">[length: bufSize]
        /// Specifies the address of a variable into which to write the retrieved information.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInternalformativ")]
        [CLSCompliant(false)]
        public static void GetInternalformat(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, OpenTK.Graphics.ES31.All pname, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve information about implementation-dependent support for internal formats
        /// </summary>
        /// <param name="target">
        /// Indicates the usage of the internal format. target must be Renderbuffer.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format about which to retrieve information.
        /// </param>
        /// <param name="pname">
        /// Specifies the type of information to query.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of integers that may be written to params by the function.
        /// </param>
        /// <param name="@params">[length: bufSize]
        /// Specifies the address of a variable into which to write the retrieved information.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInternalformativ")]
        [CLSCompliant(false)]
        public static unsafe void GetInternalformat(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, OpenTK.Graphics.ES31.All pname, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve the location of a sample
        /// </summary>
        /// <param name="pname">
        /// Specifies the sample parameter name. pname must be SamplePosition.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the sample whose position to query.
        /// </param>
        /// <param name="val">[length: COMPSIZE(pname)]
        /// Specifies the address of an array to receive the position of the sample.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetMultisamplefv")]
        [CLSCompliant(false)]
        public static void GetMultisample(OpenTK.Graphics.ES31.All pname, Int32 index, [OutAttribute, CountAttribute(Computed = "pname")] Single[] val) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve the location of a sample
        /// </summary>
        /// <param name="pname">
        /// Specifies the sample parameter name. pname must be SamplePosition.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the sample whose position to query.
        /// </param>
        /// <param name="val">[length: COMPSIZE(pname)]
        /// Specifies the address of an array to receive the position of the sample.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetMultisamplefv")]
        [CLSCompliant(false)]
        public static void GetMultisample(OpenTK.Graphics.ES31.All pname, Int32 index, [OutAttribute, CountAttribute(Computed = "pname")] out Single val) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve the location of a sample
        /// </summary>
        /// <param name="pname">
        /// Specifies the sample parameter name. pname must be SamplePosition.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the sample whose position to query.
        /// </param>
        /// <param name="val">[length: COMPSIZE(pname)]
        /// Specifies the address of an array to receive the position of the sample.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetMultisamplefv")]
        [CLSCompliant(false)]
        public static unsafe void GetMultisample(OpenTK.Graphics.ES31.All pname, Int32 index, [OutAttribute, CountAttribute(Computed = "pname")] Single* val) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve the location of a sample
        /// </summary>
        /// <param name="pname">
        /// Specifies the sample parameter name. pname must be SamplePosition.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the sample whose position to query.
        /// </param>
        /// <param name="val">[length: COMPSIZE(pname)]
        /// Specifies the address of an array to receive the position of the sample.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetMultisamplefv")]
        [CLSCompliant(false)]
        public static void GetMultisample(OpenTK.Graphics.ES31.All pname, UInt32 index, [OutAttribute, CountAttribute(Computed = "pname")] Single[] val) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve the location of a sample
        /// </summary>
        /// <param name="pname">
        /// Specifies the sample parameter name. pname must be SamplePosition.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the sample whose position to query.
        /// </param>
        /// <param name="val">[length: COMPSIZE(pname)]
        /// Specifies the address of an array to receive the position of the sample.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetMultisamplefv")]
        [CLSCompliant(false)]
        public static void GetMultisample(OpenTK.Graphics.ES31.All pname, UInt32 index, [OutAttribute, CountAttribute(Computed = "pname")] out Single val) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve the location of a sample
        /// </summary>
        /// <param name="pname">
        /// Specifies the sample parameter name. pname must be SamplePosition.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the sample whose position to query.
        /// </param>
        /// <param name="val">[length: COMPSIZE(pname)]
        /// Specifies the address of an array to receive the position of the sample.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetMultisamplefv")]
        [CLSCompliant(false)]
        public static unsafe void GetMultisample(OpenTK.Graphics.ES31.All pname, UInt32 index, [OutAttribute, CountAttribute(Computed = "pname")] Single* val) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformfv")]
        [CLSCompliant(false)]
        public static void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] Single[] @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformfv")]
        [CLSCompliant(false)]
        public static void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] out Single @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformfv")]
        [CLSCompliant(false)]
        public static unsafe void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] Single* @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformfv")]
        [CLSCompliant(false)]
        public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Single[] @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformfv")]
        [CLSCompliant(false)]
        public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] out Single @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformfv")]
        [CLSCompliant(false)]
        public static unsafe void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Single* @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformiv")]
        [CLSCompliant(false)]
        public static void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformiv")]
        [CLSCompliant(false)]
        public static void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformiv")]
        [CLSCompliant(false)]
        public static unsafe void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformiv")]
        [CLSCompliant(false)]
        public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformiv")]
        [CLSCompliant(false)]
        public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformiv")]
        [CLSCompliant(false)]
        public static unsafe void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformuiv")]
        [CLSCompliant(false)]
        public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] UInt32[] @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformuiv")]
        [CLSCompliant(false)]
        public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] out UInt32 @params) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="bufSize"></param>
        /// <param name="@params"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformuiv")]
        [CLSCompliant(false)]
        public static unsafe void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] UInt32* @params) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        [CLSCompliant(false)]
        public static void GetObjectLabel(OpenTK.Graphics.ES31.All identifier, Int32 name, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        [CLSCompliant(false)]
        public static void GetObjectLabel(OpenTK.Graphics.ES31.All identifier, Int32 name, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        [CLSCompliant(false)]
        public static unsafe void GetObjectLabel(OpenTK.Graphics.ES31.All identifier, Int32 name, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        [CLSCompliant(false)]
        public static void GetObjectLabel(OpenTK.Graphics.ES31.All identifier, UInt32 name, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        [CLSCompliant(false)]
        public static void GetObjectLabel(OpenTK.Graphics.ES31.All identifier, UInt32 name, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        [CLSCompliant(false)]
        public static unsafe void GetObjectLabel(OpenTK.Graphics.ES31.All identifier, UInt32 name, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static void GetObjectPtrLabel(IntPtr ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static void GetObjectPtrLabel(IntPtr ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static unsafe void GetObjectPtrLabel(IntPtr ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The length of the buffer whose address is in label.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">[length: bufSize]
        /// The address of a string that will receive the object label.
        /// </param>
        [Obsolete("Use out overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        [CLSCompliant(false)]
        public static unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// Specifies the array or buffer pointer to be returned. Symbolic constants ColorArrayPointer, EdgeFlagArrayPointer, FogCoordArrayPointer, FeedbackBufferPointer, IndexArrayPointer, NormalArrayPointer, SecondaryColorArrayPointer, SelectionBufferPointer, TextureCoordArrayPointer, or VertexArrayPointer are accepted.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static void GetPointer(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 1)] IntPtr @params) { throw new NotImplementedException(); }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// Specifies the array or buffer pointer to be returned. Symbolic constants ColorArrayPointer, EdgeFlagArrayPointer, FogCoordArrayPointer, FeedbackBufferPointer, IndexArrayPointer, NormalArrayPointer, SecondaryColorArrayPointer, SelectionBufferPointer, TextureCoordArrayPointer, or VertexArrayPointer are accepted.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        [CLSCompliant(false)]
        public static void GetPointer<T1>(OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T1[] @params)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// Specifies the array or buffer pointer to be returned. Symbolic constants ColorArrayPointer, EdgeFlagArrayPointer, FogCoordArrayPointer, FeedbackBufferPointer, IndexArrayPointer, NormalArrayPointer, SecondaryColorArrayPointer, SelectionBufferPointer, TextureCoordArrayPointer, or VertexArrayPointer are accepted.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        [CLSCompliant(false)]
        public static void GetPointer<T1>(OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T1[,] @params)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// Specifies the array or buffer pointer to be returned. Symbolic constants ColorArrayPointer, EdgeFlagArrayPointer, FogCoordArrayPointer, FeedbackBufferPointer, IndexArrayPointer, NormalArrayPointer, SecondaryColorArrayPointer, SelectionBufferPointer, TextureCoordArrayPointer, or VertexArrayPointer are accepted.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        [CLSCompliant(false)]
        public static void GetPointer<T1>(OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T1[,,] @params)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// Specifies the array or buffer pointer to be returned. Symbolic constants ColorArrayPointer, EdgeFlagArrayPointer, FogCoordArrayPointer, FeedbackBufferPointer, IndexArrayPointer, NormalArrayPointer, SecondaryColorArrayPointer, SelectionBufferPointer, TextureCoordArrayPointer, or VertexArrayPointer are accepted.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static void GetPointer<T1>(OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] ref T1 @params)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// Specifies the array or buffer pointer to be returned. Symbolic constants ColorArrayPointer, EdgeFlagArrayPointer, FogCoordArrayPointer, FeedbackBufferPointer, IndexArrayPointer, NormalArrayPointer, SecondaryColorArrayPointer, SelectionBufferPointer, TextureCoordArrayPointer, or VertexArrayPointer are accepted.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static void GetPointer(OpenTK.Graphics.ES31.GetPointervPName pname, [OutAttribute, CountAttribute(Count = 1)] IntPtr @params) { throw new NotImplementedException(); }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// Specifies the array or buffer pointer to be returned. Symbolic constants ColorArrayPointer, EdgeFlagArrayPointer, FogCoordArrayPointer, FeedbackBufferPointer, IndexArrayPointer, NormalArrayPointer, SecondaryColorArrayPointer, SelectionBufferPointer, TextureCoordArrayPointer, or VertexArrayPointer are accepted.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        [CLSCompliant(false)]
        public static void GetPointer<T1>(OpenTK.Graphics.ES31.GetPointervPName pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T1[] @params)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// Specifies the array or buffer pointer to be returned. Symbolic constants ColorArrayPointer, EdgeFlagArrayPointer, FogCoordArrayPointer, FeedbackBufferPointer, IndexArrayPointer, NormalArrayPointer, SecondaryColorArrayPointer, SelectionBufferPointer, TextureCoordArrayPointer, or VertexArrayPointer are accepted.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        [CLSCompliant(false)]
        public static void GetPointer<T1>(OpenTK.Graphics.ES31.GetPointervPName pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T1[,] @params)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// Specifies the array or buffer pointer to be returned. Symbolic constants ColorArrayPointer, EdgeFlagArrayPointer, FogCoordArrayPointer, FeedbackBufferPointer, IndexArrayPointer, NormalArrayPointer, SecondaryColorArrayPointer, SelectionBufferPointer, TextureCoordArrayPointer, or VertexArrayPointer are accepted.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        [CLSCompliant(false)]
        public static void GetPointer<T1>(OpenTK.Graphics.ES31.GetPointervPName pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T1[,,] @params)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// Specifies the array or buffer pointer to be returned. Symbolic constants ColorArrayPointer, EdgeFlagArrayPointer, FogCoordArrayPointer, FeedbackBufferPointer, IndexArrayPointer, NormalArrayPointer, SecondaryColorArrayPointer, SelectionBufferPointer, TextureCoordArrayPointer, or VertexArrayPointer are accepted.
        /// </param>
        /// <param name="@params">[length: 1]
        /// Returns the pointer value specified by pname.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static void GetPointer<T1>(OpenTK.Graphics.ES31.GetPointervPName pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] ref T1 @params)
            where T1 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static void GetProgramBinary(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr binary) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[] binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,] binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,,] binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] ref T4 binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramBinary(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr binary) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[] binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,] binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,,] binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] ref T4 binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static void GetProgramBinary(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr binary) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[] binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,] binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,,] binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] ref T4 binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramBinary(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr binary) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[] binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,] binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,,] binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given by binary.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">[length: 1]
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </param>
        /// <param name="binary">[length: bufSize]
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] ref T4 binary)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the information log for a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object whose information log is to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </param>
        /// <param name="infoLog">[length: bufSize]
        /// Specifies an array of characters that is used to return the information log.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramInfoLog")]
        [CLSCompliant(false)]
        public static void GetProgramInfoLog(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the information log for a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object whose information log is to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </param>
        /// <param name="infoLog">[length: bufSize]
        /// Specifies an array of characters that is used to return the information log.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramInfoLog")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramInfoLog(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the information log for a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object whose information log is to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </param>
        /// <param name="infoLog">[length: bufSize]
        /// Specifies an array of characters that is used to return the information log.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramInfoLog")]
        [CLSCompliant(false)]
        public static void GetProgramInfoLog(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the information log for a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object whose information log is to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </param>
        /// <param name="infoLog">[length: bufSize]
        /// Specifies an array of characters that is used to return the information log.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramInfoLog")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramInfoLog(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query a property of an interface in a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose interface to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program to query.
        /// </param>
        /// <param name="pname">
        /// The name of the parameter within programInterface to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// The address of a variable to retrieve the value of pname for the program interface.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramInterfaceiv")]
        [CLSCompliant(false)]
        public static void GetProgramInterface(Int32 program, OpenTK.Graphics.ES31.All programInterface, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query a property of an interface in a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose interface to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program to query.
        /// </param>
        /// <param name="pname">
        /// The name of the parameter within programInterface to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// The address of a variable to retrieve the value of pname for the program interface.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramInterfaceiv")]
        [CLSCompliant(false)]
        public static void GetProgramInterface(Int32 program, OpenTK.Graphics.ES31.All programInterface, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query a property of an interface in a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose interface to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program to query.
        /// </param>
        /// <param name="pname">
        /// The name of the parameter within programInterface to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// The address of a variable to retrieve the value of pname for the program interface.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramInterfaceiv")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramInterface(Int32 program, OpenTK.Graphics.ES31.All programInterface, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query a property of an interface in a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose interface to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program to query.
        /// </param>
        /// <param name="pname">
        /// The name of the parameter within programInterface to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// The address of a variable to retrieve the value of pname for the program interface.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramInterfaceiv")]
        [CLSCompliant(false)]
        public static void GetProgramInterface(UInt32 program, OpenTK.Graphics.ES31.All programInterface, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query a property of an interface in a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose interface to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program to query.
        /// </param>
        /// <param name="pname">
        /// The name of the parameter within programInterface to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// The address of a variable to retrieve the value of pname for the program interface.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramInterfaceiv")]
        [CLSCompliant(false)]
        public static void GetProgramInterface(UInt32 program, OpenTK.Graphics.ES31.All programInterface, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query a property of an interface in a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose interface to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program to query.
        /// </param>
        /// <param name="pname">
        /// The name of the parameter within programInterface to query.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// The address of a variable to retrieve the value of pname for the program interface.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramInterfaceiv")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramInterface(UInt32 program, OpenTK.Graphics.ES31.All programInterface, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are ActiveAttributes, ActiveAttributeMaxLength, ActiveUniforms, ActiveUniformBlocks, ActiveUniformBlockMaxNameLength, ActiveUniformMaxLength, AttachedShaders, DeleteStatus, InfoLogLength, LinkStatus, ProgramBinaryRetrievableHint, TransformFeedbackBufferMode, TransformFeedbackVaryings, TransformFeedbackVaryingMaxLength and ValidateStatus.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested object parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        [CLSCompliant(false)]
        public static void GetProgram(Int32 program, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are ActiveAttributes, ActiveAttributeMaxLength, ActiveUniforms, ActiveUniformBlocks, ActiveUniformBlockMaxNameLength, ActiveUniformMaxLength, AttachedShaders, DeleteStatus, InfoLogLength, LinkStatus, ProgramBinaryRetrievableHint, TransformFeedbackBufferMode, TransformFeedbackVaryings, TransformFeedbackVaryingMaxLength and ValidateStatus.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested object parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        [CLSCompliant(false)]
        public static void GetProgram(Int32 program, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are ActiveAttributes, ActiveAttributeMaxLength, ActiveUniforms, ActiveUniformBlocks, ActiveUniformBlockMaxNameLength, ActiveUniformMaxLength, AttachedShaders, DeleteStatus, InfoLogLength, LinkStatus, ProgramBinaryRetrievableHint, TransformFeedbackBufferMode, TransformFeedbackVaryings, TransformFeedbackVaryingMaxLength and ValidateStatus.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested object parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        [CLSCompliant(false)]
        public static unsafe void GetProgram(Int32 program, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are ActiveAttributes, ActiveAttributeMaxLength, ActiveUniforms, ActiveUniformBlocks, ActiveUniformBlockMaxNameLength, ActiveUniformMaxLength, AttachedShaders, DeleteStatus, InfoLogLength, LinkStatus, ProgramBinaryRetrievableHint, TransformFeedbackBufferMode, TransformFeedbackVaryings, TransformFeedbackVaryingMaxLength and ValidateStatus.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested object parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        [CLSCompliant(false)]
        public static void GetProgram(UInt32 program, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are ActiveAttributes, ActiveAttributeMaxLength, ActiveUniforms, ActiveUniformBlocks, ActiveUniformBlockMaxNameLength, ActiveUniformMaxLength, AttachedShaders, DeleteStatus, InfoLogLength, LinkStatus, ProgramBinaryRetrievableHint, TransformFeedbackBufferMode, TransformFeedbackVaryings, TransformFeedbackVaryingMaxLength and ValidateStatus.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested object parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        [CLSCompliant(false)]
        public static void GetProgram(UInt32 program, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are ActiveAttributes, ActiveAttributeMaxLength, ActiveUniforms, ActiveUniformBlocks, ActiveUniformBlockMaxNameLength, ActiveUniformMaxLength, AttachedShaders, DeleteStatus, InfoLogLength, LinkStatus, ProgramBinaryRetrievableHint, TransformFeedbackBufferMode, TransformFeedbackVaryings, TransformFeedbackVaryingMaxLength and ValidateStatus.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested object parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        [CLSCompliant(false)]
        public static unsafe void GetProgram(UInt32 program, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve the info log string from a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object from which to retrieve the info log.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
        /// </param>
        /// <param name="infoLog">[length: bufSize]
        /// Specifies the address of an array of characters into which will be written the info log for pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramPipelineInfoLog")]
        [CLSCompliant(false)]
        public static void GetProgramPipelineInfoLog(Int32 pipeline, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve the info log string from a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object from which to retrieve the info log.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
        /// </param>
        /// <param name="infoLog">[length: bufSize]
        /// Specifies the address of an array of characters into which will be written the info log for pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramPipelineInfoLog")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramPipelineInfoLog(Int32 pipeline, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve the info log string from a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object from which to retrieve the info log.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
        /// </param>
        /// <param name="infoLog">[length: bufSize]
        /// Specifies the address of an array of characters into which will be written the info log for pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramPipelineInfoLog")]
        [CLSCompliant(false)]
        public static void GetProgramPipelineInfoLog(UInt32 pipeline, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve the info log string from a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object from which to retrieve the info log.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
        /// </param>
        /// <param name="infoLog">[length: bufSize]
        /// Specifies the address of an array of characters into which will be written the info log for pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramPipelineInfoLog")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramPipelineInfoLog(UInt32 pipeline, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve properties of a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object whose parameter retrieve.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to retrieve.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramPipelineiv")]
        [CLSCompliant(false)]
        public static void GetProgramPipeline(Int32 pipeline, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve properties of a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object whose parameter retrieve.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to retrieve.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramPipelineiv")]
        [CLSCompliant(false)]
        public static void GetProgramPipeline(Int32 pipeline, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve properties of a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object whose parameter retrieve.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to retrieve.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramPipelineiv")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramPipeline(Int32 pipeline, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve properties of a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object whose parameter retrieve.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to retrieve.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramPipelineiv")]
        [CLSCompliant(false)]
        public static void GetProgramPipeline(UInt32 pipeline, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve properties of a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object whose parameter retrieve.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to retrieve.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramPipelineiv")]
        [CLSCompliant(false)]
        public static void GetProgramPipeline(UInt32 pipeline, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve properties of a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object whose parameter retrieve.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to retrieve.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramPipelineiv")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramPipeline(UInt32 pipeline, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query the index of a named resource within a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="name">[length: COMPSIZE(name)]
        /// The name of the resource to query the index of.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceIndex")]
        [CLSCompliant(false)]
        public static Int32 GetProgramResourceIndex(Int32 program, OpenTK.Graphics.ES31.All programInterface, [CountAttribute(Computed = "name")] String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query the index of a named resource within a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="name">[length: COMPSIZE(name)]
        /// The name of the resource to query the index of.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceIndex")]
        [CLSCompliant(false)]
        public static Int32 GetProgramResourceIndex(UInt32 program, OpenTK.Graphics.ES31.All programInterface, [CountAttribute(Computed = "name")] String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve values for multiple properties of a single active resource within a program object
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"></param>
        /// <param name="propCount"></param>
        /// <param name="props">[length: propCount]</param>
        /// <param name="bufSize"></param>
        /// <param name="length">[length: 1]</param>
        /// <param name="@params">[length: bufSize]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceiv")]
        [CLSCompliant(false)]
        public static void GetProgramResource(Int32 program, OpenTK.Graphics.ES31.All programInterface, Int32 index, Int32 propCount, [CountAttribute(Parameter = "propCount")] OpenTK.Graphics.ES31.All[] props, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve values for multiple properties of a single active resource within a program object
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"></param>
        /// <param name="propCount"></param>
        /// <param name="props">[length: propCount]</param>
        /// <param name="bufSize"></param>
        /// <param name="length">[length: 1]</param>
        /// <param name="@params">[length: bufSize]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceiv")]
        [CLSCompliant(false)]
        public static void GetProgramResource(Int32 program, OpenTK.Graphics.ES31.All programInterface, Int32 index, Int32 propCount, [CountAttribute(Parameter = "propCount")] ref OpenTK.Graphics.ES31.All props, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve values for multiple properties of a single active resource within a program object
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"></param>
        /// <param name="propCount"></param>
        /// <param name="props">[length: propCount]</param>
        /// <param name="bufSize"></param>
        /// <param name="length">[length: 1]</param>
        /// <param name="@params">[length: bufSize]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceiv")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramResource(Int32 program, OpenTK.Graphics.ES31.All programInterface, Int32 index, Int32 propCount, [CountAttribute(Parameter = "propCount")] OpenTK.Graphics.ES31.All* props, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve values for multiple properties of a single active resource within a program object
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"></param>
        /// <param name="propCount"></param>
        /// <param name="props">[length: propCount]</param>
        /// <param name="bufSize"></param>
        /// <param name="length">[length: 1]</param>
        /// <param name="@params">[length: bufSize]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceiv")]
        [CLSCompliant(false)]
        public static void GetProgramResource(UInt32 program, OpenTK.Graphics.ES31.All programInterface, UInt32 index, Int32 propCount, [CountAttribute(Parameter = "propCount")] OpenTK.Graphics.ES31.All[] props, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve values for multiple properties of a single active resource within a program object
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"></param>
        /// <param name="propCount"></param>
        /// <param name="props">[length: propCount]</param>
        /// <param name="bufSize"></param>
        /// <param name="length">[length: 1]</param>
        /// <param name="@params">[length: bufSize]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceiv")]
        [CLSCompliant(false)]
        public static void GetProgramResource(UInt32 program, OpenTK.Graphics.ES31.All programInterface, UInt32 index, Int32 propCount, [CountAttribute(Parameter = "propCount")] ref OpenTK.Graphics.ES31.All props, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Retrieve values for multiple properties of a single active resource within a program object
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"></param>
        /// <param name="propCount"></param>
        /// <param name="props">[length: propCount]</param>
        /// <param name="bufSize"></param>
        /// <param name="length">[length: 1]</param>
        /// <param name="@params">[length: bufSize]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceiv")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramResource(UInt32 program, OpenTK.Graphics.ES31.All programInterface, UInt32 index, Int32 propCount, [CountAttribute(Parameter = "propCount")] OpenTK.Graphics.ES31.All* props, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query the location of a named resource within a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="name">[length: COMPSIZE(name)]
        /// The name of the resource to query the location of.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceLocation")]
        [CLSCompliant(false)]
        public static Int32 GetProgramResourceLocation(Int32 program, OpenTK.Graphics.ES31.All programInterface, [CountAttribute(Computed = "name")] String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query the location of a named resource within a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="name">[length: COMPSIZE(name)]
        /// The name of the resource to query the location of.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceLocation")]
        [CLSCompliant(false)]
        public static Int32 GetProgramResourceLocation(UInt32 program, OpenTK.Graphics.ES31.All programInterface, [CountAttribute(Computed = "name")] String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query the name of an indexed resource within a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the indexed resource.
        /// </param>
        /// <param name="index">
        /// The index of the resource within programInterface of program.
        /// </param>
        /// <param name="bufSize">
        /// The size of the character array whose address is given by name.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable which will receive the length of the resource name.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// The address of a character array into which will be written the name of the resource.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceName")]
        [CLSCompliant(false)]
        public static void GetProgramResourceName(Int32 program, OpenTK.Graphics.ES31.All programInterface, Int32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query the name of an indexed resource within a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the indexed resource.
        /// </param>
        /// <param name="index">
        /// The index of the resource within programInterface of program.
        /// </param>
        /// <param name="bufSize">
        /// The size of the character array whose address is given by name.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable which will receive the length of the resource name.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// The address of a character array into which will be written the name of the resource.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceName")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramResourceName(Int32 program, OpenTK.Graphics.ES31.All programInterface, Int32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query the name of an indexed resource within a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the indexed resource.
        /// </param>
        /// <param name="index">
        /// The index of the resource within programInterface of program.
        /// </param>
        /// <param name="bufSize">
        /// The size of the character array whose address is given by name.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable which will receive the length of the resource name.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// The address of a character array into which will be written the name of the resource.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceName")]
        [CLSCompliant(false)]
        public static void GetProgramResourceName(UInt32 program, OpenTK.Graphics.ES31.All programInterface, UInt32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Query the name of an indexed resource within a program
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the indexed resource.
        /// </param>
        /// <param name="index">
        /// The index of the resource within programInterface of program.
        /// </param>
        /// <param name="bufSize">
        /// The size of the character array whose address is given by name.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable which will receive the length of the resource name.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// The address of a character array into which will be written the name of the resource.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetProgramResourceName")]
        [CLSCompliant(false)]
        public static unsafe void GetProgramResourceName(UInt32 program, OpenTK.Graphics.ES31.All programInterface, UInt32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a query object target
        /// </summary>
        /// <param name="target">
        /// Specifies a query object target. Must be AnySamplesPassed, AnySamplesPassedConservative, or TransformFeedbackPrimitivesWritten.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object target parameter. Must be CurrentQuery.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryiv")]
        [CLSCompliant(false)]
        public static void GetQuery(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a query object target
        /// </summary>
        /// <param name="target">
        /// Specifies a query object target. Must be AnySamplesPassed, AnySamplesPassedConservative, or TransformFeedbackPrimitivesWritten.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object target parameter. Must be CurrentQuery.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryiv")]
        [CLSCompliant(false)]
        public static void GetQuery(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a query object target
        /// </summary>
        /// <param name="target">
        /// Specifies a query object target. Must be AnySamplesPassed, AnySamplesPassedConservative, or TransformFeedbackPrimitivesWritten.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object target parameter. Must be CurrentQuery.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryiv")]
        [CLSCompliant(false)]
        public static unsafe void GetQuery(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        [CLSCompliant(false)]
        public static void GetQueryObject(Int32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        [CLSCompliant(false)]
        public static void GetQueryObject(Int32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        [CLSCompliant(false)]
        public static unsafe void GetQueryObject(Int32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        [CLSCompliant(false)]
        public static void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        [CLSCompliant(false)]
        public static void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out UInt32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        [CLSCompliant(false)]
        public static unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve information about a bound renderbuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the query operation. target must be Renderbuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of an array to receive the value of the queried parameter.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetRenderbufferParameteriv")]
        [CLSCompliant(false)]
        public static void GetRenderbufferParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve information about a bound renderbuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the query operation. target must be Renderbuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of an array to receive the value of the queried parameter.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetRenderbufferParameteriv")]
        [CLSCompliant(false)]
        public static void GetRenderbufferParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve information about a bound renderbuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the query operation. target must be Renderbuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of an array to receive the value of the queried parameter.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetRenderbufferParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void GetRenderbufferParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve information about a bound renderbuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the query operation. target must be Renderbuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of an array to receive the value of the queried parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetRenderbufferParameteriv")]
        [CLSCompliant(false)]
        public static void GetRenderbufferParameter(OpenTK.Graphics.ES31.RenderbufferTarget target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve information about a bound renderbuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the query operation. target must be Renderbuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of an array to receive the value of the queried parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetRenderbufferParameteriv")]
        [CLSCompliant(false)]
        public static void GetRenderbufferParameter(OpenTK.Graphics.ES31.RenderbufferTarget target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve information about a bound renderbuffer object
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the query operation. target must be Renderbuffer.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the address of an array to receive the value of the queried parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetRenderbufferParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void GetRenderbufferParameter(OpenTK.Graphics.ES31.RenderbufferTarget target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. TextureMagFilter, TextureMinFilter, TextureMinLod, TextureMaxLod, TextureWrapS, TextureWrapT, TextureWrapR, TextureCompareMode, and TextureCompareFunc are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the sampler parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        [CLSCompliant(false)]
        public static void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. TextureMagFilter, TextureMinFilter, TextureMinLod, TextureMaxLod, TextureWrapS, TextureWrapT, TextureWrapR, TextureCompareMode, and TextureCompareFunc are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the sampler parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        [CLSCompliant(false)]
        public static void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Single @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. TextureMagFilter, TextureMinFilter, TextureMinLod, TextureMaxLod, TextureWrapS, TextureWrapT, TextureWrapR, TextureCompareMode, and TextureCompareFunc are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the sampler parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        [CLSCompliant(false)]
        public static unsafe void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. TextureMagFilter, TextureMinFilter, TextureMinLod, TextureMaxLod, TextureWrapS, TextureWrapT, TextureWrapR, TextureCompareMode, and TextureCompareFunc are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the sampler parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        [CLSCompliant(false)]
        public static void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. TextureMagFilter, TextureMinFilter, TextureMinLod, TextureMaxLod, TextureWrapS, TextureWrapT, TextureWrapR, TextureCompareMode, and TextureCompareFunc are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the sampler parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        [CLSCompliant(false)]
        public static void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Single @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. TextureMagFilter, TextureMinFilter, TextureMinLod, TextureMaxLod, TextureWrapS, TextureWrapT, TextureWrapR, TextureCompareMode, and TextureCompareFunc are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the sampler parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        [CLSCompliant(false)]
        public static unsafe void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. TextureMagFilter, TextureMinFilter, TextureMinLod, TextureMaxLod, TextureWrapS, TextureWrapT, TextureWrapR, TextureCompareMode, and TextureCompareFunc are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the sampler parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        [CLSCompliant(false)]
        public static void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. TextureMagFilter, TextureMinFilter, TextureMinLod, TextureMaxLod, TextureWrapS, TextureWrapT, TextureWrapR, TextureCompareMode, and TextureCompareFunc are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the sampler parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        [CLSCompliant(false)]
        public static void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. TextureMagFilter, TextureMinFilter, TextureMinLod, TextureMaxLod, TextureWrapS, TextureWrapT, TextureWrapR, TextureCompareMode, and TextureCompareFunc are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the sampler parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. TextureMagFilter, TextureMinFilter, TextureMinLod, TextureMaxLod, TextureWrapS, TextureWrapT, TextureWrapR, TextureCompareMode, and TextureCompareFunc are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the sampler parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        [CLSCompliant(false)]
        public static void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. TextureMagFilter, TextureMinFilter, TextureMinLod, TextureMaxLod, TextureWrapS, TextureWrapT, TextureWrapR, TextureCompareMode, and TextureCompareFunc are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the sampler parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        [CLSCompliant(false)]
        public static void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. TextureMagFilter, TextureMinFilter, TextureMinLod, TextureMaxLod, TextureWrapS, TextureWrapT, TextureWrapR, TextureCompareMode, and TextureCompareFunc are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the sampler parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the information log for a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object whose information log is to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </param>
        /// <param name="infoLog">[length: bufSize]
        /// Specifies an array of characters that is used to return the information log.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderInfoLog")]
        [CLSCompliant(false)]
        public static void GetShaderInfoLog(Int32 shader, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the information log for a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object whose information log is to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </param>
        /// <param name="infoLog">[length: bufSize]
        /// Specifies an array of characters that is used to return the information log.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderInfoLog")]
        [CLSCompliant(false)]
        public static unsafe void GetShaderInfoLog(Int32 shader, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the information log for a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object whose information log is to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </param>
        /// <param name="infoLog">[length: bufSize]
        /// Specifies an array of characters that is used to return the information log.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderInfoLog")]
        [CLSCompliant(false)]
        public static void GetShaderInfoLog(UInt32 shader, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the information log for a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object whose information log is to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </param>
        /// <param name="infoLog">[length: bufSize]
        /// Specifies an array of characters that is used to return the information log.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderInfoLog")]
        [CLSCompliant(false)]
        public static unsafe void GetShaderInfoLog(UInt32 shader, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are ShaderType, DeleteStatus, CompileStatus, InfoLogLength, ShaderSourceLength.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested object parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        [CLSCompliant(false)]
        public static void GetShader(Int32 shader, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are ShaderType, DeleteStatus, CompileStatus, InfoLogLength, ShaderSourceLength.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested object parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        [CLSCompliant(false)]
        public static void GetShader(Int32 shader, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are ShaderType, DeleteStatus, CompileStatus, InfoLogLength, ShaderSourceLength.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested object parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        [CLSCompliant(false)]
        public static unsafe void GetShader(Int32 shader, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are ShaderType, DeleteStatus, CompileStatus, InfoLogLength, ShaderSourceLength.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested object parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        [CLSCompliant(false)]
        public static void GetShader(UInt32 shader, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are ShaderType, DeleteStatus, CompileStatus, InfoLogLength, ShaderSourceLength.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested object parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        [CLSCompliant(false)]
        public static void GetShader(UInt32 shader, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are ShaderType, DeleteStatus, CompileStatus, InfoLogLength, ShaderSourceLength.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested object parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        [CLSCompliant(false)]
        public static unsafe void GetShader(UInt32 shader, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve the range and precision for numeric formats supported by the shader compiler
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the type of shader whose precision to query. shaderType must be VertexShader or FragmentShader.
        /// </param>
        /// <param name="precisiontype">
        /// Specifies the numeric format whose precision and range to query.
        /// </param>
        /// <param name="range">[length: 2]
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
        /// </param>
        /// <param name="precision">[length: 1]
        /// Specifies the address of an integer into which the numeric precision of the implementation is written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderPrecisionFormat")]
        [CLSCompliant(false)]
        public static void GetShaderPrecisionFormat(OpenTK.Graphics.ES31.All shadertype, OpenTK.Graphics.ES31.All precisiontype, [OutAttribute, CountAttribute(Count = 2)] Int32[] range, [OutAttribute, CountAttribute(Count = 1)] out Int32 precision) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve the range and precision for numeric formats supported by the shader compiler
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the type of shader whose precision to query. shaderType must be VertexShader or FragmentShader.
        /// </param>
        /// <param name="precisiontype">
        /// Specifies the numeric format whose precision and range to query.
        /// </param>
        /// <param name="range">[length: 2]
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
        /// </param>
        /// <param name="precision">[length: 1]
        /// Specifies the address of an integer into which the numeric precision of the implementation is written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderPrecisionFormat")]
        [CLSCompliant(false)]
        public static void GetShaderPrecisionFormat(OpenTK.Graphics.ES31.All shadertype, OpenTK.Graphics.ES31.All precisiontype, [OutAttribute, CountAttribute(Count = 2)] out Int32 range, [OutAttribute, CountAttribute(Count = 1)] out Int32 precision) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Retrieve the range and precision for numeric formats supported by the shader compiler
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the type of shader whose precision to query. shaderType must be VertexShader or FragmentShader.
        /// </param>
        /// <param name="precisiontype">
        /// Specifies the numeric format whose precision and range to query.
        /// </param>
        /// <param name="range">[length: 2]
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
        /// </param>
        /// <param name="precision">[length: 1]
        /// Specifies the address of an integer into which the numeric precision of the implementation is written.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderPrecisionFormat")]
        [CLSCompliant(false)]
        public static unsafe void GetShaderPrecisionFormat(OpenTK.Graphics.ES31.All shadertype, OpenTK.Graphics.ES31.All precisiontype, [OutAttribute, CountAttribute(Count = 2)] Int32* range, [OutAttribute, CountAttribute(Count = 1)] Int32* precision) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the source code string from a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned source code string.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the length of the string returned in source (excluding the null terminator).
        /// </param>
        /// <param name="source">[length: bufSize]
        /// Specifies an array of characters that is used to return the source code string.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderSource")]
        [CLSCompliant(false)]
        public static void GetShaderSource(Int32 shader, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String source) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the source code string from a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned source code string.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the length of the string returned in source (excluding the null terminator).
        /// </param>
        /// <param name="source">[length: bufSize]
        /// Specifies an array of characters that is used to return the source code string.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderSource")]
        [CLSCompliant(false)]
        public static unsafe void GetShaderSource(Int32 shader, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String source) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the source code string from a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned source code string.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the length of the string returned in source (excluding the null terminator).
        /// </param>
        /// <param name="source">[length: bufSize]
        /// Specifies an array of characters that is used to return the source code string.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderSource")]
        [CLSCompliant(false)]
        public static void GetShaderSource(UInt32 shader, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String source) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the source code string from a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned source code string.
        /// </param>
        /// <param name="length">[length: 1]
        /// Returns the length of the string returned in source (excluding the null terminator).
        /// </param>
        /// <param name="source">[length: bufSize]
        /// Specifies an array of characters that is used to return the source code string.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderSource")]
        [CLSCompliant(false)]
        public static unsafe void GetShaderSource(UInt32 shader, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String source) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a string describing the current GL connection
        /// </summary>
        /// <param name="name">
        /// Specifies a symbolic constant, one of Extensions, Renderer, ShadingLanguageVersion, Vendor, or Version. glGetStringi accepts only the Extensions token.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetString")]
        public static String GetString(OpenTK.Graphics.ES31.All name) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a string describing the current GL connection
        /// </summary>
        /// <param name="name">
        /// Specifies a symbolic constant, one of Extensions, Renderer, ShadingLanguageVersion, Vendor, or Version. glGetStringi accepts only the Extensions token.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetString")]
        public static String GetString(OpenTK.Graphics.ES31.StringName name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a string describing the current GL connection
        /// </summary>
        /// <param name="name">
        /// Specifies a symbolic constant, one of Extensions, Renderer, ShadingLanguageVersion, Vendor, or Version. glGetStringi accepts only the Extensions token.
        /// </param>
        /// <param name="index">
        /// For glGetStringi, specifies the index of the string to return.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetStringi")]
        [CLSCompliant(false)]
        public static String GetString(OpenTK.Graphics.ES31.All name, Int32 index) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Return a string describing the current GL connection
        /// </summary>
        /// <param name="name">
        /// Specifies a symbolic constant, one of Extensions, Renderer, ShadingLanguageVersion, Vendor, or Version. glGetStringi accepts only the Extensions token.
        /// </param>
        /// <param name="index">
        /// For glGetStringi, specifies the index of the string to return.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetStringi")]
        [CLSCompliant(false)]
        public static String GetString(OpenTK.Graphics.ES31.All name, UInt32 index) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Query the properties of a sync object
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose properties to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given in values.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        /// <param name="values">[length: bufSize]
        /// Specifies the address of an array to receive the values of the queried parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSynciv")]
        [CLSCompliant(false)]
        public static void GetSync(IntPtr sync, OpenTK.Graphics.ES31.All pname, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32[] values) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Query the properties of a sync object
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose properties to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given in values.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        /// <param name="values">[length: bufSize]
        /// Specifies the address of an array to receive the values of the queried parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSynciv")]
        [CLSCompliant(false)]
        public static void GetSync(IntPtr sync, OpenTK.Graphics.ES31.All pname, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out Int32 values) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Query the properties of a sync object
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose properties to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given in values.
        /// </param>
        /// <param name="length">[length: 1]
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        /// <param name="values">[length: bufSize]
        /// Specifies the address of an array to receive the values of the queried parameter.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSynciv")]
        [CLSCompliant(false)]
        public static unsafe void GetSync(IntPtr sync, OpenTK.Graphics.ES31.All pname, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* values) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture, one of Texture1D, Texture2D, Texture3D, Texture1DArray, Texture2DArray, TextureRectangle, Texture2DMultisample, Texture2DMultisampleArray, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, TextureCubeMapNegativeZ, ProxyTexture1D, ProxyTexture2D, ProxyTexture3D, ProxyTexture1DArray, ProxyTexture2DArray, ProxyTextureRectangle, ProxyTexture2DMultisample, ProxyTexture2DMultisampleArray, ProxyTextureCubeMap, or TextureBuffer.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level  is the th mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureWidth, TextureHeight, TextureDepth, TextureInternalFormat, TextureRedSize, TextureGreenSize, TextureBlueSize, TextureAlphaSize, TextureDepthSize, TextureCompressed, TextureCompressedImageSize, and TextureBufferOffset are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetTexLevelParameterfv")]
        [CLSCompliant(false)]
        public static void GetTexLevelParameter(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture, one of Texture1D, Texture2D, Texture3D, Texture1DArray, Texture2DArray, TextureRectangle, Texture2DMultisample, Texture2DMultisampleArray, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, TextureCubeMapNegativeZ, ProxyTexture1D, ProxyTexture2D, ProxyTexture3D, ProxyTexture1DArray, ProxyTexture2DArray, ProxyTextureRectangle, ProxyTexture2DMultisample, ProxyTexture2DMultisampleArray, ProxyTextureCubeMap, or TextureBuffer.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level  is the th mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureWidth, TextureHeight, TextureDepth, TextureInternalFormat, TextureRedSize, TextureGreenSize, TextureBlueSize, TextureAlphaSize, TextureDepthSize, TextureCompressed, TextureCompressedImageSize, and TextureBufferOffset are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetTexLevelParameterfv")]
        [CLSCompliant(false)]
        public static void GetTexLevelParameter(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Single @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture, one of Texture1D, Texture2D, Texture3D, Texture1DArray, Texture2DArray, TextureRectangle, Texture2DMultisample, Texture2DMultisampleArray, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, TextureCubeMapNegativeZ, ProxyTexture1D, ProxyTexture2D, ProxyTexture3D, ProxyTexture1DArray, ProxyTexture2DArray, ProxyTextureRectangle, ProxyTexture2DMultisample, ProxyTexture2DMultisampleArray, ProxyTextureCubeMap, or TextureBuffer.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level  is the th mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureWidth, TextureHeight, TextureDepth, TextureInternalFormat, TextureRedSize, TextureGreenSize, TextureBlueSize, TextureAlphaSize, TextureDepthSize, TextureCompressed, TextureCompressedImageSize, and TextureBufferOffset are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetTexLevelParameterfv")]
        [CLSCompliant(false)]
        public static unsafe void GetTexLevelParameter(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture, one of Texture1D, Texture2D, Texture3D, Texture1DArray, Texture2DArray, TextureRectangle, Texture2DMultisample, Texture2DMultisampleArray, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, TextureCubeMapNegativeZ, ProxyTexture1D, ProxyTexture2D, ProxyTexture3D, ProxyTexture1DArray, ProxyTexture2DArray, ProxyTextureRectangle, ProxyTexture2DMultisample, ProxyTexture2DMultisampleArray, ProxyTextureCubeMap, or TextureBuffer.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level  is the th mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureWidth, TextureHeight, TextureDepth, TextureInternalFormat, TextureRedSize, TextureGreenSize, TextureBlueSize, TextureAlphaSize, TextureDepthSize, TextureCompressed, TextureCompressedImageSize, and TextureBufferOffset are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetTexLevelParameterfv")]
        [CLSCompliant(false)]
        public static void GetTexLevelParameter(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] Single[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture, one of Texture1D, Texture2D, Texture3D, Texture1DArray, Texture2DArray, TextureRectangle, Texture2DMultisample, Texture2DMultisampleArray, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, TextureCubeMapNegativeZ, ProxyTexture1D, ProxyTexture2D, ProxyTexture3D, ProxyTexture1DArray, ProxyTexture2DArray, ProxyTextureRectangle, ProxyTexture2DMultisample, ProxyTexture2DMultisampleArray, ProxyTextureCubeMap, or TextureBuffer.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level  is the th mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureWidth, TextureHeight, TextureDepth, TextureInternalFormat, TextureRedSize, TextureGreenSize, TextureBlueSize, TextureAlphaSize, TextureDepthSize, TextureCompressed, TextureCompressedImageSize, and TextureBufferOffset are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetTexLevelParameterfv")]
        [CLSCompliant(false)]
        public static void GetTexLevelParameter(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] out Single @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture, one of Texture1D, Texture2D, Texture3D, Texture1DArray, Texture2DArray, TextureRectangle, Texture2DMultisample, Texture2DMultisampleArray, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, TextureCubeMapNegativeZ, ProxyTexture1D, ProxyTexture2D, ProxyTexture3D, ProxyTexture1DArray, ProxyTexture2DArray, ProxyTextureRectangle, ProxyTexture2DMultisample, ProxyTexture2DMultisampleArray, ProxyTextureCubeMap, or TextureBuffer.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level  is the th mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureWidth, TextureHeight, TextureDepth, TextureInternalFormat, TextureRedSize, TextureGreenSize, TextureBlueSize, TextureAlphaSize, TextureDepthSize, TextureCompressed, TextureCompressedImageSize, and TextureBufferOffset are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetTexLevelParameterfv")]
        [CLSCompliant(false)]
        public static unsafe void GetTexLevelParameter(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture, one of Texture1D, Texture2D, Texture3D, Texture1DArray, Texture2DArray, TextureRectangle, Texture2DMultisample, Texture2DMultisampleArray, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, TextureCubeMapNegativeZ, ProxyTexture1D, ProxyTexture2D, ProxyTexture3D, ProxyTexture1DArray, ProxyTexture2DArray, ProxyTextureRectangle, ProxyTexture2DMultisample, ProxyTexture2DMultisampleArray, ProxyTextureCubeMap, or TextureBuffer.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level  is the th mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureWidth, TextureHeight, TextureDepth, TextureInternalFormat, TextureRedSize, TextureGreenSize, TextureBlueSize, TextureAlphaSize, TextureDepthSize, TextureCompressed, TextureCompressedImageSize, and TextureBufferOffset are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetTexLevelParameteriv")]
        [CLSCompliant(false)]
        public static void GetTexLevelParameter(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture, one of Texture1D, Texture2D, Texture3D, Texture1DArray, Texture2DArray, TextureRectangle, Texture2DMultisample, Texture2DMultisampleArray, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, TextureCubeMapNegativeZ, ProxyTexture1D, ProxyTexture2D, ProxyTexture3D, ProxyTexture1DArray, ProxyTexture2DArray, ProxyTextureRectangle, ProxyTexture2DMultisample, ProxyTexture2DMultisampleArray, ProxyTextureCubeMap, or TextureBuffer.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level  is the th mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureWidth, TextureHeight, TextureDepth, TextureInternalFormat, TextureRedSize, TextureGreenSize, TextureBlueSize, TextureAlphaSize, TextureDepthSize, TextureCompressed, TextureCompressedImageSize, and TextureBufferOffset are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetTexLevelParameteriv")]
        [CLSCompliant(false)]
        public static void GetTexLevelParameter(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture, one of Texture1D, Texture2D, Texture3D, Texture1DArray, Texture2DArray, TextureRectangle, Texture2DMultisample, Texture2DMultisampleArray, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, TextureCubeMapNegativeZ, ProxyTexture1D, ProxyTexture2D, ProxyTexture3D, ProxyTexture1DArray, ProxyTexture2DArray, ProxyTextureRectangle, ProxyTexture2DMultisample, ProxyTexture2DMultisampleArray, ProxyTextureCubeMap, or TextureBuffer.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level  is the th mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureWidth, TextureHeight, TextureDepth, TextureInternalFormat, TextureRedSize, TextureGreenSize, TextureBlueSize, TextureAlphaSize, TextureDepthSize, TextureCompressed, TextureCompressedImageSize, and TextureBufferOffset are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetTexLevelParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void GetTexLevelParameter(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture, one of Texture1D, Texture2D, Texture3D, Texture1DArray, Texture2DArray, TextureRectangle, Texture2DMultisample, Texture2DMultisampleArray, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, TextureCubeMapNegativeZ, ProxyTexture1D, ProxyTexture2D, ProxyTexture3D, ProxyTexture1DArray, ProxyTexture2DArray, ProxyTextureRectangle, ProxyTexture2DMultisample, ProxyTexture2DMultisampleArray, ProxyTextureCubeMap, or TextureBuffer.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level  is the th mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureWidth, TextureHeight, TextureDepth, TextureInternalFormat, TextureRedSize, TextureGreenSize, TextureBlueSize, TextureAlphaSize, TextureDepthSize, TextureCompressed, TextureCompressedImageSize, and TextureBufferOffset are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetTexLevelParameteriv")]
        [CLSCompliant(false)]
        public static void GetTexLevelParameter(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture, one of Texture1D, Texture2D, Texture3D, Texture1DArray, Texture2DArray, TextureRectangle, Texture2DMultisample, Texture2DMultisampleArray, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, TextureCubeMapNegativeZ, ProxyTexture1D, ProxyTexture2D, ProxyTexture3D, ProxyTexture1DArray, ProxyTexture2DArray, ProxyTextureRectangle, ProxyTexture2DMultisample, ProxyTexture2DMultisampleArray, ProxyTextureCubeMap, or TextureBuffer.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level  is the th mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureWidth, TextureHeight, TextureDepth, TextureInternalFormat, TextureRedSize, TextureGreenSize, TextureBlueSize, TextureAlphaSize, TextureDepthSize, TextureCompressed, TextureCompressedImageSize, and TextureBufferOffset are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetTexLevelParameteriv")]
        [CLSCompliant(false)]
        public static void GetTexLevelParameter(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture, one of Texture1D, Texture2D, Texture3D, Texture1DArray, Texture2DArray, TextureRectangle, Texture2DMultisample, Texture2DMultisampleArray, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, TextureCubeMapNegativeZ, ProxyTexture1D, ProxyTexture2D, ProxyTexture3D, ProxyTexture1DArray, ProxyTexture2DArray, ProxyTextureRectangle, ProxyTexture2DMultisample, ProxyTexture2DMultisampleArray, ProxyTextureCubeMap, or TextureBuffer.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level  is the th mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureWidth, TextureHeight, TextureDepth, TextureInternalFormat, TextureRedSize, TextureGreenSize, TextureBlueSize, TextureAlphaSize, TextureDepthSize, TextureCompressed, TextureCompressedImageSize, and TextureBufferOffset are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glGetTexLevelParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void GetTexLevelParameter(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture. Texture2D, Texture2DArray, Texture3D, and TextureCubeMap are accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureImmutableFormat, TextureMagFilter, TextureMaxLevel, TextureMaxLod, TextureMinFilter, TextureMinLod, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, and TextureWrapR are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the texture parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameterfv")]
        [CLSCompliant(false)]
        public static void GetTexParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture. Texture2D, Texture2DArray, Texture3D, and TextureCubeMap are accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureImmutableFormat, TextureMagFilter, TextureMaxLevel, TextureMaxLod, TextureMinFilter, TextureMinLod, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, and TextureWrapR are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the texture parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameterfv")]
        [CLSCompliant(false)]
        public static void GetTexParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Single @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture. Texture2D, Texture2DArray, Texture3D, and TextureCubeMap are accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureImmutableFormat, TextureMagFilter, TextureMaxLevel, TextureMaxLod, TextureMinFilter, TextureMinLod, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, and TextureWrapR are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the texture parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameterfv")]
        [CLSCompliant(false)]
        public static unsafe void GetTexParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture. Texture2D, Texture2DArray, Texture3D, and TextureCubeMap are accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureImmutableFormat, TextureMagFilter, TextureMaxLevel, TextureMaxLod, TextureMinFilter, TextureMinLod, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, and TextureWrapR are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the texture parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameterfv")]
        [CLSCompliant(false)]
        public static void GetTexParameter(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] Single[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture. Texture2D, Texture2DArray, Texture3D, and TextureCubeMap are accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureImmutableFormat, TextureMagFilter, TextureMaxLevel, TextureMaxLod, TextureMinFilter, TextureMinLod, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, and TextureWrapR are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the texture parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameterfv")]
        [CLSCompliant(false)]
        public static void GetTexParameter(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] out Single @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture. Texture2D, Texture2DArray, Texture3D, and TextureCubeMap are accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureImmutableFormat, TextureMagFilter, TextureMaxLevel, TextureMaxLod, TextureMinFilter, TextureMinLod, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, and TextureWrapR are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the texture parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameterfv")]
        [CLSCompliant(false)]
        public static unsafe void GetTexParameter(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture. Texture2D, Texture2DArray, Texture3D, and TextureCubeMap are accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureImmutableFormat, TextureMagFilter, TextureMaxLevel, TextureMaxLod, TextureMinFilter, TextureMinLod, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, and TextureWrapR are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the texture parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameteriv")]
        [CLSCompliant(false)]
        public static void GetTexParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture. Texture2D, Texture2DArray, Texture3D, and TextureCubeMap are accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureImmutableFormat, TextureMagFilter, TextureMaxLevel, TextureMaxLod, TextureMinFilter, TextureMinLod, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, and TextureWrapR are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the texture parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameteriv")]
        [CLSCompliant(false)]
        public static void GetTexParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture. Texture2D, Texture2DArray, Texture3D, and TextureCubeMap are accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureImmutableFormat, TextureMagFilter, TextureMaxLevel, TextureMaxLod, TextureMinFilter, TextureMinLod, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, and TextureWrapR are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the texture parameters.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void GetTexParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture. Texture2D, Texture2DArray, Texture3D, and TextureCubeMap are accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureImmutableFormat, TextureMagFilter, TextureMaxLevel, TextureMaxLod, TextureMinFilter, TextureMinLod, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, and TextureWrapR are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the texture parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameteriv")]
        [CLSCompliant(false)]
        public static void GetTexParameter(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture. Texture2D, Texture2DArray, Texture3D, and TextureCubeMap are accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureImmutableFormat, TextureMagFilter, TextureMaxLevel, TextureMaxLod, TextureMinFilter, TextureMinLod, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, and TextureWrapR are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the texture parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameteriv")]
        [CLSCompliant(false)]
        public static void GetTexParameter(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of the target texture. Texture2D, Texture2DArray, Texture3D, and TextureCubeMap are accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureImmutableFormat, TextureMagFilter, TextureMaxLevel, TextureMaxLod, TextureMinFilter, TextureMinLod, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, and TextureWrapR are accepted.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Returns the texture parameters.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void GetTexParameter(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve information about varying variables selected for transform feedback
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is Null no length is returned.
        /// </param>
        /// <param name="size">[length: 1]
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">[length: 1]
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// The address of a buffer into which will be written the name of the varying.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetTransformFeedbackVarying")]
        [CLSCompliant(false)]
        public static void GetTransformFeedbackVarying(Int32 program, Int32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out Int32 size, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All type, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve information about varying variables selected for transform feedback
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is Null no length is returned.
        /// </param>
        /// <param name="size">[length: 1]
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">[length: 1]
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// The address of a buffer into which will be written the name of the varying.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetTransformFeedbackVarying")]
        [CLSCompliant(false)]
        public static unsafe void GetTransformFeedbackVarying(Int32 program, Int32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] Int32* size, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* type, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve information about varying variables selected for transform feedback
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is Null no length is returned.
        /// </param>
        /// <param name="size">[length: 1]
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">[length: 1]
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// The address of a buffer into which will be written the name of the varying.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetTransformFeedbackVarying")]
        [CLSCompliant(false)]
        public static void GetTransformFeedbackVarying(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out Int32 size, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All type, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve information about varying variables selected for transform feedback
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">[length: 1]
        /// The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is Null no length is returned.
        /// </param>
        /// <param name="size">[length: 1]
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">[length: 1]
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">[length: bufSize]
        /// The address of a buffer into which will be written the name of the varying.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetTransformFeedbackVarying")]
        [CLSCompliant(false)]
        public static unsafe void GetTransformFeedbackVarying(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] Int32* size, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* type, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockName">[length: COMPSIZE()]
        /// Specifies the address an array of characters containing the name of the uniform block whose index to retrieve.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformBlockIndex")]
        [CLSCompliant(false)]
        public static Int32 GetUniformBlockIndex(Int32 program, [CountAttribute(Computed = "")] String uniformBlockName) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockName">[length: COMPSIZE()]
        /// Specifies the address an array of characters containing the name of the uniform block whose index to retrieve.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformBlockIndex")]
        [CLSCompliant(false)]
        public static Int32 GetUniformBlockIndex(UInt32 program, [CountAttribute(Computed = "")] String uniformBlockName) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformfv")]
        [CLSCompliant(false)]
        public static void GetUniform(Int32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Single[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformfv")]
        [CLSCompliant(false)]
        public static void GetUniform(Int32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] out Single @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformfv")]
        [CLSCompliant(false)]
        public static unsafe void GetUniform(Int32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Single* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformfv")]
        [CLSCompliant(false)]
        public static void GetUniform(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Single[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformfv")]
        [CLSCompliant(false)]
        public static void GetUniform(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] out Single @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformfv")]
        [CLSCompliant(false)]
        public static unsafe void GetUniform(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Single* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies the number of uniforms whose indices to query.
        /// </param>
        /// <param name="uniformNames">[length: COMPSIZE(uniformCount)]
        /// Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
        /// </param>
        /// <param name="uniformIndices">[length: COMPSIZE(uniformCount)]
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformIndices")]
        [CLSCompliant(false)]
        public static void GetUniformIndices(Int32 program, Int32 uniformCount, [CountAttribute(Computed = "uniformCount")] String[] uniformNames, [OutAttribute, CountAttribute(Computed = "uniformCount")] Int32[] uniformIndices) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies the number of uniforms whose indices to query.
        /// </param>
        /// <param name="uniformNames">[length: COMPSIZE(uniformCount)]
        /// Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
        /// </param>
        /// <param name="uniformIndices">[length: COMPSIZE(uniformCount)]
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformIndices")]
        [CLSCompliant(false)]
        public static void GetUniformIndices(Int32 program, Int32 uniformCount, [CountAttribute(Computed = "uniformCount")] String[] uniformNames, [OutAttribute, CountAttribute(Computed = "uniformCount")] out Int32 uniformIndices) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies the number of uniforms whose indices to query.
        /// </param>
        /// <param name="uniformNames">[length: COMPSIZE(uniformCount)]
        /// Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
        /// </param>
        /// <param name="uniformIndices">[length: COMPSIZE(uniformCount)]
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformIndices")]
        [CLSCompliant(false)]
        public static unsafe void GetUniformIndices(Int32 program, Int32 uniformCount, [CountAttribute(Computed = "uniformCount")] String[] uniformNames, [OutAttribute, CountAttribute(Computed = "uniformCount")] Int32* uniformIndices) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies the number of uniforms whose indices to query.
        /// </param>
        /// <param name="uniformNames">[length: COMPSIZE(uniformCount)]
        /// Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
        /// </param>
        /// <param name="uniformIndices">[length: COMPSIZE(uniformCount)]
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformIndices")]
        [CLSCompliant(false)]
        public static void GetUniformIndices(UInt32 program, Int32 uniformCount, [CountAttribute(Computed = "uniformCount")] String[] uniformNames, [OutAttribute, CountAttribute(Computed = "uniformCount")] UInt32[] uniformIndices) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies the number of uniforms whose indices to query.
        /// </param>
        /// <param name="uniformNames">[length: COMPSIZE(uniformCount)]
        /// Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
        /// </param>
        /// <param name="uniformIndices">[length: COMPSIZE(uniformCount)]
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformIndices")]
        [CLSCompliant(false)]
        public static void GetUniformIndices(UInt32 program, Int32 uniformCount, [CountAttribute(Computed = "uniformCount")] String[] uniformNames, [OutAttribute, CountAttribute(Computed = "uniformCount")] out UInt32 uniformIndices) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies the number of uniforms whose indices to query.
        /// </param>
        /// <param name="uniformNames">[length: COMPSIZE(uniformCount)]
        /// Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
        /// </param>
        /// <param name="uniformIndices">[length: COMPSIZE(uniformCount)]
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformIndices")]
        [CLSCompliant(false)]
        public static unsafe void GetUniformIndices(UInt32 program, Int32 uniformCount, [CountAttribute(Computed = "uniformCount")] String[] uniformNames, [OutAttribute, CountAttribute(Computed = "uniformCount")] UInt32* uniformIndices) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformiv")]
        [CLSCompliant(false)]
        public static void GetUniform(Int32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformiv")]
        [CLSCompliant(false)]
        public static void GetUniform(Int32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformiv")]
        [CLSCompliant(false)]
        public static unsafe void GetUniform(Int32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformiv")]
        [CLSCompliant(false)]
        public static void GetUniform(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformiv")]
        [CLSCompliant(false)]
        public static void GetUniform(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformiv")]
        [CLSCompliant(false)]
        public static unsafe void GetUniform(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the location of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="name">
        /// Points to a null terminated string containing the name of the uniform variable whose location is to be queried.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformLocation")]
        [CLSCompliant(false)]
        public static Int32 GetUniformLocation(Int32 program, String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Returns the location of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="name">
        /// Points to a null terminated string containing the name of the uniform variable whose location is to be queried.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformLocation")]
        [CLSCompliant(false)]
        public static Int32 GetUniformLocation(UInt32 program, String name) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformuiv")]
        [CLSCompliant(false)]
        public static void GetUniform(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] UInt32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformuiv")]
        [CLSCompliant(false)]
        public static void GetUniform(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] out UInt32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(program,location)]
        /// Returns the value of the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformuiv")]
        [CLSCompliant(false)]
        public static unsafe void GetUniform(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] UInt32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are VertexAttribArrayBufferBinding, VertexAttribArrayEnabled, VertexAttribArraySize, VertexAttribArrayStride, VertexAttribArrayType, VertexAttribArrayNormalized, VertexAttribArrayInteger, VertexAttribArrayDivisor, or CurrentVertexAttrib.
        /// </param>
        /// <param name="@params">[length: 4]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        [CLSCompliant(false)]
        public static void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Single[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are VertexAttribArrayBufferBinding, VertexAttribArrayEnabled, VertexAttribArraySize, VertexAttribArrayStride, VertexAttribArrayType, VertexAttribArrayNormalized, VertexAttribArrayInteger, VertexAttribArrayDivisor, or CurrentVertexAttrib.
        /// </param>
        /// <param name="@params">[length: 4]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        [CLSCompliant(false)]
        public static void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] out Single @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are VertexAttribArrayBufferBinding, VertexAttribArrayEnabled, VertexAttribArraySize, VertexAttribArrayStride, VertexAttribArrayType, VertexAttribArrayNormalized, VertexAttribArrayInteger, VertexAttribArrayDivisor, or CurrentVertexAttrib.
        /// </param>
        /// <param name="@params">[length: 4]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        [CLSCompliant(false)]
        public static unsafe void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Single* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are VertexAttribArrayBufferBinding, VertexAttribArrayEnabled, VertexAttribArraySize, VertexAttribArrayStride, VertexAttribArrayType, VertexAttribArrayNormalized, VertexAttribArrayInteger, VertexAttribArrayDivisor, or CurrentVertexAttrib.
        /// </param>
        /// <param name="@params">[length: 4]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        [CLSCompliant(false)]
        public static void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Single[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are VertexAttribArrayBufferBinding, VertexAttribArrayEnabled, VertexAttribArraySize, VertexAttribArrayStride, VertexAttribArrayType, VertexAttribArrayNormalized, VertexAttribArrayInteger, VertexAttribArrayDivisor, or CurrentVertexAttrib.
        /// </param>
        /// <param name="@params">[length: 4]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        [CLSCompliant(false)]
        public static void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] out Single @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are VertexAttribArrayBufferBinding, VertexAttribArrayEnabled, VertexAttribArraySize, VertexAttribArrayStride, VertexAttribArrayType, VertexAttribArrayNormalized, VertexAttribArrayInteger, VertexAttribArrayDivisor, or CurrentVertexAttrib.
        /// </param>
        /// <param name="@params">[length: 4]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        [CLSCompliant(false)]
        public static unsafe void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Single* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="pname"></param>
        /// <param name="@params">[length: 1]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetVertexAttribIiv")]
        [CLSCompliant(false)]
        public static void GetVertexAttribI(Int32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 1)] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="pname"></param>
        /// <param name="@params">[length: 1]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetVertexAttribIiv")]
        [CLSCompliant(false)]
        public static unsafe void GetVertexAttribI(Int32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 1)] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="pname"></param>
        /// <param name="@params">[length: 1]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetVertexAttribIiv")]
        [CLSCompliant(false)]
        public static void GetVertexAttribI(UInt32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 1)] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="pname"></param>
        /// <param name="@params">[length: 1]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetVertexAttribIiv")]
        [CLSCompliant(false)]
        public static unsafe void GetVertexAttribI(UInt32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 1)] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="pname"></param>
        /// <param name="@params">[length: 1]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetVertexAttribIuiv")]
        [CLSCompliant(false)]
        public static void GetVertexAttribI(UInt32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 1)] out UInt32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="pname"></param>
        /// <param name="@params">[length: 1]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetVertexAttribIuiv")]
        [CLSCompliant(false)]
        public static unsafe void GetVertexAttribI(UInt32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 1)] UInt32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are VertexAttribArrayBufferBinding, VertexAttribArrayEnabled, VertexAttribArraySize, VertexAttribArrayStride, VertexAttribArrayType, VertexAttribArrayNormalized, VertexAttribArrayInteger, VertexAttribArrayDivisor, or CurrentVertexAttrib.
        /// </param>
        /// <param name="@params">[length: 4]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        [CLSCompliant(false)]
        public static void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are VertexAttribArrayBufferBinding, VertexAttribArrayEnabled, VertexAttribArraySize, VertexAttribArrayStride, VertexAttribArrayType, VertexAttribArrayNormalized, VertexAttribArrayInteger, VertexAttribArrayDivisor, or CurrentVertexAttrib.
        /// </param>
        /// <param name="@params">[length: 4]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        [CLSCompliant(false)]
        public static void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are VertexAttribArrayBufferBinding, VertexAttribArrayEnabled, VertexAttribArraySize, VertexAttribArrayStride, VertexAttribArrayType, VertexAttribArrayNormalized, VertexAttribArrayInteger, VertexAttribArrayDivisor, or CurrentVertexAttrib.
        /// </param>
        /// <param name="@params">[length: 4]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        [CLSCompliant(false)]
        public static unsafe void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are VertexAttribArrayBufferBinding, VertexAttribArrayEnabled, VertexAttribArraySize, VertexAttribArrayStride, VertexAttribArrayType, VertexAttribArrayNormalized, VertexAttribArrayInteger, VertexAttribArrayDivisor, or CurrentVertexAttrib.
        /// </param>
        /// <param name="@params">[length: 4]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        [CLSCompliant(false)]
        public static void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are VertexAttribArrayBufferBinding, VertexAttribArrayEnabled, VertexAttribArraySize, VertexAttribArrayStride, VertexAttribArrayType, VertexAttribArrayNormalized, VertexAttribArrayInteger, VertexAttribArrayDivisor, or CurrentVertexAttrib.
        /// </param>
        /// <param name="@params">[length: 4]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        [CLSCompliant(false)]
        public static void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] out Int32 @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are VertexAttribArrayBufferBinding, VertexAttribArrayEnabled, VertexAttribArraySize, VertexAttribArrayStride, VertexAttribArrayType, VertexAttribArrayNormalized, VertexAttribArrayInteger, VertexAttribArrayDivisor, or CurrentVertexAttrib.
        /// </param>
        /// <param name="@params">[length: 4]
        /// Returns the requested data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        [CLSCompliant(false)]
        public static unsafe void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be VertexAttribArrayPointer.
        /// </param>
        /// <param name="pointer">[length: 1]
        /// Returns the pointer value.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        [CLSCompliant(false)]
        public static void GetVertexAttribPointer(Int32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 1)] IntPtr pointer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be VertexAttribArrayPointer.
        /// </param>
        /// <param name="pointer">[length: 1]
        /// Returns the pointer value.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        [CLSCompliant(false)]
        public static void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T2[] pointer)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be VertexAttribArrayPointer.
        /// </param>
        /// <param name="pointer">[length: 1]
        /// Returns the pointer value.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        [CLSCompliant(false)]
        public static void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T2[,] pointer)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be VertexAttribArrayPointer.
        /// </param>
        /// <param name="pointer">[length: 1]
        /// Returns the pointer value.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        [CLSCompliant(false)]
        public static void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T2[,,] pointer)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be VertexAttribArrayPointer.
        /// </param>
        /// <param name="pointer">[length: 1]
        /// Returns the pointer value.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        [CLSCompliant(false)]
        public static void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] ref T2 pointer)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be VertexAttribArrayPointer.
        /// </param>
        /// <param name="pointer">[length: 1]
        /// Returns the pointer value.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        [CLSCompliant(false)]
        public static void GetVertexAttribPointer(UInt32 index, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 1)] IntPtr pointer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be VertexAttribArrayPointer.
        /// </param>
        /// <param name="pointer">[length: 1]
        /// Returns the pointer value.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        [CLSCompliant(false)]
        public static void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T2[] pointer)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be VertexAttribArrayPointer.
        /// </param>
        /// <param name="pointer">[length: 1]
        /// Returns the pointer value.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        [CLSCompliant(false)]
        public static void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T2[,] pointer)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be VertexAttribArrayPointer.
        /// </param>
        /// <param name="pointer">[length: 1]
        /// Returns the pointer value.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        [CLSCompliant(false)]
        public static void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] T2[,,] pointer)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be VertexAttribArrayPointer.
        /// </param>
        /// <param name="pointer">[length: 1]
        /// Returns the pointer value.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        [CLSCompliant(false)]
        public static void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute, CountAttribute(Count = 1)] ref T2 pointer)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify implementation-specific hints
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating the behavior to be controlled. FragmentShaderDerivativeHint, and GenerateMipmapHint are accepted.
        /// </param>
        /// <param name="mode">
        /// Specifies a symbolic constant indicating the desired behavior. Fastest, Nicest, and DontCare are accepted.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glHint")]
        public static void Hint(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All mode) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify implementation-specific hints
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating the behavior to be controlled. FragmentShaderDerivativeHint, and GenerateMipmapHint are accepted.
        /// </param>
        /// <param name="mode">
        /// Specifies a symbolic constant indicating the desired behavior. Fastest, Nicest, and DontCare are accepted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glHint")]
        public static void Hint(OpenTK.Graphics.ES31.HintTarget target, OpenTK.Graphics.ES31.HintMode mode) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Invalidate the contents of attachments within a framebuffer
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the invalidate operation. Must be Framebuffer.
        /// </param>
        /// <param name="numAttachments">
        /// Specifies how many attachments are supplied in the attachments list.
        /// </param>
        /// <param name="attachments">[length: numAttachments]
        /// A list of numAttachments attachments to invalidate.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateFramebuffer")]
        [CLSCompliant(false)]
        public static void InvalidateFramebuffer(OpenTK.Graphics.ES31.All target, Int32 numAttachments, [CountAttribute(Parameter = "numAttachments")] OpenTK.Graphics.ES31.All[] attachments) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Invalidate the contents of attachments within a framebuffer
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the invalidate operation. Must be Framebuffer.
        /// </param>
        /// <param name="numAttachments">
        /// Specifies how many attachments are supplied in the attachments list.
        /// </param>
        /// <param name="attachments">[length: numAttachments]
        /// A list of numAttachments attachments to invalidate.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateFramebuffer")]
        [CLSCompliant(false)]
        public static void InvalidateFramebuffer(OpenTK.Graphics.ES31.All target, Int32 numAttachments, [CountAttribute(Parameter = "numAttachments")] ref OpenTK.Graphics.ES31.All attachments) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Invalidate the contents of attachments within a framebuffer
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the invalidate operation. Must be Framebuffer.
        /// </param>
        /// <param name="numAttachments">
        /// Specifies how many attachments are supplied in the attachments list.
        /// </param>
        /// <param name="attachments">[length: numAttachments]
        /// A list of numAttachments attachments to invalidate.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateFramebuffer")]
        [CLSCompliant(false)]
        public static unsafe void InvalidateFramebuffer(OpenTK.Graphics.ES31.All target, Int32 numAttachments, [CountAttribute(Parameter = "numAttachments")] OpenTK.Graphics.ES31.All* attachments) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Invalidate portions of the contents of attachments within a framebuffer
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the invalidate operation. Must be Framebuffer.
        /// </param>
        /// <param name="numAttachments">
        /// Specifies how many attachments are supplied in the attachments list.
        /// </param>
        /// <param name="attachments">[length: numAttachments]
        /// A list of numAttachments attachments to invalidate.
        /// </param>
        /// <param name="x">
        /// Specifies the left origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0).
        /// </param>
        /// <param name="y">
        /// Specifies the bottom origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0).
        /// </param>
        /// <param name="width">
        /// Specifies the width of the pixel rectangle to invalidate.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the pixel rectangle to invalidate.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateSubFramebuffer")]
        [CLSCompliant(false)]
        public static void InvalidateSubFramebuffer(OpenTK.Graphics.ES31.All target, Int32 numAttachments, [CountAttribute(Parameter = "numAttachments")] OpenTK.Graphics.ES31.All[] attachments, Int32 x, Int32 y, Int32 width, Int32 height) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Invalidate portions of the contents of attachments within a framebuffer
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the invalidate operation. Must be Framebuffer.
        /// </param>
        /// <param name="numAttachments">
        /// Specifies how many attachments are supplied in the attachments list.
        /// </param>
        /// <param name="attachments">[length: numAttachments]
        /// A list of numAttachments attachments to invalidate.
        /// </param>
        /// <param name="x">
        /// Specifies the left origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0).
        /// </param>
        /// <param name="y">
        /// Specifies the bottom origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0).
        /// </param>
        /// <param name="width">
        /// Specifies the width of the pixel rectangle to invalidate.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the pixel rectangle to invalidate.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateSubFramebuffer")]
        [CLSCompliant(false)]
        public static void InvalidateSubFramebuffer(OpenTK.Graphics.ES31.All target, Int32 numAttachments, [CountAttribute(Parameter = "numAttachments")] ref OpenTK.Graphics.ES31.All attachments, Int32 x, Int32 y, Int32 width, Int32 height) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Invalidate portions of the contents of attachments within a framebuffer
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the invalidate operation. Must be Framebuffer.
        /// </param>
        /// <param name="numAttachments">
        /// Specifies how many attachments are supplied in the attachments list.
        /// </param>
        /// <param name="attachments">[length: numAttachments]
        /// A list of numAttachments attachments to invalidate.
        /// </param>
        /// <param name="x">
        /// Specifies the left origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0).
        /// </param>
        /// <param name="y">
        /// Specifies the bottom origin of the pixel rectangle to invalidate, with lower left hand corner at (0,0).
        /// </param>
        /// <param name="width">
        /// Specifies the width of the pixel rectangle to invalidate.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the pixel rectangle to invalidate.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateSubFramebuffer")]
        [CLSCompliant(false)]
        public static unsafe void InvalidateSubFramebuffer(OpenTK.Graphics.ES31.All target, Int32 numAttachments, [CountAttribute(Parameter = "numAttachments")] OpenTK.Graphics.ES31.All* attachments, Int32 x, Int32 y, Int32 width, Int32 height) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Determine if a name corresponds to a buffer object
        /// </summary>
        /// <param name="buffer">
        /// Specifies a value that may be the name of a buffer object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsBuffer")]
        [CLSCompliant(false)]
        public static bool IsBuffer(Int32 buffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Determine if a name corresponds to a buffer object
        /// </summary>
        /// <param name="buffer">
        /// Specifies a value that may be the name of a buffer object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsBuffer")]
        [CLSCompliant(false)]
        public static bool IsBuffer(UInt32 buffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Test whether a capability is enabled
        /// </summary>
        /// <param name="cap">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsEnabled")]
        public static bool IsEnabled(OpenTK.Graphics.ES31.All cap) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Test whether a capability is enabled
        /// </summary>
        /// <param name="cap">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsEnabled")]
        public static bool IsEnabled(OpenTK.Graphics.ES31.EnableCap cap) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Determine if a name corresponds to a framebuffer object
        /// </summary>
        /// <param name="framebuffer">
        /// Specifies a value that may be the name of a framebuffer object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsFramebuffer")]
        [CLSCompliant(false)]
        public static bool IsFramebuffer(Int32 framebuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Determine if a name corresponds to a framebuffer object
        /// </summary>
        /// <param name="framebuffer">
        /// Specifies a value that may be the name of a framebuffer object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsFramebuffer")]
        [CLSCompliant(false)]
        public static bool IsFramebuffer(UInt32 framebuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Determines if a name corresponds to a program object
        /// </summary>
        /// <param name="program">
        /// Specifies a potential program object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsProgram")]
        [CLSCompliant(false)]
        public static bool IsProgram(Int32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Determines if a name corresponds to a program object
        /// </summary>
        /// <param name="program">
        /// Specifies a potential program object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsProgram")]
        [CLSCompliant(false)]
        public static bool IsProgram(UInt32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Determine if a name corresponds to a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies a value that may be the name of a program pipeline object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glIsProgramPipeline")]
        [CLSCompliant(false)]
        public static bool IsProgramPipeline(Int32 pipeline) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Determine if a name corresponds to a program pipeline object
        /// </summary>
        /// <param name="pipeline">
        /// Specifies a value that may be the name of a program pipeline object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glIsProgramPipeline")]
        [CLSCompliant(false)]
        public static bool IsProgramPipeline(UInt32 pipeline) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Determine if a name corresponds to a query object
        /// </summary>
        /// <param name="id">
        /// Specifies a value that may be the name of a query object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsQuery")]
        [CLSCompliant(false)]
        public static bool IsQuery(Int32 id) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Determine if a name corresponds to a query object
        /// </summary>
        /// <param name="id">
        /// Specifies a value that may be the name of a query object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsQuery")]
        [CLSCompliant(false)]
        public static bool IsQuery(UInt32 id) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Determine if a name corresponds to a renderbuffer object
        /// </summary>
        /// <param name="renderbuffer">
        /// Specifies a value that may be the name of a renderbuffer object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsRenderbuffer")]
        [CLSCompliant(false)]
        public static bool IsRenderbuffer(Int32 renderbuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Determine if a name corresponds to a renderbuffer object
        /// </summary>
        /// <param name="renderbuffer">
        /// Specifies a value that may be the name of a renderbuffer object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsRenderbuffer")]
        [CLSCompliant(false)]
        public static bool IsRenderbuffer(UInt32 renderbuffer) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Determine if a name corresponds to a sampler object
        /// </summary>
        /// <param name="sampler">
        /// Specifies a value that may be the name of a sampler object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsSampler")]
        [CLSCompliant(false)]
        public static bool IsSampler(Int32 sampler) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Determine if a name corresponds to a sampler object
        /// </summary>
        /// <param name="sampler">
        /// Specifies a value that may be the name of a sampler object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsSampler")]
        [CLSCompliant(false)]
        public static bool IsSampler(UInt32 sampler) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Determines if a name corresponds to a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies a potential shader object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsShader")]
        [CLSCompliant(false)]
        public static bool IsShader(Int32 shader) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Determines if a name corresponds to a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies a potential shader object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsShader")]
        [CLSCompliant(false)]
        public static bool IsShader(UInt32 shader) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Determine if a name corresponds to a sync object
        /// </summary>
        /// <param name="sync">
        /// Specifies a value that may be the name of a sync object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsSync")]
        public static bool IsSync(IntPtr sync) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Determine if a name corresponds to a texture
        /// </summary>
        /// <param name="texture">
        /// Specifies a value that may be the name of a texture.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsTexture")]
        [CLSCompliant(false)]
        public static bool IsTexture(Int32 texture) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Determine if a name corresponds to a texture
        /// </summary>
        /// <param name="texture">
        /// Specifies a value that may be the name of a texture.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsTexture")]
        [CLSCompliant(false)]
        public static bool IsTexture(UInt32 texture) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Determine if a name corresponds to a transform feedback object
        /// </summary>
        /// <param name="id">
        /// Specifies a value that may be the name of a transform feedback object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsTransformFeedback")]
        [CLSCompliant(false)]
        public static bool IsTransformFeedback(Int32 id) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Determine if a name corresponds to a transform feedback object
        /// </summary>
        /// <param name="id">
        /// Specifies a value that may be the name of a transform feedback object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsTransformFeedback")]
        [CLSCompliant(false)]
        public static bool IsTransformFeedback(UInt32 id) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Determine if a name corresponds to a vertex array object
        /// </summary>
        /// <param name="array">
        /// Specifies a value that may be the name of a vertex array object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsVertexArray")]
        [CLSCompliant(false)]
        public static bool IsVertexArray(Int32 array) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Determine if a name corresponds to a vertex array object
        /// </summary>
        /// <param name="array">
        /// Specifies a value that may be the name of a vertex array object.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsVertexArray")]
        [CLSCompliant(false)]
        public static bool IsVertexArray(UInt32 array) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the width of rasterized lines
        /// </summary>
        /// <param name="width">
        /// Specifies the width of rasterized lines. The initial value is 1.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glLineWidth")]
        public static void LineWidth(Single width) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Links a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object to be linked.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glLinkProgram")]
        [CLSCompliant(false)]
        public static void LinkProgram(Int32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Links a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object to be linked.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glLinkProgram")]
        [CLSCompliant(false)]
        public static void LinkProgram(UInt32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Map a section of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies a binding to which the target buffer is bound.
        /// </param>
        /// <param name="offset">
        /// Specifies the starting offset within the buffer of the range to be mapped.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the range to be mapped.
        /// </param>
        /// <param name="access">
        /// Specifies a combination of access flags indicating the desired access to the range.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glMapBufferRange")]
        public static IntPtr MapBufferRange(OpenTK.Graphics.ES31.All target, IntPtr offset, Int32 length, OpenTK.Graphics.ES31.All access) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Map a section of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies a binding to which the target buffer is bound.
        /// </param>
        /// <param name="offset">
        /// Specifies the starting offset within the buffer of the range to be mapped.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the range to be mapped.
        /// </param>
        /// <param name="access">
        /// Specifies a combination of access flags indicating the desired access to the range.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glMapBufferRange")]
        public static IntPtr MapBufferRange(OpenTK.Graphics.ES31.All target, IntPtr offset, IntPtr length, OpenTK.Graphics.ES31.All access) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Map a section of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies a binding to which the target buffer is bound.
        /// </param>
        /// <param name="offset">
        /// Specifies the starting offset within the buffer of the range to be mapped.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the range to be mapped.
        /// </param>
        /// <param name="access">
        /// Specifies a combination of access flags indicating the desired access to the range.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glMapBufferRange")]
        public static IntPtr MapBufferRange(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, Int32 length, OpenTK.Graphics.ES31.BufferAccessMask access) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Map a section of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// Specifies a binding to which the target buffer is bound.
        /// </param>
        /// <param name="offset">
        /// Specifies the starting offset within the buffer of the range to be mapped.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the range to be mapped.
        /// </param>
        /// <param name="access">
        /// Specifies a combination of access flags indicating the desired access to the range.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glMapBufferRange")]
        public static IntPtr MapBufferRange(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr offset, IntPtr length, OpenTK.Graphics.ES31.BufferAccessMask access) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Defines a barrier ordering memory transactions
        /// </summary>
        /// <param name="barriers">
        /// Specifies the barriers to insert. Must be a bitwise combination of VertexAttribArrayBarrierBit, ElementArrayBarrierBit, UniformBarrierBit, TextureFetchBarrierBit, ShaderImageAccessBarrierBit, CommandBarrierBit, PixelBufferBarrierBit, TextureUpdateBarrierBit, BufferUpdateBarrierBit, FramebufferBarrierBit, TransformFeedbackBarrierBit, AtomicCounterBarrierBit, or ShaderStorageBarrierBit. If the special value AllBarrierBits is specified, all supported barriers will be inserted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glMemoryBarrier")]
        [CLSCompliant(false)]
        public static void MemoryBarrier(Int32 barriers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Defines a barrier ordering memory transactions
        /// </summary>
        /// <param name="barriers">
        /// Specifies the barriers to insert. Must be a bitwise combination of VertexAttribArrayBarrierBit, ElementArrayBarrierBit, UniformBarrierBit, TextureFetchBarrierBit, ShaderImageAccessBarrierBit, CommandBarrierBit, PixelBufferBarrierBit, TextureUpdateBarrierBit, BufferUpdateBarrierBit, FramebufferBarrierBit, TransformFeedbackBarrierBit, AtomicCounterBarrierBit, or ShaderStorageBarrierBit. If the special value AllBarrierBits is specified, all supported barriers will be inserted.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glMemoryBarrier")]
        [CLSCompliant(false)]
        public static void MemoryBarrier(UInt32 barriers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="barriers"></param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glMemoryBarrierByRegion")]
        [CLSCompliant(false)]
        public static void MemoryBarrierByRegion(Int32 barriers) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="barriers"></param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glMemoryBarrierByRegion")]
        [CLSCompliant(false)]
        public static void MemoryBarrierByRegion(UInt32 barriers) { throw new NotImplementedException(); }

        /// <summary>
        /// Label a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object to label.
        /// </param>
        /// <param name="length">
        /// The length of the label to be used for the object.
        /// </param>
        /// <param name="label">[length: COMPSIZE(label,length)]
        /// The address of a string containing the label to assign to the object.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectLabel")]
        [CLSCompliant(false)]
        public static void ObjectLabel(OpenTK.Graphics.ES31.All identifier, Int32 name, Int32 length, [CountAttribute(Computed = "label,length")] String label) { throw new NotImplementedException(); }

        /// <summary>
        /// Label a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object to label.
        /// </param>
        /// <param name="length">
        /// The length of the label to be used for the object.
        /// </param>
        /// <param name="label">[length: COMPSIZE(label,length)]
        /// The address of a string containing the label to assign to the object.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectLabel")]
        [CLSCompliant(false)]
        public static void ObjectLabel(OpenTK.Graphics.ES31.All identifier, UInt32 name, Int32 length, [CountAttribute(Computed = "label,length")] String label) { throw new NotImplementedException(); }

        /// <summary>
        /// Label a a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// A pointer identifying a sync object.
        /// </param>
        /// <param name="length">
        /// The length of the label to be used for the object.
        /// </param>
        /// <param name="label">[length: COMPSIZE(label,length)]
        /// The address of a string containing the label to assign to the object.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabel")]
        public static void ObjectPtrLabel(IntPtr ptr, Int32 length, [CountAttribute(Computed = "label,length")] String label) { throw new NotImplementedException(); }

        /// <summary>
        /// Label a a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// A pointer identifying a sync object.
        /// </param>
        /// <param name="length">
        /// The length of the label to be used for the object.
        /// </param>
        /// <param name="label">[length: COMPSIZE(label,length)]
        /// The address of a string containing the label to assign to the object.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabel")]
        [CLSCompliant(false)]
        public static void ObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 length, [CountAttribute(Computed = "label,length")] String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Label a a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// A pointer identifying a sync object.
        /// </param>
        /// <param name="length">
        /// The length of the label to be used for the object.
        /// </param>
        /// <param name="label">[length: COMPSIZE(label,length)]
        /// The address of a string containing the label to assign to the object.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabel")]
        [CLSCompliant(false)]
        public static void ObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 length, [CountAttribute(Computed = "label,length")] String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Label a a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// A pointer identifying a sync object.
        /// </param>
        /// <param name="length">
        /// The length of the label to be used for the object.
        /// </param>
        /// <param name="label">[length: COMPSIZE(label,length)]
        /// The address of a string containing the label to assign to the object.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabel")]
        [CLSCompliant(false)]
        public static void ObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 length, [CountAttribute(Computed = "label,length")] String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>
        /// Label a a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// A pointer identifying a sync object.
        /// </param>
        /// <param name="length">
        /// The length of the label to be used for the object.
        /// </param>
        /// <param name="label">[length: COMPSIZE(label,length)]
        /// The address of a string containing the label to assign to the object.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabel")]
        public static void ObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 length, [CountAttribute(Computed = "label,length")] String label)
            where T0 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Pause transform feedback operations
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glPauseTransformFeedback")]
        public static void PauseTransformFeedback() { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set pixel storage modes
        /// </summary>
        /// <param name="pname">
        /// Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: PackRowLength, PackImageHeight, PackSkipPixels, PackSkipRows, PackSkipImages, and PackAlignment. Six more affect the unpacking of pixel data from memory: UnpackRowLength, UnpackImageHeight, UnpackSkipPixels, UnpackSkipRows, UnpackSkipImages, and UnpackAlignment.
        /// </param>
        /// <param name="param">
        /// Specifies the value that pname is set to.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glPixelStorei")]
        public static void PixelStore(OpenTK.Graphics.ES31.All pname, Int32 param) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set pixel storage modes
        /// </summary>
        /// <param name="pname">
        /// Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: PackRowLength, PackImageHeight, PackSkipPixels, PackSkipRows, PackSkipImages, and PackAlignment. Six more affect the unpacking of pixel data from memory: UnpackRowLength, UnpackImageHeight, UnpackSkipPixels, UnpackSkipRows, UnpackSkipImages, and UnpackAlignment.
        /// </param>
        /// <param name="param">
        /// Specifies the value that pname is set to.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glPixelStorei")]
        public static void PixelStore(OpenTK.Graphics.ES31.PixelStoreParameter pname, Int32 param) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set the scale and units used to calculate depth values
        /// </summary>
        /// <param name="factor">
        /// Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.
        /// </param>
        /// <param name="units">
        /// Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glPolygonOffset")]
        public static void PolygonOffset(Single factor, Single units) { throw new NotImplementedException(); }

        /// <summary>
        /// Pop the active debug group
        /// </summary>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glPopDebugGroup")]
        public static void PopDebugGroup() { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object into which to load a program binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the format of the binary data in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array containing the binary to be loaded into program.
        /// </param>
        /// <param name="length">
        /// Specifies the number of bytes contained in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        [CLSCompliant(false)]
        public static void ProgramBinary(Int32 program, OpenTK.Graphics.ES31.All binaryFormat, [CountAttribute(Parameter = "length")] IntPtr binary, Int32 length) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object into which to load a program binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the format of the binary data in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array containing the binary to be loaded into program.
        /// </param>
        /// <param name="length">
        /// Specifies the number of bytes contained in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        [CLSCompliant(false)]
        public static void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T2[] binary, Int32 length)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object into which to load a program binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the format of the binary data in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array containing the binary to be loaded into program.
        /// </param>
        /// <param name="length">
        /// Specifies the number of bytes contained in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        [CLSCompliant(false)]
        public static void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T2[,] binary, Int32 length)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object into which to load a program binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the format of the binary data in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array containing the binary to be loaded into program.
        /// </param>
        /// <param name="length">
        /// Specifies the number of bytes contained in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        [CLSCompliant(false)]
        public static void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T2[,,] binary, Int32 length)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object into which to load a program binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the format of the binary data in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array containing the binary to be loaded into program.
        /// </param>
        /// <param name="length">
        /// Specifies the number of bytes contained in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        [CLSCompliant(false)]
        public static void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] ref T2 binary, Int32 length)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object into which to load a program binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the format of the binary data in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array containing the binary to be loaded into program.
        /// </param>
        /// <param name="length">
        /// Specifies the number of bytes contained in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        [CLSCompliant(false)]
        public static void ProgramBinary(UInt32 program, OpenTK.Graphics.ES31.All binaryFormat, [CountAttribute(Parameter = "length")] IntPtr binary, Int32 length) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object into which to load a program binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the format of the binary data in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array containing the binary to be loaded into program.
        /// </param>
        /// <param name="length">
        /// Specifies the number of bytes contained in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        [CLSCompliant(false)]
        public static void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T2[] binary, Int32 length)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object into which to load a program binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the format of the binary data in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array containing the binary to be loaded into program.
        /// </param>
        /// <param name="length">
        /// Specifies the number of bytes contained in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        [CLSCompliant(false)]
        public static void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T2[,] binary, Int32 length)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object into which to load a program binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the format of the binary data in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array containing the binary to be loaded into program.
        /// </param>
        /// <param name="length">
        /// Specifies the number of bytes contained in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        [CLSCompliant(false)]
        public static void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T2[,,] binary, Int32 length)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object into which to load a program binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the format of the binary data in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array containing the binary to be loaded into program.
        /// </param>
        /// <param name="length">
        /// Specifies the number of bytes contained in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        [CLSCompliant(false)]
        public static void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] ref T2 binary, Int32 length)
            where T2 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a parameter for a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to modify.
        /// </param>
        /// <param name="value">
        /// Specifies the new value of the parameter specified by pname for program.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramParameteri")]
        [CLSCompliant(false)]
        public static void ProgramParameter(Int32 program, OpenTK.Graphics.ES31.All pname, Int32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a parameter for a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to modify.
        /// </param>
        /// <param name="value">
        /// Specifies the new value of the parameter specified by pname for program.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramParameteri")]
        [CLSCompliant(false)]
        public static void ProgramParameter(UInt32 program, OpenTK.Graphics.ES31.All pname, Int32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1f")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(Int32 program, Int32 location, Single v0) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1f")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(UInt32 program, Int32 location, Single v0) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1i")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(Int32 program, Int32 location, Int32 v0) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1i")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(UInt32 program, Int32 location, Int32 v0) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Int32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1iv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Int32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1iv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1ui")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(UInt32 program, Int32 location, UInt32 v0) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1uiv")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1uiv")]
        [CLSCompliant(false)]
        public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref UInt32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform1uiv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2f")]
        [CLSCompliant(false)]
        public static void ProgramUniform2(Int32 program, Int32 location, Single v0, Single v1) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2f")]
        [CLSCompliant(false)]
        public static void ProgramUniform2(UInt32 program, Int32 location, Single v0, Single v1) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform2(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform2(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform2(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2i")]
        [CLSCompliant(false)]
        public static void ProgramUniform2(Int32 program, Int32 location, Int32 v0, Int32 v1) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2i")]
        [CLSCompliant(false)]
        public static void ProgramUniform2(UInt32 program, Int32 location, Int32 v0, Int32 v1) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform2(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2iv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform2(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2iv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2ui")]
        [CLSCompliant(false)]
        public static void ProgramUniform2(UInt32 program, Int32 location, UInt32 v0, UInt32 v1) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2uiv")]
        [CLSCompliant(false)]
        public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2uiv")]
        [CLSCompliant(false)]
        public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] ref UInt32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform2uiv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3f")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(Int32 program, Int32 location, Single v0, Single v1, Single v2) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3f")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(UInt32 program, Int32 location, Single v0, Single v1, Single v2) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3i")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(Int32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3i")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(UInt32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref Int32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3iv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref Int32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3iv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3ui")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(UInt32 program, Int32 location, UInt32 v0, UInt32 v1, UInt32 v2) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3uiv")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3uiv")]
        [CLSCompliant(false)]
        public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref UInt32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform3uiv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v3">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4f")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(Int32 program, Int32 location, Single v0, Single v1, Single v2, Single v3) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v3">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4f")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(UInt32 program, Int32 location, Single v0, Single v1, Single v2, Single v3) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v3">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4i")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(Int32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v3">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4i")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(UInt32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref Int32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4iv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4iv")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref Int32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4iv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v3">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4ui")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(UInt32 program, Int32 location, UInt32 v0, UInt32 v1, UInt32 v2, UInt32 v3) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4uiv")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4uiv")]
        [CLSCompliant(false)]
        public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref UInt32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the value of a uniform variable for a specified program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniform4uiv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2x3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix2x3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2x3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix2x3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2x3fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix2x3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2x3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix2x3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2x3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix2x3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2x3fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix2x3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2x4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix2x4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2x4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix2x4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2x4fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix2x4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2x4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix2x4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2x4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix2x4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix2x4fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix2x4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*9]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*9]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*9]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*9]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*9]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*9]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3x2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix3x2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3x2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix3x2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3x2fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix3x2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3x2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix3x2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3x2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix3x2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3x2fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix3x2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3x4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix3x4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3x4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix3x4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3x4fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix3x4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3x4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix3x4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3x4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix3x4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix3x4fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix3x4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*16]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*16]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*16]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*16]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*16]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*16]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4x2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix4x2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4x2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix4x2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4x2fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix4x2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4x2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix4x2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4x2fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix4x2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4x2fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix4x2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4x3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix4x3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4x3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix4x3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4x3fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix4x3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4x3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix4x3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4x3fv")]
        [CLSCompliant(false)]
        public static void ProgramUniformMatrix4x3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="program"></param>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glProgramUniformMatrix4x3fv")]
        [CLSCompliant(false)]
        public static unsafe void ProgramUniformMatrix4x3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value) { throw new NotImplementedException(); }

        /// <summary>
        /// Push a named debug group into the command stream
        /// </summary>
        /// <param name="source">
        /// The source of the debug message.
        /// </param>
        /// <param name="id">
        /// The identifier of the message.
        /// </param>
        /// <param name="length">
        /// The length of the message to be sent to the debug output stream.
        /// </param>
        /// <param name="message">[length: COMPSIZE(message,length)]
        /// The a string containing the message to be sent to the debug output stream.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glPushDebugGroup")]
        [CLSCompliant(false)]
        public static void PushDebugGroup(OpenTK.Graphics.ES31.All source, Int32 id, Int32 length, [CountAttribute(Computed = "message,length")] String message) { throw new NotImplementedException(); }

        /// <summary>
        /// Push a named debug group into the command stream
        /// </summary>
        /// <param name="source">
        /// The source of the debug message.
        /// </param>
        /// <param name="id">
        /// The identifier of the message.
        /// </param>
        /// <param name="length">
        /// The length of the message to be sent to the debug output stream.
        /// </param>
        /// <param name="message">[length: COMPSIZE(message,length)]
        /// The a string containing the message to be sent to the debug output stream.
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glPushDebugGroup")]
        [CLSCompliant(false)]
        public static void PushDebugGroup(OpenTK.Graphics.ES31.All source, UInt32 id, Int32 length, [CountAttribute(Computed = "message,length")] String message) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Select a color buffer source for pixels
        /// </summary>
        /// <param name="src">
        /// Specifies a color buffer. Accepted values are Back, None, and ColorAttachmenti.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glReadBuffer")]
        public static void ReadBuffer(OpenTK.Graphics.ES31.All src) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Select a color buffer source for pixels
        /// </summary>
        /// <param name="src">
        /// Specifies a color buffer. Accepted values are Back, None, and ColorAttachmenti.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glReadBuffer")]
        public static void ReadBuffer(OpenTK.Graphics.ES31.ReadBufferMode src) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        /// <param name="format"></param>
        /// <param name="type"></param>
        /// <param name="bufSize"></param>
        /// <param name="data"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixels")]
        public static void ReadnPixels(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [OutAttribute] IntPtr data) { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        /// <param name="format"></param>
        /// <param name="type"></param>
        /// <param name="bufSize"></param>
        /// <param name="data"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixels")]
        [CLSCompliant(false)]
        public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [InAttribute, OutAttribute] T7[] data)
            where T7 : struct
         { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        /// <param name="format"></param>
        /// <param name="type"></param>
        /// <param name="bufSize"></param>
        /// <param name="data"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixels")]
        [CLSCompliant(false)]
        public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [InAttribute, OutAttribute] T7[,] data)
            where T7 : struct
         { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        /// <param name="format"></param>
        /// <param name="type"></param>
        /// <param name="bufSize"></param>
        /// <param name="data"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixels")]
        [CLSCompliant(false)]
        public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [InAttribute, OutAttribute] T7[,,] data)
            where T7 : struct
         { throw new NotImplementedException(); }

        /// <summary></summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        /// <param name="format"></param>
        /// <param name="type"></param>
        /// <param name="bufSize"></param>
        /// <param name="data"></param>
        [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixels")]
        public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [InAttribute, OutAttribute] ref T7 data)
            where T7 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="width">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="height">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Rgba, and RgbaInteger. An implementation-chosen format will also be accepted. This can be queried with glGet and ImplementationColorReadFormat.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. Must be one of UnsignedByte, UnsignedInt, Int, or Float. An implementation-chosen type will also be accepted. This can be queried with glGet and ImplementationColorReadType.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Returns the pixel data.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static void ReadPixels(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [OutAttribute, CountAttribute(Computed = "format,type,width,height")] IntPtr pixels) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="width">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="height">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Rgba, and RgbaInteger. An implementation-chosen format will also be accepted. This can be queried with glGet and ImplementationColorReadFormat.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. Must be one of UnsignedByte, UnsignedInt, Int, or Float. An implementation-chosen type will also be accepted. This can be queried with glGet and ImplementationColorReadType.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Returns the pixel data.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        [CLSCompliant(false)]
        public static void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T6[] pixels)
            where T6 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="width">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="height">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Rgba, and RgbaInteger. An implementation-chosen format will also be accepted. This can be queried with glGet and ImplementationColorReadFormat.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. Must be one of UnsignedByte, UnsignedInt, Int, or Float. An implementation-chosen type will also be accepted. This can be queried with glGet and ImplementationColorReadType.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Returns the pixel data.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        [CLSCompliant(false)]
        public static void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T6[,] pixels)
            where T6 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="width">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="height">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Rgba, and RgbaInteger. An implementation-chosen format will also be accepted. This can be queried with glGet and ImplementationColorReadFormat.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. Must be one of UnsignedByte, UnsignedInt, Int, or Float. An implementation-chosen type will also be accepted. This can be queried with glGet and ImplementationColorReadType.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Returns the pixel data.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        [CLSCompliant(false)]
        public static void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T6[,,] pixels)
            where T6 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="width">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="height">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Rgba, and RgbaInteger. An implementation-chosen format will also be accepted. This can be queried with glGet and ImplementationColorReadFormat.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. Must be one of UnsignedByte, UnsignedInt, Int, or Float. An implementation-chosen type will also be accepted. This can be queried with glGet and ImplementationColorReadType.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Returns the pixel data.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] ref T6 pixels)
            where T6 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="width">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="height">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Rgba, and RgbaInteger. An implementation-chosen format will also be accepted. This can be queried with glGet and ImplementationColorReadFormat.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. Must be one of UnsignedByte, UnsignedInt, Int, or Float. An implementation-chosen type will also be accepted. This can be queried with glGet and ImplementationColorReadType.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Returns the pixel data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static void ReadPixels(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [OutAttribute, CountAttribute(Computed = "format,type,width,height")] IntPtr pixels) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="width">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="height">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Rgba, and RgbaInteger. An implementation-chosen format will also be accepted. This can be queried with glGet and ImplementationColorReadFormat.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. Must be one of UnsignedByte, UnsignedInt, Int, or Float. An implementation-chosen type will also be accepted. This can be queried with glGet and ImplementationColorReadType.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Returns the pixel data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        [CLSCompliant(false)]
        public static void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T6[] pixels)
            where T6 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="width">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="height">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Rgba, and RgbaInteger. An implementation-chosen format will also be accepted. This can be queried with glGet and ImplementationColorReadFormat.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. Must be one of UnsignedByte, UnsignedInt, Int, or Float. An implementation-chosen type will also be accepted. This can be queried with glGet and ImplementationColorReadType.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Returns the pixel data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        [CLSCompliant(false)]
        public static void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T6[,] pixels)
            where T6 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="width">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="height">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Rgba, and RgbaInteger. An implementation-chosen format will also be accepted. This can be queried with glGet and ImplementationColorReadFormat.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. Must be one of UnsignedByte, UnsignedInt, Int, or Float. An implementation-chosen type will also be accepted. This can be queried with glGet and ImplementationColorReadType.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Returns the pixel data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        [CLSCompliant(false)]
        public static void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T6[,,] pixels)
            where T6 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="width">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="height">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Rgba, and RgbaInteger. An implementation-chosen format will also be accepted. This can be queried with glGet and ImplementationColorReadFormat.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. Must be one of UnsignedByte, UnsignedInt, Int, or Float. An implementation-chosen type will also be accepted. This can be queried with glGet and ImplementationColorReadType.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Returns the pixel data.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] ref T6 pixels)
            where T6 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Release resources consumed by the implementation's shader compiler
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReleaseShaderCompiler")]
        public static void ReleaseShaderCompiler() { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Establish data storage, format and dimensions of a renderbuffer object's image
        /// </summary>
        /// <param name="target">
        /// Specifies a binding to which the target of the allocation and must be Renderbuffer.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format to use for the renderbuffer object's image.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the renderbuffer, in pixels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the renderbuffer, in pixels.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glRenderbufferStorage")]
        public static void RenderbufferStorage(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Establish data storage, format and dimensions of a renderbuffer object's image
        /// </summary>
        /// <param name="target">
        /// Specifies a binding to which the target of the allocation and must be Renderbuffer.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format to use for the renderbuffer object's image.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the renderbuffer, in pixels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the renderbuffer, in pixels.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glRenderbufferStorage")]
        public static void RenderbufferStorage(OpenTK.Graphics.ES31.RenderbufferTarget target, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
        /// </summary>
        /// <param name="target">
        /// Specifies a binding to which the target of the allocation and must be Renderbuffer.
        /// </param>
        /// <param name="samples">
        /// Specifies the number of samples to be used for the renderbuffer object's storage.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format to use for the renderbuffer object's image.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the renderbuffer, in pixels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the renderbuffer, in pixels.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glRenderbufferStorageMultisample")]
        public static void RenderbufferStorageMultisample(OpenTK.Graphics.ES31.All target, Int32 samples, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Resume transform feedback operations
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glResumeTransformFeedback")]
        public static void ResumeTransformFeedback() { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify multisample coverage parameters
        /// </summary>
        /// <param name="value">
        /// Specify a single floating-point sample coverage value.  The value is clamped to the range [0 ,1]. The initial value is 1.0.
        /// </param>
        /// <param name="invert">
        /// Specify a single boolean value representing if the coverage masks should be inverted.  True and False are accepted.  The initial value is False.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glSampleCoverage")]
        public static void SampleCoverage(Single value, bool invert) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Set the value of a sub-word of the sample mask
        /// </summary>
        /// <param name="maskNumber">
        /// Specifies which 32-bit sub-word of the sample mask to update.
        /// </param>
        /// <param name="mask">
        /// Specifies the new value of the mask sub-word.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glSampleMaski")]
        [CLSCompliant(false)]
        public static void SampleMask(Int32 maskNumber, Int32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Set the value of a sub-word of the sample mask
        /// </summary>
        /// <param name="maskNumber">
        /// Specifies which 32-bit sub-word of the sample mask to update.
        /// </param>
        /// <param name="mask">
        /// Specifies the new value of the mask sub-word.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glSampleMaski")]
        [CLSCompliant(false)]
        public static void SampleMask(UInt32 maskNumber, UInt32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: TextureWrapS, TextureWrapT, TextureWrapR, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureCompareMode, or TextureCompareFunc.
        /// </param>
        /// <param name="param">
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterf")]
        [CLSCompliant(false)]
        public static void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES31.All pname, Single param) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: TextureWrapS, TextureWrapT, TextureWrapR, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureCompareMode, or TextureCompareFunc.
        /// </param>
        /// <param name="param">
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterf")]
        [CLSCompliant(false)]
        public static void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES31.All pname, Single param) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: TextureWrapS, TextureWrapT, TextureWrapR, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureCompareMode, or TextureCompareFunc.
        /// </param>
        /// <param name="param">[length: COMPSIZE(pname)]
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterfv")]
        [CLSCompliant(false)]
        public static void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Single[] param) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: TextureWrapS, TextureWrapT, TextureWrapR, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureCompareMode, or TextureCompareFunc.
        /// </param>
        /// <param name="param">[length: COMPSIZE(pname)]
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterfv")]
        [CLSCompliant(false)]
        public static unsafe void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Single* param) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: TextureWrapS, TextureWrapT, TextureWrapR, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureCompareMode, or TextureCompareFunc.
        /// </param>
        /// <param name="param">[length: COMPSIZE(pname)]
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterfv")]
        [CLSCompliant(false)]
        public static void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Single[] param) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: TextureWrapS, TextureWrapT, TextureWrapR, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureCompareMode, or TextureCompareFunc.
        /// </param>
        /// <param name="param">[length: COMPSIZE(pname)]
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterfv")]
        [CLSCompliant(false)]
        public static unsafe void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Single* param) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: TextureWrapS, TextureWrapT, TextureWrapR, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureCompareMode, or TextureCompareFunc.
        /// </param>
        /// <param name="param">
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteri")]
        [CLSCompliant(false)]
        public static void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES31.All pname, Int32 param) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: TextureWrapS, TextureWrapT, TextureWrapR, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureCompareMode, or TextureCompareFunc.
        /// </param>
        /// <param name="param">
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteri")]
        [CLSCompliant(false)]
        public static void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES31.All pname, Int32 param) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: TextureWrapS, TextureWrapT, TextureWrapR, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureCompareMode, or TextureCompareFunc.
        /// </param>
        /// <param name="param">[length: COMPSIZE(pname)]
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteriv")]
        [CLSCompliant(false)]
        public static void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32[] param) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: TextureWrapS, TextureWrapT, TextureWrapR, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureCompareMode, or TextureCompareFunc.
        /// </param>
        /// <param name="param">[length: COMPSIZE(pname)]
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32* param) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: TextureWrapS, TextureWrapT, TextureWrapR, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureCompareMode, or TextureCompareFunc.
        /// </param>
        /// <param name="param">[length: COMPSIZE(pname)]
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteriv")]
        [CLSCompliant(false)]
        public static void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32[] param) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: TextureWrapS, TextureWrapT, TextureWrapR, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureCompareMode, or TextureCompareFunc.
        /// </param>
        /// <param name="param">[length: COMPSIZE(pname)]
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32* param) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define the scissor box
        /// </summary>
        /// <param name="x">
        /// Specify the lower left corner of the scissor box. Initially (0, 0).
        /// </param>
        /// <param name="y">
        /// Specify the lower left corner of the scissor box. Initially (0, 0).
        /// </param>
        /// <param name="width">
        /// Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
        /// </param>
        /// <param name="height">
        /// Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glScissor")]
        public static void Scissor(Int32 x, Int32 y, Int32 width, Int32 height) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary(Int32 count, [CountAttribute(Parameter = "count")] Int32[] shaders, OpenTK.Graphics.ES31.All binaryformat, [CountAttribute(Parameter = "length")] IntPtr binary, Int32 length) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] Int32[] shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] Int32[] shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] Int32[] shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,,] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] Int32[] shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] ref T3 binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary(Int32 count, [CountAttribute(Parameter = "count")] ref Int32 shaders, OpenTK.Graphics.ES31.All binaryformat, [CountAttribute(Parameter = "length")] IntPtr binary, Int32 length) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] ref Int32 shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] ref Int32 shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] ref Int32 shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,,] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] ref Int32 shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] ref T3 binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static unsafe void ShaderBinary(Int32 count, [CountAttribute(Parameter = "count")] Int32* shaders, OpenTK.Graphics.ES31.All binaryformat, [CountAttribute(Parameter = "length")] IntPtr binary, Int32 length) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static unsafe void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] Int32* shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static unsafe void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] Int32* shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static unsafe void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] Int32* shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,,] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static unsafe void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] Int32* shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] ref T3 binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary(Int32 count, [CountAttribute(Parameter = "count")] UInt32[] shaders, OpenTK.Graphics.ES31.All binaryformat, [CountAttribute(Parameter = "length")] IntPtr binary, Int32 length) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] UInt32[] shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] UInt32[] shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] UInt32[] shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,,] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] UInt32[] shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] ref T3 binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary(Int32 count, [CountAttribute(Parameter = "count")] ref UInt32 shaders, OpenTK.Graphics.ES31.All binaryformat, [CountAttribute(Parameter = "length")] IntPtr binary, Int32 length) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] ref UInt32 shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] ref UInt32 shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] ref UInt32 shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,,] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] ref UInt32 shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] ref T3 binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static unsafe void ShaderBinary(Int32 count, [CountAttribute(Parameter = "count")] UInt32* shaders, OpenTK.Graphics.ES31.All binaryformat, [CountAttribute(Parameter = "length")] IntPtr binary, Int32 length) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static unsafe void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] UInt32* shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static unsafe void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] UInt32* shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static unsafe void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] UInt32* shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,,] binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">[length: count]
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">[length: length]
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        [CLSCompliant(false)]
        public static unsafe void ShaderBinary<T3>(Int32 count, [CountAttribute(Parameter = "count")] UInt32* shaders, OpenTK.Graphics.ES31.All binaryformat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] ref T3 binary, Int32 length)
            where T3 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Replaces the source code in a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements in the string and length arrays.
        /// </param>
        /// <param name="@string">[length: count]
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        /// <param name="length">[length: count]
        /// Specifies an array of string lengths.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderSource")]
        [CLSCompliant(false)]
        public static void ShaderSource(Int32 shader, Int32 count, [CountAttribute(Parameter = "count")] String[] @string, [CountAttribute(Parameter = "count")] Int32[] length) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Replaces the source code in a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements in the string and length arrays.
        /// </param>
        /// <param name="@string">[length: count]
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        /// <param name="length">[length: count]
        /// Specifies an array of string lengths.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderSource")]
        [CLSCompliant(false)]
        public static void ShaderSource(Int32 shader, Int32 count, [CountAttribute(Parameter = "count")] String[] @string, [CountAttribute(Parameter = "count")] ref Int32 length) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Replaces the source code in a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements in the string and length arrays.
        /// </param>
        /// <param name="@string">[length: count]
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        /// <param name="length">[length: count]
        /// Specifies an array of string lengths.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderSource")]
        [CLSCompliant(false)]
        public static unsafe void ShaderSource(Int32 shader, Int32 count, [CountAttribute(Parameter = "count")] String[] @string, [CountAttribute(Parameter = "count")] Int32* length) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Replaces the source code in a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements in the string and length arrays.
        /// </param>
        /// <param name="@string">[length: count]
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        /// <param name="length">[length: count]
        /// Specifies an array of string lengths.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderSource")]
        [CLSCompliant(false)]
        public static void ShaderSource(UInt32 shader, Int32 count, [CountAttribute(Parameter = "count")] String[] @string, [CountAttribute(Parameter = "count")] Int32[] length) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Replaces the source code in a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements in the string and length arrays.
        /// </param>
        /// <param name="@string">[length: count]
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        /// <param name="length">[length: count]
        /// Specifies an array of string lengths.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderSource")]
        [CLSCompliant(false)]
        public static void ShaderSource(UInt32 shader, Int32 count, [CountAttribute(Parameter = "count")] String[] @string, [CountAttribute(Parameter = "count")] ref Int32 length) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Replaces the source code in a shader object
        /// </summary>
        /// <param name="shader">
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements in the string and length arrays.
        /// </param>
        /// <param name="@string">[length: count]
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        /// <param name="length">[length: count]
        /// Specifies an array of string lengths.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderSource")]
        [CLSCompliant(false)]
        public static unsafe void ShaderSource(UInt32 shader, Int32 count, [CountAttribute(Parameter = "count")] String[] @string, [CountAttribute(Parameter = "count")] Int32* length) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set front and back function and reference value for stencil testing
        /// </summary>
        /// <param name="func">
        /// Specifies the test function. Eight symbolic constants are valid: Never, Less, Lequal, Greater, Gequal, Equal, Notequal, and Always. The initial value is Always.
        /// </param>
        /// <param name="@ref">
        /// Specifies the reference value for the stencil test. Stencil comparison operations and queries of ref clamp its value to the range [0, 2 sup n - 1], where  is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </param>
        /// <param name="mask">
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFunc")]
        [CLSCompliant(false)]
        public static void StencilFunc(OpenTK.Graphics.ES31.All func, Int32 @ref, Int32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set front and back function and reference value for stencil testing
        /// </summary>
        /// <param name="func">
        /// Specifies the test function. Eight symbolic constants are valid: Never, Less, Lequal, Greater, Gequal, Equal, Notequal, and Always. The initial value is Always.
        /// </param>
        /// <param name="@ref">
        /// Specifies the reference value for the stencil test. Stencil comparison operations and queries of ref clamp its value to the range [0, 2 sup n - 1], where  is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </param>
        /// <param name="mask">
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFunc")]
        [CLSCompliant(false)]
        public static void StencilFunc(OpenTK.Graphics.ES31.All func, Int32 @ref, UInt32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set front and back function and reference value for stencil testing
        /// </summary>
        /// <param name="func">
        /// Specifies the test function. Eight symbolic constants are valid: Never, Less, Lequal, Greater, Gequal, Equal, Notequal, and Always. The initial value is Always.
        /// </param>
        /// <param name="@ref">
        /// Specifies the reference value for the stencil test. Stencil comparison operations and queries of ref clamp its value to the range [0, 2 sup n - 1], where  is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </param>
        /// <param name="mask">
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFunc")]
        [CLSCompliant(false)]
        public static void StencilFunc(OpenTK.Graphics.ES31.StencilFunction func, Int32 @ref, Int32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set front and back function and reference value for stencil testing
        /// </summary>
        /// <param name="func">
        /// Specifies the test function. Eight symbolic constants are valid: Never, Less, Lequal, Greater, Gequal, Equal, Notequal, and Always. The initial value is Always.
        /// </param>
        /// <param name="@ref">
        /// Specifies the reference value for the stencil test. Stencil comparison operations and queries of ref clamp its value to the range [0, 2 sup n - 1], where  is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </param>
        /// <param name="mask">
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFunc")]
        [CLSCompliant(false)]
        public static void StencilFunc(OpenTK.Graphics.ES31.StencilFunction func, Int32 @ref, UInt32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set front and/or back function and reference value for stencil testing
        /// </summary>
        /// <param name="face">
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: Front, Back, and FrontAndBack.
        /// </param>
        /// <param name="func">
        /// Specifies the test function. Eight symbolic constants are valid: Never, Less, Lequal, Greater, Gequal, Equal, Notequal, and Always. The initial value is Always.
        /// </param>
        /// <param name="@ref">
        /// Specifies the reference value for the stencil test. Stencil comparison operations and queries of ref clamp its value to the range [0, 2 sup n - 1], where  is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </param>
        /// <param name="mask">
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFuncSeparate")]
        [CLSCompliant(false)]
        public static void StencilFuncSeparate(OpenTK.Graphics.ES31.All face, OpenTK.Graphics.ES31.All func, Int32 @ref, Int32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set front and/or back function and reference value for stencil testing
        /// </summary>
        /// <param name="face">
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: Front, Back, and FrontAndBack.
        /// </param>
        /// <param name="func">
        /// Specifies the test function. Eight symbolic constants are valid: Never, Less, Lequal, Greater, Gequal, Equal, Notequal, and Always. The initial value is Always.
        /// </param>
        /// <param name="@ref">
        /// Specifies the reference value for the stencil test. Stencil comparison operations and queries of ref clamp its value to the range [0, 2 sup n - 1], where  is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </param>
        /// <param name="mask">
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFuncSeparate")]
        [CLSCompliant(false)]
        public static void StencilFuncSeparate(OpenTK.Graphics.ES31.All face, OpenTK.Graphics.ES31.All func, Int32 @ref, UInt32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set front and/or back function and reference value for stencil testing
        /// </summary>
        /// <param name="face">
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: Front, Back, and FrontAndBack.
        /// </param>
        /// <param name="func">
        /// Specifies the test function. Eight symbolic constants are valid: Never, Less, Lequal, Greater, Gequal, Equal, Notequal, and Always. The initial value is Always.
        /// </param>
        /// <param name="@ref">
        /// Specifies the reference value for the stencil test. Stencil comparison operations and queries of ref clamp its value to the range [0, 2 sup n - 1], where  is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </param>
        /// <param name="mask">
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFuncSeparate")]
        [CLSCompliant(false)]
        public static void StencilFuncSeparate(OpenTK.Graphics.ES31.StencilFaceDirection face, OpenTK.Graphics.ES31.StencilFunction func, Int32 @ref, Int32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set front and/or back function and reference value for stencil testing
        /// </summary>
        /// <param name="face">
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: Front, Back, and FrontAndBack.
        /// </param>
        /// <param name="func">
        /// Specifies the test function. Eight symbolic constants are valid: Never, Less, Lequal, Greater, Gequal, Equal, Notequal, and Always. The initial value is Always.
        /// </param>
        /// <param name="@ref">
        /// Specifies the reference value for the stencil test. Stencil comparison operations and queries of ref clamp its value to the range [0, 2 sup n - 1], where  is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </param>
        /// <param name="mask">
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFuncSeparate")]
        [CLSCompliant(false)]
        public static void StencilFuncSeparate(OpenTK.Graphics.ES31.StencilFaceDirection face, OpenTK.Graphics.ES31.StencilFunction func, Int32 @ref, UInt32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Control the front and back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="mask">
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilMask")]
        [CLSCompliant(false)]
        public static void StencilMask(Int32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Control the front and back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="mask">
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilMask")]
        [CLSCompliant(false)]
        public static void StencilMask(UInt32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Control the front and/or back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="face">
        /// Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: Front, Back, and FrontAndBack.
        /// </param>
        /// <param name="mask">
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilMaskSeparate")]
        [CLSCompliant(false)]
        public static void StencilMaskSeparate(OpenTK.Graphics.ES31.All face, Int32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Control the front and/or back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="face">
        /// Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: Front, Back, and FrontAndBack.
        /// </param>
        /// <param name="mask">
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilMaskSeparate")]
        [CLSCompliant(false)]
        public static void StencilMaskSeparate(OpenTK.Graphics.ES31.All face, UInt32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Control the front and/or back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="face">
        /// Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: Front, Back, and FrontAndBack.
        /// </param>
        /// <param name="mask">
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilMaskSeparate")]
        [CLSCompliant(false)]
        public static void StencilMaskSeparate(OpenTK.Graphics.ES31.StencilFaceDirection face, Int32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Control the front and/or back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="face">
        /// Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: Front, Back, and FrontAndBack.
        /// </param>
        /// <param name="mask">
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilMaskSeparate")]
        [CLSCompliant(false)]
        public static void StencilMaskSeparate(OpenTK.Graphics.ES31.StencilFaceDirection face, UInt32 mask) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set front and back stencil test actions
        /// </summary>
        /// <param name="fail">
        /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: Keep, Zero, Replace, Incr, IncrWrap, Decr, DecrWrap, and Invert. The initial value is Keep.
        /// </param>
        /// <param name="zfail">
        /// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is Keep.
        /// </param>
        /// <param name="zpass">
        /// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is Keep.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilOp")]
        public static void StencilOp(OpenTK.Graphics.ES31.All fail, OpenTK.Graphics.ES31.All zfail, OpenTK.Graphics.ES31.All zpass) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set front and back stencil test actions
        /// </summary>
        /// <param name="fail">
        /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: Keep, Zero, Replace, Incr, IncrWrap, Decr, DecrWrap, and Invert. The initial value is Keep.
        /// </param>
        /// <param name="zfail">
        /// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is Keep.
        /// </param>
        /// <param name="zpass">
        /// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is Keep.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilOp")]
        public static void StencilOp(OpenTK.Graphics.ES31.StencilOp fail, OpenTK.Graphics.ES31.StencilOp zfail, OpenTK.Graphics.ES31.StencilOp zpass) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set front and/or back stencil test actions
        /// </summary>
        /// <param name="face">
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: Front, Back, and FrontAndBack.
        /// </param>
        /// <param name="sfail">
        /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: Keep, Zero, Replace, Incr, IncrWrap, Decr, DecrWrap, and Invert. The initial value is Keep.
        /// </param>
        /// <param name="dpfail">
        /// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is Keep.
        /// </param>
        /// <param name="dppass">
        /// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is Keep.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilOpSeparate")]
        public static void StencilOpSeparate(OpenTK.Graphics.ES31.All face, OpenTK.Graphics.ES31.All sfail, OpenTK.Graphics.ES31.All dpfail, OpenTK.Graphics.ES31.All dppass) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set front and/or back stencil test actions
        /// </summary>
        /// <param name="face">
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: Front, Back, and FrontAndBack.
        /// </param>
        /// <param name="sfail">
        /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: Keep, Zero, Replace, Incr, IncrWrap, Decr, DecrWrap, and Invert. The initial value is Keep.
        /// </param>
        /// <param name="dpfail">
        /// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is Keep.
        /// </param>
        /// <param name="dppass">
        /// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is Keep.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilOpSeparate")]
        public static void StencilOpSeparate(OpenTK.Graphics.ES31.StencilFaceDirection face, OpenTK.Graphics.ES31.StencilOp sfail, OpenTK.Graphics.ES31.StencilOp dpfail, OpenTK.Graphics.ES31.StencilOp dppass) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static void TexImage2D(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "format,type,width,height")] IntPtr pixels) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        [CLSCompliant(false)]
        public static void TexImage2D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T8[] pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        [CLSCompliant(false)]
        public static void TexImage2D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T8[,] pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        [CLSCompliant(false)]
        public static void TexImage2D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T8[,,] pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static void TexImage2D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] ref T8 pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static void TexImage2D(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [CountAttribute(Computed = "format,type,width,height")] IntPtr pixels) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        [CLSCompliant(false)]
        public static void TexImage2D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T8[] pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        [CLSCompliant(false)]
        public static void TexImage2D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T8[,] pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        [CLSCompliant(false)]
        public static void TexImage2D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T8[,,] pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at least 2048 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support texture images that are at least 2048 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static void TexImage2D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] ref T8 pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static void TexImage3D(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "format,type,width,height,depth")] IntPtr pixels) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        [CLSCompliant(false)]
        public static void TexImage3D<T9>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T9[] pixels)
            where T9 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        [CLSCompliant(false)]
        public static void TexImage3D<T9>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T9[,] pixels)
            where T9 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        [CLSCompliant(false)]
        public static void TexImage3D<T9>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T9[,,] pixels)
            where T9 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static void TexImage3D<T9>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] ref T9 pixels)
            where T9 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static void TexImage3D(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [CountAttribute(Computed = "format,type,width,height,depth")] IntPtr pixels) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        [CLSCompliant(false)]
        public static void TexImage3D<T9>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T9[] pixels)
            where T9 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        [CLSCompliant(false)]
        public static void TexImage3D<T9>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T9[,] pixels)
            where T9 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        [CLSCompliant(false)]
        public static void TexImage3D<T9>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T9[,,] pixels)
            where T9 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static void TexImage3D<T9>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, OpenTK.Graphics.ES31.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] ref T9 pixels)
            where T9 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture, which must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureMaxLevel, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, or TextureWrapR.
        /// </param>
        /// <param name="param">
        /// Specifies the value of pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameterf")]
        public static void TexParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, Single param) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture, which must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureMaxLevel, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, or TextureWrapR.
        /// </param>
        /// <param name="param">
        /// Specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameterf")]
        public static void TexParameter(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, Single param) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture, which must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureMaxLevel, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, or TextureWrapR.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the value of pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameterfv")]
        [CLSCompliant(false)]
        public static void TexParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Single[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture, which must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureMaxLevel, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, or TextureWrapR.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the value of pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameterfv")]
        [CLSCompliant(false)]
        public static unsafe void TexParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Single* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture, which must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureMaxLevel, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, or TextureWrapR.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameterfv")]
        [CLSCompliant(false)]
        public static void TexParameter(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] Single[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture, which must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureMaxLevel, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, or TextureWrapR.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameterfv")]
        [CLSCompliant(false)]
        public static unsafe void TexParameter(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] Single* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture, which must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureMaxLevel, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, or TextureWrapR.
        /// </param>
        /// <param name="param">
        /// Specifies the value of pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameteri")]
        public static void TexParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, Int32 param) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture, which must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureMaxLevel, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, or TextureWrapR.
        /// </param>
        /// <param name="param">
        /// Specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameteri")]
        public static void TexParameter(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, Int32 param) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture, which must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureMaxLevel, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, or TextureWrapR.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the value of pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameteriv")]
        [CLSCompliant(false)]
        public static void TexParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture, which must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureMaxLevel, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, or TextureWrapR.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the value of pname.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void TexParameter(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture, which must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureMaxLevel, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, or TextureWrapR.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameteriv")]
        [CLSCompliant(false)]
        public static void TexParameter(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture, which must be either Texture2D, Texture3D, Texture2DArray, or TextureCubeMap.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: TextureBaseLevel, TextureCompareFunc, TextureCompareMode, TextureMinFilter, TextureMagFilter, TextureMinLod, TextureMaxLod, TextureMaxLevel, TextureSwizzleR, TextureSwizzleG, TextureSwizzleB, TextureSwizzleA, TextureWrapS, TextureWrapT, or TextureWrapR.
        /// </param>
        /// <param name="@params">[length: COMPSIZE(pname)]
        /// Specifies the value of pname.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameteriv")]
        [CLSCompliant(false)]
        public static unsafe void TexParameter(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Simultaneously specify storage for all levels of a two-dimensional texture
        /// </summary>
        /// <param name="target">
        /// Specify the target of the operation. target must be one of Texture2D, or TextureCubeMap.
        /// </param>
        /// <param name="levels">
        /// Specify the number of texture levels.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the sized internal format to be used to store texture image data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture, in texels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture, in texels.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexStorage2D")]
        public static void TexStorage2D(OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify storage for a two-dimensional multisample texture
        /// </summary>
        /// <param name="target">
        /// Specify the target of the operation. target must be Texture2DMultisample.
        /// </param>
        /// <param name="samples">
        /// Specify the number of samples in the texture.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the sized internal format to be used to store texture image data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture, in texels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture, in texels.
        /// </param>
        /// <param name="fixedsamplelocations">
        /// Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glTexStorage2DMultisample")]
        public static void TexStorage2DMultisample(OpenTK.Graphics.ES31.All target, Int32 samples, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, bool fixedsamplelocations) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Simultaneously specify storage for all levels of a three-dimensional or two-dimensional array texture
        /// </summary>
        /// <param name="target">
        /// Specify the target of the operation. target must be one of Texture3D, or Texture2DArray.
        /// </param>
        /// <param name="levels">
        /// Specify the number of texture levels.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the sized internal format to be used to store texture image data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture, in texels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture, in texels.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture, in texels.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexStorage3D")]
        public static void TexStorage3D(OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static void TexSubImage2D(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "format,type,width,height")] IntPtr pixels) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        [CLSCompliant(false)]
        public static void TexSubImage2D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T8[] pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        [CLSCompliant(false)]
        public static void TexSubImage2D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T8[,] pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        [CLSCompliant(false)]
        public static void TexSubImage2D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T8[,,] pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static void TexSubImage2D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] ref T8 pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static void TexSubImage2D(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [CountAttribute(Computed = "format,type,width,height")] IntPtr pixels) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        [CLSCompliant(false)]
        public static void TexSubImage2D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T8[] pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        [CLSCompliant(false)]
        public static void TexSubImage2D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T8[,] pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        [CLSCompliant(false)]
        public static void TexSubImage2D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] T8[,,] pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture2D, TextureCubeMapPositiveX, TextureCubeMapNegativeX, TextureCubeMapPositiveY, TextureCubeMapNegativeY, TextureCubeMapPositiveZ, or TextureCubeMapNegativeZ.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static void TexSubImage2D<T8>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height")] ref T8 pixels)
            where T8 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static void TexSubImage3D(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "format,type,width,height,depth")] IntPtr pixels) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        [CLSCompliant(false)]
        public static void TexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T10[] pixels)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        [CLSCompliant(false)]
        public static void TexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T10[,] pixels)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        [CLSCompliant(false)]
        public static void TexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T10[,,] pixels)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static void TexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] ref T10 pixels)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static void TexSubImage3D(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [CountAttribute(Computed = "format,type,width,height,depth")] IntPtr pixels) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        [CLSCompliant(false)]
        public static void TexSubImage3D<T10>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T10[] pixels)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        [CLSCompliant(false)]
        public static void TexSubImage3D<T10>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T10[,] pixels)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        [CLSCompliant(false)]
        public static void TexSubImage3D<T10>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T10[,,] pixels)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be Texture3D or Texture2DArray.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
        /// </param>
        /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
        /// Specifies a pointer to the image data in memory.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static void TexSubImage3D<T10>(OpenTK.Graphics.ES31.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] ref T10 pixels)
            where T10 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify values to record in transform feedback buffers
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="count">
        /// The number of varying variables used for transform feedback.
        /// </param>
        /// <param name="varyings">[length: count]
        /// An array of count zero-terminated strings specifying the names of the varying variables to use for transform feedback.
        /// </param>
        /// <param name="bufferMode">
        /// Identifies the mode used to capture the varying variables when transform feedback is active. bufferMode must be InterleavedAttribs or SeparateAttribs.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTransformFeedbackVaryings")]
        [CLSCompliant(false)]
        public static void TransformFeedbackVaryings(Int32 program, Int32 count, [CountAttribute(Parameter = "count")] String[] varyings, OpenTK.Graphics.ES31.All bufferMode) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify values to record in transform feedback buffers
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="count">
        /// The number of varying variables used for transform feedback.
        /// </param>
        /// <param name="varyings">[length: count]
        /// An array of count zero-terminated strings specifying the names of the varying variables to use for transform feedback.
        /// </param>
        /// <param name="bufferMode">
        /// Identifies the mode used to capture the varying variables when transform feedback is active. bufferMode must be InterleavedAttribs or SeparateAttribs.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTransformFeedbackVaryings")]
        [CLSCompliant(false)]
        public static void TransformFeedbackVaryings(UInt32 program, Int32 count, [CountAttribute(Parameter = "count")] String[] varyings, OpenTK.Graphics.ES31.All bufferMode) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1f")]
        public static void Uniform1(Int32 location, Single v0) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*1]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1fv")]
        [CLSCompliant(false)]
        public static void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*1]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1fv")]
        [CLSCompliant(false)]
        public static void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*1]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1fv")]
        [CLSCompliant(false)]
        public static unsafe void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1i")]
        public static void Uniform1(Int32 location, Int32 v0) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*1]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1iv")]
        [CLSCompliant(false)]
        public static void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] Int32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*1]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1iv")]
        [CLSCompliant(false)]
        public static void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] ref Int32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*1]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1iv")]
        [CLSCompliant(false)]
        public static unsafe void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] Int32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform1ui")]
        [CLSCompliant(false)]
        public static void Uniform1(Int32 location, UInt32 v0) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*1]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform1uiv")]
        [CLSCompliant(false)]
        public static void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] UInt32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*1]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform1uiv")]
        [CLSCompliant(false)]
        public static void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] ref UInt32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*1]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform1uiv")]
        [CLSCompliant(false)]
        public static unsafe void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] UInt32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2f")]
        public static void Uniform2(Int32 location, Single v0, Single v1) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2fv")]
        [CLSCompliant(false)]
        public static void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2fv")]
        [CLSCompliant(false)]
        public static void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2fv")]
        [CLSCompliant(false)]
        public static unsafe void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2i")]
        public static void Uniform2(Int32 location, Int32 v0, Int32 v1) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2iv")]
        [CLSCompliant(false)]
        public static void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2iv")]
        [CLSCompliant(false)]
        public static unsafe void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform2ui")]
        [CLSCompliant(false)]
        public static void Uniform2(Int32 location, UInt32 v0, UInt32 v1) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform2uiv")]
        [CLSCompliant(false)]
        public static void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform2uiv")]
        [CLSCompliant(false)]
        public static void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] ref UInt32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*2]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform2uiv")]
        [CLSCompliant(false)]
        public static unsafe void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3f")]
        public static void Uniform3(Int32 location, Single v0, Single v1, Single v2) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3fv")]
        [CLSCompliant(false)]
        public static void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3fv")]
        [CLSCompliant(false)]
        public static void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3fv")]
        [CLSCompliant(false)]
        public static unsafe void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3i")]
        public static void Uniform3(Int32 location, Int32 v0, Int32 v1, Int32 v2) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3iv")]
        [CLSCompliant(false)]
        public static void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3iv")]
        [CLSCompliant(false)]
        public static void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref Int32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3iv")]
        [CLSCompliant(false)]
        public static unsafe void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform3ui")]
        [CLSCompliant(false)]
        public static void Uniform3(Int32 location, UInt32 v0, UInt32 v1, UInt32 v2) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform3uiv")]
        [CLSCompliant(false)]
        public static void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform3uiv")]
        [CLSCompliant(false)]
        public static void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref UInt32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*3]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform3uiv")]
        [CLSCompliant(false)]
        public static unsafe void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v3">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4f")]
        public static void Uniform4(Int32 location, Single v0, Single v1, Single v2, Single v3) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4fv")]
        [CLSCompliant(false)]
        public static void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4fv")]
        [CLSCompliant(false)]
        public static void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4fv")]
        [CLSCompliant(false)]
        public static unsafe void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v3">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4i")]
        public static void Uniform4(Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4iv")]
        [CLSCompliant(false)]
        public static void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4iv")]
        [CLSCompliant(false)]
        public static void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref Int32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4iv")]
        [CLSCompliant(false)]
        public static unsafe void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v1">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v2">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        /// <param name="v3">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform4ui")]
        [CLSCompliant(false)]
        public static void Uniform4(Int32 location, UInt32 v0, UInt32 v1, UInt32 v2, UInt32 v3) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform4uiv")]
        [CLSCompliant(false)]
        public static void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt32[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform4uiv")]
        [CLSCompliant(false)]
        public static void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref UInt32 value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="count">
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </param>
        /// <param name="value">[length: count*4]
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform4uiv")]
        [CLSCompliant(false)]
        public static unsafe void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt32* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Assign a binding point to an active uniform block
        /// </summary>
        /// <param name="program">
        /// The name of a program object containing the active uniform block whose binding to assign.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// The index of the active uniform block within program whose binding to assign.
        /// </param>
        /// <param name="uniformBlockBinding">
        /// Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformBlockBinding")]
        [CLSCompliant(false)]
        public static void UniformBlockBinding(Int32 program, Int32 uniformBlockIndex, Int32 uniformBlockBinding) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Assign a binding point to an active uniform block
        /// </summary>
        /// <param name="program">
        /// The name of a program object containing the active uniform block whose binding to assign.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// The index of the active uniform block within program whose binding to assign.
        /// </param>
        /// <param name="uniformBlockBinding">
        /// Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformBlockBinding")]
        [CLSCompliant(false)]
        public static void UniformBlockBinding(UInt32 program, UInt32 uniformBlockIndex, UInt32 uniformBlockBinding) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*4]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix2fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*4]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix2fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*4]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix2fv")]
        [CLSCompliant(false)]
        public static unsafe void UniformMatrix2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix2x3fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix2x3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix2x3fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix2x3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix2x3fv")]
        [CLSCompliant(false)]
        public static unsafe void UniformMatrix2x3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix2x4fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix2x4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix2x4fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix2x4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix2x4fv")]
        [CLSCompliant(false)]
        public static unsafe void UniformMatrix2x4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*9]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix3fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*9]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix3fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*9]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix3fv")]
        [CLSCompliant(false)]
        public static unsafe void UniformMatrix3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix3x2fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix3x2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix3x2fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix3x2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*6]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix3x2fv")]
        [CLSCompliant(false)]
        public static unsafe void UniformMatrix3x2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix3x4fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix3x4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix3x4fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix3x4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix3x4fv")]
        [CLSCompliant(false)]
        public static unsafe void UniformMatrix3x4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*16]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix4fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*16]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix4fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*16]</param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix4fv")]
        [CLSCompliant(false)]
        public static unsafe void UniformMatrix4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix4x2fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix4x2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix4x2fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix4x2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*8]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix4x2fv")]
        [CLSCompliant(false)]
        public static unsafe void UniformMatrix4x2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix4x3fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix4x3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single[] value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix4x3fv")]
        [CLSCompliant(false)]
        public static void UniformMatrix4x3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] ref Single value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="location"></param>
        /// <param name="count"></param>
        /// <param name="transpose"></param>
        /// <param name="value">[length: count*12]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix4x3fv")]
        [CLSCompliant(false)]
        public static unsafe void UniformMatrix4x3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUnmapBuffer")]
        public static bool UnmapBuffer(OpenTK.Graphics.ES31.All target) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="target"></param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUnmapBuffer")]
        public static bool UnmapBuffer(OpenTK.Graphics.ES31.BufferTargetArb target) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Installs a program object as part of current rendering state
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object whose executables are to be used as part of current rendering state.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUseProgram")]
        [CLSCompliant(false)]
        public static void UseProgram(Int32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Installs a program object as part of current rendering state
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object whose executables are to be used as part of current rendering state.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUseProgram")]
        [CLSCompliant(false)]
        public static void UseProgram(UInt32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Bind stages of a program object to a program pipeline
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the program pipeline object to which to bind stages from program.
        /// </param>
        /// <param name="stages">
        /// Specifies a set of program stages to bind to the program pipeline object.
        /// </param>
        /// <param name="program">
        /// Specifies the program object containing the shader executables to use in pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glUseProgramStages")]
        [CLSCompliant(false)]
        public static void UseProgramStages(Int32 pipeline, Int32 stages, Int32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Bind stages of a program object to a program pipeline
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the program pipeline object to which to bind stages from program.
        /// </param>
        /// <param name="stages">
        /// Specifies a set of program stages to bind to the program pipeline object.
        /// </param>
        /// <param name="program">
        /// Specifies the program object containing the shader executables to use in pipeline.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glUseProgramStages")]
        [CLSCompliant(false)]
        public static void UseProgramStages(UInt32 pipeline, UInt32 stages, UInt32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Validates a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object to be validated.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glValidateProgram")]
        [CLSCompliant(false)]
        public static void ValidateProgram(Int32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Validates a program object
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object to be validated.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glValidateProgram")]
        [CLSCompliant(false)]
        public static void ValidateProgram(UInt32 program) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Validate a program pipeline object against current GL state
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object to validate.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glValidateProgramPipeline")]
        [CLSCompliant(false)]
        public static void ValidateProgramPipeline(Int32 pipeline) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Validate a program pipeline object against current GL state
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object to validate.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glValidateProgramPipeline")]
        [CLSCompliant(false)]
        public static void ValidateProgramPipeline(UInt32 pipeline) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="x">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib1f")]
        [CLSCompliant(false)]
        public static void VertexAttrib1(Int32 index, Single x) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="x">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib1f")]
        [CLSCompliant(false)]
        public static void VertexAttrib1(UInt32 index, Single x) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 1]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib1fv")]
        [CLSCompliant(false)]
        public static unsafe void VertexAttrib1(Int32 index, [CountAttribute(Count = 1)] Single* v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 1]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib1fv")]
        [CLSCompliant(false)]
        public static unsafe void VertexAttrib1(UInt32 index, [CountAttribute(Count = 1)] Single* v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="x">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        /// <param name="y">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2f")]
        [CLSCompliant(false)]
        public static void VertexAttrib2(Int32 index, Single x, Single y) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="x">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        /// <param name="y">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2f")]
        [CLSCompliant(false)]
        public static void VertexAttrib2(UInt32 index, Single x, Single y) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 2]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2fv")]
        [CLSCompliant(false)]
        public static void VertexAttrib2(Int32 index, [CountAttribute(Count = 2)] Single[] v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 2]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2fv")]
        [CLSCompliant(false)]
        public static void VertexAttrib2(Int32 index, [CountAttribute(Count = 2)] ref Single v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 2]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2fv")]
        [CLSCompliant(false)]
        public static unsafe void VertexAttrib2(Int32 index, [CountAttribute(Count = 2)] Single* v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 2]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2fv")]
        [CLSCompliant(false)]
        public static void VertexAttrib2(UInt32 index, [CountAttribute(Count = 2)] Single[] v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 2]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2fv")]
        [CLSCompliant(false)]
        public static void VertexAttrib2(UInt32 index, [CountAttribute(Count = 2)] ref Single v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 2]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2fv")]
        [CLSCompliant(false)]
        public static unsafe void VertexAttrib2(UInt32 index, [CountAttribute(Count = 2)] Single* v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="x">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        /// <param name="y">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        /// <param name="z">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3f")]
        [CLSCompliant(false)]
        public static void VertexAttrib3(Int32 index, Single x, Single y, Single z) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="x">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        /// <param name="y">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        /// <param name="z">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3f")]
        [CLSCompliant(false)]
        public static void VertexAttrib3(UInt32 index, Single x, Single y, Single z) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 3]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3fv")]
        [CLSCompliant(false)]
        public static void VertexAttrib3(Int32 index, [CountAttribute(Count = 3)] Single[] v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 3]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3fv")]
        [CLSCompliant(false)]
        public static void VertexAttrib3(Int32 index, [CountAttribute(Count = 3)] ref Single v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 3]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3fv")]
        [CLSCompliant(false)]
        public static unsafe void VertexAttrib3(Int32 index, [CountAttribute(Count = 3)] Single* v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 3]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3fv")]
        [CLSCompliant(false)]
        public static void VertexAttrib3(UInt32 index, [CountAttribute(Count = 3)] Single[] v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 3]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3fv")]
        [CLSCompliant(false)]
        public static void VertexAttrib3(UInt32 index, [CountAttribute(Count = 3)] ref Single v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 3]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3fv")]
        [CLSCompliant(false)]
        public static unsafe void VertexAttrib3(UInt32 index, [CountAttribute(Count = 3)] Single* v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="x">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        /// <param name="y">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        /// <param name="z">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        /// <param name="w">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4f")]
        [CLSCompliant(false)]
        public static void VertexAttrib4(Int32 index, Single x, Single y, Single z, Single w) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="x">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        /// <param name="y">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        /// <param name="z">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        /// <param name="w">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4f")]
        [CLSCompliant(false)]
        public static void VertexAttrib4(UInt32 index, Single x, Single y, Single z, Single w) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 4]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4fv")]
        [CLSCompliant(false)]
        public static void VertexAttrib4(Int32 index, [CountAttribute(Count = 4)] Single[] v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 4]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4fv")]
        [CLSCompliant(false)]
        public static void VertexAttrib4(Int32 index, [CountAttribute(Count = 4)] ref Single v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 4]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4fv")]
        [CLSCompliant(false)]
        public static unsafe void VertexAttrib4(Int32 index, [CountAttribute(Count = 4)] Single* v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 4]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4fv")]
        [CLSCompliant(false)]
        public static void VertexAttrib4(UInt32 index, [CountAttribute(Count = 4)] Single[] v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 4]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4fv")]
        [CLSCompliant(false)]
        public static void VertexAttrib4(UInt32 index, [CountAttribute(Count = 4)] ref Single v) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="v">[length: 4]
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4fv")]
        [CLSCompliant(false)]
        public static unsafe void VertexAttrib4(UInt32 index, [CountAttribute(Count = 4)] Single* v) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Associate a vertex attribute and a vertex buffer binding
        /// </summary>
        /// <param name="attribindex">
        /// The index of the attribute to associate with a vertex buffer binding.
        /// </param>
        /// <param name="bindingindex">
        /// The index of the vertex buffer binding with which to associate the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glVertexAttribBinding")]
        [CLSCompliant(false)]
        public static void VertexAttribBinding(Int32 attribindex, Int32 bindingindex) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Associate a vertex attribute and a vertex buffer binding
        /// </summary>
        /// <param name="attribindex">
        /// The index of the attribute to associate with a vertex buffer binding.
        /// </param>
        /// <param name="bindingindex">
        /// The index of the vertex buffer binding with which to associate the generic vertex attribute.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glVertexAttribBinding")]
        [CLSCompliant(false)]
        public static void VertexAttribBinding(UInt32 attribindex, UInt32 bindingindex) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Modify the rate at which generic vertex attributes advance during instanced rendering
        /// </summary>
        /// <param name="index">
        /// Specify the index of the generic vertex attribute.
        /// </param>
        /// <param name="divisor">
        /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribDivisor")]
        [CLSCompliant(false)]
        public static void VertexAttribDivisor(Int32 index, Int32 divisor) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Modify the rate at which generic vertex attributes advance during instanced rendering
        /// </summary>
        /// <param name="index">
        /// Specify the index of the generic vertex attribute.
        /// </param>
        /// <param name="divisor">
        /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribDivisor")]
        [CLSCompliant(false)]
        public static void VertexAttribDivisor(UInt32 index, UInt32 divisor) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the organization of vertex arrays
        /// </summary>
        /// <param name="attribindex">
        /// The generic vertex attribute array being described.
        /// </param>
        /// <param name="size">
        /// The number of values per vertex that are stored in the array.
        /// </param>
        /// <param name="type">
        /// The type of the data stored in the array.
        /// </param>
        /// <param name="normalized">
        /// The distance between elements within the buffer.
        /// </param>
        /// <param name="relativeoffset">
        /// The distance between elements within the buffer.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glVertexAttribFormat")]
        [CLSCompliant(false)]
        public static void VertexAttribFormat(Int32 attribindex, Int32 size, OpenTK.Graphics.ES31.All type, bool normalized, Int32 relativeoffset) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Specify the organization of vertex arrays
        /// </summary>
        /// <param name="attribindex">
        /// The generic vertex attribute array being described.
        /// </param>
        /// <param name="size">
        /// The number of values per vertex that are stored in the array.
        /// </param>
        /// <param name="type">
        /// The type of the data stored in the array.
        /// </param>
        /// <param name="normalized">
        /// The distance between elements within the buffer.
        /// </param>
        /// <param name="relativeoffset">
        /// The distance between elements within the buffer.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glVertexAttribFormat")]
        [CLSCompliant(false)]
        public static void VertexAttribFormat(UInt32 attribindex, Int32 size, OpenTK.Graphics.ES31.All type, bool normalized, UInt32 relativeoffset) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="z"></param>
        /// <param name="w"></param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4i")]
        [CLSCompliant(false)]
        public static void VertexAttribI4(Int32 index, Int32 x, Int32 y, Int32 z, Int32 w) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="z"></param>
        /// <param name="w"></param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4i")]
        [CLSCompliant(false)]
        public static void VertexAttribI4(UInt32 index, Int32 x, Int32 y, Int32 z, Int32 w) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="v">[length: 4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4iv")]
        [CLSCompliant(false)]
        public static void VertexAttribI4(Int32 index, [CountAttribute(Count = 4)] Int32[] v) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="v">[length: 4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4iv")]
        [CLSCompliant(false)]
        public static void VertexAttribI4(Int32 index, [CountAttribute(Count = 4)] ref Int32 v) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="v">[length: 4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4iv")]
        [CLSCompliant(false)]
        public static unsafe void VertexAttribI4(Int32 index, [CountAttribute(Count = 4)] Int32* v) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="v">[length: 4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4iv")]
        [CLSCompliant(false)]
        public static void VertexAttribI4(UInt32 index, [CountAttribute(Count = 4)] Int32[] v) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="v">[length: 4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4iv")]
        [CLSCompliant(false)]
        public static void VertexAttribI4(UInt32 index, [CountAttribute(Count = 4)] ref Int32 v) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="v">[length: 4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4iv")]
        [CLSCompliant(false)]
        public static unsafe void VertexAttribI4(UInt32 index, [CountAttribute(Count = 4)] Int32* v) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="z"></param>
        /// <param name="w"></param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4ui")]
        [CLSCompliant(false)]
        public static void VertexAttribI4(UInt32 index, UInt32 x, UInt32 y, UInt32 z, UInt32 w) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="v">[length: 4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4uiv")]
        [CLSCompliant(false)]
        public static void VertexAttribI4(UInt32 index, [CountAttribute(Count = 4)] UInt32[] v) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="v">[length: 4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4uiv")]
        [CLSCompliant(false)]
        public static void VertexAttribI4(UInt32 index, [CountAttribute(Count = 4)] ref UInt32 v) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="v">[length: 4]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4uiv")]
        [CLSCompliant(false)]
        public static unsafe void VertexAttribI4(UInt32 index, [CountAttribute(Count = 4)] UInt32* v) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="attribindex"></param>
        /// <param name="size"></param>
        /// <param name="type"></param>
        /// <param name="relativeoffset"></param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glVertexAttribIFormat")]
        [CLSCompliant(false)]
        public static void VertexAttribIFormat(Int32 attribindex, Int32 size, OpenTK.Graphics.ES31.All type, Int32 relativeoffset) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]</summary>
        /// <param name="attribindex"></param>
        /// <param name="size"></param>
        /// <param name="type"></param>
        /// <param name="relativeoffset"></param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glVertexAttribIFormat")]
        [CLSCompliant(false)]
        public static void VertexAttribIFormat(UInt32 attribindex, Int32 size, OpenTK.Graphics.ES31.All type, UInt32 relativeoffset) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="size"></param>
        /// <param name="type"></param>
        /// <param name="stride"></param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribIPointer(Int32 index, Int32 size, OpenTK.Graphics.ES31.All type, Int32 stride, [CountAttribute(Computed = "size,type,stride")] IntPtr pointer) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="size"></param>
        /// <param name="type"></param>
        /// <param name="stride"></param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.ES31.All type, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T4[] pointer)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="size"></param>
        /// <param name="type"></param>
        /// <param name="stride"></param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.ES31.All type, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T4[,] pointer)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="size"></param>
        /// <param name="type"></param>
        /// <param name="stride"></param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.ES31.All type, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T4[,,] pointer)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="size"></param>
        /// <param name="type"></param>
        /// <param name="stride"></param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.ES31.All type, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] ref T4 pointer)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="size"></param>
        /// <param name="type"></param>
        /// <param name="stride"></param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribIPointer(UInt32 index, Int32 size, OpenTK.Graphics.ES31.All type, Int32 stride, [CountAttribute(Computed = "size,type,stride")] IntPtr pointer) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="size"></param>
        /// <param name="type"></param>
        /// <param name="stride"></param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.ES31.All type, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T4[] pointer)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="size"></param>
        /// <param name="type"></param>
        /// <param name="stride"></param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.ES31.All type, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T4[,] pointer)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="size"></param>
        /// <param name="type"></param>
        /// <param name="stride"></param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.ES31.All type, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T4[,,] pointer)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]</summary>
        /// <param name="index"></param>
        /// <param name="size"></param>
        /// <param name="type"></param>
        /// <param name="stride"></param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]</param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.ES31.All type, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] ref T4 pointer)
            where T4 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer(Int32 index, Int32 size, OpenTK.Graphics.ES31.All type, bool normalized, Int32 stride, [CountAttribute(Computed = "size,type,stride")] IntPtr pointer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES31.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T5[] pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES31.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T5[,] pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES31.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T5[,,] pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES31.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] ref T5 pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer(Int32 index, Int32 size, OpenTK.Graphics.ES31.VertexAttribPointerType type, bool normalized, Int32 stride, [CountAttribute(Computed = "size,type,stride")] IntPtr pointer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES31.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T5[] pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES31.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T5[,] pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES31.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T5[,,] pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES31.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] ref T5 pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer(UInt32 index, Int32 size, OpenTK.Graphics.ES31.All type, bool normalized, Int32 stride, [CountAttribute(Computed = "size,type,stride")] IntPtr pointer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES31.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T5[] pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES31.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T5[,] pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES31.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T5[,,] pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES31.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] ref T5 pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer(UInt32 index, Int32 size, OpenTK.Graphics.ES31.VertexAttribPointerType type, bool normalized, Int32 stride, [CountAttribute(Computed = "size,type,stride")] IntPtr pointer) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES31.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T5[] pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES31.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T5[,] pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES31.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] T5[,,] pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants Byte, UnsignedByte, Short, UnsignedShort, Int, and UnsignedInt are accepted by both functions. Additionally HalfFloat, Float, Fixed, Int2101010Rev, and UnsignedInt2101010Rev are accepted by glVertexAttribPointer. The initial value is Float.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (True) or converted directly as fixed-point values (False) when they are accessed. This parameter is ignored if type is Fixed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">[length: COMPSIZE(size,type,stride)]
        /// Specifies a pointer to the first generic vertex attribute in the array. If a non-zero buffer is currently bound to the ArrayBuffer target, pointer specifies an offset of into the array in the data store of that buffer. The initial value is 0.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        [CLSCompliant(false)]
        public static void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES31.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute, CountAttribute(Computed = "size,type,stride")] ref T5 pointer)
            where T5 : struct
         { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Modify the rate at which generic vertex attributes advance
        /// </summary>
        /// <param name="bindingindex">
        /// The index of the binding whose divisor to modify.
        /// </param>
        /// <param name="divisor">
        /// The new value for the instance step rate to apply.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glVertexBindingDivisor")]
        [CLSCompliant(false)]
        public static void VertexBindingDivisor(Int32 bindingindex, Int32 divisor) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.1 or ES_VERSION_3_1]
        /// Modify the rate at which generic vertex attributes advance
        /// </summary>
        /// <param name="bindingindex">
        /// The index of the binding whose divisor to modify.
        /// </param>
        /// <param name="divisor">
        /// The new value for the instance step rate to apply.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_1", Version = "3.1", EntryPoint = "glVertexBindingDivisor")]
        [CLSCompliant(false)]
        public static void VertexBindingDivisor(UInt32 bindingindex, UInt32 divisor) { throw new NotImplementedException(); }

        /// <summary>[requires: v2.0 or ES_VERSION_2_0]
        /// Set the viewport
        /// </summary>
        /// <param name="x">
        /// Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
        /// </param>
        /// <param name="y">
        /// Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
        /// </param>
        /// <param name="width">
        /// Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
        /// </param>
        /// <param name="height">
        /// Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glViewport")]
        public static void Viewport(Int32 x, Int32 y, Int32 width, Int32 height) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Instruct the GL server to block until the specified sync object becomes signaled
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose status to wait on.
        /// </param>
        /// <param name="flags">
        /// A bitfield controlling the command flushing behavior. flags must be zero.
        /// </param>
        /// <param name="timeout">
        /// Specifies the timeout that the server should wait before continuing. timeout must be TimeoutIgnored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glWaitSync")]
        [CLSCompliant(false)]
        public static void WaitSync(IntPtr sync, Int32 flags, Int64 timeout) { throw new NotImplementedException(); }

        /// <summary>[requires: v3.0 or ES_VERSION_3_0]
        /// Instruct the GL server to block until the specified sync object becomes signaled
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose status to wait on.
        /// </param>
        /// <param name="flags">
        /// A bitfield controlling the command flushing behavior. flags must be zero.
        /// </param>
        /// <param name="timeout">
        /// Specifies the timeout that the server should wait before continuing. timeout must be TimeoutIgnored.
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glWaitSync")]
        [CLSCompliant(false)]
        public static void WaitSync(IntPtr sync, UInt32 flags, UInt64 timeout) { throw new NotImplementedException(); }
        public static partial class Ext
        {
            /// <summary>[requires: EXT_win32_keyed_mutex]</summary>
            /// <param name="memory"></param>
            /// <param name="key"></param>
            /// <param name="timeout"></param>
            [AutoGenerated(Category = "EXT_win32_keyed_mutex", Version = "", EntryPoint = "glAcquireKeyedMutexWin32EXT")]
            [CLSCompliant(false)]
            public static bool AcquireKeyedMutexWin32(Int32 memory, Int64 key, Int32 timeout) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_win32_keyed_mutex]</summary>
            /// <param name="memory"></param>
            /// <param name="key"></param>
            /// <param name="timeout"></param>
            [AutoGenerated(Category = "EXT_win32_keyed_mutex", Version = "", EntryPoint = "glAcquireKeyedMutexWin32EXT")]
            [CLSCompliant(false)]
            public static bool AcquireKeyedMutexWin32(UInt32 memory, UInt64 key, UInt32 timeout) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glActiveProgramEXT")]
            [CLSCompliant(false)]
            public static void ActiveProgram(Int32 program) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glActiveProgramEXT")]
            [CLSCompliant(false)]
            public static void ActiveProgram(UInt32 program) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Set the active program object for a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the program pipeline object to set the active program object for.
            /// </param>
            /// <param name="program">
            /// Specifies the program object to set as the active program pipeline object pipeline.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glActiveShaderProgramEXT")]
            [CLSCompliant(false)]
            public static void ActiveShaderProgram(Int32 pipeline, Int32 program) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Set the active program object for a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the program pipeline object to set the active program object for.
            /// </param>
            /// <param name="program">
            /// Specifies the program object to set as the active program pipeline object pipeline.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glActiveShaderProgramEXT")]
            [CLSCompliant(false)]
            public static void ActiveShaderProgram(UInt32 pipeline, UInt32 program) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delimit the boundaries of a query object
            /// </summary>
            /// <param name="target">
            /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of AnySamplesPassed, AnySamplesPassedConservative, or TransformFeedbackPrimitivesWritten.
            /// </param>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glBeginQueryEXT")]
            [CLSCompliant(false)]
            public static void BeginQuery(OpenTK.Graphics.ES31.All target, Int32 id) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delimit the boundaries of a query object
            /// </summary>
            /// <param name="target">
            /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of AnySamplesPassed, AnySamplesPassedConservative, or TransformFeedbackPrimitivesWritten.
            /// </param>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glBeginQueryEXT")]
            [CLSCompliant(false)]
            public static void BeginQuery(OpenTK.Graphics.ES31.All target, UInt32 id) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_blend_func_extended]
            /// Bind a user-defined varying out variable to a fragment shader color number
            /// </summary>
            /// <param name="program">
            /// The name of the program containing varying out variable whose binding to modify
            /// </param>
            /// <param name="color">
            /// The color number to bind the user-defined varying out variable to
            /// </param>
            /// <param name="name">[length: COMPSIZE(name)]
            /// The name of the user-defined varying out variable whose binding to modify
            /// </param>
            [AutoGenerated(Category = "EXT_blend_func_extended", Version = "", EntryPoint = "glBindFragDataLocationEXT")]
            [CLSCompliant(false)]
            public static void BindFragDataLocation(Int32 program, Int32 color, [CountAttribute(Computed = "name")] String name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_blend_func_extended]
            /// Bind a user-defined varying out variable to a fragment shader color number
            /// </summary>
            /// <param name="program">
            /// The name of the program containing varying out variable whose binding to modify
            /// </param>
            /// <param name="color">
            /// The color number to bind the user-defined varying out variable to
            /// </param>
            /// <param name="name">[length: COMPSIZE(name)]
            /// The name of the user-defined varying out variable whose binding to modify
            /// </param>
            [AutoGenerated(Category = "EXT_blend_func_extended", Version = "", EntryPoint = "glBindFragDataLocationEXT")]
            [CLSCompliant(false)]
            public static void BindFragDataLocation(UInt32 program, UInt32 color, [CountAttribute(Computed = "name")] String name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_blend_func_extended]
            /// Bind a user-defined varying out variable to a fragment shader color number and index
            /// </summary>
            /// <param name="program">
            /// The name of the program containing varying out variable whose binding to modify
            /// </param>
            /// <param name="colorNumber">
            /// The color number to bind the user-defined varying out variable to
            /// </param>
            /// <param name="index">
            /// The index of the color input to bind the user-defined varying out variable to
            /// </param>
            /// <param name="name">
            /// The name of the user-defined varying out variable whose binding to modify
            /// </param>
            [AutoGenerated(Category = "EXT_blend_func_extended", Version = "", EntryPoint = "glBindFragDataLocationIndexedEXT")]
            [CLSCompliant(false)]
            public static void BindFragDataLocationIndexed(Int32 program, Int32 colorNumber, Int32 index, String name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_blend_func_extended]
            /// Bind a user-defined varying out variable to a fragment shader color number and index
            /// </summary>
            /// <param name="program">
            /// The name of the program containing varying out variable whose binding to modify
            /// </param>
            /// <param name="colorNumber">
            /// The color number to bind the user-defined varying out variable to
            /// </param>
            /// <param name="index">
            /// The index of the color input to bind the user-defined varying out variable to
            /// </param>
            /// <param name="name">
            /// The name of the user-defined varying out variable whose binding to modify
            /// </param>
            [AutoGenerated(Category = "EXT_blend_func_extended", Version = "", EntryPoint = "glBindFragDataLocationIndexedEXT")]
            [CLSCompliant(false)]
            public static void BindFragDataLocationIndexed(UInt32 program, UInt32 colorNumber, UInt32 index, String name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Bind a program pipeline to the current context
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of the pipeline object to bind to the context.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glBindProgramPipelineEXT")]
            [CLSCompliant(false)]
            public static void BindProgramPipeline(Int32 pipeline) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Bind a program pipeline to the current context
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of the pipeline object to bind to the context.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glBindProgramPipelineEXT")]
            [CLSCompliant(false)]
            public static void BindProgramPipeline(UInt32 pipeline) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_blend_minmax]
            /// Specify the equation used for both the RGB blend equation and the Alpha blend equation
            /// </summary>
            /// <param name="mode">
            /// specifies how source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_blend_minmax", Version = "", EntryPoint = "glBlendEquationEXT")]
            public static void BlendEquation(OpenTK.Graphics.ES31.All mode) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_blend_minmax]
            /// Specify the equation used for both the RGB blend equation and the Alpha blend equation
            /// </summary>
            /// <param name="mode">
            /// specifies how source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            [AutoGenerated(Category = "EXT_blend_minmax", Version = "", EntryPoint = "glBlendEquationEXT")]
            public static void BlendEquation(OpenTK.Graphics.ES31.BlendEquationModeExt mode) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Specify the equation used for both the RGB blend equation and the Alpha blend equation
            /// </summary>
            /// <param name="buf">
            /// specifies how source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            /// <param name="mode">
            /// specifies how source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glBlendEquationiEXT")]
            [CLSCompliant(false)]
            public static void BlendEquation(Int32 buf, OpenTK.Graphics.ES31.All mode) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Specify the equation used for both the RGB blend equation and the Alpha blend equation
            /// </summary>
            /// <param name="buf">
            /// specifies how source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            /// <param name="mode">
            /// specifies how source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glBlendEquationiEXT")]
            [CLSCompliant(false)]
            public static void BlendEquation(UInt32 buf, OpenTK.Graphics.ES31.All mode) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Set the RGB blend equation and the alpha blend equation separately
            /// </summary>
            /// <param name="buf">
            /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            /// <param name="modeRGB">
            /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            /// <param name="modeAlpha">
            /// specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glBlendEquationSeparateiEXT")]
            [CLSCompliant(false)]
            public static void BlendEquationSeparate(Int32 buf, OpenTK.Graphics.ES31.All modeRGB, OpenTK.Graphics.ES31.All modeAlpha) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Set the RGB blend equation and the alpha blend equation separately
            /// </summary>
            /// <param name="buf">
            /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            /// <param name="modeRGB">
            /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            /// <param name="modeAlpha">
            /// specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glBlendEquationSeparateiEXT")]
            [CLSCompliant(false)]
            public static void BlendEquationSeparate(UInt32 buf, OpenTK.Graphics.ES31.All modeRGB, OpenTK.Graphics.ES31.All modeAlpha) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Specify pixel arithmetic
            /// </summary>
            /// <param name="buf">
            /// Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is One.
            /// </param>
            /// <param name="src">
            /// Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: Zero, One, SrcColor, OneMinusSrcColor, DstColor, OneMinusDstColor, SrcAlpha, OneMinusSrcAlpha, DstAlpha, OneMinusDstAlpha. ConstantColor, OneMinusConstantColor, ConstantAlpha, and OneMinusConstantAlpha. The initial value is Zero.
            /// </param>
            /// <param name="dst"></param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glBlendFunciEXT")]
            [CLSCompliant(false)]
            public static void BlendFunc(Int32 buf, OpenTK.Graphics.ES31.All src, OpenTK.Graphics.ES31.All dst) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Specify pixel arithmetic
            /// </summary>
            /// <param name="buf">
            /// Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is One.
            /// </param>
            /// <param name="src">
            /// Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: Zero, One, SrcColor, OneMinusSrcColor, DstColor, OneMinusDstColor, SrcAlpha, OneMinusSrcAlpha, DstAlpha, OneMinusDstAlpha. ConstantColor, OneMinusConstantColor, ConstantAlpha, and OneMinusConstantAlpha. The initial value is Zero.
            /// </param>
            /// <param name="dst"></param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glBlendFunciEXT")]
            [CLSCompliant(false)]
            public static void BlendFunc(UInt32 buf, OpenTK.Graphics.ES31.All src, OpenTK.Graphics.ES31.All dst) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Specify pixel arithmetic for RGB and alpha components separately
            /// </summary>
            /// <param name="buf">
            /// Specifies how the red, green, and blue blending factors are computed. The initial value is One.
            /// </param>
            /// <param name="srcRGB">
            /// Specifies how the red, green, and blue blending factors are computed. The initial value is One.
            /// </param>
            /// <param name="dstRGB">
            /// Specifies how the red, green, and blue destination blending factors are computed. The initial value is Zero.
            /// </param>
            /// <param name="srcAlpha">
            /// Specified how the alpha source blending factor is computed. The initial value is One.
            /// </param>
            /// <param name="dstAlpha">
            /// Specified how the alpha destination blending factor is computed. The initial value is Zero.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glBlendFuncSeparateiEXT")]
            [CLSCompliant(false)]
            public static void BlendFuncSeparate(Int32 buf, OpenTK.Graphics.ES31.All srcRGB, OpenTK.Graphics.ES31.All dstRGB, OpenTK.Graphics.ES31.All srcAlpha, OpenTK.Graphics.ES31.All dstAlpha) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Specify pixel arithmetic for RGB and alpha components separately
            /// </summary>
            /// <param name="buf">
            /// Specifies how the red, green, and blue blending factors are computed. The initial value is One.
            /// </param>
            /// <param name="srcRGB">
            /// Specifies how the red, green, and blue blending factors are computed. The initial value is One.
            /// </param>
            /// <param name="dstRGB">
            /// Specifies how the red, green, and blue destination blending factors are computed. The initial value is Zero.
            /// </param>
            /// <param name="srcAlpha">
            /// Specified how the alpha source blending factor is computed. The initial value is One.
            /// </param>
            /// <param name="dstAlpha">
            /// Specified how the alpha destination blending factor is computed. The initial value is Zero.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glBlendFuncSeparateiEXT")]
            [CLSCompliant(false)]
            public static void BlendFuncSeparate(UInt32 buf, OpenTK.Graphics.ES31.All srcRGB, OpenTK.Graphics.ES31.All dstRGB, OpenTK.Graphics.ES31.All srcAlpha, OpenTK.Graphics.ES31.All dstAlpha) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage(OpenTK.Graphics.ES31.All target, Int32 size, [CountAttribute(Parameter = "size")] IntPtr data, Int32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage(OpenTK.Graphics.ES31.All target, Int32 size, [CountAttribute(Parameter = "size")] IntPtr data, UInt32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[] data, Int32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[] data, UInt32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,] data, Int32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,] data, UInt32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,,] data, Int32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,,] data, UInt32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] ref T2 data, Int32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, Int32 size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] ref T2 data, UInt32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage(OpenTK.Graphics.ES31.All target, IntPtr size, [CountAttribute(Parameter = "size")] IntPtr data, Int32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage(OpenTK.Graphics.ES31.All target, IntPtr size, [CountAttribute(Parameter = "size")] IntPtr data, UInt32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[] data, Int32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[] data, UInt32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,] data, Int32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,] data, UInt32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,,] data, Int32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] T2[,,] data, UInt32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] ref T2 data, Int32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_buffer_storage]
            /// Creates and initializes a buffer object's immutable data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="size">
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </param>
            /// <param name="data">[length: size]
            /// Specifies a pointer to data that will be copied into the data store for initialization, or Null if no data is to be copied.
            /// </param>
            /// <param name="flags">
            /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. DynamicStorageBit, MapReadBitMapWriteBit, MapPersistentBit, MapCoherentBit, and ClientStorageBit.
            /// </param>
            [AutoGenerated(Category = "EXT_buffer_storage", Version = "", EntryPoint = "glBufferStorageEXT")]
            [CLSCompliant(false)]
            public static void BufferStorage<T2>(OpenTK.Graphics.ES31.All target, IntPtr size, [InAttribute, OutAttribute, CountAttribute(Parameter = "size")] ref T2 data, UInt32 flags)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_external_buffer]</summary>
            /// <param name="target"></param>
            /// <param name="offset"></param>
            /// <param name="size"></param>
            /// <param name="clientBuffer"></param>
            /// <param name="flags"></param>
            [AutoGenerated(Category = "EXT_external_buffer", Version = "", EntryPoint = "glBufferStorageExternalEXT")]
            [CLSCompliant(false)]
            public static void BufferStorageExternal(OpenTK.Graphics.ES31.All target, IntPtr offset, Int32 size, IntPtr clientBuffer, Int32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_external_buffer]</summary>
            /// <param name="target"></param>
            /// <param name="offset"></param>
            /// <param name="size"></param>
            /// <param name="clientBuffer"></param>
            /// <param name="flags"></param>
            [AutoGenerated(Category = "EXT_external_buffer", Version = "", EntryPoint = "glBufferStorageExternalEXT")]
            [CLSCompliant(false)]
            public static void BufferStorageExternal(OpenTK.Graphics.ES31.All target, IntPtr offset, Int32 size, IntPtr clientBuffer, UInt32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_external_buffer]</summary>
            /// <param name="target"></param>
            /// <param name="offset"></param>
            /// <param name="size"></param>
            /// <param name="clientBuffer"></param>
            /// <param name="flags"></param>
            [AutoGenerated(Category = "EXT_external_buffer", Version = "", EntryPoint = "glBufferStorageExternalEXT")]
            [CLSCompliant(false)]
            public static void BufferStorageExternal(OpenTK.Graphics.ES31.All target, IntPtr offset, IntPtr size, IntPtr clientBuffer, Int32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_external_buffer]</summary>
            /// <param name="target"></param>
            /// <param name="offset"></param>
            /// <param name="size"></param>
            /// <param name="clientBuffer"></param>
            /// <param name="flags"></param>
            [AutoGenerated(Category = "EXT_external_buffer", Version = "", EntryPoint = "glBufferStorageExternalEXT")]
            [CLSCompliant(false)]
            public static void BufferStorageExternal(OpenTK.Graphics.ES31.All target, IntPtr offset, IntPtr size, IntPtr clientBuffer, UInt32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="size"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glBufferStorageMemEXT")]
            [CLSCompliant(false)]
            public static void BufferStorageMem(OpenTK.Graphics.ES31.All target, Int32 size, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="size"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glBufferStorageMemEXT")]
            [CLSCompliant(false)]
            public static void BufferStorageMem(OpenTK.Graphics.ES31.All target, Int32 size, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="size"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glBufferStorageMemEXT")]
            [CLSCompliant(false)]
            public static void BufferStorageMem(OpenTK.Graphics.ES31.All target, IntPtr size, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="size"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glBufferStorageMemEXT")]
            [CLSCompliant(false)]
            public static void BufferStorageMem(OpenTK.Graphics.ES31.All target, IntPtr size, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="size"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glBufferStorageMemEXT")]
            [CLSCompliant(false)]
            public static void BufferStorageMem(OpenTK.Graphics.ES31.BufferTargetArb target, Int32 size, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="size"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glBufferStorageMemEXT")]
            [CLSCompliant(false)]
            public static void BufferStorageMem(OpenTK.Graphics.ES31.BufferTargetArb target, Int32 size, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="size"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glBufferStorageMemEXT")]
            [CLSCompliant(false)]
            public static void BufferStorageMem(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr size, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="size"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glBufferStorageMemEXT")]
            [CLSCompliant(false)]
            public static void BufferStorageMem(OpenTK.Graphics.ES31.BufferTargetArb target, IntPtr size, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_shader_pixel_local_storage2]</summary>
            /// <param name="offset"></param>
            /// <param name="n"></param>
            /// <param name="values"></param>
            [AutoGenerated(Category = "EXT_shader_pixel_local_storage2", Version = "", EntryPoint = "glClearPixelLocalStorageuiEXT")]
            [CLSCompliant(false)]
            public static void ClearPixelLocalStorage(Int32 offset, Int32 n, Int32[] values) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_shader_pixel_local_storage2]</summary>
            /// <param name="offset"></param>
            /// <param name="n"></param>
            /// <param name="values"></param>
            [AutoGenerated(Category = "EXT_shader_pixel_local_storage2", Version = "", EntryPoint = "glClearPixelLocalStorageuiEXT")]
            [CLSCompliant(false)]
            public static void ClearPixelLocalStorage(Int32 offset, Int32 n, ref Int32 values) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_shader_pixel_local_storage2]</summary>
            /// <param name="offset"></param>
            /// <param name="n"></param>
            /// <param name="values"></param>
            [AutoGenerated(Category = "EXT_shader_pixel_local_storage2", Version = "", EntryPoint = "glClearPixelLocalStorageuiEXT")]
            [CLSCompliant(false)]
            public static unsafe void ClearPixelLocalStorage(Int32 offset, Int32 n, Int32* values) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_shader_pixel_local_storage2]</summary>
            /// <param name="offset"></param>
            /// <param name="n"></param>
            /// <param name="values"></param>
            [AutoGenerated(Category = "EXT_shader_pixel_local_storage2", Version = "", EntryPoint = "glClearPixelLocalStorageuiEXT")]
            [CLSCompliant(false)]
            public static void ClearPixelLocalStorage(Int32 offset, Int32 n, UInt32[] values) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_shader_pixel_local_storage2]</summary>
            /// <param name="offset"></param>
            /// <param name="n"></param>
            /// <param name="values"></param>
            [AutoGenerated(Category = "EXT_shader_pixel_local_storage2", Version = "", EntryPoint = "glClearPixelLocalStorageuiEXT")]
            [CLSCompliant(false)]
            public static void ClearPixelLocalStorage(Int32 offset, Int32 n, ref UInt32 values) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_shader_pixel_local_storage2]</summary>
            /// <param name="offset"></param>
            /// <param name="n"></param>
            /// <param name="values"></param>
            [AutoGenerated(Category = "EXT_shader_pixel_local_storage2", Version = "", EntryPoint = "glClearPixelLocalStorageuiEXT")]
            [CLSCompliant(false)]
            public static unsafe void ClearPixelLocalStorage(Int32 offset, Int32 n, UInt32* values) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexImage(Int32 texture, Int32 level, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "format,type")] IntPtr data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexImage<T4>(Int32 texture, Int32 level, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] T4[] data)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexImage<T4>(Int32 texture, Int32 level, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] T4[,] data)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexImage<T4>(Int32 texture, Int32 level, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] T4[,,] data)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexImage<T4>(Int32 texture, Int32 level, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] ref T4 data)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexImage(UInt32 texture, Int32 level, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "format,type")] IntPtr data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexImage<T4>(UInt32 texture, Int32 level, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] T4[] data)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexImage<T4>(UInt32 texture, Int32 level, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] T4[,] data)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexImage<T4>(UInt32 texture, Int32 level, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] T4[,,] data)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexImage<T4>(UInt32 texture, Int32 level, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] ref T4 data)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all or part of a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="xoffset">
            /// The coordinate of the left edge of the region to be cleared.
            /// </param>
            /// <param name="yoffset">
            /// The coordinate of the lower edge of the region to be cleared.
            /// </param>
            /// <param name="zoffset">
            /// The coordinate of the front of the region to be cleared.
            /// </param>
            /// <param name="width">
            /// The width of the region to be cleared.
            /// </param>
            /// <param name="height">
            /// The height of the region to be cleared.
            /// </param>
            /// <param name="depth">
            /// The depth of the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexSubImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexSubImage(Int32 texture, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "format,type")] IntPtr data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all or part of a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="xoffset">
            /// The coordinate of the left edge of the region to be cleared.
            /// </param>
            /// <param name="yoffset">
            /// The coordinate of the lower edge of the region to be cleared.
            /// </param>
            /// <param name="zoffset">
            /// The coordinate of the front of the region to be cleared.
            /// </param>
            /// <param name="width">
            /// The width of the region to be cleared.
            /// </param>
            /// <param name="height">
            /// The height of the region to be cleared.
            /// </param>
            /// <param name="depth">
            /// The depth of the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexSubImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexSubImage<T10>(Int32 texture, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] T10[] data)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all or part of a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="xoffset">
            /// The coordinate of the left edge of the region to be cleared.
            /// </param>
            /// <param name="yoffset">
            /// The coordinate of the lower edge of the region to be cleared.
            /// </param>
            /// <param name="zoffset">
            /// The coordinate of the front of the region to be cleared.
            /// </param>
            /// <param name="width">
            /// The width of the region to be cleared.
            /// </param>
            /// <param name="height">
            /// The height of the region to be cleared.
            /// </param>
            /// <param name="depth">
            /// The depth of the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexSubImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexSubImage<T10>(Int32 texture, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] T10[,] data)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all or part of a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="xoffset">
            /// The coordinate of the left edge of the region to be cleared.
            /// </param>
            /// <param name="yoffset">
            /// The coordinate of the lower edge of the region to be cleared.
            /// </param>
            /// <param name="zoffset">
            /// The coordinate of the front of the region to be cleared.
            /// </param>
            /// <param name="width">
            /// The width of the region to be cleared.
            /// </param>
            /// <param name="height">
            /// The height of the region to be cleared.
            /// </param>
            /// <param name="depth">
            /// The depth of the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexSubImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexSubImage<T10>(Int32 texture, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] T10[,,] data)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all or part of a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="xoffset">
            /// The coordinate of the left edge of the region to be cleared.
            /// </param>
            /// <param name="yoffset">
            /// The coordinate of the lower edge of the region to be cleared.
            /// </param>
            /// <param name="zoffset">
            /// The coordinate of the front of the region to be cleared.
            /// </param>
            /// <param name="width">
            /// The width of the region to be cleared.
            /// </param>
            /// <param name="height">
            /// The height of the region to be cleared.
            /// </param>
            /// <param name="depth">
            /// The depth of the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexSubImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexSubImage<T10>(Int32 texture, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] ref T10 data)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all or part of a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="xoffset">
            /// The coordinate of the left edge of the region to be cleared.
            /// </param>
            /// <param name="yoffset">
            /// The coordinate of the lower edge of the region to be cleared.
            /// </param>
            /// <param name="zoffset">
            /// The coordinate of the front of the region to be cleared.
            /// </param>
            /// <param name="width">
            /// The width of the region to be cleared.
            /// </param>
            /// <param name="height">
            /// The height of the region to be cleared.
            /// </param>
            /// <param name="depth">
            /// The depth of the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexSubImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexSubImage(UInt32 texture, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "format,type")] IntPtr data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all or part of a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="xoffset">
            /// The coordinate of the left edge of the region to be cleared.
            /// </param>
            /// <param name="yoffset">
            /// The coordinate of the lower edge of the region to be cleared.
            /// </param>
            /// <param name="zoffset">
            /// The coordinate of the front of the region to be cleared.
            /// </param>
            /// <param name="width">
            /// The width of the region to be cleared.
            /// </param>
            /// <param name="height">
            /// The height of the region to be cleared.
            /// </param>
            /// <param name="depth">
            /// The depth of the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexSubImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexSubImage<T10>(UInt32 texture, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] T10[] data)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all or part of a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="xoffset">
            /// The coordinate of the left edge of the region to be cleared.
            /// </param>
            /// <param name="yoffset">
            /// The coordinate of the lower edge of the region to be cleared.
            /// </param>
            /// <param name="zoffset">
            /// The coordinate of the front of the region to be cleared.
            /// </param>
            /// <param name="width">
            /// The width of the region to be cleared.
            /// </param>
            /// <param name="height">
            /// The height of the region to be cleared.
            /// </param>
            /// <param name="depth">
            /// The depth of the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexSubImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexSubImage<T10>(UInt32 texture, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] T10[,] data)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all or part of a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="xoffset">
            /// The coordinate of the left edge of the region to be cleared.
            /// </param>
            /// <param name="yoffset">
            /// The coordinate of the lower edge of the region to be cleared.
            /// </param>
            /// <param name="zoffset">
            /// The coordinate of the front of the region to be cleared.
            /// </param>
            /// <param name="width">
            /// The width of the region to be cleared.
            /// </param>
            /// <param name="height">
            /// The height of the region to be cleared.
            /// </param>
            /// <param name="depth">
            /// The depth of the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexSubImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexSubImage<T10>(UInt32 texture, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] T10[,,] data)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_clear_texture]
            /// Fills all or part of a texture image with a constant value
            /// </summary>
            /// <param name="texture">
            /// The name of an existing texture object containing the image to be cleared.
            /// </param>
            /// <param name="level">
            /// The level of texture containing the region to be cleared.
            /// </param>
            /// <param name="xoffset">
            /// The coordinate of the left edge of the region to be cleared.
            /// </param>
            /// <param name="yoffset">
            /// The coordinate of the lower edge of the region to be cleared.
            /// </param>
            /// <param name="zoffset">
            /// The coordinate of the front of the region to be cleared.
            /// </param>
            /// <param name="width">
            /// The width of the region to be cleared.
            /// </param>
            /// <param name="height">
            /// The height of the region to be cleared.
            /// </param>
            /// <param name="depth">
            /// The depth of the region to be cleared.
            /// </param>
            /// <param name="format">
            /// The format of the data whose address in memory is given by data.
            /// </param>
            /// <param name="type">
            /// The type of the data whose address in memory is given by data.
            /// </param>
            /// <param name="data">[length: COMPSIZE(format,type)]
            /// The address in memory of the data to be used to clear the specified region.
            /// </param>
            [AutoGenerated(Category = "EXT_clear_texture", Version = "", EntryPoint = "glClearTexSubImageEXT")]
            [CLSCompliant(false)]
            public static void ClearTexSubImage<T10>(UInt32 texture, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type")] ref T10 data)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Enable and disable writing of frame buffer color components
            /// </summary>
            /// <param name="index">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="r">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="g">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="b">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="a"></param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glColorMaskiEXT")]
            [CLSCompliant(false)]
            public static void ColorMask(Int32 index, bool r, bool g, bool b, bool a) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Enable and disable writing of frame buffer color components
            /// </summary>
            /// <param name="index">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="r">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="g">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="b">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="a"></param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glColorMaskiEXT")]
            [CLSCompliant(false)]
            public static void ColorMask(UInt32 index, bool r, bool g, bool b, bool a) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_copy_image]
            /// Perform a raw data copy between two images
            /// </summary>
            /// <param name="srcName">
            /// The name of a texture or renderbuffer object from which to copy.
            /// </param>
            /// <param name="srcTarget">
            /// The target representing the namespace of the source name srcName.
            /// </param>
            /// <param name="srcLevel">
            /// The mipmap level to read from the source.
            /// </param>
            /// <param name="srcX">
            /// The X coordinate of the left edge of the souce region to copy.
            /// </param>
            /// <param name="srcY">
            /// The Y coordinate of the top edge of the souce region to copy.
            /// </param>
            /// <param name="srcZ">
            /// The Z coordinate of the near edge of the souce region to copy.
            /// </param>
            /// <param name="dstName">
            /// The name of a texture or renderbuffer object to which to copy.
            /// </param>
            /// <param name="dstTarget">
            /// The target representing the namespace of the destination name dstName.
            /// </param>
            /// <param name="dstLevel">
            /// The X coordinate of the left edge of the destination region.
            /// </param>
            /// <param name="dstX">
            /// The X coordinate of the left edge of the destination region.
            /// </param>
            /// <param name="dstY">
            /// The Y coordinate of the top edge of the destination region.
            /// </param>
            /// <param name="dstZ">
            /// The Z coordinate of the near edge of the destination region.
            /// </param>
            /// <param name="srcWidth">
            /// The width of the region to be copied.
            /// </param>
            /// <param name="srcHeight">
            /// The height of the region to be copied.
            /// </param>
            /// <param name="srcDepth">
            /// The depth of the region to be copied.
            /// </param>
            [AutoGenerated(Category = "EXT_copy_image", Version = "", EntryPoint = "glCopyImageSubDataEXT")]
            [CLSCompliant(false)]
            public static void CopyImageSubData(Int32 srcName, OpenTK.Graphics.ES31.All srcTarget, Int32 srcLevel, Int32 srcX, Int32 srcY, Int32 srcZ, Int32 dstName, OpenTK.Graphics.ES31.All dstTarget, Int32 dstLevel, Int32 dstX, Int32 dstY, Int32 dstZ, Int32 srcWidth, Int32 srcHeight, Int32 srcDepth) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_copy_image]
            /// Perform a raw data copy between two images
            /// </summary>
            /// <param name="srcName">
            /// The name of a texture or renderbuffer object from which to copy.
            /// </param>
            /// <param name="srcTarget">
            /// The target representing the namespace of the source name srcName.
            /// </param>
            /// <param name="srcLevel">
            /// The mipmap level to read from the source.
            /// </param>
            /// <param name="srcX">
            /// The X coordinate of the left edge of the souce region to copy.
            /// </param>
            /// <param name="srcY">
            /// The Y coordinate of the top edge of the souce region to copy.
            /// </param>
            /// <param name="srcZ">
            /// The Z coordinate of the near edge of the souce region to copy.
            /// </param>
            /// <param name="dstName">
            /// The name of a texture or renderbuffer object to which to copy.
            /// </param>
            /// <param name="dstTarget">
            /// The target representing the namespace of the destination name dstName.
            /// </param>
            /// <param name="dstLevel">
            /// The X coordinate of the left edge of the destination region.
            /// </param>
            /// <param name="dstX">
            /// The X coordinate of the left edge of the destination region.
            /// </param>
            /// <param name="dstY">
            /// The Y coordinate of the top edge of the destination region.
            /// </param>
            /// <param name="dstZ">
            /// The Z coordinate of the near edge of the destination region.
            /// </param>
            /// <param name="srcWidth">
            /// The width of the region to be copied.
            /// </param>
            /// <param name="srcHeight">
            /// The height of the region to be copied.
            /// </param>
            /// <param name="srcDepth">
            /// The depth of the region to be copied.
            /// </param>
            [AutoGenerated(Category = "EXT_copy_image", Version = "", EntryPoint = "glCopyImageSubDataEXT")]
            [CLSCompliant(false)]
            public static void CopyImageSubData(UInt32 srcName, OpenTK.Graphics.ES31.All srcTarget, Int32 srcLevel, Int32 srcX, Int32 srcY, Int32 srcZ, UInt32 dstName, OpenTK.Graphics.ES31.All dstTarget, Int32 dstLevel, Int32 dstX, Int32 dstY, Int32 dstZ, Int32 srcWidth, Int32 srcHeight, Int32 srcDepth) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="n"></param>
            /// <param name="memoryObjects"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glCreateMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static void CreateMemoryObjects(Int32 n, [OutAttribute] Int32[] memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="n"></param>
            /// <param name="memoryObjects"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glCreateMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static void CreateMemoryObjects(Int32 n, [OutAttribute] out Int32 memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="n"></param>
            /// <param name="memoryObjects"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glCreateMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static unsafe void CreateMemoryObjects(Int32 n, [OutAttribute] Int32* memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="n"></param>
            /// <param name="memoryObjects"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glCreateMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static void CreateMemoryObjects(Int32 n, [OutAttribute] UInt32[] memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="n"></param>
            /// <param name="memoryObjects"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glCreateMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static void CreateMemoryObjects(Int32 n, [OutAttribute] out UInt32 memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="n"></param>
            /// <param name="memoryObjects"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glCreateMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static unsafe void CreateMemoryObjects(Int32 n, [OutAttribute] UInt32* memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Create a stand-alone program from an array of null-terminated source code strings
            /// </summary>
            /// <param name="type">
            /// Specifies the type of shader to create.
            /// </param>
            /// <param name="@string">
            /// Specifies the number of source code strings in the array strings.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glCreateShaderProgramEXT")]
            public static Int32 CreateShaderProgram(OpenTK.Graphics.ES31.All type, String @string) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Create a stand-alone program from an array of null-terminated source code strings
            /// </summary>
            /// <param name="type">
            /// Specifies the type of shader to create.
            /// </param>
            /// <param name="count">
            /// Specifies the number of source code strings in the array strings.
            /// </param>
            /// <param name="strings">[length: count]
            /// Specifies the address of an array of pointers to source code strings from which to create the program object.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glCreateShaderProgramvEXT")]
            public static Int32 CreateShaderProgram(OpenTK.Graphics.ES31.All type, Int32 count, [CountAttribute(Parameter = "count")] String[] strings) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObjects">[length: n]</param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glDeleteMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static void DeleteMemoryObject([CountAttribute(Parameter = "n")] Int32 memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObjects">[length: n]</param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glDeleteMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static void DeleteMemoryObject([CountAttribute(Parameter = "n")] UInt32 memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="n"></param>
            /// <param name="memoryObjects">[length: n]</param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glDeleteMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static void DeleteMemoryObjects(Int32 n, [CountAttribute(Parameter = "n")] Int32[] memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="n"></param>
            /// <param name="memoryObjects">[length: n]</param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glDeleteMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static void DeleteMemoryObjects(Int32 n, [CountAttribute(Parameter = "n")] ref Int32 memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="n"></param>
            /// <param name="memoryObjects">[length: n]</param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glDeleteMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static unsafe void DeleteMemoryObjects(Int32 n, [CountAttribute(Parameter = "n")] Int32* memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="n"></param>
            /// <param name="memoryObjects">[length: n]</param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glDeleteMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static void DeleteMemoryObjects(Int32 n, [CountAttribute(Parameter = "n")] UInt32[] memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="n"></param>
            /// <param name="memoryObjects">[length: n]</param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glDeleteMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static void DeleteMemoryObjects(Int32 n, [CountAttribute(Parameter = "n")] ref UInt32 memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="n"></param>
            /// <param name="memoryObjects">[length: n]</param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glDeleteMemoryObjectsEXT")]
            [CLSCompliant(false)]
            public static unsafe void DeleteMemoryObjects(Int32 n, [CountAttribute(Parameter = "n")] UInt32* memoryObjects) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of names of program pipeline objects to delete.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static void DeleteProgramPipeline([CountAttribute(Parameter = "n")] Int32 pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of names of program pipeline objects to delete.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static void DeleteProgramPipeline([CountAttribute(Parameter = "n")] UInt32 pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of program pipeline objects to delete.
            /// </param>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of names of program pipeline objects to delete.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static void DeleteProgramPipelines(Int32 n, [CountAttribute(Parameter = "n")] Int32[] pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of program pipeline objects to delete.
            /// </param>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of names of program pipeline objects to delete.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static void DeleteProgramPipelines(Int32 n, [CountAttribute(Parameter = "n")] ref Int32 pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of program pipeline objects to delete.
            /// </param>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of names of program pipeline objects to delete.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static unsafe void DeleteProgramPipelines(Int32 n, [CountAttribute(Parameter = "n")] Int32* pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of program pipeline objects to delete.
            /// </param>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of names of program pipeline objects to delete.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static void DeleteProgramPipelines(Int32 n, [CountAttribute(Parameter = "n")] UInt32[] pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of program pipeline objects to delete.
            /// </param>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of names of program pipeline objects to delete.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static void DeleteProgramPipelines(Int32 n, [CountAttribute(Parameter = "n")] ref UInt32 pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of program pipeline objects to delete.
            /// </param>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of names of program pipeline objects to delete.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static unsafe void DeleteProgramPipelines(Int32 n, [CountAttribute(Parameter = "n")] UInt32* pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="ids">[length: n]
            /// Specifies an array of query objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            [CLSCompliant(false)]
            public static void DeleteQuery([CountAttribute(Parameter = "n")] Int32 ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="ids">[length: n]
            /// Specifies an array of query objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            [CLSCompliant(false)]
            public static void DeleteQuery([CountAttribute(Parameter = "n")] UInt32 ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of query objects to be deleted.
            /// </param>
            /// <param name="ids">[length: n]
            /// Specifies an array of query objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            [CLSCompliant(false)]
            public static void DeleteQueries(Int32 n, [CountAttribute(Parameter = "n")] Int32[] ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of query objects to be deleted.
            /// </param>
            /// <param name="ids">[length: n]
            /// Specifies an array of query objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            [CLSCompliant(false)]
            public static void DeleteQueries(Int32 n, [CountAttribute(Parameter = "n")] ref Int32 ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of query objects to be deleted.
            /// </param>
            /// <param name="ids">[length: n]
            /// Specifies an array of query objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            [CLSCompliant(false)]
            public static unsafe void DeleteQueries(Int32 n, [CountAttribute(Parameter = "n")] Int32* ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of query objects to be deleted.
            /// </param>
            /// <param name="ids">[length: n]
            /// Specifies an array of query objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            [CLSCompliant(false)]
            public static void DeleteQueries(Int32 n, [CountAttribute(Parameter = "n")] UInt32[] ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of query objects to be deleted.
            /// </param>
            /// <param name="ids">[length: n]
            /// Specifies an array of query objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            [CLSCompliant(false)]
            public static void DeleteQueries(Int32 n, [CountAttribute(Parameter = "n")] ref UInt32 ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of query objects to be deleted.
            /// </param>
            /// <param name="ids">[length: n]
            /// Specifies an array of query objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            [CLSCompliant(false)]
            public static unsafe void DeleteQueries(Int32 n, [CountAttribute(Parameter = "n")] UInt32* ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glDeleteSemaphoresEXT")]
            [CLSCompliant(false)]
            public static void DeleteSemaphore([CountAttribute(Parameter = "count")] Int32 semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glDeleteSemaphoresEXT")]
            [CLSCompliant(false)]
            public static void DeleteSemaphore([CountAttribute(Parameter = "count")] UInt32 semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="n"></param>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glDeleteSemaphoresEXT")]
            [CLSCompliant(false)]
            public static void DeleteSemaphores(Int32 n, [CountAttribute(Parameter = "count")] Int32[] semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="n"></param>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glDeleteSemaphoresEXT")]
            [CLSCompliant(false)]
            public static void DeleteSemaphores(Int32 n, [CountAttribute(Parameter = "count")] ref Int32 semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="n"></param>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glDeleteSemaphoresEXT")]
            [CLSCompliant(false)]
            public static unsafe void DeleteSemaphores(Int32 n, [CountAttribute(Parameter = "count")] Int32* semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="n"></param>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glDeleteSemaphoresEXT")]
            [CLSCompliant(false)]
            public static void DeleteSemaphores(Int32 n, [CountAttribute(Parameter = "count")] UInt32[] semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="n"></param>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glDeleteSemaphoresEXT")]
            [CLSCompliant(false)]
            public static void DeleteSemaphores(Int32 n, [CountAttribute(Parameter = "count")] ref UInt32 semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="n"></param>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glDeleteSemaphoresEXT")]
            [CLSCompliant(false)]
            public static unsafe void DeleteSemaphores(Int32 n, [CountAttribute(Parameter = "count")] UInt32* semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glDisableiEXT")]
            [CLSCompliant(false)]
            public static void Disable(OpenTK.Graphics.ES31.All target, Int32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glDisableiEXT")]
            [CLSCompliant(false)]
            public static void Disable(OpenTK.Graphics.ES31.All target, UInt32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_discard_framebuffer]</summary>
            /// <param name="target"></param>
            /// <param name="numAttachments"></param>
            /// <param name="attachments">[length: numAttachments]</param>
            [AutoGenerated(Category = "EXT_discard_framebuffer", Version = "", EntryPoint = "glDiscardFramebufferEXT")]
            [CLSCompliant(false)]
            public static void DiscardFramebuffer(OpenTK.Graphics.ES31.All target, Int32 numAttachments, [CountAttribute(Parameter = "numAttachments")] OpenTK.Graphics.ES31.All[] attachments) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_discard_framebuffer]</summary>
            /// <param name="target"></param>
            /// <param name="numAttachments"></param>
            /// <param name="attachments">[length: numAttachments]</param>
            [AutoGenerated(Category = "EXT_discard_framebuffer", Version = "", EntryPoint = "glDiscardFramebufferEXT")]
            [CLSCompliant(false)]
            public static void DiscardFramebuffer(OpenTK.Graphics.ES31.All target, Int32 numAttachments, [CountAttribute(Parameter = "numAttachments")] ref OpenTK.Graphics.ES31.All attachments) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_discard_framebuffer]</summary>
            /// <param name="target"></param>
            /// <param name="numAttachments"></param>
            /// <param name="attachments">[length: numAttachments]</param>
            [AutoGenerated(Category = "EXT_discard_framebuffer", Version = "", EntryPoint = "glDiscardFramebufferEXT")]
            [CLSCompliant(false)]
            public static unsafe void DiscardFramebuffer(OpenTK.Graphics.ES31.All target, Int32 numAttachments, [CountAttribute(Parameter = "numAttachments")] OpenTK.Graphics.ES31.All* attachments) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a range of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, TrianglesLinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="first">
            /// Specifies the starting index in the enabled arrays.
            /// </param>
            /// <param name="count">
            /// Specifies the number of indices to be rendered.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawArraysInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawArraysInstancedBaseInstance(OpenTK.Graphics.ES31.All mode, Int32 first, Int32 count, Int32 instancecount, Int32 baseinstance) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a range of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, TrianglesLinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="first">
            /// Specifies the starting index in the enabled arrays.
            /// </param>
            /// <param name="count">
            /// Specifies the number of indices to be rendered.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawArraysInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawArraysInstancedBaseInstance(OpenTK.Graphics.ES31.All mode, Int32 first, Int32 count, Int32 instancecount, UInt32 baseinstance) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a range of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, TrianglesLinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="first">
            /// Specifies the starting index in the enabled arrays.
            /// </param>
            /// <param name="count">
            /// Specifies the number of indices to be rendered.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawArraysInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawArraysInstancedBaseInstance(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 first, Int32 count, Int32 instancecount, Int32 baseinstance) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a range of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, TrianglesLinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="first">
            /// Specifies the starting index in the enabled arrays.
            /// </param>
            /// <param name="count">
            /// Specifies the number of indices to be rendered.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawArraysInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawArraysInstancedBaseInstance(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 first, Int32 count, Int32 instancecount, UInt32 baseinstance) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a range of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the starting index in the enabled arrays.
            /// </param>
            /// <param name="count">
            /// Specifies the number of indices to be rendered.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawArraysInstancedEXT")]
            public static void DrawArraysInstanced(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 count, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a range of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the starting index in the enabled arrays.
            /// </param>
            /// <param name="count">
            /// Specifies the number of indices to be rendered.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawArraysInstancedEXT")]
            public static void DrawArraysInstanced(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 count, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// Specifies the number of buffers in bufs.
            /// </param>
            /// <param name="bufs">
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_buffers", Version = "", EntryPoint = "glDrawBuffersEXT")]
            [CLSCompliant(false)]
            public static void DrawBuffers(Int32 n, OpenTK.Graphics.ES31.All[] bufs) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// Specifies the number of buffers in bufs.
            /// </param>
            /// <param name="bufs">
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_buffers", Version = "", EntryPoint = "glDrawBuffersEXT")]
            [CLSCompliant(false)]
            public static void DrawBuffers(Int32 n, ref OpenTK.Graphics.ES31.All bufs) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// Specifies the number of buffers in bufs.
            /// </param>
            /// <param name="bufs">
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_buffers", Version = "", EntryPoint = "glDrawBuffersEXT")]
            [CLSCompliant(false)]
            public static unsafe void DrawBuffers(Int32 n, OpenTK.Graphics.ES31.All* bufs) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            /// <param name="n"></param>
            /// <param name="location">[length: n]</param>
            /// <param name="indices">[length: n]</param>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glDrawBuffersIndexedEXT")]
            [CLSCompliant(false)]
            public static void DrawBuffersIndexed(Int32 n, [CountAttribute(Parameter = "n")] OpenTK.Graphics.ES31.All[] location, [CountAttribute(Parameter = "n")] Int32[] indices) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            /// <param name="n"></param>
            /// <param name="location">[length: n]</param>
            /// <param name="indices">[length: n]</param>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glDrawBuffersIndexedEXT")]
            [CLSCompliant(false)]
            public static void DrawBuffersIndexed(Int32 n, [CountAttribute(Parameter = "n")] ref OpenTK.Graphics.ES31.All location, [CountAttribute(Parameter = "n")] ref Int32 indices) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            /// <param name="n"></param>
            /// <param name="location">[length: n]</param>
            /// <param name="indices">[length: n]</param>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glDrawBuffersIndexedEXT")]
            [CLSCompliant(false)]
            public static unsafe void DrawBuffersIndexed(Int32 n, [CountAttribute(Parameter = "n")] OpenTK.Graphics.ES31.All* location, [CountAttribute(Parameter = "n")] Int32* indices) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexEXT")]
            public static void DrawElementsBaseVertex(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexEXT")]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexEXT")]
            public static void DrawElementsBaseVertex(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexEXT")]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Parameter = "count")] IntPtr indices, Int32 instancecount, Int32 baseinstance) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Parameter = "count")] IntPtr indices, Int32 instancecount, UInt32 baseinstance) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[] indices, Int32 instancecount, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[] indices, Int32 instancecount, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,] indices, Int32 instancecount, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,] indices, Int32 instancecount, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,,] indices, Int32 instancecount, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,,] indices, Int32 instancecount, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] ref T3 indices, Int32 instancecount, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] ref T3 indices, Int32 instancecount, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Parameter = "count")] IntPtr indices, Int32 instancecount, Int32 baseinstance) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Parameter = "count")] IntPtr indices, Int32 instancecount, UInt32 baseinstance) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[] indices, Int32 instancecount, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[] indices, Int32 instancecount, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,] indices, Int32 instancecount, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,] indices, Int32 instancecount, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,,] indices, Int32 instancecount, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,,] indices, Int32 instancecount, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] ref T3 indices, Int32 instancecount, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Draw multiple instances of a set of elements with offset applied to instanced attributes
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] ref T3 indices, Int32 instancecount, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Parameter = "count")] IntPtr indices, Int32 instancecount, Int32 basevertex, Int32 baseinstance) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Parameter = "count")] IntPtr indices, Int32 instancecount, Int32 basevertex, UInt32 baseinstance) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[] indices, Int32 instancecount, Int32 basevertex, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[] indices, Int32 instancecount, Int32 basevertex, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,] indices, Int32 instancecount, Int32 basevertex, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,] indices, Int32 instancecount, Int32 basevertex, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,,] indices, Int32 instancecount, Int32 basevertex, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,,] indices, Int32 instancecount, Int32 basevertex, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] ref T3 indices, Int32 instancecount, Int32 basevertex, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] ref T3 indices, Int32 instancecount, Int32 basevertex, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Parameter = "count")] IntPtr indices, Int32 instancecount, Int32 basevertex, Int32 baseinstance) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Parameter = "count")] IntPtr indices, Int32 instancecount, Int32 basevertex, UInt32 baseinstance) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[] indices, Int32 instancecount, Int32 basevertex, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[] indices, Int32 instancecount, Int32 basevertex, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,] indices, Int32 instancecount, Int32 basevertex, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,] indices, Int32 instancecount, Int32 basevertex, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,,] indices, Int32 instancecount, Int32 basevertex, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] T3[,,] indices, Int32 instancecount, Int32 basevertex, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] ref T3 indices, Int32 instancecount, Int32 basevertex, Int32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_base_instance]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: count]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            /// <param name="baseinstance">
            /// Specifies the base instance for use in fetching instanced vertex attributes.
            /// </param>
            [AutoGenerated(Category = "EXT_base_instance", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexBaseInstanceEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertexBaseInstance<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Parameter = "count")] ref T3 indices, Int32 instancecount, Int32 basevertex, UInt32 baseinstance)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexEXT")]
            public static void DrawElementsInstancedBaseVertex(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 instancecount, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexEXT")]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexEXT")]
            public static void DrawElementsInstancedBaseVertex(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 instancecount, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexEXT")]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static void DrawElementsInstanced(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static void DrawElementsInstanced(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T5 indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T5 indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T5 indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T5 indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_transform_feedback]
            /// Render primitives using a count derived from a transform feedback object
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="id">
            /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_transform_feedback", Version = "", EntryPoint = "glDrawTransformFeedbackEXT")]
            [CLSCompliant(false)]
            public static void DrawTransformFeedback(OpenTK.Graphics.ES31.All mode, Int32 id) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_transform_feedback]
            /// Render primitives using a count derived from a transform feedback object
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="id">
            /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_transform_feedback", Version = "", EntryPoint = "glDrawTransformFeedbackEXT")]
            [CLSCompliant(false)]
            public static void DrawTransformFeedback(OpenTK.Graphics.ES31.All mode, UInt32 id) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_transform_feedback]
            /// Render primitives using a count derived from a transform feedback object
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="id">
            /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_transform_feedback", Version = "", EntryPoint = "glDrawTransformFeedbackEXT")]
            [CLSCompliant(false)]
            public static void DrawTransformFeedback(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 id) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_transform_feedback]
            /// Render primitives using a count derived from a transform feedback object
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="id">
            /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_transform_feedback", Version = "", EntryPoint = "glDrawTransformFeedbackEXT")]
            [CLSCompliant(false)]
            public static void DrawTransformFeedback(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 id) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_transform_feedback]
            /// Render multiple instances of primitives using a count derived from a transform feedback object
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="id">
            /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the geometry to render.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_transform_feedback", Version = "", EntryPoint = "glDrawTransformFeedbackInstancedEXT")]
            [CLSCompliant(false)]
            public static void DrawTransformFeedbackInstanced(OpenTK.Graphics.ES31.All mode, Int32 id, Int32 instancecount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_transform_feedback]
            /// Render multiple instances of primitives using a count derived from a transform feedback object
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="id">
            /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the geometry to render.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_transform_feedback", Version = "", EntryPoint = "glDrawTransformFeedbackInstancedEXT")]
            [CLSCompliant(false)]
            public static void DrawTransformFeedbackInstanced(OpenTK.Graphics.ES31.All mode, UInt32 id, Int32 instancecount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_transform_feedback]
            /// Render multiple instances of primitives using a count derived from a transform feedback object
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="id">
            /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the geometry to render.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_transform_feedback", Version = "", EntryPoint = "glDrawTransformFeedbackInstancedEXT")]
            [CLSCompliant(false)]
            public static void DrawTransformFeedbackInstanced(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 id, Int32 instancecount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_transform_feedback]
            /// Render multiple instances of primitives using a count derived from a transform feedback object
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="id">
            /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the geometry to render.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_transform_feedback", Version = "", EntryPoint = "glDrawTransformFeedbackInstancedEXT")]
            [CLSCompliant(false)]
            public static void DrawTransformFeedbackInstanced(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 id, Int32 instancecount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Enable or disable server-side GL capabilities
            /// </summary>
            /// <param name="target">
            /// Specifies a symbolic constant indicating a GL capability.
            /// </param>
            /// <param name="index"></param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glEnableiEXT")]
            [CLSCompliant(false)]
            public static void Enable(OpenTK.Graphics.ES31.All target, Int32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Enable or disable server-side GL capabilities
            /// </summary>
            /// <param name="target">
            /// Specifies a symbolic constant indicating a GL capability.
            /// </param>
            /// <param name="index"></param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glEnableiEXT")]
            [CLSCompliant(false)]
            public static void Enable(OpenTK.Graphics.ES31.All target, UInt32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            /// <param name="target"></param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glEndQueryEXT")]
            public static void EndQuery(OpenTK.Graphics.ES31.All target) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_map_buffer_range]
            /// Indicate modifications to a range of a mapped buffer
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the flush operation. target must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="offset">
            /// Specifies the start of the buffer subrange, in basic machine units.
            /// </param>
            /// <param name="length">
            /// Specifies the length of the buffer subrange, in basic machine units.
            /// </param>
            [AutoGenerated(Category = "EXT_map_buffer_range", Version = "", EntryPoint = "glFlushMappedBufferRangeEXT")]
            public static void FlushMappedBufferRange(OpenTK.Graphics.ES31.All target, IntPtr offset, Int32 length) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_map_buffer_range]
            /// Indicate modifications to a range of a mapped buffer
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the flush operation. target must be ArrayBuffer, CopyReadBuffer, CopyWriteBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, TransformFeedbackBuffer, or UniformBuffer.
            /// </param>
            /// <param name="offset">
            /// Specifies the start of the buffer subrange, in basic machine units.
            /// </param>
            /// <param name="length">
            /// Specifies the length of the buffer subrange, in basic machine units.
            /// </param>
            [AutoGenerated(Category = "EXT_map_buffer_range", Version = "", EntryPoint = "glFlushMappedBufferRangeEXT")]
            public static void FlushMappedBufferRange(OpenTK.Graphics.ES31.All target, IntPtr offset, IntPtr length) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_shader_pixel_local_storage2]</summary>
            /// <param name="target"></param>
            /// <param name="size"></param>
            [AutoGenerated(Category = "EXT_shader_pixel_local_storage2", Version = "", EntryPoint = "glFramebufferPixelLocalStorageSizeEXT")]
            [CLSCompliant(false)]
            public static void FramebufferPixelLocalStorageSize(Int32 target, Int32 size) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_shader_pixel_local_storage2]</summary>
            /// <param name="target"></param>
            /// <param name="size"></param>
            [AutoGenerated(Category = "EXT_shader_pixel_local_storage2", Version = "", EntryPoint = "glFramebufferPixelLocalStorageSizeEXT")]
            [CLSCompliant(false)]
            public static void FramebufferPixelLocalStorageSize(UInt32 target, Int32 size) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multisampled_render_to_texture]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="textarget"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="samples"></param>
            [AutoGenerated(Category = "EXT_multisampled_render_to_texture", Version = "", EntryPoint = "glFramebufferTexture2DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void FramebufferTexture2DMultisample(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All textarget, Int32 texture, Int32 level, Int32 samples) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multisampled_render_to_texture]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="textarget"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="samples"></param>
            [AutoGenerated(Category = "EXT_multisampled_render_to_texture", Version = "", EntryPoint = "glFramebufferTexture2DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void FramebufferTexture2DMultisample(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All textarget, UInt32 texture, Int32 level, Int32 samples) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_geometry_shader]
            /// Attach a level of a texture object as a logical buffer to the currently bound framebuffer object
            /// </summary>
            /// <param name="target">
            /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
            /// </param>
            /// <param name="attachment">
            /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachment.
            /// </param>
            /// <param name="texture">
            /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
            /// </param>
            /// <param name="level">
            /// Specifies the mipmap level of texture to attach.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_geometry_shader", Version = "", EntryPoint = "glFramebufferTextureEXT")]
            [CLSCompliant(false)]
            public static void FramebufferTexture(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, Int32 texture, Int32 level) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_geometry_shader]
            /// Attach a level of a texture object as a logical buffer to the currently bound framebuffer object
            /// </summary>
            /// <param name="target">
            /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
            /// </param>
            /// <param name="attachment">
            /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachment.
            /// </param>
            /// <param name="texture">
            /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
            /// </param>
            /// <param name="level">
            /// Specifies the mipmap level of texture to attach.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_geometry_shader", Version = "", EntryPoint = "glFramebufferTextureEXT")]
            [CLSCompliant(false)]
            public static void FramebufferTexture(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, UInt32 texture, Int32 level) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_geometry_shader]
            /// Attach a level of a texture object as a logical buffer to the currently bound framebuffer object
            /// </summary>
            /// <param name="target">
            /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
            /// </param>
            /// <param name="attachment">
            /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachment.
            /// </param>
            /// <param name="texture">
            /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
            /// </param>
            /// <param name="level">
            /// Specifies the mipmap level of texture to attach.
            /// </param>
            [AutoGenerated(Category = "EXT_geometry_shader", Version = "", EntryPoint = "glFramebufferTextureEXT")]
            [CLSCompliant(false)]
            public static void FramebufferTexture(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, Int32 texture, Int32 level) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_geometry_shader]
            /// Attach a level of a texture object as a logical buffer to the currently bound framebuffer object
            /// </summary>
            /// <param name="target">
            /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
            /// </param>
            /// <param name="attachment">
            /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachment.
            /// </param>
            /// <param name="texture">
            /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
            /// </param>
            /// <param name="level">
            /// Specifies the mipmap level of texture to attach.
            /// </param>
            [AutoGenerated(Category = "EXT_geometry_shader", Version = "", EntryPoint = "glFramebufferTextureEXT")]
            [CLSCompliant(false)]
            public static void FramebufferTexture(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, UInt32 texture, Int32 level) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Reserve program pipeline object names
            /// </summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static Int32 GenProgramPipeline() { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Reserve program pipeline object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of program pipeline object names to reserve.
            /// </param>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of into which the reserved names will be written.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static void GenProgramPipelines(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Reserve program pipeline object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of program pipeline object names to reserve.
            /// </param>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of into which the reserved names will be written.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static void GenProgramPipelines(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Reserve program pipeline object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of program pipeline object names to reserve.
            /// </param>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of into which the reserved names will be written.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static unsafe void GenProgramPipelines(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Reserve program pipeline object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of program pipeline object names to reserve.
            /// </param>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of into which the reserved names will be written.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static void GenProgramPipelines(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Reserve program pipeline object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of program pipeline object names to reserve.
            /// </param>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of into which the reserved names will be written.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static void GenProgramPipelines(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Reserve program pipeline object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of program pipeline object names to reserve.
            /// </param>
            /// <param name="pipelines">[length: n]
            /// Specifies an array of into which the reserved names will be written.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            [CLSCompliant(false)]
            public static unsafe void GenProgramPipelines(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* pipelines) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Generate query object names
            /// </summary>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            [CLSCompliant(false)]
            public static Int32 GenQuery() { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of query object names to be generated.
            /// </param>
            /// <param name="ids">[length: n]
            /// Specifies an array in which the generated query object names are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            [CLSCompliant(false)]
            public static void GenQueries(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of query object names to be generated.
            /// </param>
            /// <param name="ids">[length: n]
            /// Specifies an array in which the generated query object names are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            [CLSCompliant(false)]
            public static void GenQueries(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of query object names to be generated.
            /// </param>
            /// <param name="ids">[length: n]
            /// Specifies an array in which the generated query object names are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            [CLSCompliant(false)]
            public static unsafe void GenQueries(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of query object names to be generated.
            /// </param>
            /// <param name="ids">[length: n]
            /// Specifies an array in which the generated query object names are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            [CLSCompliant(false)]
            public static void GenQueries(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of query object names to be generated.
            /// </param>
            /// <param name="ids">[length: n]
            /// Specifies an array in which the generated query object names are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            [CLSCompliant(false)]
            public static void GenQueries(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of query object names to be generated.
            /// </param>
            /// <param name="ids">[length: n]
            /// Specifies an array in which the generated query object names are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            [CLSCompliant(false)]
            public static unsafe void GenQueries(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* ids) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGenSemaphoresEXT")]
            [CLSCompliant(false)]
            public static Int32 GenSemaphore() { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="n"></param>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGenSemaphoresEXT")]
            [CLSCompliant(false)]
            public static void GenSemaphores(Int32 n, [OutAttribute, CountAttribute(Parameter = "count")] Int32[] semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="n"></param>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGenSemaphoresEXT")]
            [CLSCompliant(false)]
            public static void GenSemaphores(Int32 n, [OutAttribute, CountAttribute(Parameter = "count")] out Int32 semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="n"></param>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGenSemaphoresEXT")]
            [CLSCompliant(false)]
            public static unsafe void GenSemaphores(Int32 n, [OutAttribute, CountAttribute(Parameter = "count")] Int32* semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="n"></param>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGenSemaphoresEXT")]
            [CLSCompliant(false)]
            public static void GenSemaphores(Int32 n, [OutAttribute, CountAttribute(Parameter = "count")] UInt32[] semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="n"></param>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGenSemaphoresEXT")]
            [CLSCompliant(false)]
            public static void GenSemaphores(Int32 n, [OutAttribute, CountAttribute(Parameter = "count")] out UInt32 semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="n"></param>
            /// <param name="semaphores">[length: count]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGenSemaphoresEXT")]
            [CLSCompliant(false)]
            public static unsafe void GenSemaphores(Int32 n, [OutAttribute, CountAttribute(Parameter = "count")] UInt32* semaphores) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_blend_func_extended]
            /// Query the bindings of color indices to user-defined varying out variables
            /// </summary>
            /// <param name="program">
            /// The name of the program containing varying out variable whose binding to query
            /// </param>
            /// <param name="name">
            /// The name of the user-defined varying out variable whose index to query
            /// </param>
            [AutoGenerated(Category = "EXT_blend_func_extended", Version = "", EntryPoint = "glGetFragDataIndexEXT")]
            [CLSCompliant(false)]
            public static Int32 GetFragDataIndex(Int32 program, String name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_blend_func_extended]
            /// Query the bindings of color indices to user-defined varying out variables
            /// </summary>
            /// <param name="program">
            /// The name of the program containing varying out variable whose binding to query
            /// </param>
            /// <param name="name">
            /// The name of the user-defined varying out variable whose index to query
            /// </param>
            [AutoGenerated(Category = "EXT_blend_func_extended", Version = "", EntryPoint = "glGetFragDataIndexEXT")]
            [CLSCompliant(false)]
            public static Int32 GetFragDataIndex(UInt32 program, String name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_shader_pixel_local_storage2]</summary>
            /// <param name="target"></param>
            [AutoGenerated(Category = "EXT_shader_pixel_local_storage2", Version = "", EntryPoint = "glGetFramebufferPixelLocalStorageSizeEXT")]
            [CLSCompliant(false)]
            public static Int32 GetFramebufferPixelLocalStorageSize(Int32 target) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_shader_pixel_local_storage2]</summary>
            /// <param name="target"></param>
            [AutoGenerated(Category = "EXT_shader_pixel_local_storage2", Version = "", EntryPoint = "glGetFramebufferPixelLocalStorageSizeEXT")]
            [CLSCompliant(false)]
            public static Int32 GetFramebufferPixelLocalStorageSize(UInt32 target) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetGraphicsResetStatusEXT")]
            public static OpenTK.Graphics.ES31.All GetGraphicsResetStatus() { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data"></param>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            [CLSCompliant(false)]
            public static void GetInteger(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute] Int32[] data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data"></param>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            [CLSCompliant(false)]
            public static void GetInteger(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute] out Int32 data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data"></param>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetInteger(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute] Int32* data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data"></param>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            [CLSCompliant(false)]
            public static void GetInteger(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute] Int32[] data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data"></param>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            [CLSCompliant(false)]
            public static void GetInteger(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute] out Int32 data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data"></param>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetInteger(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute] Int32* data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glGetMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void GetMemoryObjectParameter(Int32 memoryObject, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glGetMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void GetMemoryObjectParameter(Int32 memoryObject, OpenTK.Graphics.ES31.All pname, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glGetMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetMemoryObjectParameter(Int32 memoryObject, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glGetMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void GetMemoryObjectParameter(Int32 memoryObject, OpenTK.Graphics.ES31.MemoryObjectParameterName pname, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glGetMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void GetMemoryObjectParameter(Int32 memoryObject, OpenTK.Graphics.ES31.MemoryObjectParameterName pname, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glGetMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetMemoryObjectParameter(Int32 memoryObject, OpenTK.Graphics.ES31.MemoryObjectParameterName pname, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glGetMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void GetMemoryObjectParameter(UInt32 memoryObject, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glGetMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void GetMemoryObjectParameter(UInt32 memoryObject, OpenTK.Graphics.ES31.All pname, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glGetMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetMemoryObjectParameter(UInt32 memoryObject, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glGetMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void GetMemoryObjectParameter(UInt32 memoryObject, OpenTK.Graphics.ES31.MemoryObjectParameterName pname, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glGetMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void GetMemoryObjectParameter(UInt32 memoryObject, OpenTK.Graphics.ES31.MemoryObjectParameterName pname, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glGetMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetMemoryObjectParameter(UInt32 memoryObject, OpenTK.Graphics.ES31.MemoryObjectParameterName pname, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformfvEXT")]
            [CLSCompliant(false)]
            public static void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Single[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformfvEXT")]
            [CLSCompliant(false)]
            public static void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] out Single @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformfvEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Single* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformfvEXT")]
            [CLSCompliant(false)]
            public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Single[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformfvEXT")]
            [CLSCompliant(false)]
            public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] out Single @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformfvEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Single* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformivEXT")]
            [CLSCompliant(false)]
            public static void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformivEXT")]
            [CLSCompliant(false)]
            public static void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformivEXT")]
            [CLSCompliant(false)]
            public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformivEXT")]
            [CLSCompliant(false)]
            public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_debug_label]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="type">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="@object">
            /// The name of the object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glGetObjectLabelEXT")]
            [CLSCompliant(false)]
            public static void GetObjectLabel(OpenTK.Graphics.ES31.All type, Int32 @object, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_debug_label]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="type">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="@object">
            /// The name of the object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glGetObjectLabelEXT")]
            [CLSCompliant(false)]
            public static void GetObjectLabel(OpenTK.Graphics.ES31.All type, Int32 @object, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_debug_label]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="type">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="@object">
            /// The name of the object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glGetObjectLabelEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetObjectLabel(OpenTK.Graphics.ES31.All type, Int32 @object, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_debug_label]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="type">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="@object">
            /// The name of the object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glGetObjectLabelEXT")]
            [CLSCompliant(false)]
            public static void GetObjectLabel(OpenTK.Graphics.ES31.All type, UInt32 @object, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_debug_label]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="type">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="@object">
            /// The name of the object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glGetObjectLabelEXT")]
            [CLSCompliant(false)]
            public static void GetObjectLabel(OpenTK.Graphics.ES31.All type, UInt32 @object, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_debug_label]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="type">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="@object">
            /// The name of the object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glGetObjectLabelEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetObjectLabel(OpenTK.Graphics.ES31.All type, UInt32 @object, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve the info log string from a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object from which to retrieve the info log.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
            /// </param>
            /// <param name="infoLog">[length: bufSize]
            /// Specifies the address of an array of characters into which will be written the info log for pipeline.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineInfoLogEXT")]
            [CLSCompliant(false)]
            public static void GetProgramPipelineInfoLog(Int32 pipeline, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve the info log string from a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object from which to retrieve the info log.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
            /// </param>
            /// <param name="infoLog">[length: bufSize]
            /// Specifies the address of an array of characters into which will be written the info log for pipeline.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineInfoLogEXT")]
            [CLSCompliant(false)]
            public static void GetProgramPipelineInfoLog(Int32 pipeline, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve the info log string from a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object from which to retrieve the info log.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
            /// </param>
            /// <param name="infoLog">[length: bufSize]
            /// Specifies the address of an array of characters into which will be written the info log for pipeline.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineInfoLogEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramPipelineInfoLog(Int32 pipeline, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve the info log string from a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object from which to retrieve the info log.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
            /// </param>
            /// <param name="infoLog">[length: bufSize]
            /// Specifies the address of an array of characters into which will be written the info log for pipeline.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineInfoLogEXT")]
            [CLSCompliant(false)]
            public static void GetProgramPipelineInfoLog(UInt32 pipeline, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve the info log string from a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object from which to retrieve the info log.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
            /// </param>
            /// <param name="infoLog">[length: bufSize]
            /// Specifies the address of an array of characters into which will be written the info log for pipeline.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineInfoLogEXT")]
            [CLSCompliant(false)]
            public static void GetProgramPipelineInfoLog(UInt32 pipeline, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve the info log string from a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object from which to retrieve the info log.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
            /// </param>
            /// <param name="infoLog">[length: bufSize]
            /// Specifies the address of an array of characters into which will be written the info log for pipeline.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineInfoLogEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramPipelineInfoLog(UInt32 pipeline, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String infoLog) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve properties of a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object whose parameter retrieve.
            /// </param>
            /// <param name="pname">
            /// Specifies the name of the parameter to retrieve.
            /// </param>
            /// <param name="@params">
            /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineivEXT")]
            [CLSCompliant(false)]
            public static void GetProgramPipeline(Int32 pipeline, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve properties of a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object whose parameter retrieve.
            /// </param>
            /// <param name="pname">
            /// Specifies the name of the parameter to retrieve.
            /// </param>
            /// <param name="@params">
            /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineivEXT")]
            [CLSCompliant(false)]
            public static void GetProgramPipeline(Int32 pipeline, OpenTK.Graphics.ES31.All pname, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve properties of a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object whose parameter retrieve.
            /// </param>
            /// <param name="pname">
            /// Specifies the name of the parameter to retrieve.
            /// </param>
            /// <param name="@params">
            /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramPipeline(Int32 pipeline, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve properties of a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object whose parameter retrieve.
            /// </param>
            /// <param name="pname">
            /// Specifies the name of the parameter to retrieve.
            /// </param>
            /// <param name="@params">
            /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineivEXT")]
            [CLSCompliant(false)]
            public static void GetProgramPipeline(UInt32 pipeline, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve properties of a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object whose parameter retrieve.
            /// </param>
            /// <param name="pname">
            /// Specifies the name of the parameter to retrieve.
            /// </param>
            /// <param name="@params">
            /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineivEXT")]
            [CLSCompliant(false)]
            public static void GetProgramPipeline(UInt32 pipeline, OpenTK.Graphics.ES31.All pname, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve properties of a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object whose parameter retrieve.
            /// </param>
            /// <param name="pname">
            /// Specifies the name of the parameter to retrieve.
            /// </param>
            /// <param name="@params">
            /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramPipeline(UInt32 pipeline, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_blend_func_extended]
            /// Query the fragment color index of a named variable within a program
            /// </summary>
            /// <param name="program">
            /// The name of a program object whose resources to query.
            /// </param>
            /// <param name="programInterface">
            /// A token identifying the interface within program containing the resource named name.
            /// </param>
            /// <param name="name">[length: COMPSIZE(name)]
            /// The name of the resource to query the location of.
            /// </param>
            [AutoGenerated(Category = "EXT_blend_func_extended", Version = "", EntryPoint = "glGetProgramResourceLocationIndexEXT")]
            [CLSCompliant(false)]
            public static Int32 GetProgramResourceLocationIndex(Int32 program, OpenTK.Graphics.ES31.All programInterface, [CountAttribute(Computed = "name")] String name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_blend_func_extended]
            /// Query the fragment color index of a named variable within a program
            /// </summary>
            /// <param name="program">
            /// The name of a program object whose resources to query.
            /// </param>
            /// <param name="programInterface">
            /// A token identifying the interface within program containing the resource named name.
            /// </param>
            /// <param name="name">[length: COMPSIZE(name)]
            /// The name of the resource to query the location of.
            /// </param>
            [AutoGenerated(Category = "EXT_blend_func_extended", Version = "", EntryPoint = "glGetProgramResourceLocationIndexEXT")]
            [CLSCompliant(false)]
            public static Int32 GetProgramResourceLocationIndex(UInt32 program, OpenTK.Graphics.ES31.All programInterface, [CountAttribute(Computed = "name")] String name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryivEXT")]
            [CLSCompliant(false)]
            public static void GetQuery(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryivEXT")]
            [CLSCompliant(false)]
            public static void GetQuery(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetQuery(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(pname)]
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            [CLSCompliant(false)]
            public static void GetQueryObject(Int32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(pname)]
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            [CLSCompliant(false)]
            public static void GetQueryObject(Int32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(pname)]
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetQueryObject(Int32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(pname)]
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            [CLSCompliant(false)]
            public static void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(pname)]
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            [CLSCompliant(false)]
            public static void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(pname)]
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            [CLSCompliant(false)]
            public static void GetQueryObject(Int32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            [CLSCompliant(false)]
            public static void GetQueryObject(Int32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetQueryObject(Int32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            [CLSCompliant(false)]
            public static void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            [CLSCompliant(false)]
            public static void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(pname)]
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectui64vEXT")]
            [CLSCompliant(false)]
            public static void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(pname)]
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectui64vEXT")]
            [CLSCompliant(false)]
            public static void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out UInt64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(pname)]
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectui64vEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryObjectuivEXT")]
            [CLSCompliant(false)]
            public static void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute] UInt32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryObjectuivEXT")]
            [CLSCompliant(false)]
            public static void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute] out UInt32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// Specifies the name of a query object.
            /// </param>
            /// <param name="pname">
            /// Specifies the symbolic name of a query object parameter. Accepted values are QueryResult or QueryResultAvailable.
            /// </param>
            /// <param name="@params">
            /// If a buffer is bound to the QueryResultBuffer target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to QueryResultBuffer, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryObjectuivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES31.All pname, [OutAttribute] UInt32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIivEXT")]
            [CLSCompliant(false)]
            public static void GetSamplerParameterI(Int32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIivEXT")]
            [CLSCompliant(false)]
            public static void GetSamplerParameterI(Int32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetSamplerParameterI(Int32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIivEXT")]
            [CLSCompliant(false)]
            public static void GetSamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIivEXT")]
            [CLSCompliant(false)]
            public static void GetSamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetSamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIuivEXT")]
            [CLSCompliant(false)]
            public static void GetSamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIuivEXT")]
            [CLSCompliant(false)]
            public static void GetSamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out UInt32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIuivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetSamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGetSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void GetSemaphoreParameter(Int32 semaphore, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGetSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void GetSemaphoreParameter(Int32 semaphore, OpenTK.Graphics.ES31.All pname, [OutAttribute] out Int64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGetSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetSemaphoreParameter(Int32 semaphore, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGetSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void GetSemaphoreParameter(Int32 semaphore, OpenTK.Graphics.ES31.SemaphoreParameterName pname, [OutAttribute] Int64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGetSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void GetSemaphoreParameter(Int32 semaphore, OpenTK.Graphics.ES31.SemaphoreParameterName pname, [OutAttribute] out Int64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGetSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetSemaphoreParameter(Int32 semaphore, OpenTK.Graphics.ES31.SemaphoreParameterName pname, [OutAttribute] Int64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGetSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void GetSemaphoreParameter(UInt32 semaphore, OpenTK.Graphics.ES31.All pname, [OutAttribute] UInt64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGetSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void GetSemaphoreParameter(UInt32 semaphore, OpenTK.Graphics.ES31.All pname, [OutAttribute] out UInt64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGetSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetSemaphoreParameter(UInt32 semaphore, OpenTK.Graphics.ES31.All pname, [OutAttribute] UInt64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGetSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void GetSemaphoreParameter(UInt32 semaphore, OpenTK.Graphics.ES31.SemaphoreParameterName pname, [OutAttribute] UInt64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGetSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void GetSemaphoreParameter(UInt32 semaphore, OpenTK.Graphics.ES31.SemaphoreParameterName pname, [OutAttribute] out UInt64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glGetSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetSemaphoreParameter(UInt32 semaphore, OpenTK.Graphics.ES31.SemaphoreParameterName pname, [OutAttribute] UInt64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIivEXT")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIivEXT")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetTexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIivEXT")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIivEXT")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetTexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIuivEXT")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIuivEXT")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out UInt32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIuivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetTexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIuivEXT")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIuivEXT")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] out UInt32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIuivEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetTexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytei_vEXT")]
            [CLSCompliant(false)]
            public static void GetUnsignedByte(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] Byte[] data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytei_vEXT")]
            [CLSCompliant(false)]
            public static void GetUnsignedByte(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] out Byte data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytei_vEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetUnsignedByte(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] Byte* data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytei_vEXT")]
            [CLSCompliant(false)]
            public static void GetUnsignedByte(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Byte[] data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytei_vEXT")]
            [CLSCompliant(false)]
            public static void GetUnsignedByte(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] out Byte data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytei_vEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetUnsignedByte(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Byte* data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="pname"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytevEXT")]
            [CLSCompliant(false)]
            public static Byte GetUnsignedByte(OpenTK.Graphics.ES31.All pname) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="pname"></param>
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytevEXT")]
            [CLSCompliant(false)]
            public static Byte GetUnsignedByte(OpenTK.Graphics.ES31.GetPName pname) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytevEXT")]
            [CLSCompliant(false)]
            public static void GetUnsignedByte(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Byte[] data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytevEXT")]
            [CLSCompliant(false)]
            public static void GetUnsignedByte(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Byte data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytevEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetUnsignedByte(OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Byte* data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytevEXT")]
            [CLSCompliant(false)]
            public static void GetUnsignedByte(OpenTK.Graphics.ES31.GetPName pname, [OutAttribute, CountAttribute(Computed = "pname")] Byte[] data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytevEXT")]
            [CLSCompliant(false)]
            public static void GetUnsignedByte(OpenTK.Graphics.ES31.GetPName pname, [OutAttribute, CountAttribute(Computed = "pname")] out Byte data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object|EXT_semaphore]</summary>
            /// <param name="pname"></param>
            /// <param name="data">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_memory_object|EXT_semaphore", Version = "", EntryPoint = "glGetUnsignedBytevEXT")]
            [CLSCompliant(false)]
            public static unsafe void GetUnsignedByte(OpenTK.Graphics.ES31.GetPName pname, [OutAttribute, CountAttribute(Computed = "pname")] Byte* data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_fd]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="fd"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_fd", Version = "", EntryPoint = "glImportMemoryFdEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryF(Int32 memory, Int64 size, OpenTK.Graphics.ES31.All handleType, Int32 fd) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_fd]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="fd"></param>
            [AutoGenerated(Category = "EXT_memory_object_fd", Version = "", EntryPoint = "glImportMemoryFdEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryF(Int32 memory, Int64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, Int32 fd) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_fd]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="fd"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_fd", Version = "", EntryPoint = "glImportMemoryFdEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryF(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.All handleType, Int32 fd) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_fd]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="fd"></param>
            [AutoGenerated(Category = "EXT_memory_object_fd", Version = "", EntryPoint = "glImportMemoryFdEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryF(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, Int32 fd) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle(Int32 memory, Int64 size, OpenTK.Graphics.ES31.All handleType, [OutAttribute] IntPtr handle) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T3[] handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T3[,] handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T3[,,] handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] ref T3 handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle(Int32 memory, Int64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [OutAttribute] IntPtr handle) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T3[] handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T3[,] handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T3[,,] handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] ref T3 handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.All handleType, [OutAttribute] IntPtr handle) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T3[] handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T3[,] handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T3[,,] handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] ref T3 handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [OutAttribute] IntPtr handle) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T3[] handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T3[,] handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T3[,,] handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Handle<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] ref T3 handle)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name(Int32 memory, Int64 size, OpenTK.Graphics.ES31.All handleType, IntPtr name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T3[] name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T3[,] name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T3[,,] name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] ref T3 name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name(Int32 memory, Int64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, IntPtr name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T3[] name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T3[,] name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T3[,,] name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(Int32 memory, Int64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] ref T3 name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.All handleType, IntPtr name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T3[] name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T3[,] name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T3[,,] name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] ref T3 name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, IntPtr name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T3[] name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T3[,] name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T3[,,] name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object_win32]</summary>
            /// <param name="memory"></param>
            /// <param name="size"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_memory_object_win32", Version = "", EntryPoint = "glImportMemoryWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportMemoryWin32Name<T3>(UInt32 memory, UInt64 size, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] ref T3 name)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_fd]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="fd"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_fd", Version = "", EntryPoint = "glImportSemaphoreFdEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreF(Int32 semaphore, OpenTK.Graphics.ES31.All handleType, Int32 fd) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_fd]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="fd"></param>
            [AutoGenerated(Category = "EXT_semaphore_fd", Version = "", EntryPoint = "glImportSemaphoreFdEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreF(Int32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, Int32 fd) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_fd]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="fd"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_fd", Version = "", EntryPoint = "glImportSemaphoreFdEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreF(UInt32 semaphore, OpenTK.Graphics.ES31.All handleType, Int32 fd) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_fd]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="fd"></param>
            [AutoGenerated(Category = "EXT_semaphore_fd", Version = "", EntryPoint = "glImportSemaphoreFdEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreF(UInt32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, Int32 fd) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle(Int32 semaphore, OpenTK.Graphics.ES31.All handleType, [OutAttribute] IntPtr handle) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(Int32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T2[] handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(Int32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T2[,] handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(Int32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T2[,,] handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(Int32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] ref T2 handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle(Int32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [OutAttribute] IntPtr handle) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(Int32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T2[] handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(Int32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T2[,] handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(Int32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T2[,,] handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(Int32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] ref T2 handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle(UInt32 semaphore, OpenTK.Graphics.ES31.All handleType, [OutAttribute] IntPtr handle) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T2[] handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T2[,] handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T2[,,] handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] ref T2 handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle(UInt32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [OutAttribute] IntPtr handle) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T2[] handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T2[,] handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T2[,,] handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32HandleEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Handle<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] ref T2 handle)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name(Int32 semaphore, OpenTK.Graphics.ES31.All handleType, IntPtr name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(Int32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T2[] name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(Int32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T2[,] name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(Int32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T2[,,] name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(Int32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] ref T2 name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name(Int32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, IntPtr name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(Int32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T2[] name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(Int32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T2[,] name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(Int32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T2[,,] name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(Int32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] ref T2 name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name(UInt32 semaphore, OpenTK.Graphics.ES31.All handleType, IntPtr name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T2[] name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T2[,] name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] T2[,,] name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.All handleType, [InAttribute, OutAttribute] ref T2 name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name(UInt32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, IntPtr name) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T2[] name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T2[,] name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] T2[,,] name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore_win32]</summary>
            /// <param name="semaphore"></param>
            /// <param name="handleType"></param>
            /// <param name="name"></param>
            [AutoGenerated(Category = "EXT_semaphore_win32", Version = "", EntryPoint = "glImportSemaphoreWin32NameEXT")]
            [CLSCompliant(false)]
            public static void ImportSemaphoreWin32Name<T2>(UInt32 semaphore, OpenTK.Graphics.ES31.ExternalHandleType handleType, [InAttribute, OutAttribute] ref T2 name)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_debug_marker]</summary>
            /// <param name="length"></param>
            /// <param name="marker"></param>
            [AutoGenerated(Category = "EXT_debug_marker", Version = "", EntryPoint = "glInsertEventMarkerEXT")]
            public static void InsertEventMarker(Int32 length, String marker) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Test whether a capability is enabled
            /// </summary>
            /// <param name="target">
            /// Specifies a symbolic constant indicating a GL capability.
            /// </param>
            /// <param name="index">
            /// Specifies the index of the capability.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glIsEnablediEXT")]
            [CLSCompliant(false)]
            public static bool IsEnabled(OpenTK.Graphics.ES31.All target, Int32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_buffers_indexed]
            /// Test whether a capability is enabled
            /// </summary>
            /// <param name="target">
            /// Specifies a symbolic constant indicating a GL capability.
            /// </param>
            /// <param name="index">
            /// Specifies the index of the capability.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_buffers_indexed", Version = "", EntryPoint = "glIsEnablediEXT")]
            [CLSCompliant(false)]
            public static bool IsEnabled(OpenTK.Graphics.ES31.All target, UInt32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glIsMemoryObjectEXT")]
            [CLSCompliant(false)]
            public static bool IsMemoryObject(Int32 memoryObject) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glIsMemoryObjectEXT")]
            [CLSCompliant(false)]
            public static bool IsMemoryObject(UInt32 memoryObject) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Determine if a name corresponds to a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies a value that may be the name of a program pipeline object.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glIsProgramPipelineEXT")]
            [CLSCompliant(false)]
            public static bool IsProgramPipeline(Int32 pipeline) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Determine if a name corresponds to a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// Specifies a value that may be the name of a program pipeline object.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glIsProgramPipelineEXT")]
            [CLSCompliant(false)]
            public static bool IsProgramPipeline(UInt32 pipeline) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Determine if a name corresponds to a query object
            /// </summary>
            /// <param name="id">
            /// Specifies a value that may be the name of a query object.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glIsQueryEXT")]
            [CLSCompliant(false)]
            public static bool IsQuery(Int32 id) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Determine if a name corresponds to a query object
            /// </summary>
            /// <param name="id">
            /// Specifies a value that may be the name of a query object.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glIsQueryEXT")]
            [CLSCompliant(false)]
            public static bool IsQuery(UInt32 id) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glIsSemaphoreEXT")]
            [CLSCompliant(false)]
            public static bool IsSemaphore(Int32 semaphore) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glIsSemaphoreEXT")]
            [CLSCompliant(false)]
            public static bool IsSemaphore(UInt32 semaphore) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_debug_label]</summary>
            /// <param name="type"></param>
            /// <param name="@object"></param>
            /// <param name="length"></param>
            /// <param name="label"></param>
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glLabelObjectEXT")]
            [CLSCompliant(false)]
            public static void LabelObject(OpenTK.Graphics.ES31.All type, Int32 @object, Int32 length, String label) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_debug_label]</summary>
            /// <param name="type"></param>
            /// <param name="@object"></param>
            /// <param name="length"></param>
            /// <param name="label"></param>
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glLabelObjectEXT")]
            [CLSCompliant(false)]
            public static void LabelObject(OpenTK.Graphics.ES31.All type, UInt32 @object, Int32 length, String label) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_map_buffer_range]
            /// Map a section of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// Specifies a binding to which the target buffer is bound.
            /// </param>
            /// <param name="offset">
            /// Specifies the starting offset within the buffer of the range to be mapped.
            /// </param>
            /// <param name="length">
            /// Specifies the length of the range to be mapped.
            /// </param>
            /// <param name="access">
            /// Specifies a combination of access flags indicating the desired access to the range.
            /// </param>
            [AutoGenerated(Category = "EXT_map_buffer_range", Version = "", EntryPoint = "glMapBufferRangeEXT")]
            [CLSCompliant(false)]
            public static IntPtr MapBufferRange(OpenTK.Graphics.ES31.All target, IntPtr offset, Int32 length, Int32 access) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_map_buffer_range]
            /// Map a section of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// Specifies a binding to which the target buffer is bound.
            /// </param>
            /// <param name="offset">
            /// Specifies the starting offset within the buffer of the range to be mapped.
            /// </param>
            /// <param name="length">
            /// Specifies the length of the range to be mapped.
            /// </param>
            /// <param name="access">
            /// Specifies a combination of access flags indicating the desired access to the range.
            /// </param>
            [AutoGenerated(Category = "EXT_map_buffer_range", Version = "", EntryPoint = "glMapBufferRangeEXT")]
            [CLSCompliant(false)]
            public static IntPtr MapBufferRange(OpenTK.Graphics.ES31.All target, IntPtr offset, Int32 length, UInt32 access) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_map_buffer_range]
            /// Map a section of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// Specifies a binding to which the target buffer is bound.
            /// </param>
            /// <param name="offset">
            /// Specifies the starting offset within the buffer of the range to be mapped.
            /// </param>
            /// <param name="length">
            /// Specifies the length of the range to be mapped.
            /// </param>
            /// <param name="access">
            /// Specifies a combination of access flags indicating the desired access to the range.
            /// </param>
            [AutoGenerated(Category = "EXT_map_buffer_range", Version = "", EntryPoint = "glMapBufferRangeEXT")]
            [CLSCompliant(false)]
            public static IntPtr MapBufferRange(OpenTK.Graphics.ES31.All target, IntPtr offset, IntPtr length, Int32 access) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_map_buffer_range]
            /// Map a section of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// Specifies a binding to which the target buffer is bound.
            /// </param>
            /// <param name="offset">
            /// Specifies the starting offset within the buffer of the range to be mapped.
            /// </param>
            /// <param name="length">
            /// Specifies the length of the range to be mapped.
            /// </param>
            /// <param name="access">
            /// Specifies a combination of access flags indicating the desired access to the range.
            /// </param>
            [AutoGenerated(Category = "EXT_map_buffer_range", Version = "", EntryPoint = "glMapBufferRangeEXT")]
            [CLSCompliant(false)]
            public static IntPtr MapBufferRange(OpenTK.Graphics.ES31.All target, IntPtr offset, IntPtr length, UInt32 access) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void MemoryObjectParameter(Int32 memoryObject, OpenTK.Graphics.ES31.All pname, Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void MemoryObjectParameter(Int32 memoryObject, OpenTK.Graphics.ES31.All pname, ref Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static unsafe void MemoryObjectParameter(Int32 memoryObject, OpenTK.Graphics.ES31.All pname, Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void MemoryObjectParameter(Int32 memoryObject, OpenTK.Graphics.ES31.MemoryObjectParameterName pname, Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void MemoryObjectParameter(Int32 memoryObject, OpenTK.Graphics.ES31.MemoryObjectParameterName pname, ref Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static unsafe void MemoryObjectParameter(Int32 memoryObject, OpenTK.Graphics.ES31.MemoryObjectParameterName pname, Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void MemoryObjectParameter(UInt32 memoryObject, OpenTK.Graphics.ES31.All pname, Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void MemoryObjectParameter(UInt32 memoryObject, OpenTK.Graphics.ES31.All pname, ref Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static unsafe void MemoryObjectParameter(UInt32 memoryObject, OpenTK.Graphics.ES31.All pname, Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void MemoryObjectParameter(UInt32 memoryObject, OpenTK.Graphics.ES31.MemoryObjectParameterName pname, Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static void MemoryObjectParameter(UInt32 memoryObject, OpenTK.Graphics.ES31.MemoryObjectParameterName pname, ref Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="memoryObject"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glMemoryObjectParameterivEXT")]
            [CLSCompliant(false)]
            public static unsafe void MemoryObjectParameter(UInt32 memoryObject, OpenTK.Graphics.ES31.MemoryObjectParameterName pname, Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="first">[length: COMPSIZE(primcount)]
            /// Points to an array of starting indices in the enabled arrays.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the number of indices to be rendered.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the first and count
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawArraysEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawArrays(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] Int32[] first, [CountAttribute(Computed = "primcount")] Int32[] count, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="first">[length: COMPSIZE(primcount)]
            /// Points to an array of starting indices in the enabled arrays.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the number of indices to be rendered.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the first and count
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawArraysEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawArrays(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] ref Int32 first, [CountAttribute(Computed = "primcount")] ref Int32 count, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="first">[length: COMPSIZE(primcount)]
            /// Points to an array of starting indices in the enabled arrays.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the number of indices to be rendered.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the first and count
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawArraysEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawArrays(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] Int32* first, [CountAttribute(Computed = "primcount")] Int32* count, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="first">[length: COMPSIZE(primcount)]
            /// Points to an array of starting indices in the enabled arrays.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the number of indices to be rendered.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the first and count
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawArraysEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawArrays(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] Int32[] first, [CountAttribute(Computed = "primcount")] Int32[] count, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="first">[length: COMPSIZE(primcount)]
            /// Points to an array of starting indices in the enabled arrays.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the number of indices to be rendered.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the first and count
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawArraysEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawArrays(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] ref Int32 first, [CountAttribute(Computed = "primcount")] ref Int32 count, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="first">[length: COMPSIZE(primcount)]
            /// Points to an array of starting indices in the enabled arrays.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the number of indices to be rendered.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the first and count
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawArraysEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawArrays(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] Int32* first, [CountAttribute(Computed = "primcount")] Int32* count, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render multiple sets of primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of an array of structures containing the draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the the number of elements in the array of draw parameter structures.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawArraysIndirectEXT")]
            public static void MultiDrawArraysIndirect(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount,stride")] IntPtr indirect, Int32 drawcount, Int32 stride) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render multiple sets of primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of an array of structures containing the draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the the number of elements in the array of draw parameter structures.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawArraysIndirectEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawArraysIndirect<T1>(OpenTK.Graphics.ES31.All mode, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] T1[] indirect, Int32 drawcount, Int32 stride)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render multiple sets of primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of an array of structures containing the draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the the number of elements in the array of draw parameter structures.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawArraysIndirectEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawArraysIndirect<T1>(OpenTK.Graphics.ES31.All mode, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] T1[,] indirect, Int32 drawcount, Int32 stride)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render multiple sets of primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of an array of structures containing the draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the the number of elements in the array of draw parameter structures.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawArraysIndirectEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawArraysIndirect<T1>(OpenTK.Graphics.ES31.All mode, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] T1[,,] indirect, Int32 drawcount, Int32 stride)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render multiple sets of primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of an array of structures containing the draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the the number of elements in the array of draw parameter structures.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawArraysIndirectEXT")]
            public static void MultiDrawArraysIndirect<T1>(OpenTK.Graphics.ES31.All mode, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] ref T1 indirect, Int32 drawcount, Int32 stride)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render multiple sets of primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of an array of structures containing the draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the the number of elements in the array of draw parameter structures.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawArraysIndirectEXT")]
            public static void MultiDrawArraysIndirect(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount,stride")] IntPtr indirect, Int32 drawcount, Int32 stride) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render multiple sets of primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of an array of structures containing the draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the the number of elements in the array of draw parameter structures.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawArraysIndirectEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawArraysIndirect<T1>(OpenTK.Graphics.ES31.PrimitiveType mode, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] T1[] indirect, Int32 drawcount, Int32 stride)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render multiple sets of primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of an array of structures containing the draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the the number of elements in the array of draw parameter structures.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawArraysIndirectEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawArraysIndirect<T1>(OpenTK.Graphics.ES31.PrimitiveType mode, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] T1[,] indirect, Int32 drawcount, Int32 stride)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render multiple sets of primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of an array of structures containing the draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the the number of elements in the array of draw parameter structures.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawArraysIndirectEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawArraysIndirect<T1>(OpenTK.Graphics.ES31.PrimitiveType mode, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] T1[,,] indirect, Int32 drawcount, Int32 stride)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render multiple sets of primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of an array of structures containing the draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the the number of elements in the array of draw parameter structures.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawArraysIndirectEXT")]
            public static void MultiDrawArraysIndirect<T1>(OpenTK.Graphics.ES31.PrimitiveType mode, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] ref T1 indirect, Int32 drawcount, Int32 stride)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] Int32[] count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "drawcount")] IntPtr indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32[] basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] Int32[] count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32[] basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] Int32[] count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[,] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32[] basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] Int32[] count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[,,] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32[] basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] Int32[] count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] ref T3 indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32[] basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] ref Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "drawcount")] IntPtr indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] ref Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] ref Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] ref Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] ref Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[,] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] ref Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] ref Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[,,] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] ref Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] ref Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] ref T3 indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] ref Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElementsBaseVertex(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] Int32* count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "drawcount")] IntPtr indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32* basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] Int32* count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32* basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] Int32* count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[,] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32* basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] Int32* count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[,,] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32* basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "drawcount")] Int32* count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] ref T3 indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32* basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] Int32[] count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "drawcount")] IntPtr indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32[] basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] Int32[] count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32[] basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] Int32[] count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[,] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32[] basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] Int32[] count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[,,] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32[] basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] Int32[] count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] ref T3 indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32[] basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] ref Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "drawcount")] IntPtr indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] ref Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] ref Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] ref Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] ref Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[,] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] ref Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] ref Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[,,] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] ref Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] ref Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] ref T3 indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] ref Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElementsBaseVertex(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] Int32* count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "drawcount")] IntPtr indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32* basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] Int32* count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32* basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] Int32* count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[,] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32* basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] Int32* count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] T3[,,] indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32* basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex]
            /// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(drawcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count, indices and basevertex arrays.
            /// </param>
            /// <param name="basevertex">[length: COMPSIZE(drawcount)]
            /// Specifies a pointer to the location where the base vertices are stored.
            /// </param>
            [AutoGenerated(Category = "EXT_draw_elements_base_vertex|OES_draw_elements_base_vertex", Version = "", EntryPoint = "glMultiDrawElementsBaseVertexEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "drawcount")] Int32* count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount")] ref T3 indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32* basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] Int32[] count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "primcount")] IntPtr indices, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] Int32[] count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] Int32[] count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] Int32[] count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[,,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] Int32[] count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] ref T3 indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] ref Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "primcount")] IntPtr indices, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] ref Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] ref Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] ref Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[,,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] ref Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] ref T3 indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElements(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] Int32* count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "primcount")] IntPtr indices, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] Int32* count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] Int32* count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] Int32* count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[,,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES31.All mode, [CountAttribute(Computed = "primcount")] Int32* count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] ref T3 indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] Int32[] count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "primcount")] IntPtr indices, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] Int32[] count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] Int32[] count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] Int32[] count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[,,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] Int32[] count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] ref T3 indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] ref Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "primcount")] IntPtr indices, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] ref Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] ref Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] ref Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[,,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] ref Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] ref T3 indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElements(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] Int32* count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "primcount")] IntPtr indices, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] Int32* count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] Int32* count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] Int32* count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] T3[,,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">[length: COMPSIZE(primcount)]
            /// Points to an array of the elements counts.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(primcount)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the size of the count and indices arrays.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            [CLSCompliant(false)]
            public static unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, [CountAttribute(Computed = "primcount")] Int32* count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "primcount")] ref T3 indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render indexed primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="type">
            /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of a structure containing an array of draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the number of elements in the array addressed by indirect.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawElementsIndirectEXT")]
            public static void MultiDrawElementsIndirect(OpenTK.Graphics.ES31.All mode, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "drawcount,stride")] IntPtr indirect, Int32 drawcount, Int32 stride) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render indexed primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="type">
            /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of a structure containing an array of draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the number of elements in the array addressed by indirect.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawElementsIndirectEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsIndirect<T2>(OpenTK.Graphics.ES31.All mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] T2[] indirect, Int32 drawcount, Int32 stride)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render indexed primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="type">
            /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of a structure containing an array of draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the number of elements in the array addressed by indirect.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawElementsIndirectEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsIndirect<T2>(OpenTK.Graphics.ES31.All mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] T2[,] indirect, Int32 drawcount, Int32 stride)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render indexed primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="type">
            /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of a structure containing an array of draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the number of elements in the array addressed by indirect.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawElementsIndirectEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsIndirect<T2>(OpenTK.Graphics.ES31.All mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] T2[,,] indirect, Int32 drawcount, Int32 stride)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render indexed primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="type">
            /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of a structure containing an array of draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the number of elements in the array addressed by indirect.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawElementsIndirectEXT")]
            public static void MultiDrawElementsIndirect<T2>(OpenTK.Graphics.ES31.All mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] ref T2 indirect, Int32 drawcount, Int32 stride)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render indexed primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="type">
            /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of a structure containing an array of draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the number of elements in the array addressed by indirect.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawElementsIndirectEXT")]
            public static void MultiDrawElementsIndirect(OpenTK.Graphics.ES31.PrimitiveType mode, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "drawcount,stride")] IntPtr indirect, Int32 drawcount, Int32 stride) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render indexed primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="type">
            /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of a structure containing an array of draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the number of elements in the array addressed by indirect.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawElementsIndirectEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsIndirect<T2>(OpenTK.Graphics.ES31.PrimitiveType mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] T2[] indirect, Int32 drawcount, Int32 stride)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render indexed primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="type">
            /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of a structure containing an array of draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the number of elements in the array addressed by indirect.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawElementsIndirectEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsIndirect<T2>(OpenTK.Graphics.ES31.PrimitiveType mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] T2[,] indirect, Int32 drawcount, Int32 stride)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render indexed primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="type">
            /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of a structure containing an array of draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the number of elements in the array addressed by indirect.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawElementsIndirectEXT")]
            [CLSCompliant(false)]
            public static void MultiDrawElementsIndirect<T2>(OpenTK.Graphics.ES31.PrimitiveType mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] T2[,,] indirect, Int32 drawcount, Int32 stride)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multi_draw_indirect]
            /// Render indexed primitives from array data, taking parameters from memory
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, LineStripAdjacency, LinesAdjacency, TriangleStrip, TriangleFan, Triangles, TriangleStripAdjacency, TrianglesAdjacency, and Patches are accepted.
            /// </param>
            /// <param name="type">
            /// Specifies the type of data in the buffer bound to the ElementArrayBuffer binding.
            /// </param>
            /// <param name="indirect">[length: COMPSIZE(drawcount,stride)]
            /// Specifies the address of a structure containing an array of draw parameters.
            /// </param>
            /// <param name="drawcount">
            /// Specifies the number of elements in the array addressed by indirect.
            /// </param>
            /// <param name="stride">
            /// Specifies the distance in basic machine units between elements of the draw parameter array.
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_indirect", Version = "", EntryPoint = "glMultiDrawElementsIndirectEXT")]
            public static void MultiDrawElementsIndirect<T2>(OpenTK.Graphics.ES31.PrimitiveType mode, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "drawcount,stride")] ref T2 indirect, Int32 drawcount, Int32 stride)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_external_buffer]</summary>
            /// <param name="buffer"></param>
            /// <param name="offset"></param>
            /// <param name="size"></param>
            /// <param name="clientBuffer"></param>
            /// <param name="flags"></param>
            [AutoGenerated(Category = "EXT_external_buffer", Version = "", EntryPoint = "glNamedBufferStorageExternalEXT")]
            [CLSCompliant(false)]
            public static void NamedBufferStorageExternal(Int32 buffer, IntPtr offset, Int32 size, IntPtr clientBuffer, Int32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_external_buffer]</summary>
            /// <param name="buffer"></param>
            /// <param name="offset"></param>
            /// <param name="size"></param>
            /// <param name="clientBuffer"></param>
            /// <param name="flags"></param>
            [AutoGenerated(Category = "EXT_external_buffer", Version = "", EntryPoint = "glNamedBufferStorageExternalEXT")]
            [CLSCompliant(false)]
            public static void NamedBufferStorageExternal(Int32 buffer, IntPtr offset, IntPtr size, IntPtr clientBuffer, Int32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_external_buffer]</summary>
            /// <param name="buffer"></param>
            /// <param name="offset"></param>
            /// <param name="size"></param>
            /// <param name="clientBuffer"></param>
            /// <param name="flags"></param>
            [AutoGenerated(Category = "EXT_external_buffer", Version = "", EntryPoint = "glNamedBufferStorageExternalEXT")]
            [CLSCompliant(false)]
            public static void NamedBufferStorageExternal(UInt32 buffer, IntPtr offset, Int32 size, IntPtr clientBuffer, UInt32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_external_buffer]</summary>
            /// <param name="buffer"></param>
            /// <param name="offset"></param>
            /// <param name="size"></param>
            /// <param name="clientBuffer"></param>
            /// <param name="flags"></param>
            [AutoGenerated(Category = "EXT_external_buffer", Version = "", EntryPoint = "glNamedBufferStorageExternalEXT")]
            [CLSCompliant(false)]
            public static void NamedBufferStorageExternal(UInt32 buffer, IntPtr offset, IntPtr size, IntPtr clientBuffer, UInt32 flags) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="buffer"></param>
            /// <param name="size"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glNamedBufferStorageMemEXT")]
            [CLSCompliant(false)]
            public static void NamedBufferStorageMem(Int32 buffer, Int32 size, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="buffer"></param>
            /// <param name="size"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glNamedBufferStorageMemEXT")]
            [CLSCompliant(false)]
            public static void NamedBufferStorageMem(Int32 buffer, IntPtr size, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="buffer"></param>
            /// <param name="size"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glNamedBufferStorageMemEXT")]
            [CLSCompliant(false)]
            public static void NamedBufferStorageMem(UInt32 buffer, Int32 size, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="buffer"></param>
            /// <param name="size"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glNamedBufferStorageMemEXT")]
            [CLSCompliant(false)]
            public static void NamedBufferStorageMem(UInt32 buffer, IntPtr size, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_tessellation_shader]
            /// Specifies the parameters for patch primitives
            /// </summary>
            /// <param name="pname">
            /// Specifies the name of the parameter to set. The symbolc constants PatchVertices, PatchDefaultOuterLevel, and PatchDefaultInnerLevel are accepted.
            /// </param>
            /// <param name="value">
            /// Specifies the new value for the parameter given by pname.
            /// </param>
            [AutoGenerated(Category = "EXT_tessellation_shader", Version = "", EntryPoint = "glPatchParameteriEXT")]
            public static void PatchParameter(OpenTK.Graphics.ES31.All pname, Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_polygon_offset_clamp]</summary>
            /// <param name="factor"></param>
            /// <param name="units"></param>
            /// <param name="clamp"></param>
            [AutoGenerated(Category = "EXT_polygon_offset_clamp", Version = "", EntryPoint = "glPolygonOffsetClampEXT")]
            public static void PolygonOffsetClamp(Single factor, Single units, Single clamp) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_debug_marker]</summary>
            [AutoGenerated(Category = "EXT_debug_marker", Version = "", EntryPoint = "glPopGroupMarkerEXT")]
            public static void PopGroupMarker() { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_primitive_bounding_box]</summary>
            /// <param name="minX"></param>
            /// <param name="minY"></param>
            /// <param name="minZ"></param>
            /// <param name="minW"></param>
            /// <param name="maxX"></param>
            /// <param name="maxY"></param>
            /// <param name="maxZ"></param>
            /// <param name="maxW"></param>
            [AutoGenerated(Category = "EXT_primitive_bounding_box", Version = "", EntryPoint = "glPrimitiveBoundingBoxEXT")]
            public static void PrimitiveBoundingBox(Single minX, Single minY, Single minZ, Single minW, Single maxX, Single maxY, Single maxZ, Single maxW) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify a parameter for a program object
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose parameter to modify.
            /// </param>
            /// <param name="pname">
            /// Specifies the name of the parameter to modify.
            /// </param>
            /// <param name="value">
            /// Specifies the new value of the parameter specified by pname for program.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramParameteriEXT")]
            [CLSCompliant(false)]
            public static void ProgramParameter(Int32 program, OpenTK.Graphics.ES31.All pname, Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify a parameter for a program object
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose parameter to modify.
            /// </param>
            /// <param name="pname">
            /// Specifies the name of the parameter to modify.
            /// </param>
            /// <param name="value">
            /// Specifies the new value of the parameter specified by pname for program.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramParameteriEXT")]
            [CLSCompliant(false)]
            public static void ProgramParameter(UInt32 program, OpenTK.Graphics.ES31.All pname, Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(Int32 program, Int32 location, Single v0) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, Single v0) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1iEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(Int32 program, Int32 location, Int32 v0) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1iEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, Int32 v0) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1uiEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, UInt32 v0) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1uivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1uivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref UInt32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1uivEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(Int32 program, Int32 location, Single v0, Single v1) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, Single v0, Single v1) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform2(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2iEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(Int32 program, Int32 location, Int32 v0, Int32 v1) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2iEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, Int32 v0, Int32 v1) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2ivEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform2(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2ivEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2uiEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, UInt32 v0, UInt32 v1) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2uivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2uivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] ref UInt32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2uivEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v2">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(Int32 program, Int32 location, Single v0, Single v1, Single v2) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v2">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, Single v0, Single v1, Single v2) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v2">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3iEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(Int32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v2">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3iEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v2">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3uiEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, UInt32 v0, UInt32 v1, UInt32 v2) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3uivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3uivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref UInt32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3uivEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v2">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v3">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(Int32 program, Int32 location, Single v0, Single v1, Single v2, Single v3) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v2">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v3">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, Single v0, Single v1, Single v2, Single v3) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v2">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v3">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4iEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(Int32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v2">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v3">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4iEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="v0">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v1">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v2">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="v3">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4uiEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, UInt32 v0, UInt32 v1, UInt32 v2, UInt32 v3) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4uivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4uivEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref UInt32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4uivEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*4]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*4]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*4]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*4]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*4]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*4]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix2x3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix2x3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix2x3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix2x3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix2x3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix2x3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix2x4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix2x4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix2x4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix2x4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix2x4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix2x4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*9]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*9]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*9]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*9]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*9]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*9]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix3x2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix3x2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix3x2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix3x2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix3x2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix3x2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix3x4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix3x4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix3x4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix3x4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix3x4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix3x4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects|EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*16]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects|EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects|EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*16]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects|EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects|EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*16]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects|EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix4(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects|EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*16]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects|EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects|EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*16]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects|EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects|EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*16]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects|EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix4(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix4x2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix4x2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix4x2(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix4x2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix4x2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix4x2(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix4x3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix4x3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix4x3(Int32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix4x3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            [CLSCompliant(false)]
            public static void ProgramUniformMatrix4x3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformMatrix4x3(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_debug_marker]</summary>
            /// <param name="length"></param>
            /// <param name="marker"></param>
            [AutoGenerated(Category = "EXT_debug_marker", Version = "", EntryPoint = "glPushGroupMarkerEXT")]
            public static void PushGroupMarker(Int32 length, String marker) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.
            /// </summary>
            /// <param name="id">
            /// Specify the name of a query object into which to record the GL time.
            /// </param>
            /// <param name="target">
            /// Specify the counter to query. target must be Timestamp.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glQueryCounterEXT")]
            [CLSCompliant(false)]
            public static void QueryCounter(Int32 id, OpenTK.Graphics.ES31.All target) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.
            /// </summary>
            /// <param name="id">
            /// Specify the name of a query object into which to record the GL time.
            /// </param>
            /// <param name="target">
            /// Specify the counter to query. target must be Timestamp.
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glQueryCounterEXT")]
            [CLSCompliant(false)]
            public static void QueryCounter(UInt32 id, OpenTK.Graphics.ES31.All target) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_raster_multisample|EXT_texture_filter_minmax|NV_framebuffer_mixed_samples]</summary>
            /// <param name="samples"></param>
            /// <param name="fixedsamplelocations"></param>
            [AutoGenerated(Category = "EXT_raster_multisample|EXT_texture_filter_minmax|NV_framebuffer_mixed_samples", Version = "", EntryPoint = "glRasterSamplesEXT")]
            [CLSCompliant(false)]
            public static void RasterSamples(Int32 samples, bool fixedsamplelocations) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_raster_multisample|EXT_texture_filter_minmax|NV_framebuffer_mixed_samples]</summary>
            /// <param name="samples"></param>
            /// <param name="fixedsamplelocations"></param>
            [AutoGenerated(Category = "EXT_raster_multisample|EXT_texture_filter_minmax|NV_framebuffer_mixed_samples", Version = "", EntryPoint = "glRasterSamplesEXT")]
            [CLSCompliant(false)]
            public static void RasterSamples(UInt32 samples, bool fixedsamplelocations) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            /// <param name="src"></param>
            /// <param name="index"></param>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glReadBufferIndexedEXT")]
            public static void ReadBufferIndexed(OpenTK.Graphics.ES31.All src, Int32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glReadnPixelsEXT")]
            public static void ReadnPixels(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr data) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glReadnPixelsEXT")]
            [CLSCompliant(false)]
            public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T7[] data)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glReadnPixelsEXT")]
            [CLSCompliant(false)]
            public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T7[,] data)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glReadnPixelsEXT")]
            [CLSCompliant(false)]
            public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T7[,,] data)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glReadnPixelsEXT")]
            public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] ref T7 data)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_win32_keyed_mutex]</summary>
            /// <param name="memory"></param>
            /// <param name="key"></param>
            [AutoGenerated(Category = "EXT_win32_keyed_mutex", Version = "", EntryPoint = "glReleaseKeyedMutexWin32EXT")]
            [CLSCompliant(false)]
            public static bool ReleaseKeyedMutexWin32(Int32 memory, Int64 key) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_win32_keyed_mutex]</summary>
            /// <param name="memory"></param>
            /// <param name="key"></param>
            [AutoGenerated(Category = "EXT_win32_keyed_mutex", Version = "", EntryPoint = "glReleaseKeyedMutexWin32EXT")]
            [CLSCompliant(false)]
            public static bool ReleaseKeyedMutexWin32(UInt32 memory, UInt64 key) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_multisampled_render_to_texture]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// Specifies a binding to which the target of the allocation and must be Renderbuffer.
            /// </param>
            /// <param name="samples">
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the renderbuffer, in pixels.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the renderbuffer, in pixels.
            /// </param>
            [AutoGenerated(Category = "EXT_multisampled_render_to_texture", Version = "", EntryPoint = "glRenderbufferStorageMultisampleEXT")]
            public static void RenderbufferStorageMultisample(OpenTK.Graphics.ES31.All target, Int32 samples, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIivEXT")]
            [CLSCompliant(false)]
            public static void SamplerParameterI(Int32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32[] param) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIivEXT")]
            [CLSCompliant(false)]
            public static void SamplerParameterI(Int32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] ref Int32 param) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIivEXT")]
            [CLSCompliant(false)]
            public static unsafe void SamplerParameterI(Int32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32* param) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIivEXT")]
            [CLSCompliant(false)]
            public static void SamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32[] param) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIivEXT")]
            [CLSCompliant(false)]
            public static void SamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] ref Int32 param) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIivEXT")]
            [CLSCompliant(false)]
            public static unsafe void SamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32* param) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIuivEXT")]
            [CLSCompliant(false)]
            public static void SamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] UInt32[] param) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIuivEXT")]
            [CLSCompliant(false)]
            public static void SamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] ref UInt32 param) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIuivEXT")]
            [CLSCompliant(false)]
            public static unsafe void SamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] UInt32* param) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void SemaphoreParameter(Int32 semaphore, OpenTK.Graphics.ES31.All pname, Int64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void SemaphoreParameter(Int32 semaphore, OpenTK.Graphics.ES31.All pname, ref Int64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static unsafe void SemaphoreParameter(Int32 semaphore, OpenTK.Graphics.ES31.All pname, Int64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void SemaphoreParameter(Int32 semaphore, OpenTK.Graphics.ES31.SemaphoreParameterName pname, Int64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void SemaphoreParameter(Int32 semaphore, OpenTK.Graphics.ES31.SemaphoreParameterName pname, ref Int64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static unsafe void SemaphoreParameter(Int32 semaphore, OpenTK.Graphics.ES31.SemaphoreParameterName pname, Int64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void SemaphoreParameter(UInt32 semaphore, OpenTK.Graphics.ES31.All pname, UInt64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void SemaphoreParameter(UInt32 semaphore, OpenTK.Graphics.ES31.All pname, ref UInt64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static unsafe void SemaphoreParameter(UInt32 semaphore, OpenTK.Graphics.ES31.All pname, UInt64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void SemaphoreParameter(UInt32 semaphore, OpenTK.Graphics.ES31.SemaphoreParameterName pname, UInt64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static void SemaphoreParameter(UInt32 semaphore, OpenTK.Graphics.ES31.SemaphoreParameterName pname, ref UInt64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSemaphoreParameterui64vEXT")]
            [CLSCompliant(false)]
            public static unsafe void SemaphoreParameter(UInt32 semaphore, OpenTK.Graphics.ES31.SemaphoreParameterName pname, UInt64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="dstLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSignalSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void SignalSemaphore(Int32 semaphore, Int32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] Int32[] buffers, Int32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] Int32[] textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.All[] dstLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="dstLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSignalSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void SignalSemaphore(Int32 semaphore, Int32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] Int32[] buffers, Int32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] Int32[] textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.TextureLayout[] dstLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="dstLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSignalSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void SignalSemaphore(Int32 semaphore, Int32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] ref Int32 buffers, Int32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] ref Int32 textures, [CountAttribute(Computed = "numTextureBarriers")] ref OpenTK.Graphics.ES31.All dstLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="dstLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSignalSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void SignalSemaphore(Int32 semaphore, Int32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] ref Int32 buffers, Int32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] ref Int32 textures, [CountAttribute(Computed = "numTextureBarriers")] ref OpenTK.Graphics.ES31.TextureLayout dstLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="dstLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSignalSemaphoreEXT")]
            [CLSCompliant(false)]
            public static unsafe void SignalSemaphore(Int32 semaphore, Int32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] Int32* buffers, Int32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] Int32* textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.All* dstLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="dstLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSignalSemaphoreEXT")]
            [CLSCompliant(false)]
            public static unsafe void SignalSemaphore(Int32 semaphore, Int32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] Int32* buffers, Int32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] Int32* textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.TextureLayout* dstLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="dstLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSignalSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void SignalSemaphore(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] UInt32[] buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] UInt32[] textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.All[] dstLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="dstLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSignalSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void SignalSemaphore(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] UInt32[] buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] UInt32[] textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.TextureLayout[] dstLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="dstLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSignalSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void SignalSemaphore(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] ref UInt32 buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] ref UInt32 textures, [CountAttribute(Computed = "numTextureBarriers")] ref OpenTK.Graphics.ES31.All dstLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="dstLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSignalSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void SignalSemaphore(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] ref UInt32 buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] ref UInt32 textures, [CountAttribute(Computed = "numTextureBarriers")] ref OpenTK.Graphics.ES31.TextureLayout dstLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="dstLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSignalSemaphoreEXT")]
            [CLSCompliant(false)]
            public static unsafe void SignalSemaphore(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] UInt32* buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] UInt32* textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.All* dstLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="dstLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glSignalSemaphoreEXT")]
            [CLSCompliant(false)]
            public static unsafe void SignalSemaphore(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] UInt32* buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] UInt32* textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.TextureLayout* dstLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_buffer]
            /// Attach the storage for a buffer object to the active buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_buffer", Version = "", EntryPoint = "glTexBufferEXT")]
            [CLSCompliant(false)]
            public static void TexBuffer(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, Int32 buffer) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_buffer]
            /// Attach the storage for a buffer object to the active buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_buffer", Version = "", EntryPoint = "glTexBufferEXT")]
            [CLSCompliant(false)]
            public static void TexBuffer(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, UInt32 buffer) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_buffer]
            /// Attach the storage for a buffer object to the active buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            [AutoGenerated(Category = "EXT_texture_buffer", Version = "", EntryPoint = "glTexBufferEXT")]
            [CLSCompliant(false)]
            public static void TexBuffer(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.All internalformat, Int32 buffer) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_buffer]
            /// Attach the storage for a buffer object to the active buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            [AutoGenerated(Category = "EXT_texture_buffer", Version = "", EntryPoint = "glTexBufferEXT")]
            [CLSCompliant(false)]
            public static void TexBuffer(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.All internalformat, UInt32 buffer) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_buffer]
            /// Bind a range of a buffer's data store to a buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            /// <param name="offset">
            /// Specifies the offset of the start of the range of the buffer's data store to attach.
            /// </param>
            /// <param name="size">
            /// Specifies the size of the range of the buffer's data store to attach.
            /// </param>
            [AutoGenerated(Category = "EXT_texture_buffer", Version = "", EntryPoint = "glTexBufferRangeEXT")]
            [CLSCompliant(false)]
            public static void TexBufferRange(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, Int32 buffer, IntPtr offset, Int32 size) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_buffer]
            /// Bind a range of a buffer's data store to a buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            /// <param name="offset">
            /// Specifies the offset of the start of the range of the buffer's data store to attach.
            /// </param>
            /// <param name="size">
            /// Specifies the size of the range of the buffer's data store to attach.
            /// </param>
            [AutoGenerated(Category = "EXT_texture_buffer", Version = "", EntryPoint = "glTexBufferRangeEXT")]
            [CLSCompliant(false)]
            public static void TexBufferRange(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, Int32 buffer, IntPtr offset, IntPtr size) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_buffer]
            /// Bind a range of a buffer's data store to a buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            /// <param name="offset">
            /// Specifies the offset of the start of the range of the buffer's data store to attach.
            /// </param>
            /// <param name="size">
            /// Specifies the size of the range of the buffer's data store to attach.
            /// </param>
            [AutoGenerated(Category = "EXT_texture_buffer", Version = "", EntryPoint = "glTexBufferRangeEXT")]
            [CLSCompliant(false)]
            public static void TexBufferRange(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, UInt32 buffer, IntPtr offset, Int32 size) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_buffer]
            /// Bind a range of a buffer's data store to a buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            /// <param name="offset">
            /// Specifies the offset of the start of the range of the buffer's data store to attach.
            /// </param>
            /// <param name="size">
            /// Specifies the size of the range of the buffer's data store to attach.
            /// </param>
            [AutoGenerated(Category = "EXT_texture_buffer", Version = "", EntryPoint = "glTexBufferRangeEXT")]
            [CLSCompliant(false)]
            public static void TexBufferRange(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, UInt32 buffer, IntPtr offset, IntPtr size) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_sparse_texture]</summary>
            /// <param name="target"></param>
            /// <param name="level"></param>
            /// <param name="xoffset"></param>
            /// <param name="yoffset"></param>
            /// <param name="zoffset"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="commit"></param>
            [AutoGenerated(Category = "EXT_sparse_texture", Version = "", EntryPoint = "glTexPageCommitmentEXT")]
            public static void TexPageCommitment(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, bool commit) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIivEXT")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIivEXT")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] ref Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIivEXT")]
            [CLSCompliant(false)]
            public static unsafe void TexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIivEXT")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIivEXT")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] ref Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIivEXT")]
            [CLSCompliant(false)]
            public static unsafe void TexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIuivEXT")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] UInt32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIuivEXT")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] ref UInt32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIuivEXT")]
            [CLSCompliant(false)]
            public static unsafe void TexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] UInt32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIuivEXT")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] UInt32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIuivEXT")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] ref UInt32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "EXT_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIuivEXT")]
            [CLSCompliant(false)]
            public static unsafe void TexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] UInt32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_storage]
            /// Simultaneously specify storage for all levels of a one-dimensional texture
            /// </summary>
            /// <param name="target">
            /// Specify the target of the operation. target must be either Texture1D or ProxyTexture1D.
            /// </param>
            /// <param name="levels">
            /// Specify the number of texture levels.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the sized internal format to be used to store texture image data.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture, in texels.
            /// </param>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTexStorage1DEXT")]
            public static void TexStorage1D(OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalformat, Int32 width) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_storage]
            /// Simultaneously specify storage for all levels of a two-dimensional texture
            /// </summary>
            /// <param name="target">
            /// Specify the target of the operation. target must be one of Texture2D, or TextureCubeMap.
            /// </param>
            /// <param name="levels">
            /// Specify the number of texture levels.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the sized internal format to be used to store texture image data.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture, in texels.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture, in texels.
            /// </param>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTexStorage2DEXT")]
            public static void TexStorage2D(OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_storage]
            /// Simultaneously specify storage for all levels of a three-dimensional or two-dimensional array texture
            /// </summary>
            /// <param name="target">
            /// Specify the target of the operation. target must be one of Texture3D, or Texture2DArray.
            /// </param>
            /// <param name="levels">
            /// Specify the number of texture levels.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the sized internal format to be used to store texture image data.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture, in texels.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture, in texels.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture, in texels.
            /// </param>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTexStorage3DEXT")]
            public static void TexStorage3D(OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem1DEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem1D(OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem1DEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem1D(OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem1DEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem1D(OpenTK.Graphics.ES31.TextureTarget target, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem1DEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem1D(OpenTK.Graphics.ES31.TextureTarget target, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem2DEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem2D(OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem2DEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem2D(OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem2DEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem2D(OpenTK.Graphics.ES31.TextureTarget target, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem2DEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem2D(OpenTK.Graphics.ES31.TextureTarget target, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="samples"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="fixedSampleLocations"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem2DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem2DMultisample(OpenTK.Graphics.ES31.All target, Int32 samples, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, bool fixedSampleLocations, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="samples"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="fixedSampleLocations"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem2DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem2DMultisample(OpenTK.Graphics.ES31.All target, Int32 samples, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, bool fixedSampleLocations, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="samples"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="fixedSampleLocations"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem2DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem2DMultisample(OpenTK.Graphics.ES31.TextureTarget target, Int32 samples, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, bool fixedSampleLocations, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="samples"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="fixedSampleLocations"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem2DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem2DMultisample(OpenTK.Graphics.ES31.TextureTarget target, Int32 samples, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, bool fixedSampleLocations, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem3DEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem3D(OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 depth, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem3DEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem3D(OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 depth, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem3DEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem3D(OpenTK.Graphics.ES31.TextureTarget target, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 depth, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem3DEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem3D(OpenTK.Graphics.ES31.TextureTarget target, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 depth, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="samples"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="fixedSampleLocations"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem3DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem3DMultisample(OpenTK.Graphics.ES31.All target, Int32 samples, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 depth, bool fixedSampleLocations, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="samples"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="fixedSampleLocations"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem3DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem3DMultisample(OpenTK.Graphics.ES31.All target, Int32 samples, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 depth, bool fixedSampleLocations, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="samples"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="fixedSampleLocations"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem3DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem3DMultisample(OpenTK.Graphics.ES31.TextureTarget target, Int32 samples, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 depth, bool fixedSampleLocations, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="target"></param>
            /// <param name="samples"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="fixedSampleLocations"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTexStorageMem3DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void TexStorageMem3DMultisample(OpenTK.Graphics.ES31.TextureTarget target, Int32 samples, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 depth, bool fixedSampleLocations, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_storage]</summary>
            /// <param name="texture"></param>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalformat"></param>
            /// <param name="width"></param>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTextureStorage1DEXT")]
            [CLSCompliant(false)]
            public static void TextureStorage1D(Int32 texture, OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalformat, Int32 width) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_storage]</summary>
            /// <param name="texture"></param>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalformat"></param>
            /// <param name="width"></param>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTextureStorage1DEXT")]
            [CLSCompliant(false)]
            public static void TextureStorage1D(UInt32 texture, OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalformat, Int32 width) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_storage]</summary>
            /// <param name="texture"></param>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalformat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTextureStorage2DEXT")]
            [CLSCompliant(false)]
            public static void TextureStorage2D(Int32 texture, OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_storage]</summary>
            /// <param name="texture"></param>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalformat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTextureStorage2DEXT")]
            [CLSCompliant(false)]
            public static void TextureStorage2D(UInt32 texture, OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_storage]</summary>
            /// <param name="texture"></param>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalformat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTextureStorage3DEXT")]
            [CLSCompliant(false)]
            public static void TextureStorage3D(Int32 texture, OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_storage]</summary>
            /// <param name="texture"></param>
            /// <param name="target"></param>
            /// <param name="levels"></param>
            /// <param name="internalformat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTextureStorage3DEXT")]
            [CLSCompliant(false)]
            public static void TextureStorage3D(UInt32 texture, OpenTK.Graphics.ES31.All target, Int32 levels, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="texture"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTextureStorageMem1DEXT")]
            [CLSCompliant(false)]
            public static void TextureStorageMem1D(Int32 texture, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="texture"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTextureStorageMem1DEXT")]
            [CLSCompliant(false)]
            public static void TextureStorageMem1D(UInt32 texture, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="texture"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTextureStorageMem2DEXT")]
            [CLSCompliant(false)]
            public static void TextureStorageMem2D(Int32 texture, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="texture"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTextureStorageMem2DEXT")]
            [CLSCompliant(false)]
            public static void TextureStorageMem2D(UInt32 texture, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="texture"></param>
            /// <param name="samples"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="fixedSampleLocations"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTextureStorageMem2DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void TextureStorageMem2DMultisample(Int32 texture, Int32 samples, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, bool fixedSampleLocations, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="texture"></param>
            /// <param name="samples"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="fixedSampleLocations"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTextureStorageMem2DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void TextureStorageMem2DMultisample(UInt32 texture, Int32 samples, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, bool fixedSampleLocations, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="texture"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTextureStorageMem3DEXT")]
            [CLSCompliant(false)]
            public static void TextureStorageMem3D(Int32 texture, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 depth, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="texture"></param>
            /// <param name="levels"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTextureStorageMem3DEXT")]
            [CLSCompliant(false)]
            public static void TextureStorageMem3D(UInt32 texture, Int32 levels, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 depth, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="texture"></param>
            /// <param name="samples"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="fixedSampleLocations"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTextureStorageMem3DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void TextureStorageMem3DMultisample(Int32 texture, Int32 samples, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 depth, bool fixedSampleLocations, Int32 memory, Int64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_memory_object]</summary>
            /// <param name="texture"></param>
            /// <param name="samples"></param>
            /// <param name="internalFormat"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="fixedSampleLocations"></param>
            /// <param name="memory"></param>
            /// <param name="offset"></param>
            [AutoGenerated(Category = "EXT_memory_object", Version = "", EntryPoint = "glTextureStorageMem3DMultisampleEXT")]
            [CLSCompliant(false)]
            public static void TextureStorageMem3DMultisample(UInt32 texture, Int32 samples, OpenTK.Graphics.ES31.All internalFormat, Int32 width, Int32 height, Int32 depth, bool fixedSampleLocations, UInt32 memory, UInt64 offset) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_view]
            /// Initialize a texture as a data alias of another texture's data store
            /// </summary>
            /// <param name="texture">
            /// Specifies the texture object to be initialized as a view.
            /// </param>
            /// <param name="target">
            /// Specifies the target to be used for the newly initialized texture.
            /// </param>
            /// <param name="origtexture">
            /// Specifies the name of a texture object of which to make a view.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format for the newly created view.
            /// </param>
            /// <param name="minlevel">
            /// Specifies lowest level of detail of the view.
            /// </param>
            /// <param name="numlevels">
            /// Specifies the number of levels of detail to include in the view.
            /// </param>
            /// <param name="minlayer">
            /// Specifies the index of the first layer to include in the view.
            /// </param>
            /// <param name="numlayers">
            /// Specifies the number of layers to include in the view.
            /// </param>
            [AutoGenerated(Category = "EXT_texture_view", Version = "", EntryPoint = "glTextureViewEXT")]
            [CLSCompliant(false)]
            public static void TextureView(Int32 texture, OpenTK.Graphics.ES31.All target, Int32 origtexture, OpenTK.Graphics.ES31.All internalformat, Int32 minlevel, Int32 numlevels, Int32 minlayer, Int32 numlayers) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_texture_view]
            /// Initialize a texture as a data alias of another texture's data store
            /// </summary>
            /// <param name="texture">
            /// Specifies the texture object to be initialized as a view.
            /// </param>
            /// <param name="target">
            /// Specifies the target to be used for the newly initialized texture.
            /// </param>
            /// <param name="origtexture">
            /// Specifies the name of a texture object of which to make a view.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format for the newly created view.
            /// </param>
            /// <param name="minlevel">
            /// Specifies lowest level of detail of the view.
            /// </param>
            /// <param name="numlevels">
            /// Specifies the number of levels of detail to include in the view.
            /// </param>
            /// <param name="minlayer">
            /// Specifies the index of the first layer to include in the view.
            /// </param>
            /// <param name="numlayers">
            /// Specifies the number of layers to include in the view.
            /// </param>
            [AutoGenerated(Category = "EXT_texture_view", Version = "", EntryPoint = "glTextureViewEXT")]
            [CLSCompliant(false)]
            public static void TextureView(UInt32 texture, OpenTK.Graphics.ES31.All target, UInt32 origtexture, OpenTK.Graphics.ES31.All internalformat, UInt32 minlevel, UInt32 numlevels, UInt32 minlayer, UInt32 numlayers) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Bind stages of a program object to a program pipeline
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the program pipeline object to which to bind stages from program.
            /// </param>
            /// <param name="stages">
            /// Specifies a set of program stages to bind to the program pipeline object.
            /// </param>
            /// <param name="program">
            /// Specifies the program object containing the shader executables to use in pipeline.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glUseProgramStagesEXT")]
            [CLSCompliant(false)]
            public static void UseProgramStages(Int32 pipeline, Int32 stages, Int32 program) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Bind stages of a program object to a program pipeline
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the program pipeline object to which to bind stages from program.
            /// </param>
            /// <param name="stages">
            /// Specifies a set of program stages to bind to the program pipeline object.
            /// </param>
            /// <param name="program">
            /// Specifies the program object containing the shader executables to use in pipeline.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glUseProgramStagesEXT")]
            [CLSCompliant(false)]
            public static void UseProgramStages(UInt32 pipeline, UInt32 stages, UInt32 program) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="type"></param>
            /// <param name="program"></param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glUseShaderProgramEXT")]
            [CLSCompliant(false)]
            public static void UseShaderProgram(OpenTK.Graphics.ES31.All type, Int32 program) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            /// <param name="type"></param>
            /// <param name="program"></param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glUseShaderProgramEXT")]
            [CLSCompliant(false)]
            public static void UseShaderProgram(OpenTK.Graphics.ES31.All type, UInt32 program) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Validate a program pipeline object against current GL state
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object to validate.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glValidateProgramPipelineEXT")]
            [CLSCompliant(false)]
            public static void ValidateProgramPipeline(Int32 pipeline) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Validate a program pipeline object against current GL state
            /// </summary>
            /// <param name="pipeline">
            /// Specifies the name of a program pipeline object to validate.
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glValidateProgramPipelineEXT")]
            [CLSCompliant(false)]
            public static void ValidateProgramPipeline(UInt32 pipeline) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_instanced_arrays]
            /// Modify the rate at which generic vertex attributes advance during instanced rendering
            /// </summary>
            /// <param name="index">
            /// Specify the index of the generic vertex attribute.
            /// </param>
            /// <param name="divisor">
            /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
            /// </param>
            [AutoGenerated(Category = "EXT_instanced_arrays", Version = "", EntryPoint = "glVertexAttribDivisorEXT")]
            [CLSCompliant(false)]
            public static void VertexAttribDivisor(Int32 index, Int32 divisor) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_instanced_arrays]
            /// Modify the rate at which generic vertex attributes advance during instanced rendering
            /// </summary>
            /// <param name="index">
            /// Specify the index of the generic vertex attribute.
            /// </param>
            /// <param name="divisor">
            /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
            /// </param>
            [AutoGenerated(Category = "EXT_instanced_arrays", Version = "", EntryPoint = "glVertexAttribDivisorEXT")]
            [CLSCompliant(false)]
            public static void VertexAttribDivisor(UInt32 index, UInt32 divisor) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="srcLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glWaitSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void WaitSemaphore(Int32 semaphore, Int32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] Int32[] buffers, Int32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] Int32[] textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.All[] srcLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="srcLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glWaitSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void WaitSemaphore(Int32 semaphore, Int32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] Int32[] buffers, Int32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] Int32[] textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.TextureLayout[] srcLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="srcLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glWaitSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void WaitSemaphore(Int32 semaphore, Int32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] ref Int32 buffers, Int32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] ref Int32 textures, [CountAttribute(Computed = "numTextureBarriers")] ref OpenTK.Graphics.ES31.All srcLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="srcLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glWaitSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void WaitSemaphore(Int32 semaphore, Int32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] ref Int32 buffers, Int32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] ref Int32 textures, [CountAttribute(Computed = "numTextureBarriers")] ref OpenTK.Graphics.ES31.TextureLayout srcLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="srcLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glWaitSemaphoreEXT")]
            [CLSCompliant(false)]
            public static unsafe void WaitSemaphore(Int32 semaphore, Int32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] Int32* buffers, Int32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] Int32* textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.All* srcLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="srcLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glWaitSemaphoreEXT")]
            [CLSCompliant(false)]
            public static unsafe void WaitSemaphore(Int32 semaphore, Int32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] Int32* buffers, Int32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] Int32* textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.TextureLayout* srcLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="srcLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glWaitSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void WaitSemaphore(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] UInt32[] buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] UInt32[] textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.All[] srcLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="srcLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glWaitSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void WaitSemaphore(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] UInt32[] buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] UInt32[] textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.TextureLayout[] srcLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="srcLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glWaitSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void WaitSemaphore(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] ref UInt32 buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] ref UInt32 textures, [CountAttribute(Computed = "numTextureBarriers")] ref OpenTK.Graphics.ES31.All srcLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="srcLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glWaitSemaphoreEXT")]
            [CLSCompliant(false)]
            public static void WaitSemaphore(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] ref UInt32 buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] ref UInt32 textures, [CountAttribute(Computed = "numTextureBarriers")] ref OpenTK.Graphics.ES31.TextureLayout srcLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="srcLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glWaitSemaphoreEXT")]
            [CLSCompliant(false)]
            public static unsafe void WaitSemaphore(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] UInt32* buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] UInt32* textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.All* srcLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_semaphore]</summary>
            /// <param name="semaphore"></param>
            /// <param name="numBufferBarriers"></param>
            /// <param name="buffers">[length: COMPSIZE(numBufferBarriers)]</param>
            /// <param name="numTextureBarriers"></param>
            /// <param name="textures">[length: COMPSIZE(numTextureBarriers)]</param>
            /// <param name="srcLayouts">[length: COMPSIZE(numTextureBarriers)]</param>
            [AutoGenerated(Category = "EXT_semaphore", Version = "", EntryPoint = "glWaitSemaphoreEXT")]
            [CLSCompliant(false)]
            public static unsafe void WaitSemaphore(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] UInt32* buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] UInt32* textures, [CountAttribute(Computed = "numTextureBarriers")] OpenTK.Graphics.ES31.TextureLayout* srcLayouts) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_window_rectangles]</summary>
            /// <param name="mode"></param>
            /// <param name="count"></param>
            /// <param name="box">[length: COMPSIZE(count)]</param>
            [AutoGenerated(Category = "EXT_window_rectangles", Version = "", EntryPoint = "glWindowRectanglesEXT")]
            [CLSCompliant(false)]
            public static void WindowRectangles(OpenTK.Graphics.ES31.All mode, Int32 count, [CountAttribute(Computed = "count")] Int32[] box) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_window_rectangles]</summary>
            /// <param name="mode"></param>
            /// <param name="count"></param>
            /// <param name="box">[length: COMPSIZE(count)]</param>
            [AutoGenerated(Category = "EXT_window_rectangles", Version = "", EntryPoint = "glWindowRectanglesEXT")]
            [CLSCompliant(false)]
            public static void WindowRectangles(OpenTK.Graphics.ES31.All mode, Int32 count, [CountAttribute(Computed = "count")] ref Int32 box) { throw new NotImplementedException(); }

            /// <summary>[requires: EXT_window_rectangles]</summary>
            /// <param name="mode"></param>
            /// <param name="count"></param>
            /// <param name="box">[length: COMPSIZE(count)]</param>
            [AutoGenerated(Category = "EXT_window_rectangles", Version = "", EntryPoint = "glWindowRectanglesEXT")]
            [CLSCompliant(false)]
            public static unsafe void WindowRectangles(OpenTK.Graphics.ES31.All mode, Int32 count, [CountAttribute(Computed = "count")] Int32* box) { throw new NotImplementedException(); }

        }

        public static partial class Img
        {
            /// <summary>[requires: IMG_framebuffer_downsample]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="textarget"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="xscale"></param>
            /// <param name="yscale"></param>
            [AutoGenerated(Category = "IMG_framebuffer_downsample", Version = "", EntryPoint = "glFramebufferTexture2DDownsampleIMG")]
            [CLSCompliant(false)]
            public static void FramebufferTexture2DDownsample(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All textarget, Int32 texture, Int32 level, Int32 xscale, Int32 yscale) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_framebuffer_downsample]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="textarget"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="xscale"></param>
            /// <param name="yscale"></param>
            [AutoGenerated(Category = "IMG_framebuffer_downsample", Version = "", EntryPoint = "glFramebufferTexture2DDownsampleIMG")]
            [CLSCompliant(false)]
            public static void FramebufferTexture2DDownsample(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All textarget, UInt32 texture, Int32 level, Int32 xscale, Int32 yscale) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_multisampled_render_to_texture]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="textarget"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="samples"></param>
            [AutoGenerated(Category = "IMG_multisampled_render_to_texture", Version = "", EntryPoint = "glFramebufferTexture2DMultisampleIMG")]
            [CLSCompliant(false)]
            public static void FramebufferTexture2DMultisample(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All textarget, Int32 texture, Int32 level, Int32 samples) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_multisampled_render_to_texture]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="textarget"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="samples"></param>
            [AutoGenerated(Category = "IMG_multisampled_render_to_texture", Version = "", EntryPoint = "glFramebufferTexture2DMultisampleIMG")]
            [CLSCompliant(false)]
            public static void FramebufferTexture2DMultisample(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All textarget, UInt32 texture, Int32 level, Int32 samples) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_framebuffer_downsample]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="layer"></param>
            /// <param name="xscale"></param>
            /// <param name="yscale"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "IMG_framebuffer_downsample", Version = "", EntryPoint = "glFramebufferTextureLayerDownsampleIMG")]
            [CLSCompliant(false)]
            public static void FramebufferTextureLayerDownsample(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, Int32 texture, Int32 level, Int32 layer, Int32 xscale, Int32 yscale) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_framebuffer_downsample]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="layer"></param>
            /// <param name="xscale"></param>
            /// <param name="yscale"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "IMG_framebuffer_downsample", Version = "", EntryPoint = "glFramebufferTextureLayerDownsampleIMG")]
            [CLSCompliant(false)]
            public static void FramebufferTextureLayerDownsample(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, UInt32 texture, Int32 level, Int32 layer, Int32 xscale, Int32 yscale) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_framebuffer_downsample]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="layer"></param>
            /// <param name="xscale"></param>
            /// <param name="yscale"></param>
            [AutoGenerated(Category = "IMG_framebuffer_downsample", Version = "", EntryPoint = "glFramebufferTextureLayerDownsampleIMG")]
            [CLSCompliant(false)]
            public static void FramebufferTextureLayerDownsample(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, Int32 texture, Int32 level, Int32 layer, Int32 xscale, Int32 yscale) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_framebuffer_downsample]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="layer"></param>
            /// <param name="xscale"></param>
            /// <param name="yscale"></param>
            [AutoGenerated(Category = "IMG_framebuffer_downsample", Version = "", EntryPoint = "glFramebufferTextureLayerDownsampleIMG")]
            [CLSCompliant(false)]
            public static void FramebufferTextureLayerDownsample(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, UInt32 texture, Int32 level, Int32 layer, Int32 xscale, Int32 yscale) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="texture"></param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glGetTextureHandleIMG")]
            [CLSCompliant(false)]
            public static Int64 GetTextureHandle(Int32 texture) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="texture"></param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glGetTextureHandleIMG")]
            [CLSCompliant(false)]
            public static Int64 GetTextureHandle(UInt32 texture) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="texture"></param>
            /// <param name="sampler"></param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glGetTextureSamplerHandleIMG")]
            [CLSCompliant(false)]
            public static Int64 GetTextureSamplerHandle(Int32 texture, Int32 sampler) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="texture"></param>
            /// <param name="sampler"></param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glGetTextureSamplerHandleIMG")]
            [CLSCompliant(false)]
            public static Int64 GetTextureSamplerHandle(UInt32 texture, UInt32 sampler) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="value"></param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64IMG")]
            [CLSCompliant(false)]
            public static void ProgramUniformHandle(Int32 program, Int32 location, Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="value"></param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64IMG")]
            [CLSCompliant(false)]
            public static void ProgramUniformHandle(UInt32 program, Int32 location, UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="values">[length: count]</param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64vIMG")]
            [CLSCompliant(false)]
            public static void ProgramUniformHandle(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int64[] values) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="values">[length: count]</param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64vIMG")]
            [CLSCompliant(false)]
            public static void ProgramUniformHandle(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Int64 values) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="values">[length: count]</param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64vIMG")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformHandle(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int64* values) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="values">[length: count]</param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64vIMG")]
            [CLSCompliant(false)]
            public static void ProgramUniformHandle(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64[] values) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="values">[length: count]</param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64vIMG")]
            [CLSCompliant(false)]
            public static void ProgramUniformHandle(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref UInt64 values) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="values">[length: count]</param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64vIMG")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformHandle(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64* values) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_multisampled_render_to_texture]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// Specifies a binding to which the target of the allocation and must be Renderbuffer.
            /// </param>
            /// <param name="samples">
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the renderbuffer, in pixels.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the renderbuffer, in pixels.
            /// </param>
            [AutoGenerated(Category = "IMG_multisampled_render_to_texture", Version = "", EntryPoint = "glRenderbufferStorageMultisampleIMG")]
            public static void RenderbufferStorageMultisample(OpenTK.Graphics.ES31.All target, Int32 samples, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="value"></param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64IMG")]
            [CLSCompliant(false)]
            public static void UniformHandle(Int32 location, Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="value"></param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64IMG")]
            [CLSCompliant(false)]
            public static void UniformHandle(Int32 location, UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="value">[length: count]</param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64vIMG")]
            [CLSCompliant(false)]
            public static void UniformHandle(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="value">[length: count]</param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64vIMG")]
            [CLSCompliant(false)]
            public static void UniformHandle(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="value">[length: count]</param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64vIMG")]
            [CLSCompliant(false)]
            public static unsafe void UniformHandle(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="value">[length: count]</param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64vIMG")]
            [CLSCompliant(false)]
            public static void UniformHandle(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="value">[length: count]</param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64vIMG")]
            [CLSCompliant(false)]
            public static void UniformHandle(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: IMG_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="value">[length: count]</param>
            [AutoGenerated(Category = "IMG_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64vIMG")]
            [CLSCompliant(false)]
            public static unsafe void UniformHandle(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64* value) { throw new NotImplementedException(); }

        }

        public static partial class Intel
        {
            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glBeginPerfQueryINTEL")]
            [CLSCompliant(false)]
            public static void BeginPerfQuery(Int32 queryHandle) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glBeginPerfQueryINTEL")]
            [CLSCompliant(false)]
            public static void BeginPerfQuery(UInt32 queryHandle) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="queryHandle"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glCreatePerfQueryINTEL")]
            [CLSCompliant(false)]
            public static void CreatePerfQuery(Int32 queryId, [OutAttribute] Int32[] queryHandle) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="queryHandle"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glCreatePerfQueryINTEL")]
            [CLSCompliant(false)]
            public static void CreatePerfQuery(Int32 queryId, [OutAttribute] out Int32 queryHandle) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="queryHandle"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glCreatePerfQueryINTEL")]
            [CLSCompliant(false)]
            public static unsafe void CreatePerfQuery(Int32 queryId, [OutAttribute] Int32* queryHandle) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="queryHandle"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glCreatePerfQueryINTEL")]
            [CLSCompliant(false)]
            public static void CreatePerfQuery(UInt32 queryId, [OutAttribute] UInt32[] queryHandle) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="queryHandle"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glCreatePerfQueryINTEL")]
            [CLSCompliant(false)]
            public static void CreatePerfQuery(UInt32 queryId, [OutAttribute] out UInt32 queryHandle) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="queryHandle"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glCreatePerfQueryINTEL")]
            [CLSCompliant(false)]
            public static unsafe void CreatePerfQuery(UInt32 queryId, [OutAttribute] UInt32* queryHandle) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glDeletePerfQueryINTEL")]
            [CLSCompliant(false)]
            public static void DeletePerfQuery(Int32 queryHandle) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glDeletePerfQueryINTEL")]
            [CLSCompliant(false)]
            public static void DeletePerfQuery(UInt32 queryHandle) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glEndPerfQueryINTEL")]
            [CLSCompliant(false)]
            public static void EndPerfQuery(Int32 queryHandle) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glEndPerfQueryINTEL")]
            [CLSCompliant(false)]
            public static void EndPerfQuery(UInt32 queryHandle) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetFirstPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static Int32 GetFirstPerfQueryI() { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetFirstPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static void GetFirstPerfQueryI([OutAttribute] Int32[] queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetFirstPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static void GetFirstPerfQueryI([OutAttribute] out Int32 queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetFirstPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetFirstPerfQueryI([OutAttribute] Int32* queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetFirstPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static void GetFirstPerfQueryI([OutAttribute] UInt32[] queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetFirstPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static void GetFirstPerfQueryI([OutAttribute] out UInt32 queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetFirstPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetFirstPerfQueryI([OutAttribute] UInt32* queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetNextPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static Int32 GetNextPerfQueryI(Int32 queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetNextPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static Int32 GetNextPerfQueryI(UInt32 queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="nextQueryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetNextPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static void GetNextPerfQueryI(Int32 queryId, [OutAttribute] Int32[] nextQueryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="nextQueryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetNextPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static void GetNextPerfQueryI(Int32 queryId, [OutAttribute] out Int32 nextQueryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="nextQueryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetNextPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetNextPerfQueryI(Int32 queryId, [OutAttribute] Int32* nextQueryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="nextQueryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetNextPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static void GetNextPerfQueryI(UInt32 queryId, [OutAttribute] UInt32[] nextQueryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="nextQueryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetNextPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static void GetNextPerfQueryI(UInt32 queryId, [OutAttribute] out UInt32 nextQueryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="nextQueryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetNextPerfQueryIdINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetNextPerfQueryI(UInt32 queryId, [OutAttribute] UInt32* nextQueryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="counterId"></param>
            /// <param name="counterNameLength"></param>
            /// <param name="counterName"></param>
            /// <param name="counterDescLength"></param>
            /// <param name="counterDesc"></param>
            /// <param name="counterOffset"></param>
            /// <param name="counterDataSize"></param>
            /// <param name="counterTypeEnum"></param>
            /// <param name="counterDataTypeEnum"></param>
            /// <param name="rawCounterMaxValue"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfCounterInfoINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfCounterInfo(Int32 queryId, Int32 counterId, Int32 counterNameLength, [OutAttribute] out String counterName, Int32 counterDescLength, [OutAttribute] out String counterDesc, [OutAttribute] Int32[] counterOffset, [OutAttribute] Int32[] counterDataSize, [OutAttribute] Int32[] counterTypeEnum, [OutAttribute] Int32[] counterDataTypeEnum, [OutAttribute] Int64[] rawCounterMaxValue) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="counterId"></param>
            /// <param name="counterNameLength"></param>
            /// <param name="counterName"></param>
            /// <param name="counterDescLength"></param>
            /// <param name="counterDesc"></param>
            /// <param name="counterOffset"></param>
            /// <param name="counterDataSize"></param>
            /// <param name="counterTypeEnum"></param>
            /// <param name="counterDataTypeEnum"></param>
            /// <param name="rawCounterMaxValue"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfCounterInfoINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfCounterInfo(Int32 queryId, Int32 counterId, Int32 counterNameLength, [OutAttribute] out String counterName, Int32 counterDescLength, [OutAttribute] out String counterDesc, [OutAttribute] out Int32 counterOffset, [OutAttribute] out Int32 counterDataSize, [OutAttribute] out Int32 counterTypeEnum, [OutAttribute] out Int32 counterDataTypeEnum, [OutAttribute] out Int64 rawCounterMaxValue) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="counterId"></param>
            /// <param name="counterNameLength"></param>
            /// <param name="counterName"></param>
            /// <param name="counterDescLength"></param>
            /// <param name="counterDesc"></param>
            /// <param name="counterOffset"></param>
            /// <param name="counterDataSize"></param>
            /// <param name="counterTypeEnum"></param>
            /// <param name="counterDataTypeEnum"></param>
            /// <param name="rawCounterMaxValue"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfCounterInfoINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfCounterInfo(Int32 queryId, Int32 counterId, Int32 counterNameLength, [OutAttribute] out String counterName, Int32 counterDescLength, [OutAttribute] out String counterDesc, [OutAttribute] Int32* counterOffset, [OutAttribute] Int32* counterDataSize, [OutAttribute] Int32* counterTypeEnum, [OutAttribute] Int32* counterDataTypeEnum, [OutAttribute] Int64* rawCounterMaxValue) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="counterId"></param>
            /// <param name="counterNameLength"></param>
            /// <param name="counterName"></param>
            /// <param name="counterDescLength"></param>
            /// <param name="counterDesc"></param>
            /// <param name="counterOffset"></param>
            /// <param name="counterDataSize"></param>
            /// <param name="counterTypeEnum"></param>
            /// <param name="counterDataTypeEnum"></param>
            /// <param name="rawCounterMaxValue"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfCounterInfoINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfCounterInfo(UInt32 queryId, UInt32 counterId, UInt32 counterNameLength, [OutAttribute] out String counterName, UInt32 counterDescLength, [OutAttribute] out String counterDesc, [OutAttribute] UInt32[] counterOffset, [OutAttribute] UInt32[] counterDataSize, [OutAttribute] UInt32[] counterTypeEnum, [OutAttribute] UInt32[] counterDataTypeEnum, [OutAttribute] UInt64[] rawCounterMaxValue) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="counterId"></param>
            /// <param name="counterNameLength"></param>
            /// <param name="counterName"></param>
            /// <param name="counterDescLength"></param>
            /// <param name="counterDesc"></param>
            /// <param name="counterOffset"></param>
            /// <param name="counterDataSize"></param>
            /// <param name="counterTypeEnum"></param>
            /// <param name="counterDataTypeEnum"></param>
            /// <param name="rawCounterMaxValue"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfCounterInfoINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfCounterInfo(UInt32 queryId, UInt32 counterId, UInt32 counterNameLength, [OutAttribute] out String counterName, UInt32 counterDescLength, [OutAttribute] out String counterDesc, [OutAttribute] out UInt32 counterOffset, [OutAttribute] out UInt32 counterDataSize, [OutAttribute] out UInt32 counterTypeEnum, [OutAttribute] out UInt32 counterDataTypeEnum, [OutAttribute] out UInt64 rawCounterMaxValue) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="counterId"></param>
            /// <param name="counterNameLength"></param>
            /// <param name="counterName"></param>
            /// <param name="counterDescLength"></param>
            /// <param name="counterDesc"></param>
            /// <param name="counterOffset"></param>
            /// <param name="counterDataSize"></param>
            /// <param name="counterTypeEnum"></param>
            /// <param name="counterDataTypeEnum"></param>
            /// <param name="rawCounterMaxValue"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfCounterInfoINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfCounterInfo(UInt32 queryId, UInt32 counterId, UInt32 counterNameLength, [OutAttribute] out String counterName, UInt32 counterDescLength, [OutAttribute] out String counterDesc, [OutAttribute] UInt32* counterOffset, [OutAttribute] UInt32* counterDataSize, [OutAttribute] UInt32* counterTypeEnum, [OutAttribute] UInt32* counterDataTypeEnum, [OutAttribute] UInt64* rawCounterMaxValue) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData(Int32 queryHandle, Int32 flags, Int32 dataSize, [OutAttribute] IntPtr data, [OutAttribute] Int32[] bytesWritten) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData(Int32 queryHandle, Int32 flags, Int32 dataSize, [OutAttribute] IntPtr data, [OutAttribute] out Int32 bytesWritten) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryData(Int32 queryHandle, Int32 flags, Int32 dataSize, [OutAttribute] IntPtr data, [OutAttribute] Int32* bytesWritten) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(Int32 queryHandle, Int32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[] data, [OutAttribute] Int32[] bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(Int32 queryHandle, Int32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[] data, [OutAttribute] out Int32 bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryData<T3>(Int32 queryHandle, Int32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[] data, [OutAttribute] Int32* bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(Int32 queryHandle, Int32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[,] data, [OutAttribute] Int32[] bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(Int32 queryHandle, Int32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[,] data, [OutAttribute] out Int32 bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryData<T3>(Int32 queryHandle, Int32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[,] data, [OutAttribute] Int32* bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(Int32 queryHandle, Int32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[,,] data, [OutAttribute] Int32[] bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(Int32 queryHandle, Int32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[,,] data, [OutAttribute] out Int32 bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryData<T3>(Int32 queryHandle, Int32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[,,] data, [OutAttribute] Int32* bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(Int32 queryHandle, Int32 flags, Int32 dataSize, [InAttribute, OutAttribute] ref T3 data, [OutAttribute] Int32[] bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(Int32 queryHandle, Int32 flags, Int32 dataSize, [InAttribute, OutAttribute] ref T3 data, [OutAttribute] out Int32 bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryData<T3>(Int32 queryHandle, Int32 flags, Int32 dataSize, [InAttribute, OutAttribute] ref T3 data, [OutAttribute] Int32* bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [OutAttribute] IntPtr data, [OutAttribute] UInt32[] bytesWritten) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [OutAttribute] IntPtr data, [OutAttribute] out UInt32 bytesWritten) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryData(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [OutAttribute] IntPtr data, [OutAttribute] UInt32* bytesWritten) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[] data, [OutAttribute] UInt32[] bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[] data, [OutAttribute] out UInt32 bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryData<T3>(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[] data, [OutAttribute] UInt32* bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[,] data, [OutAttribute] UInt32[] bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[,] data, [OutAttribute] out UInt32 bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryData<T3>(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[,] data, [OutAttribute] UInt32* bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[,,] data, [OutAttribute] UInt32[] bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[,,] data, [OutAttribute] out UInt32 bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryData<T3>(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [InAttribute, OutAttribute] T3[,,] data, [OutAttribute] UInt32* bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [InAttribute, OutAttribute] ref T3 data, [OutAttribute] UInt32[] bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryData<T3>(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [InAttribute, OutAttribute] ref T3 data, [OutAttribute] out UInt32 bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryHandle"></param>
            /// <param name="flags"></param>
            /// <param name="dataSize"></param>
            /// <param name="data"></param>
            /// <param name="bytesWritten"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryDataINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryData<T3>(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [InAttribute, OutAttribute] ref T3 data, [OutAttribute] UInt32* bytesWritten)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryName"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryIdByNameINTEL")]
            [CLSCompliant(false)]
            public static Int32 GetPerfQueryIdByName([OutAttribute] out String queryName) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryName"></param>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryIdByNameINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryIdByName([OutAttribute] out String queryName, [OutAttribute] Int32[] queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryName"></param>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryIdByNameINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryIdByName([OutAttribute] out String queryName, [OutAttribute] out Int32 queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryName"></param>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryIdByNameINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryIdByName([OutAttribute] out String queryName, [OutAttribute] Int32* queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryName"></param>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryIdByNameINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryIdByName([OutAttribute] out String queryName, [OutAttribute] UInt32[] queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryName"></param>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryIdByNameINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryIdByName([OutAttribute] out String queryName, [OutAttribute] out UInt32 queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryName"></param>
            /// <param name="queryId"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryIdByNameINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryIdByName([OutAttribute] out String queryName, [OutAttribute] UInt32* queryId) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="queryNameLength"></param>
            /// <param name="queryName"></param>
            /// <param name="dataSize"></param>
            /// <param name="noCounters"></param>
            /// <param name="noInstances"></param>
            /// <param name="capsMask"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryInfoINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryInfo(Int32 queryId, Int32 queryNameLength, [OutAttribute] out String queryName, [OutAttribute] Int32[] dataSize, [OutAttribute] Int32[] noCounters, [OutAttribute] Int32[] noInstances, [OutAttribute] Int32[] capsMask) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="queryNameLength"></param>
            /// <param name="queryName"></param>
            /// <param name="dataSize"></param>
            /// <param name="noCounters"></param>
            /// <param name="noInstances"></param>
            /// <param name="capsMask"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryInfoINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryInfo(Int32 queryId, Int32 queryNameLength, [OutAttribute] out String queryName, [OutAttribute] out Int32 dataSize, [OutAttribute] out Int32 noCounters, [OutAttribute] out Int32 noInstances, [OutAttribute] out Int32 capsMask) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="queryNameLength"></param>
            /// <param name="queryName"></param>
            /// <param name="dataSize"></param>
            /// <param name="noCounters"></param>
            /// <param name="noInstances"></param>
            /// <param name="capsMask"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryInfoINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryInfo(Int32 queryId, Int32 queryNameLength, [OutAttribute] out String queryName, [OutAttribute] Int32* dataSize, [OutAttribute] Int32* noCounters, [OutAttribute] Int32* noInstances, [OutAttribute] Int32* capsMask) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="queryNameLength"></param>
            /// <param name="queryName"></param>
            /// <param name="dataSize"></param>
            /// <param name="noCounters"></param>
            /// <param name="noInstances"></param>
            /// <param name="capsMask"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryInfoINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryInfo(UInt32 queryId, UInt32 queryNameLength, [OutAttribute] out String queryName, [OutAttribute] UInt32[] dataSize, [OutAttribute] UInt32[] noCounters, [OutAttribute] UInt32[] noInstances, [OutAttribute] UInt32[] capsMask) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="queryNameLength"></param>
            /// <param name="queryName"></param>
            /// <param name="dataSize"></param>
            /// <param name="noCounters"></param>
            /// <param name="noInstances"></param>
            /// <param name="capsMask"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryInfoINTEL")]
            [CLSCompliant(false)]
            public static void GetPerfQueryInfo(UInt32 queryId, UInt32 queryNameLength, [OutAttribute] out String queryName, [OutAttribute] out UInt32 dataSize, [OutAttribute] out UInt32 noCounters, [OutAttribute] out UInt32 noInstances, [OutAttribute] out UInt32 capsMask) { throw new NotImplementedException(); }

            /// <summary>[requires: INTEL_performance_query]</summary>
            /// <param name="queryId"></param>
            /// <param name="queryNameLength"></param>
            /// <param name="queryName"></param>
            /// <param name="dataSize"></param>
            /// <param name="noCounters"></param>
            /// <param name="noInstances"></param>
            /// <param name="capsMask"></param>
            [AutoGenerated(Category = "INTEL_performance_query", Version = "", EntryPoint = "glGetPerfQueryInfoINTEL")]
            [CLSCompliant(false)]
            public static unsafe void GetPerfQueryInfo(UInt32 queryId, UInt32 queryNameLength, [OutAttribute] out String queryName, [OutAttribute] UInt32* dataSize, [OutAttribute] UInt32* noCounters, [OutAttribute] UInt32* noInstances, [OutAttribute] UInt32* capsMask) { throw new NotImplementedException(); }
        }

        public static partial class Khr
        {
            /// <summary>[requires: KHR_blend_equation_advanced]</summary>
            [AutoGenerated(Category = "KHR_blend_equation_advanced", Version = "", EntryPoint = "glBlendBarrierKHR")]
            public static void BlendBarrier() { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Specify a callback to receive debugging messages from the GL
            /// </summary>
            /// <param name="callback">
            /// The address of a callback function that will be called when a debug message is generated.
            /// </param>
            /// <param name="userParam">
            /// A user supplied pointer that will be passed on each invocation of callback.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallbackKHR")]
            public static void DebugMessageCallback(DebugProcKhr callback, IntPtr userParam) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Specify a callback to receive debugging messages from the GL
            /// </summary>
            /// <param name="callback">
            /// The address of a callback function that will be called when a debug message is generated.
            /// </param>
            /// <param name="userParam">
            /// A user supplied pointer that will be passed on each invocation of callback.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallbackKHR")]
            [CLSCompliant(false)]
            public static void DebugMessageCallback<T1>(DebugProcKhr callback, [InAttribute, OutAttribute] T1[] userParam)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Specify a callback to receive debugging messages from the GL
            /// </summary>
            /// <param name="callback">
            /// The address of a callback function that will be called when a debug message is generated.
            /// </param>
            /// <param name="userParam">
            /// A user supplied pointer that will be passed on each invocation of callback.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallbackKHR")]
            [CLSCompliant(false)]
            public static void DebugMessageCallback<T1>(DebugProcKhr callback, [InAttribute, OutAttribute] T1[,] userParam)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Specify a callback to receive debugging messages from the GL
            /// </summary>
            /// <param name="callback">
            /// The address of a callback function that will be called when a debug message is generated.
            /// </param>
            /// <param name="userParam">
            /// A user supplied pointer that will be passed on each invocation of callback.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallbackKHR")]
            [CLSCompliant(false)]
            public static void DebugMessageCallback<T1>(DebugProcKhr callback, [InAttribute, OutAttribute] T1[,,] userParam)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Specify a callback to receive debugging messages from the GL
            /// </summary>
            /// <param name="callback">
            /// The address of a callback function that will be called when a debug message is generated.
            /// </param>
            /// <param name="userParam">
            /// A user supplied pointer that will be passed on each invocation of callback.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallbackKHR")]
            public static void DebugMessageCallback<T1>(DebugProcKhr callback, [InAttribute, OutAttribute] ref T1 userParam)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// The source of debug messages to enable or disable.
            /// </param>
            /// <param name="type">
            /// The type of debug messages to enable or disable.
            /// </param>
            /// <param name="severity">
            /// The severity of debug messages to enable or disable.
            /// </param>
            /// <param name="count">
            /// The length of the array ids.
            /// </param>
            /// <param name="ids">
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </param>
            /// <param name="enabled">
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            [CLSCompliant(false)]
            public static void DebugMessageControl(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, OpenTK.Graphics.ES31.All severity, Int32 count, Int32[] ids, bool enabled) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// The source of debug messages to enable or disable.
            /// </param>
            /// <param name="type">
            /// The type of debug messages to enable or disable.
            /// </param>
            /// <param name="severity">
            /// The severity of debug messages to enable or disable.
            /// </param>
            /// <param name="count">
            /// The length of the array ids.
            /// </param>
            /// <param name="ids">
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </param>
            /// <param name="enabled">
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            [CLSCompliant(false)]
            public static void DebugMessageControl(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, OpenTK.Graphics.ES31.All severity, Int32 count, ref Int32 ids, bool enabled) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// The source of debug messages to enable or disable.
            /// </param>
            /// <param name="type">
            /// The type of debug messages to enable or disable.
            /// </param>
            /// <param name="severity">
            /// The severity of debug messages to enable or disable.
            /// </param>
            /// <param name="count">
            /// The length of the array ids.
            /// </param>
            /// <param name="ids">
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </param>
            /// <param name="enabled">
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            [CLSCompliant(false)]
            public static unsafe void DebugMessageControl(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, OpenTK.Graphics.ES31.All severity, Int32 count, Int32* ids, bool enabled) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// The source of debug messages to enable or disable.
            /// </param>
            /// <param name="type">
            /// The type of debug messages to enable or disable.
            /// </param>
            /// <param name="severity">
            /// The severity of debug messages to enable or disable.
            /// </param>
            /// <param name="count">
            /// The length of the array ids.
            /// </param>
            /// <param name="ids">
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </param>
            /// <param name="enabled">
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            [CLSCompliant(false)]
            public static void DebugMessageControl(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, OpenTK.Graphics.ES31.All severity, Int32 count, UInt32[] ids, bool enabled) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// The source of debug messages to enable or disable.
            /// </param>
            /// <param name="type">
            /// The type of debug messages to enable or disable.
            /// </param>
            /// <param name="severity">
            /// The severity of debug messages to enable or disable.
            /// </param>
            /// <param name="count">
            /// The length of the array ids.
            /// </param>
            /// <param name="ids">
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </param>
            /// <param name="enabled">
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            [CLSCompliant(false)]
            public static void DebugMessageControl(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, OpenTK.Graphics.ES31.All severity, Int32 count, ref UInt32 ids, bool enabled) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// The source of debug messages to enable or disable.
            /// </param>
            /// <param name="type">
            /// The type of debug messages to enable or disable.
            /// </param>
            /// <param name="severity">
            /// The severity of debug messages to enable or disable.
            /// </param>
            /// <param name="count">
            /// The length of the array ids.
            /// </param>
            /// <param name="ids">
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </param>
            /// <param name="enabled">
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            [CLSCompliant(false)]
            public static unsafe void DebugMessageControl(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, OpenTK.Graphics.ES31.All severity, Int32 count, UInt32* ids, bool enabled) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Inject an application-supplied message into the debug message queue
            /// </summary>
            /// <param name="source">
            /// The source of the debug message to insert.
            /// </param>
            /// <param name="type">
            /// The type of the debug message insert.
            /// </param>
            /// <param name="id">
            /// The user-supplied identifier of the message to insert.
            /// </param>
            /// <param name="severity">
            /// The severity of the debug messages to insert.
            /// </param>
            /// <param name="length">
            /// The length string contained in the character array whose address is given by message.
            /// </param>
            /// <param name="buf">
            /// The address of a character array containing the message to insert.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageInsertKHR")]
            [CLSCompliant(false)]
            public static void DebugMessageInsert(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, Int32 id, OpenTK.Graphics.ES31.All severity, Int32 length, String buf) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Inject an application-supplied message into the debug message queue
            /// </summary>
            /// <param name="source">
            /// The source of the debug message to insert.
            /// </param>
            /// <param name="type">
            /// The type of the debug message insert.
            /// </param>
            /// <param name="id">
            /// The user-supplied identifier of the message to insert.
            /// </param>
            /// <param name="severity">
            /// The severity of the debug messages to insert.
            /// </param>
            /// <param name="length">
            /// The length string contained in the character array whose address is given by message.
            /// </param>
            /// <param name="buf">
            /// The address of a character array containing the message to insert.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageInsertKHR")]
            [CLSCompliant(false)]
            public static void DebugMessageInsert(OpenTK.Graphics.ES31.All source, OpenTK.Graphics.ES31.All type, UInt32 id, OpenTK.Graphics.ES31.All severity, Int32 length, String buf) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// The number of debug messages to retrieve from the log.
            /// </param>
            /// <param name="bufSize">
            /// The size of the buffer whose address is given by messageLog.
            /// </param>
            /// <param name="sources">[length: count]
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </param>
            /// <param name="types">[length: count]
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </param>
            /// <param name="ids">[length: count]
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </param>
            /// <param name="severities">[length: count]
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </param>
            /// <param name="lengths">[length: count]
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </param>
            /// <param name="messageLog">[length: bufSize]
            /// The address of an array of characters that will receive the messages.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            [CLSCompliant(false)]
            public static Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All[] sources, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All[] types, [OutAttribute, CountAttribute(Parameter = "count")] Int32[] ids, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All[] severities, [OutAttribute, CountAttribute(Parameter = "count")] Int32[] lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String messageLog) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// The number of debug messages to retrieve from the log.
            /// </param>
            /// <param name="bufSize">
            /// The size of the buffer whose address is given by messageLog.
            /// </param>
            /// <param name="sources">[length: count]
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </param>
            /// <param name="types">[length: count]
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </param>
            /// <param name="ids">[length: count]
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </param>
            /// <param name="severities">[length: count]
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </param>
            /// <param name="lengths">[length: count]
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </param>
            /// <param name="messageLog">[length: bufSize]
            /// The address of an array of characters that will receive the messages.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            [CLSCompliant(false)]
            public static Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] out OpenTK.Graphics.ES31.All sources, [OutAttribute, CountAttribute(Parameter = "count")] out OpenTK.Graphics.ES31.All types, [OutAttribute, CountAttribute(Parameter = "count")] out Int32 ids, [OutAttribute, CountAttribute(Parameter = "count")] out OpenTK.Graphics.ES31.All severities, [OutAttribute, CountAttribute(Parameter = "count")] out Int32 lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String messageLog) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// The number of debug messages to retrieve from the log.
            /// </param>
            /// <param name="bufSize">
            /// The size of the buffer whose address is given by messageLog.
            /// </param>
            /// <param name="sources">[length: count]
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </param>
            /// <param name="types">[length: count]
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </param>
            /// <param name="ids">[length: count]
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </param>
            /// <param name="severities">[length: count]
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </param>
            /// <param name="lengths">[length: count]
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </param>
            /// <param name="messageLog">[length: bufSize]
            /// The address of an array of characters that will receive the messages.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            [CLSCompliant(false)]
            public static unsafe Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All* sources, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All* types, [OutAttribute, CountAttribute(Parameter = "count")] Int32* ids, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All* severities, [OutAttribute, CountAttribute(Parameter = "count")] Int32* lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String messageLog) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// The number of debug messages to retrieve from the log.
            /// </param>
            /// <param name="bufSize">
            /// The size of the buffer whose address is given by messageLog.
            /// </param>
            /// <param name="sources">[length: count]
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </param>
            /// <param name="types">[length: count]
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </param>
            /// <param name="ids">[length: count]
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </param>
            /// <param name="severities">[length: count]
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </param>
            /// <param name="lengths">[length: count]
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </param>
            /// <param name="messageLog">[length: bufSize]
            /// The address of an array of characters that will receive the messages.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            [CLSCompliant(false)]
            public static Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All[] sources, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All[] types, [OutAttribute, CountAttribute(Parameter = "count")] UInt32[] ids, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All[] severities, [OutAttribute, CountAttribute(Parameter = "count")] Int32[] lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String messageLog) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// The number of debug messages to retrieve from the log.
            /// </param>
            /// <param name="bufSize">
            /// The size of the buffer whose address is given by messageLog.
            /// </param>
            /// <param name="sources">[length: count]
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </param>
            /// <param name="types">[length: count]
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </param>
            /// <param name="ids">[length: count]
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </param>
            /// <param name="severities">[length: count]
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </param>
            /// <param name="lengths">[length: count]
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </param>
            /// <param name="messageLog">[length: bufSize]
            /// The address of an array of characters that will receive the messages.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            [CLSCompliant(false)]
            public static Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] out OpenTK.Graphics.ES31.All sources, [OutAttribute, CountAttribute(Parameter = "count")] out OpenTK.Graphics.ES31.All types, [OutAttribute, CountAttribute(Parameter = "count")] out UInt32 ids, [OutAttribute, CountAttribute(Parameter = "count")] out OpenTK.Graphics.ES31.All severities, [OutAttribute, CountAttribute(Parameter = "count")] out Int32 lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String messageLog) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// The number of debug messages to retrieve from the log.
            /// </param>
            /// <param name="bufSize">
            /// The size of the buffer whose address is given by messageLog.
            /// </param>
            /// <param name="sources">[length: count]
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </param>
            /// <param name="types">[length: count]
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </param>
            /// <param name="ids">[length: count]
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </param>
            /// <param name="severities">[length: count]
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </param>
            /// <param name="lengths">[length: count]
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </param>
            /// <param name="messageLog">[length: bufSize]
            /// The address of an array of characters that will receive the messages.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            [CLSCompliant(false)]
            public static unsafe Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All* sources, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All* types, [OutAttribute, CountAttribute(Parameter = "count")] UInt32* ids, [OutAttribute, CountAttribute(Parameter = "count")] OpenTK.Graphics.ES31.All* severities, [OutAttribute, CountAttribute(Parameter = "count")] Int32* lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String messageLog) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetGraphicsResetStatusKHR")]
            public static OpenTK.Graphics.ES31.All GetGraphicsResetStatus() { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformfvKHR")]
            [CLSCompliant(false)]
            public static void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] Single[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformfvKHR")]
            [CLSCompliant(false)]
            public static void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] out Single @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformfvKHR")]
            [CLSCompliant(false)]
            public static unsafe void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] Single* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformfvKHR")]
            [CLSCompliant(false)]
            public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Single[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformfvKHR")]
            [CLSCompliant(false)]
            public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] out Single @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformfvKHR")]
            [CLSCompliant(false)]
            public static unsafe void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Single* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformivKHR")]
            [CLSCompliant(false)]
            public static void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformivKHR")]
            [CLSCompliant(false)]
            public static void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformivKHR")]
            [CLSCompliant(false)]
            public static unsafe void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformivKHR")]
            [CLSCompliant(false)]
            public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformivKHR")]
            [CLSCompliant(false)]
            public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformivKHR")]
            [CLSCompliant(false)]
            public static unsafe void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformuivKHR")]
            [CLSCompliant(false)]
            public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] UInt32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformuivKHR")]
            [CLSCompliant(false)]
            public static void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] out UInt32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glGetnUniformuivKHR")]
            [CLSCompliant(false)]
            public static unsafe void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] UInt32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="name">
            /// The name of the object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectLabel(OpenTK.Graphics.ES31.All identifier, Int32 name, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="name">
            /// The name of the object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectLabel(OpenTK.Graphics.ES31.All identifier, Int32 name, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="name">
            /// The name of the object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            [CLSCompliant(false)]
            public static unsafe void GetObjectLabel(OpenTK.Graphics.ES31.All identifier, Int32 name, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="name">
            /// The name of the object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectLabel(OpenTK.Graphics.ES31.All identifier, UInt32 name, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="name">
            /// The name of the object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectLabel(OpenTK.Graphics.ES31.All identifier, UInt32 name, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="name">
            /// The name of the object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            [CLSCompliant(false)]
            public static unsafe void GetObjectLabel(OpenTK.Graphics.ES31.All identifier, UInt32 name, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectPtrLabel(IntPtr ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectPtrLabel(IntPtr ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static unsafe void GetObjectPtrLabel(IntPtr ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// The name of the sync object whose label to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// The length of the buffer whose address is in label.
            /// </param>
            /// <param name="length">[length: 1]
            /// The address of a variable to receive the length of the object label.
            /// </param>
            /// <param name="label">[length: bufSize]
            /// The address of a string that will receive the object label.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]</summary>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointervKHR")]
            public static void GetPointer(OpenTK.Graphics.ES31.All pname, [OutAttribute] IntPtr @params) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]</summary>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointervKHR")]
            [CLSCompliant(false)]
            public static void GetPointer<T1>(OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute] T1[] @params)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]</summary>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointervKHR")]
            [CLSCompliant(false)]
            public static void GetPointer<T1>(OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute] T1[,] @params)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]</summary>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointervKHR")]
            [CLSCompliant(false)]
            public static void GetPointer<T1>(OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute] T1[,,] @params)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]</summary>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointervKHR")]
            public static void GetPointer<T1>(OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute] ref T1 @params)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Label a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="name">
            /// The name of the object to label.
            /// </param>
            /// <param name="length">
            /// The length of the label to be used for the object.
            /// </param>
            /// <param name="label">
            /// The address of a string containing the label to assign to the object.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectLabelKHR")]
            [CLSCompliant(false)]
            public static void ObjectLabel(OpenTK.Graphics.ES31.All identifier, Int32 name, Int32 length, String label) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Label a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// The namespace from which the name of the object is allocated.
            /// </param>
            /// <param name="name">
            /// The name of the object to label.
            /// </param>
            /// <param name="length">
            /// The length of the label to be used for the object.
            /// </param>
            /// <param name="label">
            /// The address of a string containing the label to assign to the object.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectLabelKHR")]
            [CLSCompliant(false)]
            public static void ObjectLabel(OpenTK.Graphics.ES31.All identifier, UInt32 name, Int32 length, String label) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Label a a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// A pointer identifying a sync object.
            /// </param>
            /// <param name="length">
            /// The length of the label to be used for the object.
            /// </param>
            /// <param name="label">
            /// The address of a string containing the label to assign to the object.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabelKHR")]
            public static void ObjectPtrLabel(IntPtr ptr, Int32 length, String label) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Label a a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// A pointer identifying a sync object.
            /// </param>
            /// <param name="length">
            /// The length of the label to be used for the object.
            /// </param>
            /// <param name="label">
            /// The address of a string containing the label to assign to the object.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static void ObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 length, String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Label a a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// A pointer identifying a sync object.
            /// </param>
            /// <param name="length">
            /// The length of the label to be used for the object.
            /// </param>
            /// <param name="label">
            /// The address of a string containing the label to assign to the object.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static void ObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 length, String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Label a a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// A pointer identifying a sync object.
            /// </param>
            /// <param name="length">
            /// The length of the label to be used for the object.
            /// </param>
            /// <param name="label">
            /// The address of a string containing the label to assign to the object.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabelKHR")]
            [CLSCompliant(false)]
            public static void ObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 length, String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Label a a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// A pointer identifying a sync object.
            /// </param>
            /// <param name="length">
            /// The length of the label to be used for the object.
            /// </param>
            /// <param name="label">
            /// The address of a string containing the label to assign to the object.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabelKHR")]
            public static void ObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 length, String label)
                where T0 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Pop the active debug group
            /// </summary>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glPopDebugGroupKHR")]
            public static void PopDebugGroup() { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Push a named debug group into the command stream
            /// </summary>
            /// <param name="source">
            /// The source of the debug message.
            /// </param>
            /// <param name="id">
            /// The identifier of the message.
            /// </param>
            /// <param name="length">
            /// The length of the message to be sent to the debug output stream.
            /// </param>
            /// <param name="message">
            /// The a string containing the message to be sent to the debug output stream.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glPushDebugGroupKHR")]
            [CLSCompliant(false)]
            public static void PushDebugGroup(OpenTK.Graphics.ES31.All source, Int32 id, Int32 length, String message) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_debug]
            /// Push a named debug group into the command stream
            /// </summary>
            /// <param name="source">
            /// The source of the debug message.
            /// </param>
            /// <param name="id">
            /// The identifier of the message.
            /// </param>
            /// <param name="length">
            /// The length of the message to be sent to the debug output stream.
            /// </param>
            /// <param name="message">
            /// The a string containing the message to be sent to the debug output stream.
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glPushDebugGroupKHR")]
            [CLSCompliant(false)]
            public static void PushDebugGroup(OpenTK.Graphics.ES31.All source, UInt32 id, Int32 length, String message) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixelsKHR")]
            public static void ReadnPixels(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr data) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixelsKHR")]
            [CLSCompliant(false)]
            public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T7[] data)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixelsKHR")]
            [CLSCompliant(false)]
            public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T7[,] data)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixelsKHR")]
            [CLSCompliant(false)]
            public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T7[,,] data)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixelsKHR")]
            public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, Int32 bufSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] ref T7 data)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixelsKHR")]
            public static void ReadnPixels(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr data) { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixelsKHR")]
            [CLSCompliant(false)]
            public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, Int32 bufSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T7[] data)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixelsKHR")]
            [CLSCompliant(false)]
            public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, Int32 bufSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T7[,] data)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixelsKHR")]
            [CLSCompliant(false)]
            public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, Int32 bufSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T7[,,] data)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: KHR_robustness]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="bufSize"></param>
            /// <param name="data">[length: bufSize]</param>
            [AutoGenerated(Category = "KHR_robustness", Version = "", EntryPoint = "glReadnPixelsKHR")]
            public static void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES31.PixelFormat format, OpenTK.Graphics.ES31.PixelType type, Int32 bufSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] ref T7 data)
                where T7 : struct
             { throw new NotImplementedException(); }
        }

        public static partial class NV
        {
            /// <summary>[requires: NV_conditional_render]
            /// Start conditional rendering
            /// </summary>
            /// <param name="id">
            /// Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.
            /// </param>
            /// <param name="mode">
            /// Specifies how glBeginConditionalRender interprets the results of the occlusion query.
            /// </param>
            [AutoGenerated(Category = "NV_conditional_render", Version = "", EntryPoint = "glBeginConditionalRenderNV")]
            [CLSCompliant(false)]
            public static void BeginConditionalRender(Int32 id, OpenTK.Graphics.ES31.All mode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_conditional_render]
            /// Start conditional rendering
            /// </summary>
            /// <param name="id">
            /// Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.
            /// </param>
            /// <param name="mode">
            /// Specifies how glBeginConditionalRender interprets the results of the occlusion query.
            /// </param>
            [AutoGenerated(Category = "NV_conditional_render", Version = "", EntryPoint = "glBeginConditionalRenderNV")]
            [CLSCompliant(false)]
            public static void BeginConditionalRender(UInt32 id, OpenTK.Graphics.ES31.All mode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_blend_equation_advanced]</summary>
            [AutoGenerated(Category = "NV_blend_equation_advanced", Version = "", EntryPoint = "glBlendBarrierNV")]
            public static void BlendBarrier() { throw new NotImplementedException(); }

            /// <summary>[requires: NV_blend_equation_advanced]</summary>
            /// <param name="pname"></param>
            /// <param name="value"></param>
            [AutoGenerated(Category = "NV_blend_equation_advanced", Version = "", EntryPoint = "glBlendParameteriNV")]
            public static void BlendParameter(OpenTK.Graphics.ES31.All pname, Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_framebuffer_blit]
            /// Copy a block of pixels from the read framebuffer to the draw framebuffer
            /// </summary>
            /// <param name="srcX0">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="srcY0">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="srcX1">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="srcY1">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="dstX0">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="dstY0">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="dstX1">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="dstY1">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="mask">
            /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are ColorBufferBit, DepthBufferBit and StencilBufferBit.
            /// </param>
            /// <param name="filter">
            /// Specifies the interpolation to be applied if the image is stretched. Must be Nearest or Linear.
            /// </param>
            [AutoGenerated(Category = "NV_framebuffer_blit", Version = "", EntryPoint = "glBlitFramebufferNV")]
            [CLSCompliant(false)]
            public static void BlitFramebuffer(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, Int32 mask, OpenTK.Graphics.ES31.All filter) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_framebuffer_blit]
            /// Copy a block of pixels from the read framebuffer to the draw framebuffer
            /// </summary>
            /// <param name="srcX0">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="srcY0">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="srcX1">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="srcY1">
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </param>
            /// <param name="dstX0">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="dstY0">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="dstX1">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="dstY1">
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </param>
            /// <param name="mask">
            /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are ColorBufferBit, DepthBufferBit and StencilBufferBit.
            /// </param>
            /// <param name="filter">
            /// Specifies the interpolation to be applied if the image is stretched. Must be Nearest or Linear.
            /// </param>
            [AutoGenerated(Category = "NV_framebuffer_blit", Version = "", EntryPoint = "glBlitFramebufferNV")]
            [CLSCompliant(false)]
            public static void BlitFramebuffer(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, UInt32 mask, OpenTK.Graphics.ES31.All filter) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_conservative_raster_pre_snap_triangles]</summary>
            /// <param name="pname"></param>
            /// <param name="param"></param>
            [AutoGenerated(Category = "NV_conservative_raster_pre_snap_triangles", Version = "", EntryPoint = "glConservativeRasterParameteriNV")]
            public static void ConservativeRasterParameter(OpenTK.Graphics.ES31.All pname, Int32 param) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_copy_buffer]
            /// Copy part of the data store of a buffer object to the data store of another buffer object
            /// </summary>
            /// <param name="readTarget">
            /// Specifies the target from whose data store data should be read.
            /// </param>
            /// <param name="writeTarget">
            /// Specifies the target to whose data store data should be written.
            /// </param>
            /// <param name="readOffset">
            /// Specifies the offset, in basic machine units, within the data store of readtarget from which data should be read.
            /// </param>
            /// <param name="writeOffset">
            /// Specifies the offset, in basic machine units, within the data store of writetarget to which data should be written.
            /// </param>
            /// <param name="size">
            /// Specifies the size, in basic machine units, of the data to be copied from readtarget to writetarget.
            /// </param>
            [AutoGenerated(Category = "NV_copy_buffer", Version = "", EntryPoint = "glCopyBufferSubDataNV")]
            public static void CopyBufferSubData(OpenTK.Graphics.ES31.All readTarget, OpenTK.Graphics.ES31.All writeTarget, IntPtr readOffset, IntPtr writeOffset, Int32 size) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_copy_buffer]
            /// Copy part of the data store of a buffer object to the data store of another buffer object
            /// </summary>
            /// <param name="readTarget">
            /// Specifies the target from whose data store data should be read.
            /// </param>
            /// <param name="writeTarget">
            /// Specifies the target to whose data store data should be written.
            /// </param>
            /// <param name="readOffset">
            /// Specifies the offset, in basic machine units, within the data store of readtarget from which data should be read.
            /// </param>
            /// <param name="writeOffset">
            /// Specifies the offset, in basic machine units, within the data store of writetarget to which data should be written.
            /// </param>
            /// <param name="size">
            /// Specifies the size, in basic machine units, of the data to be copied from readtarget to writetarget.
            /// </param>
            [AutoGenerated(Category = "NV_copy_buffer", Version = "", EntryPoint = "glCopyBufferSubDataNV")]
            public static void CopyBufferSubData(OpenTK.Graphics.ES31.All readTarget, OpenTK.Graphics.ES31.All writeTarget, IntPtr readOffset, IntPtr writeOffset, IntPtr size) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="srcPath"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCopyPathNV")]
            [CLSCompliant(false)]
            public static void CopyPath(Int32 resultPath, Int32 srcPath) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="srcPath"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCopyPathNV")]
            [CLSCompliant(false)]
            public static void CopyPath(UInt32 resultPath, UInt32 srcPath) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_coverage_sample]</summary>
            /// <param name="mask"></param>
            [AutoGenerated(Category = "NV_coverage_sample", Version = "", EntryPoint = "glCoverageMaskNV")]
            public static void CoverageMask(bool mask) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_framebuffer_mixed_samples]</summary>
            /// <param name="components"></param>
            [AutoGenerated(Category = "NV_framebuffer_mixed_samples", Version = "", EntryPoint = "glCoverageModulationNV")]
            public static void CoverageModulation(OpenTK.Graphics.ES31.All components) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_framebuffer_mixed_samples]</summary>
            /// <param name="n"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_framebuffer_mixed_samples", Version = "", EntryPoint = "glCoverageModulationTableNV")]
            [CLSCompliant(false)]
            public static void CoverageModulationTable(Int32 n, Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_framebuffer_mixed_samples]</summary>
            /// <param name="n"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_framebuffer_mixed_samples", Version = "", EntryPoint = "glCoverageModulationTableNV")]
            [CLSCompliant(false)]
            public static void CoverageModulationTable(Int32 n, ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_framebuffer_mixed_samples]</summary>
            /// <param name="n"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_framebuffer_mixed_samples", Version = "", EntryPoint = "glCoverageModulationTableNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverageModulationTable(Int32 n, Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_coverage_sample]</summary>
            /// <param name="operation"></param>
            [AutoGenerated(Category = "NV_coverage_sample", Version = "", EntryPoint = "glCoverageOperationNV")]
            public static void CoverageOperation(OpenTK.Graphics.ES31.All operation) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coverMode"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathNV")]
            [CLSCompliant(false)]
            public static void CoverFillPath(Int32 path, OpenTK.Graphics.ES31.All coverMode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coverMode"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverFillPathNV")]
            [CLSCompliant(false)]
            public static void CoverFillPath(UInt32 path, OpenTK.Graphics.ES31.All coverMode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, Int32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void CoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, UInt32 pathBase, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coverMode"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePath(Int32 path, OpenTK.Graphics.ES31.All coverMode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coverMode"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glCoverStrokePathNV")]
            [CLSCompliant(false)]
            public static void CoverStrokePath(UInt32 path, OpenTK.Graphics.ES31.All coverMode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            [CLSCompliant(false)]
            public static void DeleteFence([CountAttribute(Parameter = "n")] Int32 fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            [CLSCompliant(false)]
            public static void DeleteFence([CountAttribute(Parameter = "n")] UInt32 fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="n"></param>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            [CLSCompliant(false)]
            public static void DeleteFences(Int32 n, [CountAttribute(Parameter = "n")] Int32[] fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="n"></param>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            [CLSCompliant(false)]
            public static void DeleteFences(Int32 n, [CountAttribute(Parameter = "n")] ref Int32 fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="n"></param>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            [CLSCompliant(false)]
            public static unsafe void DeleteFences(Int32 n, [CountAttribute(Parameter = "n")] Int32* fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="n"></param>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            [CLSCompliant(false)]
            public static void DeleteFences(Int32 n, [CountAttribute(Parameter = "n")] UInt32[] fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="n"></param>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            [CLSCompliant(false)]
            public static void DeleteFences(Int32 n, [CountAttribute(Parameter = "n")] ref UInt32 fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="n"></param>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            [CLSCompliant(false)]
            public static unsafe void DeleteFences(Int32 n, [CountAttribute(Parameter = "n")] UInt32* fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="range"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glDeletePathsNV")]
            [CLSCompliant(false)]
            public static void DeletePath(Int32 path, Int32 range) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="range"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glDeletePathsNV")]
            [CLSCompliant(false)]
            public static void DeletePath(UInt32 path, Int32 range) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose depth range to update.
            /// </param>
            /// <param name="count">
            /// Specifies the number of viewports whose depth range to update.
            /// </param>
            /// <param name="v">
            /// Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glDepthRangeArrayfvNV")]
            [CLSCompliant(false)]
            public static void DepthRangeArray(Int32 first, Int32 count, Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose depth range to update.
            /// </param>
            /// <param name="count">
            /// Specifies the number of viewports whose depth range to update.
            /// </param>
            /// <param name="v">
            /// Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glDepthRangeArrayfvNV")]
            [CLSCompliant(false)]
            public static void DepthRangeArray(Int32 first, Int32 count, ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose depth range to update.
            /// </param>
            /// <param name="count">
            /// Specifies the number of viewports whose depth range to update.
            /// </param>
            /// <param name="v">
            /// Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glDepthRangeArrayfvNV")]
            [CLSCompliant(false)]
            public static unsafe void DepthRangeArray(Int32 first, Int32 count, Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose depth range to update.
            /// </param>
            /// <param name="count">
            /// Specifies the number of viewports whose depth range to update.
            /// </param>
            /// <param name="v">
            /// Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glDepthRangeArrayfvNV")]
            [CLSCompliant(false)]
            public static void DepthRangeArray(UInt32 first, Int32 count, Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose depth range to update.
            /// </param>
            /// <param name="count">
            /// Specifies the number of viewports whose depth range to update.
            /// </param>
            /// <param name="v">
            /// Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glDepthRangeArrayfvNV")]
            [CLSCompliant(false)]
            public static void DepthRangeArray(UInt32 first, Int32 count, ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose depth range to update.
            /// </param>
            /// <param name="count">
            /// Specifies the number of viewports whose depth range to update.
            /// </param>
            /// <param name="v">
            /// Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glDepthRangeArrayfvNV")]
            [CLSCompliant(false)]
            public static unsafe void DepthRangeArray(UInt32 first, Int32 count, Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose depth range to update.
            /// </param>
            /// <param name="n">
            /// Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
            /// </param>
            /// <param name="f">
            /// Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glDepthRangeIndexedfNV")]
            [CLSCompliant(false)]
            public static void DepthRangeIndexed(Int32 index, Single n, Single f) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose depth range to update.
            /// </param>
            /// <param name="n">
            /// Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
            /// </param>
            /// <param name="f">
            /// Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glDepthRangeIndexedfNV")]
            [CLSCompliant(false)]
            public static void DepthRangeIndexed(UInt32 index, Single n, Single f) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glDisableiNV")]
            [CLSCompliant(false)]
            public static void Disable(OpenTK.Graphics.ES31.All target, Int32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glDisableiNV")]
            [CLSCompliant(false)]
            public static void Disable(OpenTK.Graphics.ES31.All target, UInt32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a range of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="first">
            /// Specifies the starting index in the enabled arrays.
            /// </param>
            /// <param name="count">
            /// Specifies the number of indices to be rendered.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawArraysInstancedNV")]
            public static void DrawArraysInstanced(OpenTK.Graphics.ES31.All mode, Int32 first, Int32 count, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a range of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="first">
            /// Specifies the starting index in the enabled arrays.
            /// </param>
            /// <param name="count">
            /// Specifies the number of indices to be rendered.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawArraysInstancedNV")]
            public static void DrawArraysInstanced(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 first, Int32 count, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// Specifies the number of buffers in bufs.
            /// </param>
            /// <param name="bufs">[length: n]
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </param>
            [AutoGenerated(Category = "NV_draw_buffers", Version = "", EntryPoint = "glDrawBuffersNV")]
            [CLSCompliant(false)]
            public static void DrawBuffers(Int32 n, [CountAttribute(Parameter = "n")] OpenTK.Graphics.ES31.All[] bufs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// Specifies the number of buffers in bufs.
            /// </param>
            /// <param name="bufs">[length: n]
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </param>
            [AutoGenerated(Category = "NV_draw_buffers", Version = "", EntryPoint = "glDrawBuffersNV")]
            [CLSCompliant(false)]
            public static void DrawBuffers(Int32 n, [CountAttribute(Parameter = "n")] ref OpenTK.Graphics.ES31.All bufs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// Specifies the number of buffers in bufs.
            /// </param>
            /// <param name="bufs">[length: n]
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </param>
            [AutoGenerated(Category = "NV_draw_buffers", Version = "", EntryPoint = "glDrawBuffersNV")]
            [CLSCompliant(false)]
            public static unsafe void DrawBuffers(Int32 n, [CountAttribute(Parameter = "n")] OpenTK.Graphics.ES31.All* bufs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static void DrawElementsInstanced(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static void DrawElementsInstanced(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 primcount) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            [CLSCompliant(false)]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan and Triangles are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="primcount">
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </param>
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static void DrawElementsInstanced<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 primcount)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_vulkan_image]</summary>
            /// <param name="vkImage"></param>
            /// <param name="sampler"></param>
            /// <param name="x0"></param>
            /// <param name="y0"></param>
            /// <param name="x1"></param>
            /// <param name="y1"></param>
            /// <param name="z"></param>
            /// <param name="s0"></param>
            /// <param name="t0"></param>
            /// <param name="s1"></param>
            /// <param name="t1"></param>
            [AutoGenerated(Category = "NV_draw_vulkan_image", Version = "", EntryPoint = "glDrawVkImageNV")]
            [CLSCompliant(false)]
            public static void DrawVkImage(Int64 vkImage, Int32 sampler, Single x0, Single y0, Single x1, Single y1, Single z, Single s0, Single t0, Single s1, Single t1) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_vulkan_image]</summary>
            /// <param name="vkImage"></param>
            /// <param name="sampler"></param>
            /// <param name="x0"></param>
            /// <param name="y0"></param>
            /// <param name="x1"></param>
            /// <param name="y1"></param>
            /// <param name="z"></param>
            /// <param name="s0"></param>
            /// <param name="t0"></param>
            /// <param name="s1"></param>
            /// <param name="t1"></param>
            [AutoGenerated(Category = "NV_draw_vulkan_image", Version = "", EntryPoint = "glDrawVkImageNV")]
            [CLSCompliant(false)]
            public static void DrawVkImage(UInt64 vkImage, UInt32 sampler, Single x0, Single y0, Single x1, Single y1, Single z, Single s0, Single t0, Single s1, Single t1) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Enable or disable server-side GL capabilities
            /// </summary>
            /// <param name="target">
            /// Specifies a symbolic constant indicating a GL capability.
            /// </param>
            /// <param name="index"></param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glEnableiNV")]
            [CLSCompliant(false)]
            public static void Enable(OpenTK.Graphics.ES31.All target, Int32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Enable or disable server-side GL capabilities
            /// </summary>
            /// <param name="target">
            /// Specifies a symbolic constant indicating a GL capability.
            /// </param>
            /// <param name="index"></param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glEnableiNV")]
            [CLSCompliant(false)]
            public static void Enable(OpenTK.Graphics.ES31.All target, UInt32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_conditional_render]</summary>
            [AutoGenerated(Category = "NV_conditional_render", Version = "", EntryPoint = "glEndConditionalRenderNV")]
            public static void EndConditionalRender() { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glFinishFenceNV")]
            [CLSCompliant(false)]
            public static void FinishFence(Int32 fence) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glFinishFenceNV")]
            [CLSCompliant(false)]
            public static void FinishFence(UInt32 fence) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fragment_coverage_to_color]</summary>
            /// <param name="color"></param>
            [AutoGenerated(Category = "NV_fragment_coverage_to_color", Version = "", EntryPoint = "glFragmentCoverageColorNV")]
            [CLSCompliant(false)]
            public static void FragmentCoverageColor(Int32 color) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fragment_coverage_to_color]</summary>
            /// <param name="color"></param>
            [AutoGenerated(Category = "NV_fragment_coverage_to_color", Version = "", EntryPoint = "glFragmentCoverageColorNV")]
            [CLSCompliant(false)]
            public static void FragmentCoverageColor(UInt32 color) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_sample_locations]</summary>
            /// <param name="target"></param>
            /// <param name="start"></param>
            /// <param name="count"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_sample_locations", Version = "", EntryPoint = "glFramebufferSampleLocationsfvNV")]
            [CLSCompliant(false)]
            public static void FramebufferSampleLocations(OpenTK.Graphics.ES31.All target, Int32 start, Int32 count, Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_sample_locations]</summary>
            /// <param name="target"></param>
            /// <param name="start"></param>
            /// <param name="count"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_sample_locations", Version = "", EntryPoint = "glFramebufferSampleLocationsfvNV")]
            [CLSCompliant(false)]
            public static void FramebufferSampleLocations(OpenTK.Graphics.ES31.All target, Int32 start, Int32 count, ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_sample_locations]</summary>
            /// <param name="target"></param>
            /// <param name="start"></param>
            /// <param name="count"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_sample_locations", Version = "", EntryPoint = "glFramebufferSampleLocationsfvNV")]
            [CLSCompliant(false)]
            public static unsafe void FramebufferSampleLocations(OpenTK.Graphics.ES31.All target, Int32 start, Int32 count, Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_sample_locations]</summary>
            /// <param name="target"></param>
            /// <param name="start"></param>
            /// <param name="count"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_sample_locations", Version = "", EntryPoint = "glFramebufferSampleLocationsfvNV")]
            [CLSCompliant(false)]
            public static void FramebufferSampleLocations(OpenTK.Graphics.ES31.All target, UInt32 start, Int32 count, Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_sample_locations]</summary>
            /// <param name="target"></param>
            /// <param name="start"></param>
            /// <param name="count"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_sample_locations", Version = "", EntryPoint = "glFramebufferSampleLocationsfvNV")]
            [CLSCompliant(false)]
            public static void FramebufferSampleLocations(OpenTK.Graphics.ES31.All target, UInt32 start, Int32 count, ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_sample_locations]</summary>
            /// <param name="target"></param>
            /// <param name="start"></param>
            /// <param name="count"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_sample_locations", Version = "", EntryPoint = "glFramebufferSampleLocationsfvNV")]
            [CLSCompliant(false)]
            public static unsafe void FramebufferSampleLocations(OpenTK.Graphics.ES31.All target, UInt32 start, Int32 count, Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            [CLSCompliant(false)]
            public static Int32 GenFence() { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="n"></param>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            [CLSCompliant(false)]
            public static void GenFences(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="n"></param>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            [CLSCompliant(false)]
            public static void GenFences(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="n"></param>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            [CLSCompliant(false)]
            public static unsafe void GenFences(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="n"></param>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            [CLSCompliant(false)]
            public static void GenFences(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="n"></param>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            [CLSCompliant(false)]
            public static void GenFences(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="n"></param>
            /// <param name="fences">[length: n]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            [CLSCompliant(false)]
            public static unsafe void GenFences(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* fences) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="range"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGenPathsNV")]
            public static Int32 GenPath(Int32 range) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_framebuffer_mixed_samples]</summary>
            [AutoGenerated(Category = "NV_framebuffer_mixed_samples", Version = "", EntryPoint = "glGetCoverageModulationTableNV")]
            [CLSCompliant(false)]
            public static Single GetCoverageModulationTable() { throw new NotImplementedException(); }

            /// <summary>[requires: NV_framebuffer_mixed_samples]</summary>
            /// <param name="bufsize"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_framebuffer_mixed_samples", Version = "", EntryPoint = "glGetCoverageModulationTableNV")]
            [CLSCompliant(false)]
            public static void GetCoverageModulationTable(Int32 bufsize, [OutAttribute] Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_framebuffer_mixed_samples]</summary>
            /// <param name="bufsize"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_framebuffer_mixed_samples", Version = "", EntryPoint = "glGetCoverageModulationTableNV")]
            [CLSCompliant(false)]
            public static void GetCoverageModulationTable(Int32 bufsize, [OutAttribute] out Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_framebuffer_mixed_samples]</summary>
            /// <param name="bufsize"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_framebuffer_mixed_samples", Version = "", EntryPoint = "glGetCoverageModulationTableNV")]
            [CLSCompliant(false)]
            public static unsafe void GetCoverageModulationTable(Int32 bufsize, [OutAttribute] Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGetFenceivNV")]
            [CLSCompliant(false)]
            public static void GetFence(Int32 fence, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGetFenceivNV")]
            [CLSCompliant(false)]
            public static void GetFence(Int32 fence, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGetFenceivNV")]
            [CLSCompliant(false)]
            public static unsafe void GetFence(Int32 fence, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGetFenceivNV")]
            [CLSCompliant(false)]
            public static void GetFence(UInt32 fence, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGetFenceivNV")]
            [CLSCompliant(false)]
            public static void GetFence(UInt32 fence, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGetFenceivNV")]
            [CLSCompliant(false)]
            public static unsafe void GetFence(UInt32 fence, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glGetFloati_vNV")]
            [CLSCompliant(false)]
            public static void GetFloat(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] Single[] data) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glGetFloati_vNV")]
            [CLSCompliant(false)]
            public static void GetFloat(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] out Single data) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glGetFloati_vNV")]
            [CLSCompliant(false)]
            public static unsafe void GetFloat(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] Single* data) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glGetFloati_vNV")]
            [CLSCompliant(false)]
            public static void GetFloat(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Single[] data) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glGetFloati_vNV")]
            [CLSCompliant(false)]
            public static void GetFloat(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] out Single data) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glGetFloati_vNV")]
            [CLSCompliant(false)]
            public static unsafe void GetFloat(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Single* data) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="layered"></param>
            /// <param name="layer"></param>
            /// <param name="format"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glGetImageHandleNV")]
            [CLSCompliant(false)]
            public static Int64 GetImageHandle(Int32 texture, Int32 level, bool layered, Int32 layer, OpenTK.Graphics.ES31.All format) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="layered"></param>
            /// <param name="layer"></param>
            /// <param name="format"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glGetImageHandleNV")]
            [CLSCompliant(false)]
            public static Int64 GetImageHandle(UInt32 texture, Int32 level, bool layered, Int32 layer, OpenTK.Graphics.ES31.All format) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_internalformat_sample_query]</summary>
            /// <param name="target"></param>
            /// <param name="internalformat"></param>
            /// <param name="samples"></param>
            /// <param name="pname"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "NV_internalformat_sample_query", Version = "", EntryPoint = "glGetInternalformatSampleivNV")]
            [CLSCompliant(false)]
            public static void GetInternalformatSample(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, Int32 samples, OpenTK.Graphics.ES31.All pname, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_internalformat_sample_query]</summary>
            /// <param name="target"></param>
            /// <param name="internalformat"></param>
            /// <param name="samples"></param>
            /// <param name="pname"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "NV_internalformat_sample_query", Version = "", EntryPoint = "glGetInternalformatSampleivNV")]
            [CLSCompliant(false)]
            public static void GetInternalformatSample(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, Int32 samples, OpenTK.Graphics.ES31.All pname, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_internalformat_sample_query]</summary>
            /// <param name="target"></param>
            /// <param name="internalformat"></param>
            /// <param name="samples"></param>
            /// <param name="pname"></param>
            /// <param name="bufSize"></param>
            /// <param name="@params">[length: bufSize]</param>
            [AutoGenerated(Category = "NV_internalformat_sample_query", Version = "", EntryPoint = "glGetInternalformatSampleivNV")]
            [CLSCompliant(false)]
            public static unsafe void GetInternalformatSample(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, Int32 samples, OpenTK.Graphics.ES31.All pname, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="color"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathColorGenfvNV")]
            [CLSCompliant(false)]
            public static void GetPathColorGen(OpenTK.Graphics.ES31.All color, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="color"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathColorGenfvNV")]
            [CLSCompliant(false)]
            public static void GetPathColorGen(OpenTK.Graphics.ES31.All color, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="color"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathColorGenfvNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathColorGen(OpenTK.Graphics.ES31.All color, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="color"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathColorGenivNV")]
            [CLSCompliant(false)]
            public static void GetPathColorGen(OpenTK.Graphics.ES31.All color, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="color"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathColorGenivNV")]
            [CLSCompliant(false)]
            public static void GetPathColorGen(OpenTK.Graphics.ES31.All color, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="color"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathColorGenivNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathColorGen(OpenTK.Graphics.ES31.All color, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCommandsNV")]
            [CLSCompliant(false)]
            public static Byte GetPathCommand(Int32 path) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCommandsNV")]
            [CLSCompliant(false)]
            public static Byte GetPathCommand(UInt32 path) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commands">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCommandsNV")]
            [CLSCompliant(false)]
            public static void GetPathCommands(Int32 path, [OutAttribute, CountAttribute(Computed = "path")] Byte[] commands) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commands">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCommandsNV")]
            [CLSCompliant(false)]
            public static void GetPathCommands(Int32 path, [OutAttribute, CountAttribute(Computed = "path")] out Byte commands) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commands">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathCommands(Int32 path, [OutAttribute, CountAttribute(Computed = "path")] Byte* commands) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commands">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCommandsNV")]
            [CLSCompliant(false)]
            public static void GetPathCommands(UInt32 path, [OutAttribute, CountAttribute(Computed = "path")] Byte[] commands) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commands">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCommandsNV")]
            [CLSCompliant(false)]
            public static void GetPathCommands(UInt32 path, [OutAttribute, CountAttribute(Computed = "path")] out Byte commands) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commands">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathCommands(UInt32 path, [OutAttribute, CountAttribute(Computed = "path")] Byte* commands) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCoordsNV")]
            [CLSCompliant(false)]
            public static Single GetPathCoord(Int32 path) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCoordsNV")]
            [CLSCompliant(false)]
            public static Single GetPathCoord(UInt32 path) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coords">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCoordsNV")]
            [CLSCompliant(false)]
            public static void GetPathCoords(Int32 path, [OutAttribute, CountAttribute(Computed = "path")] Single[] coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coords">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCoordsNV")]
            [CLSCompliant(false)]
            public static void GetPathCoords(Int32 path, [OutAttribute, CountAttribute(Computed = "path")] out Single coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coords">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCoordsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathCoords(Int32 path, [OutAttribute, CountAttribute(Computed = "path")] Single* coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coords">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCoordsNV")]
            [CLSCompliant(false)]
            public static void GetPathCoords(UInt32 path, [OutAttribute, CountAttribute(Computed = "path")] Single[] coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coords">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCoordsNV")]
            [CLSCompliant(false)]
            public static void GetPathCoords(UInt32 path, [OutAttribute, CountAttribute(Computed = "path")] out Single coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coords">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathCoordsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathCoords(UInt32 path, [OutAttribute, CountAttribute(Computed = "path")] Single* coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathDashArrayNV")]
            [CLSCompliant(false)]
            public static Single GetPathDashArray(Int32 path) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathDashArrayNV")]
            [CLSCompliant(false)]
            public static Single GetPathDashArray(UInt32 path) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="dashArray">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathDashArrayNV")]
            [CLSCompliant(false)]
            public static void GetPathDashArray(Int32 path, [OutAttribute, CountAttribute(Computed = "path")] Single[] dashArray) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="dashArray">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathDashArrayNV")]
            [CLSCompliant(false)]
            public static void GetPathDashArray(Int32 path, [OutAttribute, CountAttribute(Computed = "path")] out Single dashArray) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="dashArray">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathDashArrayNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathDashArray(Int32 path, [OutAttribute, CountAttribute(Computed = "path")] Single* dashArray) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="dashArray">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathDashArrayNV")]
            [CLSCompliant(false)]
            public static void GetPathDashArray(UInt32 path, [OutAttribute, CountAttribute(Computed = "path")] Single[] dashArray) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="dashArray">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathDashArrayNV")]
            [CLSCompliant(false)]
            public static void GetPathDashArray(UInt32 path, [OutAttribute, CountAttribute(Computed = "path")] out Single dashArray) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="dashArray">[length: COMPSIZE(path)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathDashArrayNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathDashArray(UInt32 path, [OutAttribute, CountAttribute(Computed = "path")] Single* dashArray) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="startSegment"></param>
            /// <param name="numSegments"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathLengthNV")]
            [CLSCompliant(false)]
            public static Single GetPathLength(Int32 path, Int32 startSegment, Int32 numSegments) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="startSegment"></param>
            /// <param name="numSegments"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathLengthNV")]
            [CLSCompliant(false)]
            public static Single GetPathLength(UInt32 path, Int32 startSegment, Int32 numSegments) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="firstPathName"></param>
            /// <param name="numPaths"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricRangeNV")]
            [CLSCompliant(false)]
            public static void GetPathMetricRange(Int32 metricQueryMask, Int32 firstPathName, Int32 numPaths, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single[] metrics) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="firstPathName"></param>
            /// <param name="numPaths"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricRangeNV")]
            [CLSCompliant(false)]
            public static void GetPathMetricRange(Int32 metricQueryMask, Int32 firstPathName, Int32 numPaths, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] out Single metrics) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="firstPathName"></param>
            /// <param name="numPaths"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricRangeNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathMetricRange(Int32 metricQueryMask, Int32 firstPathName, Int32 numPaths, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="firstPathName"></param>
            /// <param name="numPaths"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricRangeNV")]
            [CLSCompliant(false)]
            public static void GetPathMetricRange(UInt32 metricQueryMask, UInt32 firstPathName, Int32 numPaths, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single[] metrics) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="firstPathName"></param>
            /// <param name="numPaths"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricRangeNV")]
            [CLSCompliant(false)]
            public static void GetPathMetricRange(UInt32 metricQueryMask, UInt32 firstPathName, Int32 numPaths, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] out Single metrics) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="firstPathName"></param>
            /// <param name="numPaths"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricRangeNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathMetricRange(UInt32 metricQueryMask, UInt32 firstPathName, Int32 numPaths, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single[] metrics) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] out Single metrics) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathMetric(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[] paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single[] metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[] paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] out Single metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathMetric<T3>(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[] paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,] paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single[] metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,] paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] out Single metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathMetric<T3>(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,] paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,,] paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single[] metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,,] paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] out Single metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathMetric<T3>(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,,] paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T3 paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single[] metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T3 paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] out Single metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathMetric<T3>(Int32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T3 paths, Int32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single[] metrics) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] out Single metrics) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathMetric(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[] paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single[] metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[] paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] out Single metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathMetric<T3>(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[] paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,] paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single[] metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,] paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] out Single metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathMetric<T3>(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,] paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,,] paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single[] metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,,] paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] out Single metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathMetric<T3>(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,,] paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T3 paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single[] metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static void GetPathMetric<T3>(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T3 paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] out Single metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="metricQueryMask"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="stride"></param>
            /// <param name="metrics">[length: COMPSIZE(metricQueryMask,numPaths,stride)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathMetricsNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathMetric<T3>(UInt32 metricQueryMask, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T3 paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: 4]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathParameterfvNV")]
            [CLSCompliant(false)]
            public static void GetPathParameter(Int32 path, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: 4]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathParameterfvNV")]
            [CLSCompliant(false)]
            public static void GetPathParameter(Int32 path, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] out Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: 4]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathParameterfvNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathParameter(Int32 path, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: 4]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathParameterfvNV")]
            [CLSCompliant(false)]
            public static void GetPathParameter(UInt32 path, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: 4]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathParameterfvNV")]
            [CLSCompliant(false)]
            public static void GetPathParameter(UInt32 path, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] out Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: 4]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathParameterfvNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathParameter(UInt32 path, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: 4]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathParameterivNV")]
            [CLSCompliant(false)]
            public static void GetPathParameter(Int32 path, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: 4]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathParameterivNV")]
            [CLSCompliant(false)]
            public static void GetPathParameter(Int32 path, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] out Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: 4]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathParameterivNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathParameter(Int32 path, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: 4]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathParameterivNV")]
            [CLSCompliant(false)]
            public static void GetPathParameter(UInt32 path, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: 4]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathParameterivNV")]
            [CLSCompliant(false)]
            public static void GetPathParameter(UInt32 path, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] out Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: 4]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathParameterivNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathParameter(UInt32 path, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Count = 4)] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single[] returnedSpacing) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] out Single returnedSpacing) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathSpacing(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single* returnedSpacing) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single[] returnedSpacing) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] out Single returnedSpacing) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathSpacing(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single* returnedSpacing) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[] paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single[] returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[] paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] out Single returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[] paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single* returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[] paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single[] returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[] paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] out Single returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[] paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single* returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,] paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single[] returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,] paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] out Single returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,] paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single* returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,] paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single[] returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,] paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] out Single returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,] paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single* returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,,] paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single[] returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,,] paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] out Single returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,,] paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single* returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,,] paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single[] returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,,] paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] out Single returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T3[,,] paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single* returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T3 paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single[] returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T3 paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] out Single returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T3 paths, Int32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single* returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T3 paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single[] returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T3 paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] out Single returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="pathListMode"></param>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="advanceScale"></param>
            /// <param name="kerningScale"></param>
            /// <param name="transformType"></param>
            /// <param name="returnedSpacing">[length: COMPSIZE(pathListMode,numPaths)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathSpacingNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathSpacing<T3>(OpenTK.Graphics.ES31.All pathListMode, Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T3 paths, UInt32 pathBase, Single advanceScale, Single kerningScale, OpenTK.Graphics.ES31.All transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single* returnedSpacing)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathTexGenfvNV")]
            [CLSCompliant(false)]
            public static void GetPathTexGen(OpenTK.Graphics.ES31.All texCoordSet, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathTexGenfvNV")]
            [CLSCompliant(false)]
            public static void GetPathTexGen(OpenTK.Graphics.ES31.All texCoordSet, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathTexGenfvNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathTexGen(OpenTK.Graphics.ES31.All texCoordSet, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathTexGenfvNV")]
            [CLSCompliant(false)]
            public static void GetPathTexGen(OpenTK.Graphics.ES31.TextureUnit texCoordSet, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathTexGenfvNV")]
            [CLSCompliant(false)]
            public static void GetPathTexGen(OpenTK.Graphics.ES31.TextureUnit texCoordSet, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathTexGenfvNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathTexGen(OpenTK.Graphics.ES31.TextureUnit texCoordSet, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathTexGenivNV")]
            [CLSCompliant(false)]
            public static void GetPathTexGen(OpenTK.Graphics.ES31.All texCoordSet, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathTexGenivNV")]
            [CLSCompliant(false)]
            public static void GetPathTexGen(OpenTK.Graphics.ES31.All texCoordSet, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathTexGenivNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathTexGen(OpenTK.Graphics.ES31.All texCoordSet, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathTexGenivNV")]
            [CLSCompliant(false)]
            public static void GetPathTexGen(OpenTK.Graphics.ES31.TextureUnit texCoordSet, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathTexGenivNV")]
            [CLSCompliant(false)]
            public static void GetPathTexGen(OpenTK.Graphics.ES31.TextureUnit texCoordSet, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetPathTexGenivNV")]
            [CLSCompliant(false)]
            public static unsafe void GetPathTexGen(OpenTK.Graphics.ES31.TextureUnit texCoordSet, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]
            /// Retrieve values for multiple properties of a single active resource within a program object
            /// </summary>
            /// <param name="program">
            /// The name of a program object whose resources to query.
            /// </param>
            /// <param name="programInterface">
            /// A token identifying the interface within program containing the resource named name.
            /// </param>
            /// <param name="index"></param>
            /// <param name="propCount"></param>
            /// <param name="props"></param>
            /// <param name="bufSize"></param>
            /// <param name="length"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetProgramResourcefvNV")]
            [CLSCompliant(false)]
            public static void GetProgramResource(Int32 program, OpenTK.Graphics.ES31.All programInterface, Int32 index, Int32 propCount, OpenTK.Graphics.ES31.All[] props, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] Single[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]
            /// Retrieve values for multiple properties of a single active resource within a program object
            /// </summary>
            /// <param name="program">
            /// The name of a program object whose resources to query.
            /// </param>
            /// <param name="programInterface">
            /// A token identifying the interface within program containing the resource named name.
            /// </param>
            /// <param name="index"></param>
            /// <param name="propCount"></param>
            /// <param name="props"></param>
            /// <param name="bufSize"></param>
            /// <param name="length"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetProgramResourcefvNV")]
            [CLSCompliant(false)]
            public static void GetProgramResource(Int32 program, OpenTK.Graphics.ES31.All programInterface, Int32 index, Int32 propCount, ref OpenTK.Graphics.ES31.All props, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Single @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]
            /// Retrieve values for multiple properties of a single active resource within a program object
            /// </summary>
            /// <param name="program">
            /// The name of a program object whose resources to query.
            /// </param>
            /// <param name="programInterface">
            /// A token identifying the interface within program containing the resource named name.
            /// </param>
            /// <param name="index"></param>
            /// <param name="propCount"></param>
            /// <param name="props"></param>
            /// <param name="bufSize"></param>
            /// <param name="length"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetProgramResourcefvNV")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramResource(Int32 program, OpenTK.Graphics.ES31.All programInterface, Int32 index, Int32 propCount, OpenTK.Graphics.ES31.All* props, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Single* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]
            /// Retrieve values for multiple properties of a single active resource within a program object
            /// </summary>
            /// <param name="program">
            /// The name of a program object whose resources to query.
            /// </param>
            /// <param name="programInterface">
            /// A token identifying the interface within program containing the resource named name.
            /// </param>
            /// <param name="index"></param>
            /// <param name="propCount"></param>
            /// <param name="props"></param>
            /// <param name="bufSize"></param>
            /// <param name="length"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetProgramResourcefvNV")]
            [CLSCompliant(false)]
            public static void GetProgramResource(UInt32 program, OpenTK.Graphics.ES31.All programInterface, UInt32 index, Int32 propCount, OpenTK.Graphics.ES31.All[] props, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] Single[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]
            /// Retrieve values for multiple properties of a single active resource within a program object
            /// </summary>
            /// <param name="program">
            /// The name of a program object whose resources to query.
            /// </param>
            /// <param name="programInterface">
            /// A token identifying the interface within program containing the resource named name.
            /// </param>
            /// <param name="index"></param>
            /// <param name="propCount"></param>
            /// <param name="props"></param>
            /// <param name="bufSize"></param>
            /// <param name="length"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetProgramResourcefvNV")]
            [CLSCompliant(false)]
            public static void GetProgramResource(UInt32 program, OpenTK.Graphics.ES31.All programInterface, UInt32 index, Int32 propCount, ref OpenTK.Graphics.ES31.All props, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Single @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]
            /// Retrieve values for multiple properties of a single active resource within a program object
            /// </summary>
            /// <param name="program">
            /// The name of a program object whose resources to query.
            /// </param>
            /// <param name="programInterface">
            /// A token identifying the interface within program containing the resource named name.
            /// </param>
            /// <param name="index"></param>
            /// <param name="propCount"></param>
            /// <param name="props"></param>
            /// <param name="bufSize"></param>
            /// <param name="length"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glGetProgramResourcefvNV")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramResource(UInt32 program, OpenTK.Graphics.ES31.All programInterface, UInt32 index, Int32 propCount, OpenTK.Graphics.ES31.All* props, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Single* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="texture"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glGetTextureHandleNV")]
            [CLSCompliant(false)]
            public static Int64 GetTextureHandle(Int32 texture) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="texture"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glGetTextureHandleNV")]
            [CLSCompliant(false)]
            public static Int64 GetTextureHandle(UInt32 texture) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="texture"></param>
            /// <param name="sampler"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glGetTextureSamplerHandleNV")]
            [CLSCompliant(false)]
            public static Int64 GetTextureSamplerHandle(Int32 texture, Int32 sampler) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="texture"></param>
            /// <param name="sampler"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glGetTextureSamplerHandleNV")]
            [CLSCompliant(false)]
            public static Int64 GetTextureSamplerHandle(UInt32 texture, UInt32 sampler) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// Specifies the program object to be queried.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be queried.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(program,location)]
            /// Returns the value of the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glGetUniformi64vNV")]
            [CLSCompliant(false)]
            public static void GetUniform(Int32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Int64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// Specifies the program object to be queried.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be queried.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(program,location)]
            /// Returns the value of the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glGetUniformi64vNV")]
            [CLSCompliant(false)]
            public static void GetUniform(Int32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] out Int64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// Specifies the program object to be queried.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be queried.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(program,location)]
            /// Returns the value of the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glGetUniformi64vNV")]
            [CLSCompliant(false)]
            public static unsafe void GetUniform(Int32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Int64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// Specifies the program object to be queried.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be queried.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(program,location)]
            /// Returns the value of the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glGetUniformi64vNV")]
            [CLSCompliant(false)]
            public static void GetUniform(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Int64[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// Specifies the program object to be queried.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be queried.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(program,location)]
            /// Returns the value of the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glGetUniformi64vNV")]
            [CLSCompliant(false)]
            public static void GetUniform(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] out Int64 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// Specifies the program object to be queried.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be queried.
            /// </param>
            /// <param name="@params">[length: COMPSIZE(program,location)]
            /// Returns the value of the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glGetUniformi64vNV")]
            [CLSCompliant(false)]
            public static unsafe void GetUniform(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Int64* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_vulkan_image]</summary>
            /// <param name="name">[length: COMPSIZE(name)]</param>
            [AutoGenerated(Category = "NV_draw_vulkan_image", Version = "", EntryPoint = "glGetVkProcAddrNV")]
            public static IntPtr GetVkProcAddr([CountAttribute(Computed = "name")] String name) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="pathA"></param>
            /// <param name="pathB"></param>
            /// <param name="weight"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glInterpolatePathsNV")]
            [CLSCompliant(false)]
            public static void InterpolatePath(Int32 resultPath, Int32 pathA, Int32 pathB, Single weight) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="pathA"></param>
            /// <param name="pathB"></param>
            /// <param name="weight"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glInterpolatePathsNV")]
            [CLSCompliant(false)]
            public static void InterpolatePath(UInt32 resultPath, UInt32 pathA, UInt32 pathB, Single weight) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Test whether a capability is enabled
            /// </summary>
            /// <param name="target">
            /// Specifies a symbolic constant indicating a GL capability.
            /// </param>
            /// <param name="index">
            /// Specifies the index of the capability.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glIsEnablediNV")]
            [CLSCompliant(false)]
            public static bool IsEnabled(OpenTK.Graphics.ES31.All target, Int32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Test whether a capability is enabled
            /// </summary>
            /// <param name="target">
            /// Specifies a symbolic constant indicating a GL capability.
            /// </param>
            /// <param name="index">
            /// Specifies the index of the capability.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glIsEnablediNV")]
            [CLSCompliant(false)]
            public static bool IsEnabled(OpenTK.Graphics.ES31.All target, UInt32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glIsFenceNV")]
            [CLSCompliant(false)]
            public static bool IsFence(Int32 fence) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glIsFenceNV")]
            [CLSCompliant(false)]
            public static bool IsFence(UInt32 fence) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glIsImageHandleResidentNV")]
            [CLSCompliant(false)]
            public static bool IsImageHandleResident(Int64 handle) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glIsImageHandleResidentNV")]
            [CLSCompliant(false)]
            public static bool IsImageHandleResident(UInt64 handle) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glIsPathNV")]
            [CLSCompliant(false)]
            public static bool IsPath(Int32 path) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glIsPathNV")]
            [CLSCompliant(false)]
            public static bool IsPath(UInt32 path) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="mask"></param>
            /// <param name="x"></param>
            /// <param name="y"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glIsPointInFillPathNV")]
            [CLSCompliant(false)]
            public static bool IsPointInFillPath(Int32 path, Int32 mask, Single x, Single y) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="mask"></param>
            /// <param name="x"></param>
            /// <param name="y"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glIsPointInFillPathNV")]
            [CLSCompliant(false)]
            public static bool IsPointInFillPath(UInt32 path, UInt32 mask, Single x, Single y) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="x"></param>
            /// <param name="y"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glIsPointInStrokePathNV")]
            [CLSCompliant(false)]
            public static bool IsPointInStrokePath(Int32 path, Single x, Single y) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="x"></param>
            /// <param name="y"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glIsPointInStrokePathNV")]
            [CLSCompliant(false)]
            public static bool IsPointInStrokePath(UInt32 path, Single x, Single y) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glIsTextureHandleResidentNV")]
            [CLSCompliant(false)]
            public static bool IsTextureHandleResident(Int64 handle) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glIsTextureHandleResidentNV")]
            [CLSCompliant(false)]
            public static bool IsTextureHandleResident(UInt64 handle) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glMakeImageHandleNonResidentNV")]
            [CLSCompliant(false)]
            public static void MakeImageHandleNonResident(Int64 handle) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glMakeImageHandleNonResidentNV")]
            [CLSCompliant(false)]
            public static void MakeImageHandleNonResident(UInt64 handle) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="handle"></param>
            /// <param name="access"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glMakeImageHandleResidentNV")]
            [CLSCompliant(false)]
            public static void MakeImageHandleResident(Int64 handle, OpenTK.Graphics.ES31.All access) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="handle"></param>
            /// <param name="access"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glMakeImageHandleResidentNV")]
            [CLSCompliant(false)]
            public static void MakeImageHandleResident(UInt64 handle, OpenTK.Graphics.ES31.All access) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glMakeTextureHandleNonResidentNV")]
            [CLSCompliant(false)]
            public static void MakeTextureHandleNonResident(Int64 handle) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glMakeTextureHandleNonResidentNV")]
            [CLSCompliant(false)]
            public static void MakeTextureHandleNonResident(UInt64 handle) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glMakeTextureHandleResidentNV")]
            [CLSCompliant(false)]
            public static void MakeTextureHandleResident(Int64 handle) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="handle"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glMakeTextureHandleResidentNV")]
            [CLSCompliant(false)]
            public static void MakeTextureHandleResident(UInt64 handle) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixLoad3x2fNV")]
            [CLSCompliant(false)]
            public static void MatrixLoad3x2(OpenTK.Graphics.ES31.All matrixMode, Single[] m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixLoad3x2fNV")]
            [CLSCompliant(false)]
            public static void MatrixLoad3x2(OpenTK.Graphics.ES31.All matrixMode, ref Single m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixLoad3x2fNV")]
            [CLSCompliant(false)]
            public static unsafe void MatrixLoad3x2(OpenTK.Graphics.ES31.All matrixMode, Single* m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixLoad3x3fNV")]
            [CLSCompliant(false)]
            public static void MatrixLoad3x3(OpenTK.Graphics.ES31.All matrixMode, Single[] m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixLoad3x3fNV")]
            [CLSCompliant(false)]
            public static void MatrixLoad3x3(OpenTK.Graphics.ES31.All matrixMode, ref Single m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixLoad3x3fNV")]
            [CLSCompliant(false)]
            public static unsafe void MatrixLoad3x3(OpenTK.Graphics.ES31.All matrixMode, Single* m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixLoadTranspose3x3fNV")]
            [CLSCompliant(false)]
            public static void MatrixLoadTranspose3x3(OpenTK.Graphics.ES31.All matrixMode, Single[] m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixLoadTranspose3x3fNV")]
            [CLSCompliant(false)]
            public static void MatrixLoadTranspose3x3(OpenTK.Graphics.ES31.All matrixMode, ref Single m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixLoadTranspose3x3fNV")]
            [CLSCompliant(false)]
            public static unsafe void MatrixLoadTranspose3x3(OpenTK.Graphics.ES31.All matrixMode, Single* m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixMult3x2fNV")]
            [CLSCompliant(false)]
            public static void MatrixMult3x2(OpenTK.Graphics.ES31.All matrixMode, Single[] m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixMult3x2fNV")]
            [CLSCompliant(false)]
            public static void MatrixMult3x2(OpenTK.Graphics.ES31.All matrixMode, ref Single m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixMult3x2fNV")]
            [CLSCompliant(false)]
            public static unsafe void MatrixMult3x2(OpenTK.Graphics.ES31.All matrixMode, Single* m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixMult3x3fNV")]
            [CLSCompliant(false)]
            public static void MatrixMult3x3(OpenTK.Graphics.ES31.All matrixMode, Single[] m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixMult3x3fNV")]
            [CLSCompliant(false)]
            public static void MatrixMult3x3(OpenTK.Graphics.ES31.All matrixMode, ref Single m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixMult3x3fNV")]
            [CLSCompliant(false)]
            public static unsafe void MatrixMult3x3(OpenTK.Graphics.ES31.All matrixMode, Single* m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixMultTranspose3x3fNV")]
            [CLSCompliant(false)]
            public static void MatrixMultTranspose3x3(OpenTK.Graphics.ES31.All matrixMode, Single[] m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixMultTranspose3x3fNV")]
            [CLSCompliant(false)]
            public static void MatrixMultTranspose3x3(OpenTK.Graphics.ES31.All matrixMode, ref Single m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="matrixMode"></param>
            /// <param name="m"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glMatrixMultTranspose3x3fNV")]
            [CLSCompliant(false)]
            public static unsafe void MatrixMultTranspose3x3(OpenTK.Graphics.ES31.All matrixMode, Single* m) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_sample_locations]</summary>
            /// <param name="framebuffer"></param>
            /// <param name="start"></param>
            /// <param name="count"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_sample_locations", Version = "", EntryPoint = "glNamedFramebufferSampleLocationsfvNV")]
            [CLSCompliant(false)]
            public static void NamedFramebufferSampleLocations(Int32 framebuffer, Int32 start, Int32 count, Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_sample_locations]</summary>
            /// <param name="framebuffer"></param>
            /// <param name="start"></param>
            /// <param name="count"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_sample_locations", Version = "", EntryPoint = "glNamedFramebufferSampleLocationsfvNV")]
            [CLSCompliant(false)]
            public static void NamedFramebufferSampleLocations(Int32 framebuffer, Int32 start, Int32 count, ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_sample_locations]</summary>
            /// <param name="framebuffer"></param>
            /// <param name="start"></param>
            /// <param name="count"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_sample_locations", Version = "", EntryPoint = "glNamedFramebufferSampleLocationsfvNV")]
            [CLSCompliant(false)]
            public static unsafe void NamedFramebufferSampleLocations(Int32 framebuffer, Int32 start, Int32 count, Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_sample_locations]</summary>
            /// <param name="framebuffer"></param>
            /// <param name="start"></param>
            /// <param name="count"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_sample_locations", Version = "", EntryPoint = "glNamedFramebufferSampleLocationsfvNV")]
            [CLSCompliant(false)]
            public static void NamedFramebufferSampleLocations(UInt32 framebuffer, UInt32 start, Int32 count, Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_sample_locations]</summary>
            /// <param name="framebuffer"></param>
            /// <param name="start"></param>
            /// <param name="count"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_sample_locations", Version = "", EntryPoint = "glNamedFramebufferSampleLocationsfvNV")]
            [CLSCompliant(false)]
            public static void NamedFramebufferSampleLocations(UInt32 framebuffer, UInt32 start, Int32 count, ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_sample_locations]</summary>
            /// <param name="framebuffer"></param>
            /// <param name="start"></param>
            /// <param name="count"></param>
            /// <param name="v"></param>
            [AutoGenerated(Category = "NV_sample_locations", Version = "", EntryPoint = "glNamedFramebufferSampleLocationsfvNV")]
            [CLSCompliant(false)]
            public static unsafe void NamedFramebufferSampleLocations(UInt32 framebuffer, UInt32 start, Int32 count, Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="color"></param>
            /// <param name="genMode"></param>
            /// <param name="colorFormat"></param>
            /// <param name="coeffs">[length: COMPSIZE(genMode,colorFormat)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathColorGenNV")]
            [CLSCompliant(false)]
            public static void PathColorGen(OpenTK.Graphics.ES31.All color, OpenTK.Graphics.ES31.All genMode, OpenTK.Graphics.ES31.All colorFormat, [CountAttribute(Computed = "genMode,colorFormat")] Single[] coeffs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="color"></param>
            /// <param name="genMode"></param>
            /// <param name="colorFormat"></param>
            /// <param name="coeffs">[length: COMPSIZE(genMode,colorFormat)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathColorGenNV")]
            [CLSCompliant(false)]
            public static void PathColorGen(OpenTK.Graphics.ES31.All color, OpenTK.Graphics.ES31.All genMode, OpenTK.Graphics.ES31.All colorFormat, [CountAttribute(Computed = "genMode,colorFormat")] ref Single coeffs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="color"></param>
            /// <param name="genMode"></param>
            /// <param name="colorFormat"></param>
            /// <param name="coeffs">[length: COMPSIZE(genMode,colorFormat)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathColorGenNV")]
            [CLSCompliant(false)]
            public static unsafe void PathColorGen(OpenTK.Graphics.ES31.All color, OpenTK.Graphics.ES31.All genMode, OpenTK.Graphics.ES31.All colorFormat, [CountAttribute(Computed = "genMode,colorFormat")] Single* coeffs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[,] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[,,] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T5 coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[,] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[,,] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T5 coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathCommands(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathCommands<T5>(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathCommands<T5>(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[,] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathCommands<T5>(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[,,] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathCommands<T5>(Int32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T5 coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[,] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[,,] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T5 coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[,] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[,,] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static void PathCommands<T5>(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T5 coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathCommands(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathCommands<T5>(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathCommands<T5>(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[,] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathCommands<T5>(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T5[,,] coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathCommands<T5>(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T5 coords)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCoordsNV")]
            [CLSCompliant(false)]
            public static void PathCoords(Int32 path, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCoordsNV")]
            [CLSCompliant(false)]
            public static void PathCoords<T3>(Int32 path, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T3[] coords)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCoordsNV")]
            [CLSCompliant(false)]
            public static void PathCoords<T3>(Int32 path, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T3[,] coords)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCoordsNV")]
            [CLSCompliant(false)]
            public static void PathCoords<T3>(Int32 path, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T3[,,] coords)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCoordsNV")]
            [CLSCompliant(false)]
            public static void PathCoords<T3>(Int32 path, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T3 coords)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCoordsNV")]
            [CLSCompliant(false)]
            public static void PathCoords(UInt32 path, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCoordsNV")]
            [CLSCompliant(false)]
            public static void PathCoords<T3>(UInt32 path, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T3[] coords)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCoordsNV")]
            [CLSCompliant(false)]
            public static void PathCoords<T3>(UInt32 path, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T3[,] coords)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCoordsNV")]
            [CLSCompliant(false)]
            public static void PathCoords<T3>(UInt32 path, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T3[,,] coords)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCoordsNV")]
            [CLSCompliant(false)]
            public static void PathCoords<T3>(UInt32 path, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T3 coords)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="func"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCoverDepthFuncNV")]
            public static void PathCoverDepthFunc(OpenTK.Graphics.ES31.All func) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="func"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathCoverDepthFuncNV")]
            public static void PathCoverDepthFunc(OpenTK.Graphics.ES31.DepthFunction func) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="dashCount"></param>
            /// <param name="dashArray">[length: dashCount]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathDashArrayNV")]
            [CLSCompliant(false)]
            public static void PathDashArray(Int32 path, Int32 dashCount, [CountAttribute(Parameter = "dashCount")] Single[] dashArray) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="dashCount"></param>
            /// <param name="dashArray">[length: dashCount]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathDashArrayNV")]
            [CLSCompliant(false)]
            public static void PathDashArray(Int32 path, Int32 dashCount, [CountAttribute(Parameter = "dashCount")] ref Single dashArray) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="dashCount"></param>
            /// <param name="dashArray">[length: dashCount]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathDashArrayNV")]
            [CLSCompliant(false)]
            public static unsafe void PathDashArray(Int32 path, Int32 dashCount, [CountAttribute(Parameter = "dashCount")] Single* dashArray) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="dashCount"></param>
            /// <param name="dashArray">[length: dashCount]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathDashArrayNV")]
            [CLSCompliant(false)]
            public static void PathDashArray(UInt32 path, Int32 dashCount, [CountAttribute(Parameter = "dashCount")] Single[] dashArray) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="dashCount"></param>
            /// <param name="dashArray">[length: dashCount]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathDashArrayNV")]
            [CLSCompliant(false)]
            public static void PathDashArray(UInt32 path, Int32 dashCount, [CountAttribute(Parameter = "dashCount")] ref Single dashArray) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="dashCount"></param>
            /// <param name="dashArray">[length: dashCount]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathDashArrayNV")]
            [CLSCompliant(false)]
            public static unsafe void PathDashArray(UInt32 path, Int32 dashCount, [CountAttribute(Parameter = "dashCount")] Single* dashArray) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="genMode"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathFogGenNV")]
            public static void PathFogGen(OpenTK.Graphics.ES31.All genMode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexArray(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, IntPtr fontName, Int32 fontStyle, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexArray<T2>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] T2[] fontName, Int32 fontStyle, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexArray<T2>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] T2[,] fontName, Int32 fontStyle, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexArray<T2>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] T2[,,] fontName, Int32 fontStyle, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexArray<T2>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] ref T2 fontName, Int32 fontStyle, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexArray(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, IntPtr fontName, UInt32 fontStyle, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexArray<T2>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] T2[] fontName, UInt32 fontStyle, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexArray<T2>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] T2[,] fontName, UInt32 fontStyle, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexArray<T2>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] T2[,,] fontName, UInt32 fontStyle, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexArray<T2>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] ref T2 fontName, UInt32 fontStyle, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            /// <param name="baseAndCount"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexRangeNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexRange(OpenTK.Graphics.ES31.All fontTarget, IntPtr fontName, Int32 fontStyle, Int32 pathParameterTemplate, Single emScale, Int32 baseAndCount) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            /// <param name="baseAndCount"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexRangeNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexRange(OpenTK.Graphics.ES31.All fontTarget, IntPtr fontName, UInt32 fontStyle, UInt32 pathParameterTemplate, Single emScale, UInt32 baseAndCount) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            /// <param name="baseAndCount"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexRangeNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexRange<T1>(OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] T1[] fontName, Int32 fontStyle, Int32 pathParameterTemplate, Single emScale, Int32 baseAndCount)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            /// <param name="baseAndCount"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexRangeNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexRange<T1>(OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] T1[] fontName, UInt32 fontStyle, UInt32 pathParameterTemplate, Single emScale, UInt32 baseAndCount)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            /// <param name="baseAndCount"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexRangeNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexRange<T1>(OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] T1[,] fontName, Int32 fontStyle, Int32 pathParameterTemplate, Single emScale, Int32 baseAndCount)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            /// <param name="baseAndCount"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexRangeNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexRange<T1>(OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] T1[,] fontName, UInt32 fontStyle, UInt32 pathParameterTemplate, Single emScale, UInt32 baseAndCount)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            /// <param name="baseAndCount"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexRangeNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexRange<T1>(OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] T1[,,] fontName, Int32 fontStyle, Int32 pathParameterTemplate, Single emScale, Int32 baseAndCount)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            /// <param name="baseAndCount"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexRangeNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexRange<T1>(OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] T1[,,] fontName, UInt32 fontStyle, UInt32 pathParameterTemplate, Single emScale, UInt32 baseAndCount)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            /// <param name="baseAndCount"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexRangeNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexRange<T1>(OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] ref T1 fontName, Int32 fontStyle, Int32 pathParameterTemplate, Single emScale, Int32 baseAndCount)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="fontTarget"></param>
            /// <param name="fontName"></param>
            /// <param name="fontStyle"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            /// <param name="baseAndCount"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphIndexRangeNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathGlyphIndexRange<T1>(OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute] ref T1 fontName, UInt32 fontStyle, UInt32 pathParameterTemplate, Single emScale, UInt32 baseAndCount)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyph"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphRangeNV")]
            [CLSCompliant(false)]
            public static void PathGlyphRange(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [CountAttribute(Computed = "fontTarget,fontName")] IntPtr fontName, Int32 fontStyle, Int32 firstGlyph, Int32 numGlyphs, OpenTK.Graphics.ES31.All handleMissingGlyphs, Int32 pathParameterTemplate, Single emScale) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyph"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphRangeNV")]
            [CLSCompliant(false)]
            public static void PathGlyphRange<T2>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] T2[] fontName, Int32 fontStyle, Int32 firstGlyph, Int32 numGlyphs, OpenTK.Graphics.ES31.All handleMissingGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyph"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphRangeNV")]
            [CLSCompliant(false)]
            public static void PathGlyphRange<T2>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] T2[,] fontName, Int32 fontStyle, Int32 firstGlyph, Int32 numGlyphs, OpenTK.Graphics.ES31.All handleMissingGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyph"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphRangeNV")]
            [CLSCompliant(false)]
            public static void PathGlyphRange<T2>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] T2[,,] fontName, Int32 fontStyle, Int32 firstGlyph, Int32 numGlyphs, OpenTK.Graphics.ES31.All handleMissingGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyph"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphRangeNV")]
            [CLSCompliant(false)]
            public static void PathGlyphRange<T2>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] ref T2 fontName, Int32 fontStyle, Int32 firstGlyph, Int32 numGlyphs, OpenTK.Graphics.ES31.All handleMissingGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyph"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphRangeNV")]
            [CLSCompliant(false)]
            public static void PathGlyphRange(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [CountAttribute(Computed = "fontTarget,fontName")] IntPtr fontName, UInt32 fontStyle, UInt32 firstGlyph, Int32 numGlyphs, OpenTK.Graphics.ES31.All handleMissingGlyphs, UInt32 pathParameterTemplate, Single emScale) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyph"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphRangeNV")]
            [CLSCompliant(false)]
            public static void PathGlyphRange<T2>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] T2[] fontName, UInt32 fontStyle, UInt32 firstGlyph, Int32 numGlyphs, OpenTK.Graphics.ES31.All handleMissingGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyph"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphRangeNV")]
            [CLSCompliant(false)]
            public static void PathGlyphRange<T2>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] T2[,] fontName, UInt32 fontStyle, UInt32 firstGlyph, Int32 numGlyphs, OpenTK.Graphics.ES31.All handleMissingGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyph"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphRangeNV")]
            [CLSCompliant(false)]
            public static void PathGlyphRange<T2>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] T2[,,] fontName, UInt32 fontStyle, UInt32 firstGlyph, Int32 numGlyphs, OpenTK.Graphics.ES31.All handleMissingGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="firstGlyph"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphRangeNV")]
            [CLSCompliant(false)]
            public static void PathGlyphRange<T2>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] ref T2 fontName, UInt32 fontStyle, UInt32 firstGlyph, Int32 numGlyphs, OpenTK.Graphics.ES31.All handleMissingGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="type"></param>
            /// <param name="charcodes">[length: COMPSIZE(numGlyphs,type,charcodes)]</param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphsNV")]
            [CLSCompliant(false)]
            public static void PathGlyph(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [CountAttribute(Computed = "fontTarget,fontName")] IntPtr fontName, Int32 fontStyle, Int32 numGlyphs, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "numGlyphs,type,charcodes")] IntPtr charcodes, OpenTK.Graphics.ES31.All handleMissingGlyphs, Int32 pathParameterTemplate, Single emScale) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="type"></param>
            /// <param name="charcodes">[length: COMPSIZE(numGlyphs,type,charcodes)]</param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphsNV")]
            [CLSCompliant(false)]
            public static void PathGlyph<T2, T6>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] T2[] fontName, Int32 fontStyle, Int32 numGlyphs, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "numGlyphs,type,charcodes")] T6[] charcodes, OpenTK.Graphics.ES31.All handleMissingGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T2 : struct
                where T6 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="type"></param>
            /// <param name="charcodes">[length: COMPSIZE(numGlyphs,type,charcodes)]</param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphsNV")]
            [CLSCompliant(false)]
            public static void PathGlyph<T2, T6>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] T2[,] fontName, Int32 fontStyle, Int32 numGlyphs, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "numGlyphs,type,charcodes")] T6[,] charcodes, OpenTK.Graphics.ES31.All handleMissingGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T2 : struct
                where T6 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="type"></param>
            /// <param name="charcodes">[length: COMPSIZE(numGlyphs,type,charcodes)]</param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphsNV")]
            [CLSCompliant(false)]
            public static void PathGlyph<T2, T6>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] T2[,,] fontName, Int32 fontStyle, Int32 numGlyphs, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "numGlyphs,type,charcodes")] T6[,,] charcodes, OpenTK.Graphics.ES31.All handleMissingGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T2 : struct
                where T6 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="type"></param>
            /// <param name="charcodes">[length: COMPSIZE(numGlyphs,type,charcodes)]</param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphsNV")]
            [CLSCompliant(false)]
            public static void PathGlyph<T2, T6>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] ref T2 fontName, Int32 fontStyle, Int32 numGlyphs, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "numGlyphs,type,charcodes")] ref T6 charcodes, OpenTK.Graphics.ES31.All handleMissingGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T2 : struct
                where T6 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="type"></param>
            /// <param name="charcodes">[length: COMPSIZE(numGlyphs,type,charcodes)]</param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphsNV")]
            [CLSCompliant(false)]
            public static void PathGlyph(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [CountAttribute(Computed = "fontTarget,fontName")] IntPtr fontName, UInt32 fontStyle, Int32 numGlyphs, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "numGlyphs,type,charcodes")] IntPtr charcodes, OpenTK.Graphics.ES31.All handleMissingGlyphs, UInt32 pathParameterTemplate, Single emScale) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="type"></param>
            /// <param name="charcodes">[length: COMPSIZE(numGlyphs,type,charcodes)]</param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphsNV")]
            [CLSCompliant(false)]
            public static void PathGlyph<T2, T6>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] T2[] fontName, UInt32 fontStyle, Int32 numGlyphs, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "numGlyphs,type,charcodes")] T6[] charcodes, OpenTK.Graphics.ES31.All handleMissingGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T2 : struct
                where T6 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="type"></param>
            /// <param name="charcodes">[length: COMPSIZE(numGlyphs,type,charcodes)]</param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphsNV")]
            [CLSCompliant(false)]
            public static void PathGlyph<T2, T6>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] T2[,] fontName, UInt32 fontStyle, Int32 numGlyphs, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "numGlyphs,type,charcodes")] T6[,] charcodes, OpenTK.Graphics.ES31.All handleMissingGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T2 : struct
                where T6 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="type"></param>
            /// <param name="charcodes">[length: COMPSIZE(numGlyphs,type,charcodes)]</param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphsNV")]
            [CLSCompliant(false)]
            public static void PathGlyph<T2, T6>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] T2[,,] fontName, UInt32 fontStyle, Int32 numGlyphs, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "numGlyphs,type,charcodes")] T6[,,] charcodes, OpenTK.Graphics.ES31.All handleMissingGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T2 : struct
                where T6 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontName">[length: COMPSIZE(fontTarget,fontName)]</param>
            /// <param name="fontStyle"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="type"></param>
            /// <param name="charcodes">[length: COMPSIZE(numGlyphs,type,charcodes)]</param>
            /// <param name="handleMissingGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathGlyphsNV")]
            [CLSCompliant(false)]
            public static void PathGlyph<T2, T6>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, [InAttribute, OutAttribute, CountAttribute(Computed = "fontTarget,fontName")] ref T2 fontName, UInt32 fontStyle, Int32 numGlyphs, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "numGlyphs,type,charcodes")] ref T6 charcodes, OpenTK.Graphics.ES31.All handleMissingGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T2 : struct
                where T6 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, Int32 fontSize, IntPtr fontData, Int32 faceIndex, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, Int32 fontSize, [InAttribute, OutAttribute] T3[] fontData, Int32 faceIndex, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, Int32 fontSize, [InAttribute, OutAttribute] T3[,] fontData, Int32 faceIndex, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, Int32 fontSize, [InAttribute, OutAttribute] T3[,,] fontData, Int32 faceIndex, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, Int32 fontSize, [InAttribute, OutAttribute] ref T3 fontData, Int32 faceIndex, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, IntPtr fontSize, IntPtr fontData, Int32 faceIndex, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, IntPtr fontSize, [InAttribute, OutAttribute] T3[] fontData, Int32 faceIndex, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, IntPtr fontSize, [InAttribute, OutAttribute] T3[,] fontData, Int32 faceIndex, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, IntPtr fontSize, [InAttribute, OutAttribute] T3[,,] fontData, Int32 faceIndex, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(Int32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, IntPtr fontSize, [InAttribute, OutAttribute] ref T3 fontData, Int32 faceIndex, Int32 firstGlyphIndex, Int32 numGlyphs, Int32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, Int32 fontSize, IntPtr fontData, Int32 faceIndex, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, Int32 fontSize, [InAttribute, OutAttribute] T3[] fontData, Int32 faceIndex, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, Int32 fontSize, [InAttribute, OutAttribute] T3[,] fontData, Int32 faceIndex, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, Int32 fontSize, [InAttribute, OutAttribute] T3[,,] fontData, Int32 faceIndex, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, Int32 fontSize, [InAttribute, OutAttribute] ref T3 fontData, Int32 faceIndex, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, IntPtr fontSize, IntPtr fontData, Int32 faceIndex, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, IntPtr fontSize, [InAttribute, OutAttribute] T3[] fontData, Int32 faceIndex, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, IntPtr fontSize, [InAttribute, OutAttribute] T3[,] fontData, Int32 faceIndex, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, IntPtr fontSize, [InAttribute, OutAttribute] T3[,,] fontData, Int32 faceIndex, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="firstPathName"></param>
            /// <param name="fontTarget"></param>
            /// <param name="fontSize"></param>
            /// <param name="fontData"></param>
            /// <param name="faceIndex"></param>
            /// <param name="firstGlyphIndex"></param>
            /// <param name="numGlyphs"></param>
            /// <param name="pathParameterTemplate"></param>
            /// <param name="emScale"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathMemoryGlyphIndexArrayNV")]
            [CLSCompliant(false)]
            public static OpenTK.Graphics.ES31.All PathMemoryGlyphIndexArray<T3>(UInt32 firstPathName, OpenTK.Graphics.ES31.All fontTarget, IntPtr fontSize, [InAttribute, OutAttribute] ref T3 fontData, Int32 faceIndex, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathParameterfNV")]
            [CLSCompliant(false)]
            public static void PathParameter(Int32 path, OpenTK.Graphics.ES31.All pname, Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathParameterfNV")]
            [CLSCompliant(false)]
            public static void PathParameter(UInt32 path, OpenTK.Graphics.ES31.All pname, Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathParameterfvNV")]
            [CLSCompliant(false)]
            public static void PathParameter(Int32 path, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathParameterfvNV")]
            [CLSCompliant(false)]
            public static unsafe void PathParameter(Int32 path, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathParameterfvNV")]
            [CLSCompliant(false)]
            public static void PathParameter(UInt32 path, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathParameterfvNV")]
            [CLSCompliant(false)]
            public static unsafe void PathParameter(UInt32 path, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathParameteriNV")]
            [CLSCompliant(false)]
            public static void PathParameter(Int32 path, OpenTK.Graphics.ES31.All pname, Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathParameteriNV")]
            [CLSCompliant(false)]
            public static void PathParameter(UInt32 path, OpenTK.Graphics.ES31.All pname, Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathParameterivNV")]
            [CLSCompliant(false)]
            public static void PathParameter(Int32 path, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathParameterivNV")]
            [CLSCompliant(false)]
            public static unsafe void PathParameter(Int32 path, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathParameterivNV")]
            [CLSCompliant(false)]
            public static void PathParameter(UInt32 path, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="pname"></param>
            /// <param name="value">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathParameterivNV")]
            [CLSCompliant(false)]
            public static unsafe void PathParameter(UInt32 path, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="factor"></param>
            /// <param name="units"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStencilDepthOffsetNV")]
            public static void PathStencilDepthOffset(Single factor, Single units) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="func"></param>
            /// <param name="@ref"></param>
            /// <param name="mask"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStencilFuncNV")]
            [CLSCompliant(false)]
            public static void PathStencilFunc(OpenTK.Graphics.ES31.All func, Int32 @ref, Int32 mask) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="func"></param>
            /// <param name="@ref"></param>
            /// <param name="mask"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStencilFuncNV")]
            [CLSCompliant(false)]
            public static void PathStencilFunc(OpenTK.Graphics.ES31.All func, Int32 @ref, UInt32 mask) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="func"></param>
            /// <param name="@ref"></param>
            /// <param name="mask"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStencilFuncNV")]
            [CLSCompliant(false)]
            public static void PathStencilFunc(OpenTK.Graphics.ES31.StencilFunction func, Int32 @ref, Int32 mask) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="func"></param>
            /// <param name="@ref"></param>
            /// <param name="mask"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStencilFuncNV")]
            [CLSCompliant(false)]
            public static void PathStencilFunc(OpenTK.Graphics.ES31.StencilFunction func, Int32 @ref, UInt32 mask) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="format"></param>
            /// <param name="length"></param>
            /// <param name="pathString">[length: length]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStringNV")]
            [CLSCompliant(false)]
            public static void PathString(Int32 path, OpenTK.Graphics.ES31.All format, Int32 length, [CountAttribute(Parameter = "length")] IntPtr pathString) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="format"></param>
            /// <param name="length"></param>
            /// <param name="pathString">[length: length]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStringNV")]
            [CLSCompliant(false)]
            public static void PathString<T3>(Int32 path, OpenTK.Graphics.ES31.All format, Int32 length, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[] pathString)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="format"></param>
            /// <param name="length"></param>
            /// <param name="pathString">[length: length]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStringNV")]
            [CLSCompliant(false)]
            public static void PathString<T3>(Int32 path, OpenTK.Graphics.ES31.All format, Int32 length, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,] pathString)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="format"></param>
            /// <param name="length"></param>
            /// <param name="pathString">[length: length]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStringNV")]
            [CLSCompliant(false)]
            public static void PathString<T3>(Int32 path, OpenTK.Graphics.ES31.All format, Int32 length, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,,] pathString)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="format"></param>
            /// <param name="length"></param>
            /// <param name="pathString">[length: length]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStringNV")]
            [CLSCompliant(false)]
            public static void PathString<T3>(Int32 path, OpenTK.Graphics.ES31.All format, Int32 length, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] ref T3 pathString)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="format"></param>
            /// <param name="length"></param>
            /// <param name="pathString">[length: length]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStringNV")]
            [CLSCompliant(false)]
            public static void PathString(UInt32 path, OpenTK.Graphics.ES31.All format, Int32 length, [CountAttribute(Parameter = "length")] IntPtr pathString) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="format"></param>
            /// <param name="length"></param>
            /// <param name="pathString">[length: length]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStringNV")]
            [CLSCompliant(false)]
            public static void PathString<T3>(UInt32 path, OpenTK.Graphics.ES31.All format, Int32 length, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[] pathString)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="format"></param>
            /// <param name="length"></param>
            /// <param name="pathString">[length: length]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStringNV")]
            [CLSCompliant(false)]
            public static void PathString<T3>(UInt32 path, OpenTK.Graphics.ES31.All format, Int32 length, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,] pathString)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="format"></param>
            /// <param name="length"></param>
            /// <param name="pathString">[length: length]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStringNV")]
            [CLSCompliant(false)]
            public static void PathString<T3>(UInt32 path, OpenTK.Graphics.ES31.All format, Int32 length, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T3[,,] pathString)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="format"></param>
            /// <param name="length"></param>
            /// <param name="pathString">[length: length]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathStringNV")]
            [CLSCompliant(false)]
            public static void PathString<T3>(UInt32 path, OpenTK.Graphics.ES31.All format, Int32 length, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] ref T3 pathString)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[,] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[,,] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T7 coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[,] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[,,] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T7 coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathSubCommands(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathSubCommands<T7>(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathSubCommands<T7>(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[,] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathSubCommands<T7>(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[,,] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathSubCommands<T7>(Int32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T7 coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[,] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[,,] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte[] commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T7 coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[,] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[,,] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static void PathSubCommands<T7>(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] ref Byte commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T7 coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathSubCommands(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathSubCommands<T7>(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathSubCommands<T7>(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[,] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathSubCommands<T7>(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T7[,,] coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="commandStart"></param>
            /// <param name="commandsToDelete"></param>
            /// <param name="numCommands"></param>
            /// <param name="commands">[length: numCommands]</param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCommandsNV")]
            [CLSCompliant(false)]
            public static unsafe void PathSubCommands<T7>(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T7 coords)
                where T7 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coordStart"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCoordsNV")]
            [CLSCompliant(false)]
            public static void PathSubCoords(Int32 path, Int32 coordStart, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coordStart"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCoordsNV")]
            [CLSCompliant(false)]
            public static void PathSubCoords<T4>(Int32 path, Int32 coordStart, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T4[] coords)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coordStart"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCoordsNV")]
            [CLSCompliant(false)]
            public static void PathSubCoords<T4>(Int32 path, Int32 coordStart, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T4[,] coords)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coordStart"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCoordsNV")]
            [CLSCompliant(false)]
            public static void PathSubCoords<T4>(Int32 path, Int32 coordStart, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T4[,,] coords)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coordStart"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCoordsNV")]
            [CLSCompliant(false)]
            public static void PathSubCoords<T4>(Int32 path, Int32 coordStart, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T4 coords)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coordStart"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCoordsNV")]
            [CLSCompliant(false)]
            public static void PathSubCoords(UInt32 path, Int32 coordStart, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coordStart"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCoordsNV")]
            [CLSCompliant(false)]
            public static void PathSubCoords<T4>(UInt32 path, Int32 coordStart, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T4[] coords)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coordStart"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCoordsNV")]
            [CLSCompliant(false)]
            public static void PathSubCoords<T4>(UInt32 path, Int32 coordStart, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T4[,] coords)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coordStart"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCoordsNV")]
            [CLSCompliant(false)]
            public static void PathSubCoords<T4>(UInt32 path, Int32 coordStart, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] T4[,,] coords)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="coordStart"></param>
            /// <param name="numCoords"></param>
            /// <param name="coordType"></param>
            /// <param name="coords">[length: COMPSIZE(numCoords,coordType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathSubCoordsNV")]
            [CLSCompliant(false)]
            public static void PathSubCoords<T4>(UInt32 path, Int32 coordStart, Int32 numCoords, OpenTK.Graphics.ES31.All coordType, [InAttribute, OutAttribute, CountAttribute(Computed = "numCoords,coordType")] ref T4 coords)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="genMode"></param>
            /// <param name="components"></param>
            /// <param name="coeffs">[length: COMPSIZE(genMode,components)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathTexGenNV")]
            [CLSCompliant(false)]
            public static void PathTexGen(OpenTK.Graphics.ES31.All texCoordSet, OpenTK.Graphics.ES31.All genMode, Int32 components, [CountAttribute(Computed = "genMode,components")] Single[] coeffs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="genMode"></param>
            /// <param name="components"></param>
            /// <param name="coeffs">[length: COMPSIZE(genMode,components)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathTexGenNV")]
            [CLSCompliant(false)]
            public static void PathTexGen(OpenTK.Graphics.ES31.All texCoordSet, OpenTK.Graphics.ES31.All genMode, Int32 components, [CountAttribute(Computed = "genMode,components")] ref Single coeffs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="texCoordSet"></param>
            /// <param name="genMode"></param>
            /// <param name="components"></param>
            /// <param name="coeffs">[length: COMPSIZE(genMode,components)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPathTexGenNV")]
            [CLSCompliant(false)]
            public static unsafe void PathTexGen(OpenTK.Graphics.ES31.All texCoordSet, OpenTK.Graphics.ES31.All genMode, Int32 components, [CountAttribute(Computed = "genMode,components")] Single* coeffs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="startSegment"></param>
            /// <param name="numSegments"></param>
            /// <param name="distance"></param>
            /// <param name="x">[length: 1]</param>
            /// <param name="y">[length: 1]</param>
            /// <param name="tangentX">[length: 1]</param>
            /// <param name="tangentY">[length: 1]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPointAlongPathNV")]
            [CLSCompliant(false)]
            public static bool PointAlongPath(Int32 path, Int32 startSegment, Int32 numSegments, Single distance, [OutAttribute, CountAttribute(Count = 1)] out Single x, [OutAttribute, CountAttribute(Count = 1)] out Single y, [OutAttribute, CountAttribute(Count = 1)] out Single tangentX, [OutAttribute, CountAttribute(Count = 1)] out Single tangentY) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="startSegment"></param>
            /// <param name="numSegments"></param>
            /// <param name="distance"></param>
            /// <param name="x">[length: 1]</param>
            /// <param name="y">[length: 1]</param>
            /// <param name="tangentX">[length: 1]</param>
            /// <param name="tangentY">[length: 1]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPointAlongPathNV")]
            [CLSCompliant(false)]
            public static unsafe bool PointAlongPath(Int32 path, Int32 startSegment, Int32 numSegments, Single distance, [OutAttribute, CountAttribute(Count = 1)] Single* x, [OutAttribute, CountAttribute(Count = 1)] Single* y, [OutAttribute, CountAttribute(Count = 1)] Single* tangentX, [OutAttribute, CountAttribute(Count = 1)] Single* tangentY) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="startSegment"></param>
            /// <param name="numSegments"></param>
            /// <param name="distance"></param>
            /// <param name="x">[length: 1]</param>
            /// <param name="y">[length: 1]</param>
            /// <param name="tangentX">[length: 1]</param>
            /// <param name="tangentY">[length: 1]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPointAlongPathNV")]
            [CLSCompliant(false)]
            public static bool PointAlongPath(UInt32 path, Int32 startSegment, Int32 numSegments, Single distance, [OutAttribute, CountAttribute(Count = 1)] out Single x, [OutAttribute, CountAttribute(Count = 1)] out Single y, [OutAttribute, CountAttribute(Count = 1)] out Single tangentX, [OutAttribute, CountAttribute(Count = 1)] out Single tangentY) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="startSegment"></param>
            /// <param name="numSegments"></param>
            /// <param name="distance"></param>
            /// <param name="x">[length: 1]</param>
            /// <param name="y">[length: 1]</param>
            /// <param name="tangentX">[length: 1]</param>
            /// <param name="tangentY">[length: 1]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glPointAlongPathNV")]
            [CLSCompliant(false)]
            public static unsafe bool PointAlongPath(UInt32 path, Int32 startSegment, Int32 numSegments, Single distance, [OutAttribute, CountAttribute(Count = 1)] Single* x, [OutAttribute, CountAttribute(Count = 1)] Single* y, [OutAttribute, CountAttribute(Count = 1)] Single* tangentX, [OutAttribute, CountAttribute(Count = 1)] Single* tangentY) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_polygon_mode]
            /// Select a polygon rasterization mode
            /// </summary>
            /// <param name="face">
            /// Specifies the polygons that mode applies to. Must be FrontAndBack for front- and back-facing polygons.
            /// </param>
            /// <param name="mode">
            /// Specifies how polygons will be rasterized. Accepted values are Point, Line, and Fill. The initial value is Fill for both front- and back-facing polygons.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_polygon_mode", Version = "", EntryPoint = "glPolygonModeNV")]
            public static void PolygonMode(OpenTK.Graphics.ES31.All face, OpenTK.Graphics.ES31.All mode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_polygon_mode]
            /// Select a polygon rasterization mode
            /// </summary>
            /// <param name="face">
            /// Specifies the polygons that mode applies to. Must be FrontAndBack for front- and back-facing polygons.
            /// </param>
            /// <param name="mode">
            /// Specifies how polygons will be rasterized. Accepted values are Point, Line, and Fill. The initial value is Fill for both front- and back-facing polygons.
            /// </param>
            [AutoGenerated(Category = "NV_polygon_mode", Version = "", EntryPoint = "glPolygonModeNV")]
            public static void PolygonMode(OpenTK.Graphics.ES31.MaterialFace face, OpenTK.Graphics.ES31.PolygonMode mode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="genMode"></param>
            /// <param name="components"></param>
            /// <param name="coeffs"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glProgramPathFragmentInputGenNV")]
            [CLSCompliant(false)]
            public static void ProgramPathFragmentInputGen(Int32 program, Int32 location, OpenTK.Graphics.ES31.All genMode, Int32 components, Single[] coeffs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="genMode"></param>
            /// <param name="components"></param>
            /// <param name="coeffs"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glProgramPathFragmentInputGenNV")]
            [CLSCompliant(false)]
            public static void ProgramPathFragmentInputGen(Int32 program, Int32 location, OpenTK.Graphics.ES31.All genMode, Int32 components, ref Single coeffs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="genMode"></param>
            /// <param name="components"></param>
            /// <param name="coeffs"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glProgramPathFragmentInputGenNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramPathFragmentInputGen(Int32 program, Int32 location, OpenTK.Graphics.ES31.All genMode, Int32 components, Single* coeffs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="genMode"></param>
            /// <param name="components"></param>
            /// <param name="coeffs"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glProgramPathFragmentInputGenNV")]
            [CLSCompliant(false)]
            public static void ProgramPathFragmentInputGen(UInt32 program, Int32 location, OpenTK.Graphics.ES31.All genMode, Int32 components, Single[] coeffs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="genMode"></param>
            /// <param name="components"></param>
            /// <param name="coeffs"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glProgramPathFragmentInputGenNV")]
            [CLSCompliant(false)]
            public static void ProgramPathFragmentInputGen(UInt32 program, Int32 location, OpenTK.Graphics.ES31.All genMode, Int32 components, ref Single coeffs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="genMode"></param>
            /// <param name="components"></param>
            /// <param name="coeffs"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glProgramPathFragmentInputGenNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramPathFragmentInputGen(UInt32 program, Int32 location, OpenTK.Graphics.ES31.All genMode, Int32 components, Single* coeffs) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform1i64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(Int32 program, Int32 location, Int64 x) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform1i64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, Int64 x) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform1i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform1i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform1i64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform1(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform1i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform1i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform1i64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform1ui64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, UInt64 x) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform1ui64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform1ui64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform1ui64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform2i64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(Int32 program, Int32 location, Int64 x, Int64 y) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform2i64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, Int64 x, Int64 y) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform2i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform2i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform2i64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform2(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform2i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform2i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform2i64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform2ui64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, UInt64 x, UInt64 y) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform2ui64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform2ui64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] ref UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform2ui64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            /// <param name="z">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform3i64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(Int32 program, Int32 location, Int64 x, Int64 y, Int64 z) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            /// <param name="z">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform3i64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, Int64 x, Int64 y, Int64 z) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform3i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform3i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform3i64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform3(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform3i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform3i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform3i64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            /// <param name="z">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform3ui64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, UInt64 x, UInt64 y, UInt64 z) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform3ui64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform3ui64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform3ui64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            /// <param name="z">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="w">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform4i64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(Int32 program, Int32 location, Int64 x, Int64 y, Int64 z, Int64 w) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            /// <param name="z">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="w">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform4i64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, Int64 x, Int64 y, Int64 z, Int64 w) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform4i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform4i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform4i64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform4(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform4i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform4i64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform4i64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            /// <param name="z">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="w">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform4ui64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform4ui64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform4ui64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </param>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glProgramUniform4ui64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="value"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniformHandle(Int32 program, Int32 location, Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="value"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64NV")]
            [CLSCompliant(false)]
            public static void ProgramUniformHandle(UInt32 program, Int32 location, UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="values">[length: count]</param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniformHandle(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int64[] values) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="values">[length: count]</param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniformHandle(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Int64 values) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="values">[length: count]</param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformHandle(Int32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int64* values) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="values">[length: count]</param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniformHandle(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64[] values) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="values">[length: count]</param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64vNV")]
            [CLSCompliant(false)]
            public static void ProgramUniformHandle(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref UInt64 values) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="program"></param>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="values">[length: count]</param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glProgramUniformHandleui64vNV")]
            [CLSCompliant(false)]
            public static unsafe void ProgramUniformHandle(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64* values) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_read_buffer]
            /// Select a color buffer source for pixels
            /// </summary>
            /// <param name="mode">
            /// Specifies a color buffer. Accepted values are Back, None, and ColorAttachmenti.
            /// </param>
            [AutoGenerated(Category = "NV_read_buffer", Version = "", EntryPoint = "glReadBufferNV")]
            public static void ReadBuffer(OpenTK.Graphics.ES31.All mode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_framebuffer_multisample]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// Specifies a binding to which the target of the allocation and must be Renderbuffer.
            /// </param>
            /// <param name="samples">
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the renderbuffer, in pixels.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the renderbuffer, in pixels.
            /// </param>
            [AutoGenerated(Category = "NV_framebuffer_multisample", Version = "", EntryPoint = "glRenderbufferStorageMultisampleNV")]
            public static void RenderbufferStorageMultisample(OpenTK.Graphics.ES31.All target, Int32 samples, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_sample_locations]</summary>
            [AutoGenerated(Category = "NV_sample_locations", Version = "", EntryPoint = "glResolveDepthValuesNV")]
            public static void ResolveDepthValues() { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose scissor box to modify.
            /// </param>
            /// <param name="count">
            /// Specifies the number of scissor boxes to modify.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorArrayvNV")]
            [CLSCompliant(false)]
            public static void ScissorArray(Int32 first, Int32 count, [CountAttribute(Computed = "count")] Int32[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose scissor box to modify.
            /// </param>
            /// <param name="count">
            /// Specifies the number of scissor boxes to modify.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorArrayvNV")]
            [CLSCompliant(false)]
            public static void ScissorArray(Int32 first, Int32 count, [CountAttribute(Computed = "count")] ref Int32 v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose scissor box to modify.
            /// </param>
            /// <param name="count">
            /// Specifies the number of scissor boxes to modify.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorArrayvNV")]
            [CLSCompliant(false)]
            public static unsafe void ScissorArray(Int32 first, Int32 count, [CountAttribute(Computed = "count")] Int32* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose scissor box to modify.
            /// </param>
            /// <param name="count">
            /// Specifies the number of scissor boxes to modify.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorArrayvNV")]
            [CLSCompliant(false)]
            public static void ScissorArray(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] Int32[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose scissor box to modify.
            /// </param>
            /// <param name="count">
            /// Specifies the number of scissor boxes to modify.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorArrayvNV")]
            [CLSCompliant(false)]
            public static void ScissorArray(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] ref Int32 v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose scissor box to modify.
            /// </param>
            /// <param name="count">
            /// Specifies the number of scissor boxes to modify.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorArrayvNV")]
            [CLSCompliant(false)]
            public static unsafe void ScissorArray(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] Int32* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="left">
            /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
            /// </param>
            /// <param name="bottom">
            /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
            /// </param>
            /// <param name="width">
            /// Specify ths dimensions of the scissor box, in pixels.
            /// </param>
            /// <param name="height">
            /// Specify ths dimensions of the scissor box, in pixels.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorIndexedNV")]
            [CLSCompliant(false)]
            public static void ScissorIndexed(Int32 index, Int32 left, Int32 bottom, Int32 width, Int32 height) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="left">
            /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
            /// </param>
            /// <param name="bottom">
            /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
            /// </param>
            /// <param name="width">
            /// Specify ths dimensions of the scissor box, in pixels.
            /// </param>
            /// <param name="height">
            /// Specify ths dimensions of the scissor box, in pixels.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorIndexedNV")]
            [CLSCompliant(false)]
            public static void ScissorIndexed(UInt32 index, Int32 left, Int32 bottom, Int32 width, Int32 height) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorIndexedvNV")]
            [CLSCompliant(false)]
            public static void ScissorIndexed(Int32 index, [CountAttribute(Count = 4)] Int32[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorIndexedvNV")]
            [CLSCompliant(false)]
            public static void ScissorIndexed(Int32 index, [CountAttribute(Count = 4)] ref Int32 v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorIndexedvNV")]
            [CLSCompliant(false)]
            public static unsafe void ScissorIndexed(Int32 index, [CountAttribute(Count = 4)] Int32* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorIndexedvNV")]
            [CLSCompliant(false)]
            public static void ScissorIndexed(UInt32 index, [CountAttribute(Count = 4)] Int32[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorIndexedvNV")]
            [CLSCompliant(false)]
            public static void ScissorIndexed(UInt32 index, [CountAttribute(Count = 4)] ref Int32 v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glScissorIndexedvNV")]
            [CLSCompliant(false)]
            public static unsafe void ScissorIndexed(UInt32 index, [CountAttribute(Count = 4)] Int32* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            /// <param name="condition"></param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glSetFenceNV")]
            [CLSCompliant(false)]
            public static void SetFence(Int32 fence, OpenTK.Graphics.ES31.All condition) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            /// <param name="condition"></param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glSetFenceNV")]
            [CLSCompliant(false)]
            public static void SetFence(UInt32 fence, OpenTK.Graphics.ES31.All condition) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_vulkan_image]</summary>
            /// <param name="vkFence"></param>
            [AutoGenerated(Category = "NV_draw_vulkan_image", Version = "", EntryPoint = "glSignalVkFenceNV")]
            [CLSCompliant(false)]
            public static void SignalVkFence(Int64 vkFence) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_vulkan_image]</summary>
            /// <param name="vkFence"></param>
            [AutoGenerated(Category = "NV_draw_vulkan_image", Version = "", EntryPoint = "glSignalVkFenceNV")]
            [CLSCompliant(false)]
            public static void SignalVkFence(UInt64 vkFence) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_vulkan_image]</summary>
            /// <param name="vkSemaphore"></param>
            [AutoGenerated(Category = "NV_draw_vulkan_image", Version = "", EntryPoint = "glSignalVkSemaphoreNV")]
            [CLSCompliant(false)]
            public static void SignalVkSemaphore(Int64 vkSemaphore) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_vulkan_image]</summary>
            /// <param name="vkSemaphore"></param>
            [AutoGenerated(Category = "NV_draw_vulkan_image", Version = "", EntryPoint = "glSignalVkSemaphoreNV")]
            [CLSCompliant(false)]
            public static void SignalVkSemaphore(UInt64 vkSemaphore) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathNV")]
            [CLSCompliant(false)]
            public static void StencilFillPath(Int32 path, OpenTK.Graphics.ES31.All fillMode, Int32 mask) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilFillPathNV")]
            [CLSCompliant(false)]
            public static void StencilFillPath(UInt32 path, OpenTK.Graphics.ES31.All fillMode, UInt32 mask) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] T2[,,] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths">[length: COMPSIZE(numPaths,pathNameType,paths)]</param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(numPaths,transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute, CountAttribute(Computed = "numPaths,pathNameType,paths")] ref T2 paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePath(Int32 path, Int32 reference, Int32 mask) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilStrokePathNV")]
            [CLSCompliant(false)]
            public static void StencilStrokePath(UInt32 path, Int32 reference, UInt32 mask) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, IntPtr paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, IntPtr paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, IntPtr paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, IntPtr paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, IntPtr paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverFillPathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, IntPtr paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,,] paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,,] paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] ref T2 paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] ref T2 paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] ref T2 paths, Int32 pathBase, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] ref T2 paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] ref T2 paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverFillPathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] ref T2 paths, UInt32 pathBase, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPath(Int32 path, OpenTK.Graphics.ES31.All fillMode, Int32 mask, OpenTK.Graphics.ES31.All coverMode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="fillMode"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverFillPathNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverFillPath(UInt32 path, OpenTK.Graphics.ES31.All fillMode, UInt32 mask, OpenTK.Graphics.ES31.All coverMode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, IntPtr paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, IntPtr paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, IntPtr paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, IntPtr paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, IntPtr paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverStrokePathInstanced(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, IntPtr paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,,] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,,] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,,] paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,,] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,,] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] T2[,,] paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] ref T2 paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] ref T2 paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] ref T2 paths, Int32 pathBase, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] ref T2 paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single[] transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] ref T2 paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, ref Single transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="numPaths"></param>
            /// <param name="pathNameType"></param>
            /// <param name="paths"></param>
            /// <param name="pathBase"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathInstancedNV")]
            [CLSCompliant(false)]
            public static unsafe void StencilThenCoverStrokePathInstanced<T2>(Int32 numPaths, OpenTK.Graphics.ES31.All pathNameType, [InAttribute, OutAttribute] ref T2 paths, UInt32 pathBase, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode, OpenTK.Graphics.ES31.All transformType, Single* transformValues)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePath(Int32 path, Int32 reference, Int32 mask, OpenTK.Graphics.ES31.All coverMode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="path"></param>
            /// <param name="reference"></param>
            /// <param name="mask"></param>
            /// <param name="coverMode"></param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glStencilThenCoverStrokePathNV")]
            [CLSCompliant(false)]
            public static void StencilThenCoverStrokePath(UInt32 path, Int32 reference, UInt32 mask, OpenTK.Graphics.ES31.All coverMode) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_conservative_raster]</summary>
            /// <param name="xbits"></param>
            /// <param name="ybits"></param>
            [AutoGenerated(Category = "NV_conservative_raster", Version = "", EntryPoint = "glSubpixelPrecisionBiasNV")]
            [CLSCompliant(false)]
            public static void SubpixelPrecisionBia(Int32 xbits, Int32 ybits) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_conservative_raster]</summary>
            /// <param name="xbits"></param>
            /// <param name="ybits"></param>
            [AutoGenerated(Category = "NV_conservative_raster", Version = "", EntryPoint = "glSubpixelPrecisionBiasNV")]
            [CLSCompliant(false)]
            public static void SubpixelPrecisionBia(UInt32 xbits, UInt32 ybits) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glTestFenceNV")]
            [CLSCompliant(false)]
            public static bool TestFence(Int32 fence) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_fence]</summary>
            /// <param name="fence"></param>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glTestFenceNV")]
            [CLSCompliant(false)]
            public static bool TestFence(UInt32 fence) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="srcPath"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glTransformPathNV")]
            [CLSCompliant(false)]
            public static void TransformPath(Int32 resultPath, Int32 srcPath, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "transformType")] Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="srcPath"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glTransformPathNV")]
            [CLSCompliant(false)]
            public static void TransformPath(Int32 resultPath, Int32 srcPath, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "transformType")] ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="srcPath"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glTransformPathNV")]
            [CLSCompliant(false)]
            public static unsafe void TransformPath(Int32 resultPath, Int32 srcPath, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "transformType")] Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="srcPath"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glTransformPathNV")]
            [CLSCompliant(false)]
            public static void TransformPath(UInt32 resultPath, UInt32 srcPath, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "transformType")] Single[] transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="srcPath"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glTransformPathNV")]
            [CLSCompliant(false)]
            public static void TransformPath(UInt32 resultPath, UInt32 srcPath, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "transformType")] ref Single transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="srcPath"></param>
            /// <param name="transformType"></param>
            /// <param name="transformValues">[length: COMPSIZE(transformType)]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glTransformPathNV")]
            [CLSCompliant(false)]
            public static unsafe void TransformPath(UInt32 resultPath, UInt32 srcPath, OpenTK.Graphics.ES31.All transformType, [CountAttribute(Computed = "transformType")] Single* transformValues) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform1i64NV")]
            public static void Uniform1(Int32 location, Int64 x) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*1]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform1i64vNV")]
            [CLSCompliant(false)]
            public static void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*1]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform1i64vNV")]
            [CLSCompliant(false)]
            public static void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*1]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform1i64vNV")]
            [CLSCompliant(false)]
            public static unsafe void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform1ui64NV")]
            [CLSCompliant(false)]
            public static void Uniform1(Int32 location, UInt64 x) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*1]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform1ui64vNV")]
            [CLSCompliant(false)]
            public static void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] UInt64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*1]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform1ui64vNV")]
            [CLSCompliant(false)]
            public static void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] ref UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*1]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform1ui64vNV")]
            [CLSCompliant(false)]
            public static unsafe void Uniform1(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] UInt64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform2i64NV")]
            public static void Uniform2(Int32 location, Int64 x, Int64 y) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform2i64vNV")]
            [CLSCompliant(false)]
            public static void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform2i64vNV")]
            [CLSCompliant(false)]
            public static void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform2i64vNV")]
            [CLSCompliant(false)]
            public static unsafe void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform2ui64NV")]
            [CLSCompliant(false)]
            public static void Uniform2(Int32 location, UInt64 x, UInt64 y) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform2ui64vNV")]
            [CLSCompliant(false)]
            public static void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform2ui64vNV")]
            [CLSCompliant(false)]
            public static void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] ref UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*2]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform2ui64vNV")]
            [CLSCompliant(false)]
            public static unsafe void Uniform2(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            /// <param name="z">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform3i64NV")]
            public static void Uniform3(Int32 location, Int64 x, Int64 y, Int64 z) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform3i64vNV")]
            [CLSCompliant(false)]
            public static void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform3i64vNV")]
            [CLSCompliant(false)]
            public static void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform3i64vNV")]
            [CLSCompliant(false)]
            public static unsafe void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            /// <param name="z">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform3ui64NV")]
            [CLSCompliant(false)]
            public static void Uniform3(Int32 location, UInt64 x, UInt64 y, UInt64 z) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform3ui64vNV")]
            [CLSCompliant(false)]
            public static void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform3ui64vNV")]
            [CLSCompliant(false)]
            public static void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] ref UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*3]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform3ui64vNV")]
            [CLSCompliant(false)]
            public static unsafe void Uniform3(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            /// <param name="z">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="w">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform4i64NV")]
            public static void Uniform4(Int32 location, Int64 x, Int64 y, Int64 z, Int64 w) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform4i64vNV")]
            [CLSCompliant(false)]
            public static void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform4i64vNV")]
            [CLSCompliant(false)]
            public static void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform4i64vNV")]
            [CLSCompliant(false)]
            public static unsafe void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="x">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="y">
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </param>
            /// <param name="z">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            /// <param name="w">
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform4ui64NV")]
            [CLSCompliant(false)]
            public static void Uniform4(Int32 location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform4ui64vNV")]
            [CLSCompliant(false)]
            public static void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform4ui64vNV")]
            [CLSCompliant(false)]
            public static void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] ref UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_gpu_shader5]
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// Specifies the location of the uniform variable to be modified.
            /// </param>
            /// <param name="count">
            /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.  For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </param>
            /// <param name="value">[length: count*4]
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </param>
            [AutoGenerated(Category = "NV_gpu_shader5", Version = "", EntryPoint = "glUniform4ui64vNV")]
            [CLSCompliant(false)]
            public static unsafe void Uniform4(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="value"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64NV")]
            [CLSCompliant(false)]
            public static void UniformHandle(Int32 location, Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="value"></param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64NV")]
            [CLSCompliant(false)]
            public static void UniformHandle(Int32 location, UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="value">[length: count]</param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64vNV")]
            [CLSCompliant(false)]
            public static void UniformHandle(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="value">[length: count]</param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64vNV")]
            [CLSCompliant(false)]
            public static void UniformHandle(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref Int64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="value">[length: count]</param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64vNV")]
            [CLSCompliant(false)]
            public static unsafe void UniformHandle(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="value">[length: count]</param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64vNV")]
            [CLSCompliant(false)]
            public static void UniformHandle(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="value">[length: count]</param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64vNV")]
            [CLSCompliant(false)]
            public static void UniformHandle(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] ref UInt64 value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_bindless_texture]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="value">[length: count]</param>
            [AutoGenerated(Category = "NV_bindless_texture", Version = "", EntryPoint = "glUniformHandleui64vNV")]
            [CLSCompliant(false)]
            public static unsafe void UniformHandle(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix2x3fvNV")]
            [CLSCompliant(false)]
            public static void UniformMatrix2x3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix2x3fvNV")]
            [CLSCompliant(false)]
            public static void UniformMatrix2x3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix2x3fvNV")]
            [CLSCompliant(false)]
            public static unsafe void UniformMatrix2x3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix2x4fvNV")]
            [CLSCompliant(false)]
            public static void UniformMatrix2x4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix2x4fvNV")]
            [CLSCompliant(false)]
            public static void UniformMatrix2x4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix2x4fvNV")]
            [CLSCompliant(false)]
            public static unsafe void UniformMatrix2x4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix3x2fvNV")]
            [CLSCompliant(false)]
            public static void UniformMatrix3x2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix3x2fvNV")]
            [CLSCompliant(false)]
            public static void UniformMatrix3x2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*6]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix3x2fvNV")]
            [CLSCompliant(false)]
            public static unsafe void UniformMatrix3x2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix3x4fvNV")]
            [CLSCompliant(false)]
            public static void UniformMatrix3x4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix3x4fvNV")]
            [CLSCompliant(false)]
            public static void UniformMatrix3x4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix3x4fvNV")]
            [CLSCompliant(false)]
            public static unsafe void UniformMatrix3x4(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix4x2fvNV")]
            [CLSCompliant(false)]
            public static void UniformMatrix4x2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix4x2fvNV")]
            [CLSCompliant(false)]
            public static void UniformMatrix4x2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*8]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix4x2fvNV")]
            [CLSCompliant(false)]
            public static unsafe void UniformMatrix4x2(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix4x3fvNV")]
            [CLSCompliant(false)]
            public static void UniformMatrix4x3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single[] value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix4x3fvNV")]
            [CLSCompliant(false)]
            public static void UniformMatrix4x3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] ref Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            /// <param name="location"></param>
            /// <param name="count"></param>
            /// <param name="transpose"></param>
            /// <param name="value">[length: count*12]</param>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix4x3fvNV")]
            [CLSCompliant(false)]
            public static unsafe void UniformMatrix4x3(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_instanced_arrays]
            /// Modify the rate at which generic vertex attributes advance during instanced rendering
            /// </summary>
            /// <param name="index">
            /// Specify the index of the generic vertex attribute.
            /// </param>
            /// <param name="divisor">
            /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
            /// </param>
            [AutoGenerated(Category = "NV_instanced_arrays", Version = "", EntryPoint = "glVertexAttribDivisorNV")]
            [CLSCompliant(false)]
            public static void VertexAttribDivisor(Int32 index, Int32 divisor) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_instanced_arrays]
            /// Modify the rate at which generic vertex attributes advance during instanced rendering
            /// </summary>
            /// <param name="index">
            /// Specify the index of the generic vertex attribute.
            /// </param>
            /// <param name="divisor">
            /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
            /// </param>
            [AutoGenerated(Category = "NV_instanced_arrays", Version = "", EntryPoint = "glVertexAttribDivisorNV")]
            [CLSCompliant(false)]
            public static void VertexAttribDivisor(UInt32 index, UInt32 divisor) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="count">
            /// Specify the number of viewports to set.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specify the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportArrayvNV")]
            [CLSCompliant(false)]
            public static void ViewportArray(Int32 first, Int32 count, [CountAttribute(Computed = "count")] Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="count">
            /// Specify the number of viewports to set.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specify the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportArrayvNV")]
            [CLSCompliant(false)]
            public static void ViewportArray(Int32 first, Int32 count, [CountAttribute(Computed = "count")] ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="count">
            /// Specify the number of viewports to set.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specify the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportArrayvNV")]
            [CLSCompliant(false)]
            public static unsafe void ViewportArray(Int32 first, Int32 count, [CountAttribute(Computed = "count")] Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="count">
            /// Specify the number of viewports to set.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specify the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportArrayvNV")]
            [CLSCompliant(false)]
            public static void ViewportArray(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="count">
            /// Specify the number of viewports to set.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specify the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportArrayvNV")]
            [CLSCompliant(false)]
            public static void ViewportArray(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="count">
            /// Specify the number of viewports to set.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specify the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportArrayvNV")]
            [CLSCompliant(false)]
            public static unsafe void ViewportArray(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="x">
            /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
            /// </param>
            /// <param name="y">
            /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
            /// </param>
            /// <param name="w">
            /// For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
            /// </param>
            /// <param name="h">
            /// For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportIndexedfNV")]
            [CLSCompliant(false)]
            public static void ViewportIndexed(Int32 index, Single x, Single y, Single w, Single h) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="x">
            /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
            /// </param>
            /// <param name="y">
            /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
            /// </param>
            /// <param name="w">
            /// For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
            /// </param>
            /// <param name="h">
            /// For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportIndexedfNV")]
            [CLSCompliant(false)]
            public static void ViewportIndexed(UInt32 index, Single x, Single y, Single w, Single h) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportIndexedfvNV")]
            [CLSCompliant(false)]
            public static void ViewportIndexed(Int32 index, [CountAttribute(Count = 4)] Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportIndexedfvNV")]
            [CLSCompliant(false)]
            public static void ViewportIndexed(Int32 index, [CountAttribute(Count = 4)] ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportIndexedfvNV")]
            [CLSCompliant(false)]
            public static unsafe void ViewportIndexed(Int32 index, [CountAttribute(Count = 4)] Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportIndexedfvNV")]
            [CLSCompliant(false)]
            public static void ViewportIndexed(UInt32 index, [CountAttribute(Count = 4)] Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportIndexedfvNV")]
            [CLSCompliant(false)]
            public static void ViewportIndexed(UInt32 index, [CountAttribute(Count = 4)] ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "NV_viewport_array", Version = "", EntryPoint = "glViewportIndexedfvNV")]
            [CLSCompliant(false)]
            public static unsafe void ViewportIndexed(UInt32 index, [CountAttribute(Count = 4)] Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_swizzle]</summary>
            /// <param name="index"></param>
            /// <param name="swizzlex"></param>
            /// <param name="swizzley"></param>
            /// <param name="swizzlez"></param>
            /// <param name="swizzlew"></param>
            [AutoGenerated(Category = "NV_viewport_swizzle", Version = "", EntryPoint = "glViewportSwizzleNV")]
            [CLSCompliant(false)]
            public static void ViewportSwizzle(Int32 index, OpenTK.Graphics.ES31.All swizzlex, OpenTK.Graphics.ES31.All swizzley, OpenTK.Graphics.ES31.All swizzlez, OpenTK.Graphics.ES31.All swizzlew) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_viewport_swizzle]</summary>
            /// <param name="index"></param>
            /// <param name="swizzlex"></param>
            /// <param name="swizzley"></param>
            /// <param name="swizzlez"></param>
            /// <param name="swizzlew"></param>
            [AutoGenerated(Category = "NV_viewport_swizzle", Version = "", EntryPoint = "glViewportSwizzleNV")]
            [CLSCompliant(false)]
            public static void ViewportSwizzle(UInt32 index, OpenTK.Graphics.ES31.All swizzlex, OpenTK.Graphics.ES31.All swizzley, OpenTK.Graphics.ES31.All swizzlez, OpenTK.Graphics.ES31.All swizzlew) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_vulkan_image]</summary>
            /// <param name="vkSemaphore"></param>
            [AutoGenerated(Category = "NV_draw_vulkan_image", Version = "", EntryPoint = "glWaitVkSemaphoreNV")]
            [CLSCompliant(false)]
            public static void WaitVkSemaphore(Int64 vkSemaphore) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_draw_vulkan_image]</summary>
            /// <param name="vkSemaphore"></param>
            [AutoGenerated(Category = "NV_draw_vulkan_image", Version = "", EntryPoint = "glWaitVkSemaphoreNV")]
            [CLSCompliant(false)]
            public static void WaitVkSemaphore(UInt64 vkSemaphore) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="numPaths"></param>
            /// <param name="paths">[length: numPaths]</param>
            /// <param name="weights">[length: numPaths]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glWeightPathsNV")]
            [CLSCompliant(false)]
            public static void WeightPath(Int32 resultPath, Int32 numPaths, [CountAttribute(Parameter = "numPaths")] Int32[] paths, [CountAttribute(Parameter = "numPaths")] Single[] weights) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="numPaths"></param>
            /// <param name="paths">[length: numPaths]</param>
            /// <param name="weights">[length: numPaths]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glWeightPathsNV")]
            [CLSCompliant(false)]
            public static void WeightPath(Int32 resultPath, Int32 numPaths, [CountAttribute(Parameter = "numPaths")] ref Int32 paths, [CountAttribute(Parameter = "numPaths")] ref Single weights) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="numPaths"></param>
            /// <param name="paths">[length: numPaths]</param>
            /// <param name="weights">[length: numPaths]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glWeightPathsNV")]
            [CLSCompliant(false)]
            public static unsafe void WeightPath(Int32 resultPath, Int32 numPaths, [CountAttribute(Parameter = "numPaths")] Int32* paths, [CountAttribute(Parameter = "numPaths")] Single* weights) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="numPaths"></param>
            /// <param name="paths">[length: numPaths]</param>
            /// <param name="weights">[length: numPaths]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glWeightPathsNV")]
            [CLSCompliant(false)]
            public static void WeightPath(UInt32 resultPath, Int32 numPaths, [CountAttribute(Parameter = "numPaths")] UInt32[] paths, [CountAttribute(Parameter = "numPaths")] Single[] weights) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="numPaths"></param>
            /// <param name="paths">[length: numPaths]</param>
            /// <param name="weights">[length: numPaths]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glWeightPathsNV")]
            [CLSCompliant(false)]
            public static void WeightPath(UInt32 resultPath, Int32 numPaths, [CountAttribute(Parameter = "numPaths")] ref UInt32 paths, [CountAttribute(Parameter = "numPaths")] ref Single weights) { throw new NotImplementedException(); }

            /// <summary>[requires: NV_path_rendering]</summary>
            /// <param name="resultPath"></param>
            /// <param name="numPaths"></param>
            /// <param name="paths">[length: numPaths]</param>
            /// <param name="weights">[length: numPaths]</param>
            [AutoGenerated(Category = "NV_path_rendering", Version = "", EntryPoint = "glWeightPathsNV")]
            [CLSCompliant(false)]
            public static unsafe void WeightPath(UInt32 resultPath, Int32 numPaths, [CountAttribute(Parameter = "numPaths")] UInt32* paths, [CountAttribute(Parameter = "numPaths")] Single* weights) { throw new NotImplementedException(); }

        }

        public static partial class Oes
        {
            /// <summary>[requires: OES_vertex_array_object]
            /// Bind a vertex array object
            /// </summary>
            /// <param name="array">
            /// Specifies the name of the vertex array to bind.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glBindVertexArrayOES")]
            [CLSCompliant(false)]
            public static void BindVertexArray(Int32 array) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Bind a vertex array object
            /// </summary>
            /// <param name="array">
            /// Specifies the name of the vertex array to bind.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glBindVertexArrayOES")]
            [CLSCompliant(false)]
            public static void BindVertexArray(UInt32 array) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed]
            /// Specify the equation used for both the RGB blend equation and the Alpha blend equation
            /// </summary>
            /// <param name="buf">
            /// specifies how source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            /// <param name="mode">
            /// specifies how source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed", Version = "", EntryPoint = "glBlendEquationiOES")]
            [CLSCompliant(false)]
            public static void BlendEquation(Int32 buf, OpenTK.Graphics.ES31.All mode) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed]
            /// Specify the equation used for both the RGB blend equation and the Alpha blend equation
            /// </summary>
            /// <param name="buf">
            /// specifies how source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            /// <param name="mode">
            /// specifies how source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed", Version = "", EntryPoint = "glBlendEquationiOES")]
            [CLSCompliant(false)]
            public static void BlendEquation(UInt32 buf, OpenTK.Graphics.ES31.All mode) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed]
            /// Set the RGB blend equation and the alpha blend equation separately
            /// </summary>
            /// <param name="buf">
            /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            /// <param name="modeRGB">
            /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            /// <param name="modeAlpha">
            /// specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed", Version = "", EntryPoint = "glBlendEquationSeparateiOES")]
            [CLSCompliant(false)]
            public static void BlendEquationSeparate(Int32 buf, OpenTK.Graphics.ES31.All modeRGB, OpenTK.Graphics.ES31.All modeAlpha) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed]
            /// Set the RGB blend equation and the alpha blend equation separately
            /// </summary>
            /// <param name="buf">
            /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            /// <param name="modeRGB">
            /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            /// <param name="modeAlpha">
            /// specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be FuncAdd, FuncSubtract, FuncReverseSubtract, Min, Max.
            /// </param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed", Version = "", EntryPoint = "glBlendEquationSeparateiOES")]
            [CLSCompliant(false)]
            public static void BlendEquationSeparate(UInt32 buf, OpenTK.Graphics.ES31.All modeRGB, OpenTK.Graphics.ES31.All modeAlpha) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed]
            /// Specify pixel arithmetic
            /// </summary>
            /// <param name="buf">
            /// Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is One.
            /// </param>
            /// <param name="src">
            /// Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: Zero, One, SrcColor, OneMinusSrcColor, DstColor, OneMinusDstColor, SrcAlpha, OneMinusSrcAlpha, DstAlpha, OneMinusDstAlpha. ConstantColor, OneMinusConstantColor, ConstantAlpha, and OneMinusConstantAlpha. The initial value is Zero.
            /// </param>
            /// <param name="dst"></param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed", Version = "", EntryPoint = "glBlendFunciOES")]
            [CLSCompliant(false)]
            public static void BlendFunc(Int32 buf, OpenTK.Graphics.ES31.All src, OpenTK.Graphics.ES31.All dst) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed]
            /// Specify pixel arithmetic
            /// </summary>
            /// <param name="buf">
            /// Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is One.
            /// </param>
            /// <param name="src">
            /// Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: Zero, One, SrcColor, OneMinusSrcColor, DstColor, OneMinusDstColor, SrcAlpha, OneMinusSrcAlpha, DstAlpha, OneMinusDstAlpha. ConstantColor, OneMinusConstantColor, ConstantAlpha, and OneMinusConstantAlpha. The initial value is Zero.
            /// </param>
            /// <param name="dst"></param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed", Version = "", EntryPoint = "glBlendFunciOES")]
            [CLSCompliant(false)]
            public static void BlendFunc(UInt32 buf, OpenTK.Graphics.ES31.All src, OpenTK.Graphics.ES31.All dst) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed]
            /// Specify pixel arithmetic for RGB and alpha components separately
            /// </summary>
            /// <param name="buf">
            /// Specifies how the red, green, and blue blending factors are computed. The initial value is One.
            /// </param>
            /// <param name="srcRGB">
            /// Specifies how the red, green, and blue blending factors are computed. The initial value is One.
            /// </param>
            /// <param name="dstRGB">
            /// Specifies how the red, green, and blue destination blending factors are computed. The initial value is Zero.
            /// </param>
            /// <param name="srcAlpha">
            /// Specified how the alpha source blending factor is computed. The initial value is One.
            /// </param>
            /// <param name="dstAlpha">
            /// Specified how the alpha destination blending factor is computed. The initial value is Zero.
            /// </param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed", Version = "", EntryPoint = "glBlendFuncSeparateiOES")]
            [CLSCompliant(false)]
            public static void BlendFuncSeparate(Int32 buf, OpenTK.Graphics.ES31.All srcRGB, OpenTK.Graphics.ES31.All dstRGB, OpenTK.Graphics.ES31.All srcAlpha, OpenTK.Graphics.ES31.All dstAlpha) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed]
            /// Specify pixel arithmetic for RGB and alpha components separately
            /// </summary>
            /// <param name="buf">
            /// Specifies how the red, green, and blue blending factors are computed. The initial value is One.
            /// </param>
            /// <param name="srcRGB">
            /// Specifies how the red, green, and blue blending factors are computed. The initial value is One.
            /// </param>
            /// <param name="dstRGB">
            /// Specifies how the red, green, and blue destination blending factors are computed. The initial value is Zero.
            /// </param>
            /// <param name="srcAlpha">
            /// Specified how the alpha source blending factor is computed. The initial value is One.
            /// </param>
            /// <param name="dstAlpha">
            /// Specified how the alpha destination blending factor is computed. The initial value is Zero.
            /// </param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed", Version = "", EntryPoint = "glBlendFuncSeparateiOES")]
            [CLSCompliant(false)]
            public static void BlendFuncSeparate(UInt32 buf, OpenTK.Graphics.ES31.All srcRGB, OpenTK.Graphics.ES31.All dstRGB, OpenTK.Graphics.ES31.All srcAlpha, OpenTK.Graphics.ES31.All dstAlpha) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed]
            /// Enable and disable writing of frame buffer color components
            /// </summary>
            /// <param name="index">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="r">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="g">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="b">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="a"></param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed", Version = "", EntryPoint = "glColorMaskiOES")]
            [CLSCompliant(false)]
            public static void ColorMask(Int32 index, bool r, bool g, bool b, bool a) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed]
            /// Enable and disable writing of frame buffer color components
            /// </summary>
            /// <param name="index">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="r">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="g">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="b">
            /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all True, indicating that the color components are written.
            /// </param>
            /// <param name="a"></param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed", Version = "", EntryPoint = "glColorMaskiOES")]
            [CLSCompliant(false)]
            public static void ColorMask(UInt32 index, bool r, bool g, bool b, bool a) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the format of the compressed image data stored at address data.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture image.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture image.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture image.
            /// </param>
            /// <param name="border">
            /// This value must be 0.
            /// </param>
            /// <param name="imageSize">
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </param>
            /// <param name="data">[length: imageSize]
            /// Specifies a pointer to the compressed image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            public static void CompressedTexImage3D(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the format of the compressed image data stored at address data.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture image.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture image.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture image.
            /// </param>
            /// <param name="border">
            /// This value must be 0.
            /// </param>
            /// <param name="imageSize">
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </param>
            /// <param name="data">[length: imageSize]
            /// Specifies a pointer to the compressed image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            [CLSCompliant(false)]
            public static void CompressedTexImage3D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[] data)
                where T8 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the format of the compressed image data stored at address data.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture image.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture image.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture image.
            /// </param>
            /// <param name="border">
            /// This value must be 0.
            /// </param>
            /// <param name="imageSize">
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </param>
            /// <param name="data">[length: imageSize]
            /// Specifies a pointer to the compressed image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            [CLSCompliant(false)]
            public static void CompressedTexImage3D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[,] data)
                where T8 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the format of the compressed image data stored at address data.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture image.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture image.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture image.
            /// </param>
            /// <param name="border">
            /// This value must be 0.
            /// </param>
            /// <param name="imageSize">
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </param>
            /// <param name="data">[length: imageSize]
            /// Specifies a pointer to the compressed image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            [CLSCompliant(false)]
            public static void CompressedTexImage3D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T8[,,] data)
                where T8 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D, or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the format of the compressed image data stored at address data.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture image.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture image.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture image.
            /// </param>
            /// <param name="border">
            /// This value must be 0.
            /// </param>
            /// <param name="imageSize">
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </param>
            /// <param name="data">[length: imageSize]
            /// Specifies a pointer to the compressed image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            public static void CompressedTexImage3D<T8>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] ref T8 data)
                where T8 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="xoffset">
            /// Specifies a texel offset in the x direction within the texture array.
            /// </param>
            /// <param name="yoffset">
            /// Specifies a texel offset in the y direction within the texture array.
            /// </param>
            /// <param name="zoffset">
            /// Specifies a texel offset in the z direction within the texture array.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture subimage.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture subimage.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture subimage.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the compressed image data stored at address data.
            /// </param>
            /// <param name="imageSize">
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </param>
            /// <param name="data">[length: imageSize]
            /// Specifies a pointer to the compressed image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            public static void CompressedTexSubImage3D(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="xoffset">
            /// Specifies a texel offset in the x direction within the texture array.
            /// </param>
            /// <param name="yoffset">
            /// Specifies a texel offset in the y direction within the texture array.
            /// </param>
            /// <param name="zoffset">
            /// Specifies a texel offset in the z direction within the texture array.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture subimage.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture subimage.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture subimage.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the compressed image data stored at address data.
            /// </param>
            /// <param name="imageSize">
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </param>
            /// <param name="data">[length: imageSize]
            /// Specifies a pointer to the compressed image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            [CLSCompliant(false)]
            public static void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T10[] data)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="xoffset">
            /// Specifies a texel offset in the x direction within the texture array.
            /// </param>
            /// <param name="yoffset">
            /// Specifies a texel offset in the y direction within the texture array.
            /// </param>
            /// <param name="zoffset">
            /// Specifies a texel offset in the z direction within the texture array.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture subimage.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture subimage.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture subimage.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the compressed image data stored at address data.
            /// </param>
            /// <param name="imageSize">
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </param>
            /// <param name="data">[length: imageSize]
            /// Specifies a pointer to the compressed image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            [CLSCompliant(false)]
            public static void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T10[,] data)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="xoffset">
            /// Specifies a texel offset in the x direction within the texture array.
            /// </param>
            /// <param name="yoffset">
            /// Specifies a texel offset in the y direction within the texture array.
            /// </param>
            /// <param name="zoffset">
            /// Specifies a texel offset in the z direction within the texture array.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture subimage.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture subimage.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture subimage.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the compressed image data stored at address data.
            /// </param>
            /// <param name="imageSize">
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </param>
            /// <param name="data">[length: imageSize]
            /// Specifies a pointer to the compressed image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            [CLSCompliant(false)]
            public static void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] T10[,,] data)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="xoffset">
            /// Specifies a texel offset in the x direction within the texture array.
            /// </param>
            /// <param name="yoffset">
            /// Specifies a texel offset in the y direction within the texture array.
            /// </param>
            /// <param name="zoffset">
            /// Specifies a texel offset in the z direction within the texture array.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture subimage.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture subimage.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture subimage.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the compressed image data stored at address data.
            /// </param>
            /// <param name="imageSize">
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </param>
            /// <param name="data">[length: imageSize]
            /// Specifies a pointer to the compressed image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            public static void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, Int32 imageSize, [InAttribute, OutAttribute, CountAttribute(Parameter = "imageSize")] ref T10 data)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_copy_image]
            /// Perform a raw data copy between two images
            /// </summary>
            /// <param name="srcName">
            /// The name of a texture or renderbuffer object from which to copy.
            /// </param>
            /// <param name="srcTarget">
            /// The target representing the namespace of the source name srcName.
            /// </param>
            /// <param name="srcLevel">
            /// The mipmap level to read from the source.
            /// </param>
            /// <param name="srcX">
            /// The X coordinate of the left edge of the souce region to copy.
            /// </param>
            /// <param name="srcY">
            /// The Y coordinate of the top edge of the souce region to copy.
            /// </param>
            /// <param name="srcZ">
            /// The Z coordinate of the near edge of the souce region to copy.
            /// </param>
            /// <param name="dstName">
            /// The name of a texture or renderbuffer object to which to copy.
            /// </param>
            /// <param name="dstTarget">
            /// The target representing the namespace of the destination name dstName.
            /// </param>
            /// <param name="dstLevel">
            /// The X coordinate of the left edge of the destination region.
            /// </param>
            /// <param name="dstX">
            /// The X coordinate of the left edge of the destination region.
            /// </param>
            /// <param name="dstY">
            /// The Y coordinate of the top edge of the destination region.
            /// </param>
            /// <param name="dstZ">
            /// The Z coordinate of the near edge of the destination region.
            /// </param>
            /// <param name="srcWidth">
            /// The width of the region to be copied.
            /// </param>
            /// <param name="srcHeight">
            /// The height of the region to be copied.
            /// </param>
            /// <param name="srcDepth">
            /// The depth of the region to be copied.
            /// </param>
            [AutoGenerated(Category = "OES_copy_image", Version = "", EntryPoint = "glCopyImageSubDataOES")]
            [CLSCompliant(false)]
            public static void CopyImageSubData(Int32 srcName, OpenTK.Graphics.ES31.All srcTarget, Int32 srcLevel, Int32 srcX, Int32 srcY, Int32 srcZ, Int32 dstName, OpenTK.Graphics.ES31.All dstTarget, Int32 dstLevel, Int32 dstX, Int32 dstY, Int32 dstZ, Int32 srcWidth, Int32 srcHeight, Int32 srcDepth) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_copy_image]
            /// Perform a raw data copy between two images
            /// </summary>
            /// <param name="srcName">
            /// The name of a texture or renderbuffer object from which to copy.
            /// </param>
            /// <param name="srcTarget">
            /// The target representing the namespace of the source name srcName.
            /// </param>
            /// <param name="srcLevel">
            /// The mipmap level to read from the source.
            /// </param>
            /// <param name="srcX">
            /// The X coordinate of the left edge of the souce region to copy.
            /// </param>
            /// <param name="srcY">
            /// The Y coordinate of the top edge of the souce region to copy.
            /// </param>
            /// <param name="srcZ">
            /// The Z coordinate of the near edge of the souce region to copy.
            /// </param>
            /// <param name="dstName">
            /// The name of a texture or renderbuffer object to which to copy.
            /// </param>
            /// <param name="dstTarget">
            /// The target representing the namespace of the destination name dstName.
            /// </param>
            /// <param name="dstLevel">
            /// The X coordinate of the left edge of the destination region.
            /// </param>
            /// <param name="dstX">
            /// The X coordinate of the left edge of the destination region.
            /// </param>
            /// <param name="dstY">
            /// The Y coordinate of the top edge of the destination region.
            /// </param>
            /// <param name="dstZ">
            /// The Z coordinate of the near edge of the destination region.
            /// </param>
            /// <param name="srcWidth">
            /// The width of the region to be copied.
            /// </param>
            /// <param name="srcHeight">
            /// The height of the region to be copied.
            /// </param>
            /// <param name="srcDepth">
            /// The depth of the region to be copied.
            /// </param>
            [AutoGenerated(Category = "OES_copy_image", Version = "", EntryPoint = "glCopyImageSubDataOES")]
            [CLSCompliant(false)]
            public static void CopyImageSubData(UInt32 srcName, OpenTK.Graphics.ES31.All srcTarget, Int32 srcLevel, Int32 srcX, Int32 srcY, Int32 srcZ, UInt32 dstName, OpenTK.Graphics.ES31.All dstTarget, Int32 dstLevel, Int32 dstX, Int32 dstY, Int32 dstZ, Int32 srcWidth, Int32 srcHeight, Int32 srcDepth) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Copy a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="xoffset">
            /// Specifies a texel offset in the x direction within the texture array.
            /// </param>
            /// <param name="yoffset">
            /// Specifies a texel offset in the y direction within the texture array.
            /// </param>
            /// <param name="zoffset">
            /// Specifies a texel offset in the z direction within the texture array.
            /// </param>
            /// <param name="x">
            /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
            /// </param>
            /// <param name="y">
            /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture subimage.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture subimage.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCopyTexSubImage3DOES")]
            public static void CopyTexSubImage3D(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="arrays">[length: n]
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            [CLSCompliant(false)]
            public static void DeleteVertexArray([CountAttribute(Parameter = "n")] Int32 arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="arrays">[length: n]
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            [CLSCompliant(false)]
            public static void DeleteVertexArray([CountAttribute(Parameter = "n")] UInt32 arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of vertex array objects to be deleted.
            /// </param>
            /// <param name="arrays">[length: n]
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            [CLSCompliant(false)]
            public static void DeleteVertexArrays(Int32 n, [CountAttribute(Parameter = "n")] Int32[] arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of vertex array objects to be deleted.
            /// </param>
            /// <param name="arrays">[length: n]
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            [CLSCompliant(false)]
            public static void DeleteVertexArrays(Int32 n, [CountAttribute(Parameter = "n")] ref Int32 arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of vertex array objects to be deleted.
            /// </param>
            /// <param name="arrays">[length: n]
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            [CLSCompliant(false)]
            public static unsafe void DeleteVertexArrays(Int32 n, [CountAttribute(Parameter = "n")] Int32* arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of vertex array objects to be deleted.
            /// </param>
            /// <param name="arrays">[length: n]
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            [CLSCompliant(false)]
            public static void DeleteVertexArrays(Int32 n, [CountAttribute(Parameter = "n")] UInt32[] arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of vertex array objects to be deleted.
            /// </param>
            /// <param name="arrays">[length: n]
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            [CLSCompliant(false)]
            public static void DeleteVertexArrays(Int32 n, [CountAttribute(Parameter = "n")] ref UInt32 arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="n">
            /// Specifies the number of vertex array objects to be deleted.
            /// </param>
            /// <param name="arrays">[length: n]
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            [CLSCompliant(false)]
            public static unsafe void DeleteVertexArrays(Int32 n, [CountAttribute(Parameter = "n")] UInt32* arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose depth range to update.
            /// </param>
            /// <param name="count">
            /// Specifies the number of viewports whose depth range to update.
            /// </param>
            /// <param name="v">
            /// Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glDepthRangeArrayfvOES")]
            [CLSCompliant(false)]
            public static void DepthRangeArray(Int32 first, Int32 count, Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose depth range to update.
            /// </param>
            /// <param name="count">
            /// Specifies the number of viewports whose depth range to update.
            /// </param>
            /// <param name="v">
            /// Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glDepthRangeArrayfvOES")]
            [CLSCompliant(false)]
            public static void DepthRangeArray(Int32 first, Int32 count, ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose depth range to update.
            /// </param>
            /// <param name="count">
            /// Specifies the number of viewports whose depth range to update.
            /// </param>
            /// <param name="v">
            /// Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glDepthRangeArrayfvOES")]
            [CLSCompliant(false)]
            public static unsafe void DepthRangeArray(Int32 first, Int32 count, Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose depth range to update.
            /// </param>
            /// <param name="count">
            /// Specifies the number of viewports whose depth range to update.
            /// </param>
            /// <param name="v">
            /// Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glDepthRangeArrayfvOES")]
            [CLSCompliant(false)]
            public static void DepthRangeArray(UInt32 first, Int32 count, Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose depth range to update.
            /// </param>
            /// <param name="count">
            /// Specifies the number of viewports whose depth range to update.
            /// </param>
            /// <param name="v">
            /// Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glDepthRangeArrayfvOES")]
            [CLSCompliant(false)]
            public static void DepthRangeArray(UInt32 first, Int32 count, ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose depth range to update.
            /// </param>
            /// <param name="count">
            /// Specifies the number of viewports whose depth range to update.
            /// </param>
            /// <param name="v">
            /// Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glDepthRangeArrayfvOES")]
            [CLSCompliant(false)]
            public static unsafe void DepthRangeArray(UInt32 first, Int32 count, Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose depth range to update.
            /// </param>
            /// <param name="n">
            /// Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
            /// </param>
            /// <param name="f">
            /// Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glDepthRangeIndexedfOES")]
            [CLSCompliant(false)]
            public static void DepthRangeIndexed(Int32 index, Single n, Single f) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose depth range to update.
            /// </param>
            /// <param name="n">
            /// Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
            /// </param>
            /// <param name="f">
            /// Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glDepthRangeIndexedfOES")]
            [CLSCompliant(false)]
            public static void DepthRangeIndexed(UInt32 index, Single n, Single f) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed|OES_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed|OES_viewport_array", Version = "", EntryPoint = "glDisableiOES")]
            [CLSCompliant(false)]
            public static void Disable(OpenTK.Graphics.ES31.All target, Int32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed|OES_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed|OES_viewport_array", Version = "", EntryPoint = "glDisableiOES")]
            [CLSCompliant(false)]
            public static void Disable(OpenTK.Graphics.ES31.All target, UInt32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexOES")]
            public static void DrawElementsBaseVertex(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexOES")]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexOES")]
            public static void DrawElementsBaseVertex(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsBaseVertexOES")]
            public static void DrawElementsBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexOES")]
            public static void DrawElementsInstancedBaseVertex(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 instancecount, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexOES")]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.All mode, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexOES")]
            public static void DrawElementsInstancedBaseVertex(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 instancecount, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[] indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,] indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T3[,,] indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render multiple instances of a set of primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="instancecount">
            /// Specifies the number of instances of the indexed geometry that should be drawn.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawElementsInstancedBaseVertexOES")]
            public static void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T3 indices, Int32 instancecount, Int32 basevertex)
                where T3 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T5 indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T5 indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T5 indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] T5[,,] indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_elements_base_vertex]
            /// Render primitives from array data with a per-element offset
            /// </summary>
            /// <param name="mode">
            /// Specifies what kind of primitives to render. Symbolic constants Points, LineStrip, LineLoop, Lines, TriangleStrip, TriangleFan, Triangles, LinesAdjacency, LineStripAdjacency, TrianglesAdjacency, TriangleStripAdjacency and Patches are accepted.
            /// </param>
            /// <param name="start">
            /// Specifies the minimum array index contained in indices.
            /// </param>
            /// <param name="end">
            /// Specifies the maximum array index contained in indices.
            /// </param>
            /// <param name="count">
            /// Specifies the number of elements to be rendered.
            /// </param>
            /// <param name="type">
            /// Specifies the type of the values in indices. Must be one of UnsignedByte, UnsignedShort, or UnsignedInt.
            /// </param>
            /// <param name="indices">[length: COMPSIZE(count,type)]
            /// Specifies a pointer to the location where the indices are stored.
            /// </param>
            /// <param name="basevertex">
            /// Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.
            /// </param>
            [AutoGenerated(Category = "OES_draw_elements_base_vertex", Version = "", EntryPoint = "glDrawRangeElementsBaseVertexOES")]
            [CLSCompliant(false)]
            public static void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.ES31.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES31.DrawElementsType type, [InAttribute, OutAttribute, CountAttribute(Computed = "count,type")] ref T5 indices, Int32 basevertex)
                where T5 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_EGL_image]</summary>
            /// <param name="target"></param>
            /// <param name="image"></param>
            [AutoGenerated(Category = "OES_EGL_image", Version = "", EntryPoint = "glEGLImageTargetRenderbufferStorageOES")]
            public static void EGLImageTargetRenderbufferStorage(OpenTK.Graphics.ES31.All target, IntPtr image) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_EGL_image]</summary>
            /// <param name="target"></param>
            /// <param name="image"></param>
            [AutoGenerated(Category = "OES_EGL_image", Version = "", EntryPoint = "glEGLImageTargetTexture2DOES")]
            public static void EGLImageTargetTexture2D(OpenTK.Graphics.ES31.All target, IntPtr image) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed|OES_viewport_array]
            /// Enable or disable server-side GL capabilities
            /// </summary>
            /// <param name="target">
            /// Specifies a symbolic constant indicating a GL capability.
            /// </param>
            /// <param name="index"></param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed|OES_viewport_array", Version = "", EntryPoint = "glEnableiOES")]
            [CLSCompliant(false)]
            public static void Enable(OpenTK.Graphics.ES31.All target, Int32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed|OES_viewport_array]
            /// Enable or disable server-side GL capabilities
            /// </summary>
            /// <param name="target">
            /// Specifies a symbolic constant indicating a GL capability.
            /// </param>
            /// <param name="index"></param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed|OES_viewport_array", Version = "", EntryPoint = "glEnableiOES")]
            [CLSCompliant(false)]
            public static void Enable(OpenTK.Graphics.ES31.All target, UInt32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="textarget"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="zoffset"></param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glFramebufferTexture3DOES")]
            [CLSCompliant(false)]
            public static void FramebufferTexture3D(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All textarget, Int32 texture, Int32 level, Int32 zoffset) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="textarget"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="zoffset"></param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glFramebufferTexture3DOES")]
            [CLSCompliant(false)]
            public static void FramebufferTexture3D(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, OpenTK.Graphics.ES31.All textarget, UInt32 texture, Int32 level, Int32 zoffset) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_geometry_shader]
            /// Attach a level of a texture object as a logical buffer to the currently bound framebuffer object
            /// </summary>
            /// <param name="target">
            /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
            /// </param>
            /// <param name="attachment">
            /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachment.
            /// </param>
            /// <param name="texture">
            /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
            /// </param>
            /// <param name="level">
            /// Specifies the mipmap level of texture to attach.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_geometry_shader", Version = "", EntryPoint = "glFramebufferTextureOES")]
            [CLSCompliant(false)]
            public static void FramebufferTexture(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, Int32 texture, Int32 level) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_geometry_shader]
            /// Attach a level of a texture object as a logical buffer to the currently bound framebuffer object
            /// </summary>
            /// <param name="target">
            /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
            /// </param>
            /// <param name="attachment">
            /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachment.
            /// </param>
            /// <param name="texture">
            /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
            /// </param>
            /// <param name="level">
            /// Specifies the mipmap level of texture to attach.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_geometry_shader", Version = "", EntryPoint = "glFramebufferTextureOES")]
            [CLSCompliant(false)]
            public static void FramebufferTexture(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, UInt32 texture, Int32 level) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_geometry_shader]
            /// Attach a level of a texture object as a logical buffer to the currently bound framebuffer object
            /// </summary>
            /// <param name="target">
            /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
            /// </param>
            /// <param name="attachment">
            /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachment.
            /// </param>
            /// <param name="texture">
            /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
            /// </param>
            /// <param name="level">
            /// Specifies the mipmap level of texture to attach.
            /// </param>
            [AutoGenerated(Category = "OES_geometry_shader", Version = "", EntryPoint = "glFramebufferTextureOES")]
            [CLSCompliant(false)]
            public static void FramebufferTexture(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, Int32 texture, Int32 level) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_geometry_shader]
            /// Attach a level of a texture object as a logical buffer to the currently bound framebuffer object
            /// </summary>
            /// <param name="target">
            /// Specifies the framebuffer target. target must be DrawFramebuffer, ReadFramebuffer, or Framebuffer. Framebuffer is equivalent to DrawFramebuffer.
            /// </param>
            /// <param name="attachment">
            /// Specifies the attachment point of the framebuffer. attachment must be ColorAttachmenti, DepthAttachment, StencilAttachment or DepthStencilAttachment.
            /// </param>
            /// <param name="texture">
            /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
            /// </param>
            /// <param name="level">
            /// Specifies the mipmap level of texture to attach.
            /// </param>
            [AutoGenerated(Category = "OES_geometry_shader", Version = "", EntryPoint = "glFramebufferTextureOES")]
            [CLSCompliant(false)]
            public static void FramebufferTexture(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, UInt32 texture, Int32 level) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Generate vertex array object names
            /// </summary>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            [CLSCompliant(false)]
            public static Int32 GenVertexArray() { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Generate vertex array object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of vertex array object names to generate.
            /// </param>
            /// <param name="arrays">[length: n]
            /// Specifies an array in which the generated vertex array object names are stored.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            [CLSCompliant(false)]
            public static void GenVertexArrays(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32[] arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Generate vertex array object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of vertex array object names to generate.
            /// </param>
            /// <param name="arrays">[length: n]
            /// Specifies an array in which the generated vertex array object names are stored.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            [CLSCompliant(false)]
            public static void GenVertexArrays(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out Int32 arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Generate vertex array object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of vertex array object names to generate.
            /// </param>
            /// <param name="arrays">[length: n]
            /// Specifies an array in which the generated vertex array object names are stored.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            [CLSCompliant(false)]
            public static unsafe void GenVertexArrays(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] Int32* arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Generate vertex array object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of vertex array object names to generate.
            /// </param>
            /// <param name="arrays">[length: n]
            /// Specifies an array in which the generated vertex array object names are stored.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            [CLSCompliant(false)]
            public static void GenVertexArrays(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32[] arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Generate vertex array object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of vertex array object names to generate.
            /// </param>
            /// <param name="arrays">[length: n]
            /// Specifies an array in which the generated vertex array object names are stored.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            [CLSCompliant(false)]
            public static void GenVertexArrays(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] out UInt32 arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Generate vertex array object names
            /// </summary>
            /// <param name="n">
            /// Specifies the number of vertex array object names to generate.
            /// </param>
            /// <param name="arrays">[length: n]
            /// Specifies an array in which the generated vertex array object names are stored.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            [CLSCompliant(false)]
            public static unsafe void GenVertexArrays(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* arrays) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_mapbuffer]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            public static void GetBufferPointer(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute] IntPtr @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_mapbuffer]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            [CLSCompliant(false)]
            public static void GetBufferPointer<T2>(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute] T2[] @params)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_mapbuffer]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            [CLSCompliant(false)]
            public static void GetBufferPointer<T2>(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute] T2[,] @params)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_mapbuffer]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            [CLSCompliant(false)]
            public static void GetBufferPointer<T2>(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute] T2[,,] @params)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_mapbuffer]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            public static void GetBufferPointer<T2>(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [InAttribute, OutAttribute] ref T2 @params)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glGetFloati_vOES")]
            [CLSCompliant(false)]
            public static void GetFloat(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] Single[] data) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glGetFloati_vOES")]
            [CLSCompliant(false)]
            public static void GetFloat(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] out Single data) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glGetFloati_vOES")]
            [CLSCompliant(false)]
            public static unsafe void GetFloat(OpenTK.Graphics.ES31.All target, Int32 index, [OutAttribute, CountAttribute(Computed = "target")] Single* data) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glGetFloati_vOES")]
            [CLSCompliant(false)]
            public static void GetFloat(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Single[] data) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glGetFloati_vOES")]
            [CLSCompliant(false)]
            public static void GetFloat(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] out Single data) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]</summary>
            /// <param name="target"></param>
            /// <param name="index"></param>
            /// <param name="data">[length: COMPSIZE(target)]</param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glGetFloati_vOES")]
            [CLSCompliant(false)]
            public static unsafe void GetFloat(OpenTK.Graphics.ES31.All target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Single* data) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All[] binaryFormat, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr binary) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All[] binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All[] binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All[] binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,,] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All[] binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] ref T4 binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr binary) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,,] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] ref T4 binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramBinary(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr binary) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,,] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] ref T4 binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All[] binaryFormat, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr binary) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All[] binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All[] binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All[] binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,,] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32[] length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All[] binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] ref T4 binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr binary) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,,] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] out Int32 length, [OutAttribute, CountAttribute(Count = 1)] out OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] ref T4 binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramBinary(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr binary) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] T4[,,] binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </param>
            /// <param name="bufSize">
            /// Specifies the size of the buffer whose address is given by binary.
            /// </param>
            /// <param name="length">[length: 1]
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </param>
            /// <param name="binaryFormat">[length: 1]
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </param>
            /// <param name="binary">[length: bufSize]
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            [CLSCompliant(false)]
            public static unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] OpenTK.Graphics.ES31.All* binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "bufSize")] ref T4 binary)
                where T4 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIivOES")]
            [CLSCompliant(false)]
            public static void GetSamplerParameterI(Int32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIivOES")]
            [CLSCompliant(false)]
            public static void GetSamplerParameterI(Int32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIivOES")]
            [CLSCompliant(false)]
            public static unsafe void GetSamplerParameterI(Int32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIivOES")]
            [CLSCompliant(false)]
            public static void GetSamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIivOES")]
            [CLSCompliant(false)]
            public static void GetSamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIivOES")]
            [CLSCompliant(false)]
            public static unsafe void GetSamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIuivOES")]
            [CLSCompliant(false)]
            public static void GetSamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIuivOES")]
            [CLSCompliant(false)]
            public static void GetSamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out UInt32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetSamplerParameterIuivOES")]
            [CLSCompliant(false)]
            public static unsafe void GetSamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIivOES")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIivOES")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIivOES")]
            [CLSCompliant(false)]
            public static unsafe void GetTexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIivOES")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIivOES")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIivOES")]
            [CLSCompliant(false)]
            public static unsafe void GetTexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIuivOES")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIuivOES")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] out UInt32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIuivOES")]
            [CLSCompliant(false)]
            public static unsafe void GetTexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIuivOES")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIuivOES")]
            [CLSCompliant(false)]
            public static void GetTexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] out UInt32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glGetTexParameterIuivOES")]
            [CLSCompliant(false)]
            public static unsafe void GetTexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.GetTextureParameter pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed|OES_viewport_array]
            /// Test whether a capability is enabled
            /// </summary>
            /// <param name="target">
            /// Specifies a symbolic constant indicating a GL capability.
            /// </param>
            /// <param name="index">
            /// Specifies the index of the capability.
            /// </param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed|OES_viewport_array", Version = "", EntryPoint = "glIsEnablediOES")]
            [CLSCompliant(false)]
            public static bool IsEnabled(OpenTK.Graphics.ES31.All target, Int32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_draw_buffers_indexed|OES_viewport_array]
            /// Test whether a capability is enabled
            /// </summary>
            /// <param name="target">
            /// Specifies a symbolic constant indicating a GL capability.
            /// </param>
            /// <param name="index">
            /// Specifies the index of the capability.
            /// </param>
            [AutoGenerated(Category = "OES_draw_buffers_indexed|OES_viewport_array", Version = "", EntryPoint = "glIsEnablediOES")]
            [CLSCompliant(false)]
            public static bool IsEnabled(OpenTK.Graphics.ES31.All target, UInt32 index) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Determine if a name corresponds to a vertex array object
            /// </summary>
            /// <param name="array">
            /// Specifies a value that may be the name of a vertex array object.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glIsVertexArrayOES")]
            [CLSCompliant(false)]
            public static bool IsVertexArray(Int32 array) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_vertex_array_object]
            /// Determine if a name corresponds to a vertex array object
            /// </summary>
            /// <param name="array">
            /// Specifies a value that may be the name of a vertex array object.
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glIsVertexArrayOES")]
            [CLSCompliant(false)]
            public static bool IsVertexArray(UInt32 array) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_mapbuffer]
            /// Map a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// Specifies the target buffer object being mapped. The symbolic constant must be ArrayBuffer, AtomicCounterBuffer, CopyReadBuffer, CopyWriteBuffer, DrawIndirectBuffer, DispatchIndirectBuffer, ElementArrayBuffer, PixelPackBuffer, PixelUnpackBuffer, QueryBuffer, ShaderStorageBuffer, TextureBuffer, TransformFeedbackBuffer or UniformBuffer.
            /// </param>
            /// <param name="access">
            /// For glMapBuffer only, specifies the access policy, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be ReadOnly, WriteOnly, or ReadWrite.
            /// </param>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glMapBufferOES")]
            public static IntPtr MapBuffer(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All access) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_sample_shading]
            /// Specifies minimum rate at which sample shaing takes place
            /// </summary>
            /// <param name="value">
            /// Specifies the rate at which samples are shaded within each covered pixel.
            /// </param>
            [AutoGenerated(Category = "OES_sample_shading", Version = "", EntryPoint = "glMinSampleShadingOES")]
            public static void MinSampleShading(Single value) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_tessellation_shader]
            /// Specifies the parameters for patch primitives
            /// </summary>
            /// <param name="pname">
            /// Specifies the name of the parameter to set. The symbolc constants PatchVertices, PatchDefaultOuterLevel, and PatchDefaultInnerLevel are accepted.
            /// </param>
            /// <param name="value">
            /// Specifies the new value for the parameter given by pname.
            /// </param>
            [AutoGenerated(Category = "OES_tessellation_shader", Version = "", EntryPoint = "glPatchParameteriOES")]
            public static void PatchParameter(OpenTK.Graphics.ES31.All pname, Int32 value) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_primitive_bounding_box]</summary>
            /// <param name="minX"></param>
            /// <param name="minY"></param>
            /// <param name="minZ"></param>
            /// <param name="minW"></param>
            /// <param name="maxX"></param>
            /// <param name="maxY"></param>
            /// <param name="maxZ"></param>
            /// <param name="maxW"></param>
            [AutoGenerated(Category = "OES_primitive_bounding_box", Version = "", EntryPoint = "glPrimitiveBoundingBoxOES")]
            public static void PrimitiveBoundingBox(Single minX, Single minY, Single minZ, Single minW, Single maxX, Single maxY, Single maxZ, Single maxW) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object into which to load a program binary.
            /// </param>
            /// <param name="binaryFormat">
            /// Specifies the format of the binary data in binary.
            /// </param>
            /// <param name="binary">[length: length]
            /// Specifies the address of an array containing the binary to be loaded into program.
            /// </param>
            /// <param name="length">
            /// Specifies the number of bytes contained in binary.
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void ProgramBinary(Int32 program, OpenTK.Graphics.ES31.All binaryFormat, [CountAttribute(Parameter = "length")] IntPtr binary, Int32 length) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object into which to load a program binary.
            /// </param>
            /// <param name="binaryFormat">
            /// Specifies the format of the binary data in binary.
            /// </param>
            /// <param name="binary">[length: length]
            /// Specifies the address of an array containing the binary to be loaded into program.
            /// </param>
            /// <param name="length">
            /// Specifies the number of bytes contained in binary.
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T2[] binary, Int32 length)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object into which to load a program binary.
            /// </param>
            /// <param name="binaryFormat">
            /// Specifies the format of the binary data in binary.
            /// </param>
            /// <param name="binary">[length: length]
            /// Specifies the address of an array containing the binary to be loaded into program.
            /// </param>
            /// <param name="length">
            /// Specifies the number of bytes contained in binary.
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T2[,] binary, Int32 length)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object into which to load a program binary.
            /// </param>
            /// <param name="binaryFormat">
            /// Specifies the format of the binary data in binary.
            /// </param>
            /// <param name="binary">[length: length]
            /// Specifies the address of an array containing the binary to be loaded into program.
            /// </param>
            /// <param name="length">
            /// Specifies the number of bytes contained in binary.
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T2[,,] binary, Int32 length)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object into which to load a program binary.
            /// </param>
            /// <param name="binaryFormat">
            /// Specifies the format of the binary data in binary.
            /// </param>
            /// <param name="binary">[length: length]
            /// Specifies the address of an array containing the binary to be loaded into program.
            /// </param>
            /// <param name="length">
            /// Specifies the number of bytes contained in binary.
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] ref T2 binary, Int32 length)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object into which to load a program binary.
            /// </param>
            /// <param name="binaryFormat">
            /// Specifies the format of the binary data in binary.
            /// </param>
            /// <param name="binary">[length: length]
            /// Specifies the address of an array containing the binary to be loaded into program.
            /// </param>
            /// <param name="length">
            /// Specifies the number of bytes contained in binary.
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void ProgramBinary(UInt32 program, OpenTK.Graphics.ES31.All binaryFormat, [CountAttribute(Parameter = "length")] IntPtr binary, Int32 length) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object into which to load a program binary.
            /// </param>
            /// <param name="binaryFormat">
            /// Specifies the format of the binary data in binary.
            /// </param>
            /// <param name="binary">[length: length]
            /// Specifies the address of an array containing the binary to be loaded into program.
            /// </param>
            /// <param name="length">
            /// Specifies the number of bytes contained in binary.
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T2[] binary, Int32 length)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object into which to load a program binary.
            /// </param>
            /// <param name="binaryFormat">
            /// Specifies the format of the binary data in binary.
            /// </param>
            /// <param name="binary">[length: length]
            /// Specifies the address of an array containing the binary to be loaded into program.
            /// </param>
            /// <param name="length">
            /// Specifies the number of bytes contained in binary.
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T2[,] binary, Int32 length)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object into which to load a program binary.
            /// </param>
            /// <param name="binaryFormat">
            /// Specifies the format of the binary data in binary.
            /// </param>
            /// <param name="binary">[length: length]
            /// Specifies the address of an array containing the binary to be loaded into program.
            /// </param>
            /// <param name="length">
            /// Specifies the number of bytes contained in binary.
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] T2[,,] binary, Int32 length)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// Specifies the name of a program object into which to load a program binary.
            /// </param>
            /// <param name="binaryFormat">
            /// Specifies the format of the binary data in binary.
            /// </param>
            /// <param name="binary">[length: length]
            /// Specifies the address of an array containing the binary to be loaded into program.
            /// </param>
            /// <param name="length">
            /// Specifies the number of bytes contained in binary.
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            [CLSCompliant(false)]
            public static void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES31.All binaryFormat, [InAttribute, OutAttribute, CountAttribute(Parameter = "length")] ref T2 binary, Int32 length)
                where T2 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIivOES")]
            [CLSCompliant(false)]
            public static void SamplerParameterI(Int32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32[] param) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIivOES")]
            [CLSCompliant(false)]
            public static void SamplerParameterI(Int32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] ref Int32 param) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIivOES")]
            [CLSCompliant(false)]
            public static unsafe void SamplerParameterI(Int32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32* param) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIivOES")]
            [CLSCompliant(false)]
            public static void SamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32[] param) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIivOES")]
            [CLSCompliant(false)]
            public static void SamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] ref Int32 param) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIivOES")]
            [CLSCompliant(false)]
            public static unsafe void SamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32* param) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIuivOES")]
            [CLSCompliant(false)]
            public static void SamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] UInt32[] param) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIuivOES")]
            [CLSCompliant(false)]
            public static void SamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] ref UInt32 param) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="sampler"></param>
            /// <param name="pname"></param>
            /// <param name="param">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glSamplerParameterIuivOES")]
            [CLSCompliant(false)]
            public static unsafe void SamplerParameterI(UInt32 sampler, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] UInt32* param) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose scissor box to modify.
            /// </param>
            /// <param name="count">
            /// Specifies the number of scissor boxes to modify.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorArrayvOES")]
            [CLSCompliant(false)]
            public static void ScissorArray(Int32 first, Int32 count, [CountAttribute(Computed = "count")] Int32[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose scissor box to modify.
            /// </param>
            /// <param name="count">
            /// Specifies the number of scissor boxes to modify.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorArrayvOES")]
            [CLSCompliant(false)]
            public static void ScissorArray(Int32 first, Int32 count, [CountAttribute(Computed = "count")] ref Int32 v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose scissor box to modify.
            /// </param>
            /// <param name="count">
            /// Specifies the number of scissor boxes to modify.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorArrayvOES")]
            [CLSCompliant(false)]
            public static unsafe void ScissorArray(Int32 first, Int32 count, [CountAttribute(Computed = "count")] Int32* v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose scissor box to modify.
            /// </param>
            /// <param name="count">
            /// Specifies the number of scissor boxes to modify.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorArrayvOES")]
            [CLSCompliant(false)]
            public static void ScissorArray(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] Int32[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose scissor box to modify.
            /// </param>
            /// <param name="count">
            /// Specifies the number of scissor boxes to modify.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorArrayvOES")]
            [CLSCompliant(false)]
            public static void ScissorArray(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] ref Int32 v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specifies the index of the first viewport whose scissor box to modify.
            /// </param>
            /// <param name="count">
            /// Specifies the number of scissor boxes to modify.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorArrayvOES")]
            [CLSCompliant(false)]
            public static unsafe void ScissorArray(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] Int32* v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="left">
            /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
            /// </param>
            /// <param name="bottom">
            /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
            /// </param>
            /// <param name="width">
            /// Specify ths dimensions of the scissor box, in pixels.
            /// </param>
            /// <param name="height">
            /// Specify ths dimensions of the scissor box, in pixels.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorIndexedOES")]
            [CLSCompliant(false)]
            public static void ScissorIndexed(Int32 index, Int32 left, Int32 bottom, Int32 width, Int32 height) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="left">
            /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
            /// </param>
            /// <param name="bottom">
            /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
            /// </param>
            /// <param name="width">
            /// Specify ths dimensions of the scissor box, in pixels.
            /// </param>
            /// <param name="height">
            /// Specify ths dimensions of the scissor box, in pixels.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorIndexedOES")]
            [CLSCompliant(false)]
            public static void ScissorIndexed(UInt32 index, Int32 left, Int32 bottom, Int32 width, Int32 height) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorIndexedvOES")]
            [CLSCompliant(false)]
            public static void ScissorIndexed(Int32 index, [CountAttribute(Count = 4)] Int32[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorIndexedvOES")]
            [CLSCompliant(false)]
            public static void ScissorIndexed(Int32 index, [CountAttribute(Count = 4)] ref Int32 v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorIndexedvOES")]
            [CLSCompliant(false)]
            public static unsafe void ScissorIndexed(Int32 index, [CountAttribute(Count = 4)] Int32* v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorIndexedvOES")]
            [CLSCompliant(false)]
            public static void ScissorIndexed(UInt32 index, [CountAttribute(Count = 4)] Int32[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorIndexedvOES")]
            [CLSCompliant(false)]
            public static void ScissorIndexed(UInt32 index, [CountAttribute(Count = 4)] ref Int32 v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Define the scissor box for a specific viewport
            /// </summary>
            /// <param name="index">
            /// Specifies the index of the viewport whose scissor box to modify.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glScissorIndexedvOES")]
            [CLSCompliant(false)]
            public static unsafe void ScissorIndexed(UInt32 index, [CountAttribute(Count = 4)] Int32* v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_buffer]
            /// Attach the storage for a buffer object to the active buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_buffer", Version = "", EntryPoint = "glTexBufferOES")]
            [CLSCompliant(false)]
            public static void TexBuffer(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, Int32 buffer) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_buffer]
            /// Attach the storage for a buffer object to the active buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_buffer", Version = "", EntryPoint = "glTexBufferOES")]
            [CLSCompliant(false)]
            public static void TexBuffer(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, UInt32 buffer) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_buffer]
            /// Attach the storage for a buffer object to the active buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            [AutoGenerated(Category = "OES_texture_buffer", Version = "", EntryPoint = "glTexBufferOES")]
            [CLSCompliant(false)]
            public static void TexBuffer(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.All internalformat, Int32 buffer) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_buffer]
            /// Attach the storage for a buffer object to the active buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            [AutoGenerated(Category = "OES_texture_buffer", Version = "", EntryPoint = "glTexBufferOES")]
            [CLSCompliant(false)]
            public static void TexBuffer(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.All internalformat, UInt32 buffer) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_buffer]
            /// Bind a range of a buffer's data store to a buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            /// <param name="offset">
            /// Specifies the offset of the start of the range of the buffer's data store to attach.
            /// </param>
            /// <param name="size">
            /// Specifies the size of the range of the buffer's data store to attach.
            /// </param>
            [AutoGenerated(Category = "OES_texture_buffer", Version = "", EntryPoint = "glTexBufferRangeOES")]
            [CLSCompliant(false)]
            public static void TexBufferRange(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, Int32 buffer, IntPtr offset, Int32 size) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_buffer]
            /// Bind a range of a buffer's data store to a buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            /// <param name="offset">
            /// Specifies the offset of the start of the range of the buffer's data store to attach.
            /// </param>
            /// <param name="size">
            /// Specifies the size of the range of the buffer's data store to attach.
            /// </param>
            [AutoGenerated(Category = "OES_texture_buffer", Version = "", EntryPoint = "glTexBufferRangeOES")]
            [CLSCompliant(false)]
            public static void TexBufferRange(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, Int32 buffer, IntPtr offset, IntPtr size) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_buffer]
            /// Bind a range of a buffer's data store to a buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            /// <param name="offset">
            /// Specifies the offset of the start of the range of the buffer's data store to attach.
            /// </param>
            /// <param name="size">
            /// Specifies the size of the range of the buffer's data store to attach.
            /// </param>
            [AutoGenerated(Category = "OES_texture_buffer", Version = "", EntryPoint = "glTexBufferRangeOES")]
            [CLSCompliant(false)]
            public static void TexBufferRange(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, UInt32 buffer, IntPtr offset, Int32 size) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_buffer]
            /// Bind a range of a buffer's data store to a buffer texture
            /// </summary>
            /// <param name="target">
            /// Specifies the target of the operation and must be TextureBuffer.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format of the data in the store belonging to buffer.
            /// </param>
            /// <param name="buffer">
            /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
            /// </param>
            /// <param name="offset">
            /// Specifies the offset of the start of the range of the buffer's data store to attach.
            /// </param>
            /// <param name="size">
            /// Specifies the size of the range of the buffer's data store to attach.
            /// </param>
            [AutoGenerated(Category = "OES_texture_buffer", Version = "", EntryPoint = "glTexBufferRangeOES")]
            [CLSCompliant(false)]
            public static void TexBufferRange(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All internalformat, UInt32 buffer, IntPtr offset, IntPtr size) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </param>
            /// <param name="border">
            /// This value must be 0.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
            /// </param>
            /// <param name="type">
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
            /// </param>
            /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
            /// Specifies a pointer to the image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            public static void TexImage3D(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "format,type,width,height,depth")] IntPtr pixels) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </param>
            /// <param name="border">
            /// This value must be 0.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
            /// </param>
            /// <param name="type">
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
            /// </param>
            /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
            /// Specifies a pointer to the image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            [CLSCompliant(false)]
            public static void TexImage3D<T9>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T9[] pixels)
                where T9 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </param>
            /// <param name="border">
            /// This value must be 0.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
            /// </param>
            /// <param name="type">
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
            /// </param>
            /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
            /// Specifies a pointer to the image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            [CLSCompliant(false)]
            public static void TexImage3D<T9>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T9[,] pixels)
                where T9 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </param>
            /// <param name="border">
            /// This value must be 0.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
            /// </param>
            /// <param name="type">
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
            /// </param>
            /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
            /// Specifies a pointer to the image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            [CLSCompliant(false)]
            public static void TexImage3D<T9>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T9[,,] pixels)
                where T9 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be one of Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level  is the n sup th mipmap reduction image.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, or one of the sized internal formats given in Table 2, below.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 256 texels wide.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </param>
            /// <param name="border">
            /// This value must be 0.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha,
            /// </param>
            /// <param name="type">
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
            /// </param>
            /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
            /// Specifies a pointer to the image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            public static void TexImage3D<T9>(OpenTK.Graphics.ES31.All target, Int32 level, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] ref T9 pixels)
                where T9 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIivOES")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIivOES")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] ref Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIivOES")]
            [CLSCompliant(false)]
            public static unsafe void TexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIivOES")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIivOES")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] ref Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIivOES")]
            [CLSCompliant(false)]
            public static unsafe void TexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIuivOES")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] UInt32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIuivOES")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] ref UInt32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIuivOES")]
            [CLSCompliant(false)]
            public static unsafe void TexParameterI(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, [CountAttribute(Computed = "pname")] UInt32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIuivOES")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] UInt32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIuivOES")]
            [CLSCompliant(false)]
            public static void TexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] ref UInt32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_border_clamp]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="@params">[length: COMPSIZE(pname)]</param>
            [AutoGenerated(Category = "OES_texture_border_clamp", Version = "", EntryPoint = "glTexParameterIuivOES")]
            [CLSCompliant(false)]
            public static unsafe void TexParameterI(OpenTK.Graphics.ES31.TextureTarget target, OpenTK.Graphics.ES31.TextureParameterName pname, [CountAttribute(Computed = "pname")] UInt32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_storage_multisample_2d_array]
            /// Specify storage for a two-dimensional multisample array texture
            /// </summary>
            /// <param name="target">
            /// Specify the target of the operation. target must be Texture2DMultisampleArray or ProxyTexture2DMultisampleMultisample.
            /// </param>
            /// <param name="samples">
            /// Specify the number of samples in the texture.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the sized internal format to be used to store texture image data.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture, in texels.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture, in texels.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture, in layers.
            /// </param>
            /// <param name="fixedsamplelocations">
            /// Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
            /// </param>
            [AutoGenerated(Category = "OES_texture_storage_multisample_2d_array", Version = "", EntryPoint = "glTexStorage3DMultisampleOES")]
            public static void TexStorage3DMultisample(OpenTK.Graphics.ES31.All target, Int32 samples, OpenTK.Graphics.ES31.All internalformat, Int32 width, Int32 height, Int32 depth, bool fixedsamplelocations) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="xoffset">
            /// Specifies a texel offset in the x direction within the texture array.
            /// </param>
            /// <param name="yoffset">
            /// Specifies a texel offset in the y direction within the texture array.
            /// </param>
            /// <param name="zoffset">
            /// Specifies a texel offset in the z direction within the texture array.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture subimage.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture subimage.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture subimage.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
            /// </param>
            /// <param name="type">
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
            /// </param>
            /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
            /// Specifies a pointer to the image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            public static void TexSubImage3D(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [CountAttribute(Computed = "format,type,width,height,depth")] IntPtr pixels) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="xoffset">
            /// Specifies a texel offset in the x direction within the texture array.
            /// </param>
            /// <param name="yoffset">
            /// Specifies a texel offset in the y direction within the texture array.
            /// </param>
            /// <param name="zoffset">
            /// Specifies a texel offset in the z direction within the texture array.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture subimage.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture subimage.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture subimage.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
            /// </param>
            /// <param name="type">
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
            /// </param>
            /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
            /// Specifies a pointer to the image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            [CLSCompliant(false)]
            public static void TexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T10[] pixels)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="xoffset">
            /// Specifies a texel offset in the x direction within the texture array.
            /// </param>
            /// <param name="yoffset">
            /// Specifies a texel offset in the y direction within the texture array.
            /// </param>
            /// <param name="zoffset">
            /// Specifies a texel offset in the z direction within the texture array.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture subimage.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture subimage.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture subimage.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
            /// </param>
            /// <param name="type">
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
            /// </param>
            /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
            /// Specifies a pointer to the image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            [CLSCompliant(false)]
            public static void TexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T10[,] pixels)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="xoffset">
            /// Specifies a texel offset in the x direction within the texture array.
            /// </param>
            /// <param name="yoffset">
            /// Specifies a texel offset in the y direction within the texture array.
            /// </param>
            /// <param name="zoffset">
            /// Specifies a texel offset in the z direction within the texture array.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture subimage.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture subimage.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture subimage.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
            /// </param>
            /// <param name="type">
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
            /// </param>
            /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
            /// Specifies a pointer to the image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            [CLSCompliant(false)]
            public static void TexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] T10[,,] pixels)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// Specifies the target texture. Must be Texture3D or Texture2DArray.
            /// </param>
            /// <param name="level">
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </param>
            /// <param name="xoffset">
            /// Specifies a texel offset in the x direction within the texture array.
            /// </param>
            /// <param name="yoffset">
            /// Specifies a texel offset in the y direction within the texture array.
            /// </param>
            /// <param name="zoffset">
            /// Specifies a texel offset in the z direction within the texture array.
            /// </param>
            /// <param name="width">
            /// Specifies the width of the texture subimage.
            /// </param>
            /// <param name="height">
            /// Specifies the height of the texture subimage.
            /// </param>
            /// <param name="depth">
            /// Specifies the depth of the texture subimage.
            /// </param>
            /// <param name="format">
            /// Specifies the format of the pixel data. The following symbolic values are accepted: Red, RedInteger, Rg, RgInteger, Rgb, RgbInteger, Rgba, RgbaInteger, DepthComponent, DepthStencil, LuminanceAlpha, Luminance, and Alpha.
            /// </param>
            /// <param name="type">
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: UnsignedByte, Byte, UnsignedShort, Short, UnsignedInt, Int, HalfFloat, Float, UnsignedShort565, UnsignedShort4444, UnsignedShort5551, UnsignedInt2101010Rev, UnsignedInt10F11F11FRev, UnsignedInt5999Rev, UnsignedInt248, and Float32UnsignedInt248Rev.
            /// </param>
            /// <param name="pixels">[length: COMPSIZE(format,type,width,height,depth)]
            /// Specifies a pointer to the image data in memory.
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            public static void TexSubImage3D<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute, CountAttribute(Computed = "format,type,width,height,depth")] ref T10 pixels)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_view]
            /// Initialize a texture as a data alias of another texture's data store
            /// </summary>
            /// <param name="texture">
            /// Specifies the texture object to be initialized as a view.
            /// </param>
            /// <param name="target">
            /// Specifies the target to be used for the newly initialized texture.
            /// </param>
            /// <param name="origtexture">
            /// Specifies the name of a texture object of which to make a view.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format for the newly created view.
            /// </param>
            /// <param name="minlevel">
            /// Specifies lowest level of detail of the view.
            /// </param>
            /// <param name="numlevels">
            /// Specifies the number of levels of detail to include in the view.
            /// </param>
            /// <param name="minlayer">
            /// Specifies the index of the first layer to include in the view.
            /// </param>
            /// <param name="numlayers">
            /// Specifies the number of layers to include in the view.
            /// </param>
            [AutoGenerated(Category = "OES_texture_view", Version = "", EntryPoint = "glTextureViewOES")]
            [CLSCompliant(false)]
            public static void TextureView(Int32 texture, OpenTK.Graphics.ES31.All target, Int32 origtexture, OpenTK.Graphics.ES31.All internalformat, Int32 minlevel, Int32 numlevels, Int32 minlayer, Int32 numlayers) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_texture_view]
            /// Initialize a texture as a data alias of another texture's data store
            /// </summary>
            /// <param name="texture">
            /// Specifies the texture object to be initialized as a view.
            /// </param>
            /// <param name="target">
            /// Specifies the target to be used for the newly initialized texture.
            /// </param>
            /// <param name="origtexture">
            /// Specifies the name of a texture object of which to make a view.
            /// </param>
            /// <param name="internalformat">
            /// Specifies the internal format for the newly created view.
            /// </param>
            /// <param name="minlevel">
            /// Specifies lowest level of detail of the view.
            /// </param>
            /// <param name="numlevels">
            /// Specifies the number of levels of detail to include in the view.
            /// </param>
            /// <param name="minlayer">
            /// Specifies the index of the first layer to include in the view.
            /// </param>
            /// <param name="numlayers">
            /// Specifies the number of layers to include in the view.
            /// </param>
            [AutoGenerated(Category = "OES_texture_view", Version = "", EntryPoint = "glTextureViewOES")]
            [CLSCompliant(false)]
            public static void TextureView(UInt32 texture, OpenTK.Graphics.ES31.All target, UInt32 origtexture, OpenTK.Graphics.ES31.All internalformat, UInt32 minlevel, UInt32 numlevels, UInt32 minlayer, UInt32 numlayers) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_mapbuffer]</summary>
            /// <param name="target"></param>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glUnmapBufferOES")]
            public static bool UnmapBuffer(OpenTK.Graphics.ES31.All target) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="count">
            /// Specify the number of viewports to set.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specify the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportArrayvOES")]
            [CLSCompliant(false)]
            public static void ViewportArray(Int32 first, Int32 count, [CountAttribute(Computed = "count")] Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="count">
            /// Specify the number of viewports to set.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specify the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportArrayvOES")]
            [CLSCompliant(false)]
            public static void ViewportArray(Int32 first, Int32 count, [CountAttribute(Computed = "count")] ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="count">
            /// Specify the number of viewports to set.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specify the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportArrayvOES")]
            [CLSCompliant(false)]
            public static unsafe void ViewportArray(Int32 first, Int32 count, [CountAttribute(Computed = "count")] Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="count">
            /// Specify the number of viewports to set.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specify the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportArrayvOES")]
            [CLSCompliant(false)]
            public static void ViewportArray(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="count">
            /// Specify the number of viewports to set.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specify the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportArrayvOES")]
            [CLSCompliant(false)]
            public static void ViewportArray(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set multiple viewports
            /// </summary>
            /// <param name="first">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="count">
            /// Specify the number of viewports to set.
            /// </param>
            /// <param name="v">[length: COMPSIZE(count)]
            /// Specify the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportArrayvOES")]
            [CLSCompliant(false)]
            public static unsafe void ViewportArray(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="x">
            /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
            /// </param>
            /// <param name="y">
            /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
            /// </param>
            /// <param name="w">
            /// For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
            /// </param>
            /// <param name="h">
            /// For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportIndexedfOES")]
            [CLSCompliant(false)]
            public static void ViewportIndexed(Int32 index, Single x, Single y, Single w, Single h) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="x">
            /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
            /// </param>
            /// <param name="y">
            /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
            /// </param>
            /// <param name="w">
            /// For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
            /// </param>
            /// <param name="h">
            /// For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportIndexedfOES")]
            [CLSCompliant(false)]
            public static void ViewportIndexed(UInt32 index, Single x, Single y, Single w, Single h) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportIndexedfvOES")]
            [CLSCompliant(false)]
            public static void ViewportIndexed(Int32 index, [CountAttribute(Count = 4)] Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportIndexedfvOES")]
            [CLSCompliant(false)]
            public static void ViewportIndexed(Int32 index, [CountAttribute(Count = 4)] ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportIndexedfvOES")]
            [CLSCompliant(false)]
            public static unsafe void ViewportIndexed(Int32 index, [CountAttribute(Count = 4)] Single* v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportIndexedfvOES")]
            [CLSCompliant(false)]
            public static void ViewportIndexed(UInt32 index, [CountAttribute(Count = 4)] Single[] v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportIndexedfvOES")]
            [CLSCompliant(false)]
            public static void ViewportIndexed(UInt32 index, [CountAttribute(Count = 4)] ref Single v) { throw new NotImplementedException(); }

            /// <summary>[requires: OES_viewport_array]
            /// Set a specified viewport
            /// </summary>
            /// <param name="index">
            /// Specify the first viewport to set.
            /// </param>
            /// <param name="v">[length: 4]
            /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
            /// </param>
            [AutoGenerated(Category = "OES_viewport_array", Version = "", EntryPoint = "glViewportIndexedfvOES")]
            [CLSCompliant(false)]
            public static unsafe void ViewportIndexed(UInt32 index, [CountAttribute(Count = 4)] Single* v) { throw new NotImplementedException(); }

        }

        public static partial class Ovr
        {
            /// <summary>[requires: OVR_multiview_multisampled_render_to_texture]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="samples"></param>
            /// <param name="baseViewIndex"></param>
            /// <param name="numViews"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OVR_multiview_multisampled_render_to_texture", Version = "", EntryPoint = "glFramebufferTextureMultisampleMultiviewOVR")]
            [CLSCompliant(false)]
            public static void FramebufferTextureMultisampleMultiview(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, Int32 texture, Int32 level, Int32 samples, Int32 baseViewIndex, Int32 numViews) { throw new NotImplementedException(); }

            /// <summary>[requires: OVR_multiview_multisampled_render_to_texture]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="samples"></param>
            /// <param name="baseViewIndex"></param>
            /// <param name="numViews"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OVR_multiview_multisampled_render_to_texture", Version = "", EntryPoint = "glFramebufferTextureMultisampleMultiviewOVR")]
            [CLSCompliant(false)]
            public static void FramebufferTextureMultisampleMultiview(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, UInt32 texture, Int32 level, Int32 samples, Int32 baseViewIndex, Int32 numViews) { throw new NotImplementedException(); }

            /// <summary>[requires: OVR_multiview_multisampled_render_to_texture]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="samples"></param>
            /// <param name="baseViewIndex"></param>
            /// <param name="numViews"></param>
            [AutoGenerated(Category = "OVR_multiview_multisampled_render_to_texture", Version = "", EntryPoint = "glFramebufferTextureMultisampleMultiviewOVR")]
            [CLSCompliant(false)]
            public static void FramebufferTextureMultisampleMultiview(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, Int32 texture, Int32 level, Int32 samples, Int32 baseViewIndex, Int32 numViews) { throw new NotImplementedException(); }

            /// <summary>[requires: OVR_multiview_multisampled_render_to_texture]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="samples"></param>
            /// <param name="baseViewIndex"></param>
            /// <param name="numViews"></param>
            [AutoGenerated(Category = "OVR_multiview_multisampled_render_to_texture", Version = "", EntryPoint = "glFramebufferTextureMultisampleMultiviewOVR")]
            [CLSCompliant(false)]
            public static void FramebufferTextureMultisampleMultiview(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, UInt32 texture, Int32 level, Int32 samples, Int32 baseViewIndex, Int32 numViews) { throw new NotImplementedException(); }

            /// <summary>[requires: OVR_multiview]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="baseViewIndex"></param>
            /// <param name="numViews"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OVR_multiview", Version = "", EntryPoint = "glFramebufferTextureMultiviewOVR")]
            [CLSCompliant(false)]
            public static void FramebufferTextureMultiview(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, Int32 texture, Int32 level, Int32 baseViewIndex, Int32 numViews) { throw new NotImplementedException(); }

            /// <summary>[requires: OVR_multiview]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="baseViewIndex"></param>
            /// <param name="numViews"></param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OVR_multiview", Version = "", EntryPoint = "glFramebufferTextureMultiviewOVR")]
            [CLSCompliant(false)]
            public static void FramebufferTextureMultiview(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All attachment, UInt32 texture, Int32 level, Int32 baseViewIndex, Int32 numViews) { throw new NotImplementedException(); }

            /// <summary>[requires: OVR_multiview]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="baseViewIndex"></param>
            /// <param name="numViews"></param>
            [AutoGenerated(Category = "OVR_multiview", Version = "", EntryPoint = "glFramebufferTextureMultiviewOVR")]
            [CLSCompliant(false)]
            public static void FramebufferTextureMultiview(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, Int32 texture, Int32 level, Int32 baseViewIndex, Int32 numViews) { throw new NotImplementedException(); }

            /// <summary>[requires: OVR_multiview]</summary>
            /// <param name="target"></param>
            /// <param name="attachment"></param>
            /// <param name="texture"></param>
            /// <param name="level"></param>
            /// <param name="baseViewIndex"></param>
            /// <param name="numViews"></param>
            [AutoGenerated(Category = "OVR_multiview", Version = "", EntryPoint = "glFramebufferTextureMultiviewOVR")]
            [CLSCompliant(false)]
            public static void FramebufferTextureMultiview(OpenTK.Graphics.ES31.FramebufferTarget target, OpenTK.Graphics.ES31.FramebufferAttachment attachment, UInt32 texture, Int32 level, Int32 baseViewIndex, Int32 numViews) { throw new NotImplementedException(); }

        }

        public static partial class Qcom
        {
            /// <summary>[requires: QCOM_alpha_test]
            /// Specify the alpha test function
            /// </summary>
            /// <param name="func">
            /// Specifies the alpha comparison function. Symbolic constants Never, Less, Equal, Lequal, Greater, Notequal, Gequal, and Always are accepted. The initial value is Always.
            /// </param>
            /// <param name="@ref">
            /// Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range [0,1], where 0 represents the lowest possible alpha value and 1 the highest possible value. The initial reference value is 0.
            /// </param>
            [AutoGenerated(Category = "QCOM_alpha_test", Version = "", EntryPoint = "glAlphaFuncQCOM")]
            public static void AlphaFunc(OpenTK.Graphics.ES31.All func, Single @ref) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="driverControl"></param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glDisableDriverControlQCOM")]
            [CLSCompliant(false)]
            public static void DisableDriverControl(Int32 driverControl) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="driverControl"></param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glDisableDriverControlQCOM")]
            [CLSCompliant(false)]
            public static void DisableDriverControl(UInt32 driverControl) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="driverControl"></param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glEnableDriverControlQCOM")]
            [CLSCompliant(false)]
            public static void EnableDriverControl(Int32 driverControl) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="driverControl"></param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glEnableDriverControlQCOM")]
            [CLSCompliant(false)]
            public static void EnableDriverControl(UInt32 driverControl) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_tiled_rendering]</summary>
            /// <param name="preserveMask"></param>
            [AutoGenerated(Category = "QCOM_tiled_rendering", Version = "", EntryPoint = "glEndTilingQCOM")]
            [CLSCompliant(false)]
            public static void EndTiling(Int32 preserveMask) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_tiled_rendering]</summary>
            /// <param name="preserveMask"></param>
            [AutoGenerated(Category = "QCOM_tiled_rendering", Version = "", EntryPoint = "glEndTilingQCOM")]
            [CLSCompliant(false)]
            public static void EndTiling(UInt32 preserveMask) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="target"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBufferPointervQCOM")]
            public static void ExtGetBufferPointer(OpenTK.Graphics.ES31.All target, [OutAttribute] IntPtr @params) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="target"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBufferPointervQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetBufferPointer<T1>(OpenTK.Graphics.ES31.All target, [InAttribute, OutAttribute] T1[] @params)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="target"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBufferPointervQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetBufferPointer<T1>(OpenTK.Graphics.ES31.All target, [InAttribute, OutAttribute] T1[,] @params)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="target"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBufferPointervQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetBufferPointer<T1>(OpenTK.Graphics.ES31.All target, [InAttribute, OutAttribute] T1[,,] @params)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="target"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBufferPointervQCOM")]
            public static void ExtGetBufferPointer<T1>(OpenTK.Graphics.ES31.All target, [InAttribute, OutAttribute] ref T1 @params)
                where T1 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="buffers">[length: maxBuffers]</param>
            /// <param name="maxBuffers"></param>
            /// <param name="numBuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetBuffers([OutAttribute, CountAttribute(Parameter = "maxBuffers")] Int32[] buffers, Int32 maxBuffers, [OutAttribute, CountAttribute(Count = 1)] Int32[] numBuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="buffers">[length: maxBuffers]</param>
            /// <param name="maxBuffers"></param>
            /// <param name="numBuffers">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetBuffers([OutAttribute, CountAttribute(Parameter = "maxBuffers")] Int32[] buffers, Int32 maxBuffers, [OutAttribute, CountAttribute(Count = 1)] out Int32 numBuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="buffers">[length: maxBuffers]</param>
            /// <param name="maxBuffers"></param>
            /// <param name="numBuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetBuffers([OutAttribute, CountAttribute(Parameter = "maxBuffers")] out Int32 buffers, Int32 maxBuffers, [OutAttribute, CountAttribute(Count = 1)] out Int32 numBuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="buffers">[length: maxBuffers]</param>
            /// <param name="maxBuffers"></param>
            /// <param name="numBuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetBuffers([OutAttribute, CountAttribute(Parameter = "maxBuffers")] Int32* buffers, Int32 maxBuffers, [OutAttribute, CountAttribute(Count = 1)] Int32* numBuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="buffers">[length: maxBuffers]</param>
            /// <param name="maxBuffers"></param>
            /// <param name="numBuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetBuffers([OutAttribute, CountAttribute(Parameter = "maxBuffers")] UInt32[] buffers, Int32 maxBuffers, [OutAttribute, CountAttribute(Count = 1)] Int32[] numBuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="buffers">[length: maxBuffers]</param>
            /// <param name="maxBuffers"></param>
            /// <param name="numBuffers">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetBuffers([OutAttribute, CountAttribute(Parameter = "maxBuffers")] UInt32[] buffers, Int32 maxBuffers, [OutAttribute, CountAttribute(Count = 1)] out Int32 numBuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="buffers">[length: maxBuffers]</param>
            /// <param name="maxBuffers"></param>
            /// <param name="numBuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetBuffers([OutAttribute, CountAttribute(Parameter = "maxBuffers")] out UInt32 buffers, Int32 maxBuffers, [OutAttribute, CountAttribute(Count = 1)] out Int32 numBuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="buffers">[length: maxBuffers]</param>
            /// <param name="maxBuffers"></param>
            /// <param name="numBuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetBuffers([OutAttribute, CountAttribute(Parameter = "maxBuffers")] UInt32* buffers, Int32 maxBuffers, [OutAttribute, CountAttribute(Count = 1)] Int32* numBuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="framebuffers">[length: maxFramebuffers]</param>
            /// <param name="maxFramebuffers"></param>
            /// <param name="numFramebuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetFramebuffers([OutAttribute, CountAttribute(Parameter = "maxFramebuffers")] Int32[] framebuffers, Int32 maxFramebuffers, [OutAttribute, CountAttribute(Count = 1)] Int32[] numFramebuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="framebuffers">[length: maxFramebuffers]</param>
            /// <param name="maxFramebuffers"></param>
            /// <param name="numFramebuffers">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetFramebuffers([OutAttribute, CountAttribute(Parameter = "maxFramebuffers")] Int32[] framebuffers, Int32 maxFramebuffers, [OutAttribute, CountAttribute(Count = 1)] out Int32 numFramebuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="framebuffers">[length: maxFramebuffers]</param>
            /// <param name="maxFramebuffers"></param>
            /// <param name="numFramebuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetFramebuffers([OutAttribute, CountAttribute(Parameter = "maxFramebuffers")] out Int32 framebuffers, Int32 maxFramebuffers, [OutAttribute, CountAttribute(Count = 1)] out Int32 numFramebuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="framebuffers">[length: maxFramebuffers]</param>
            /// <param name="maxFramebuffers"></param>
            /// <param name="numFramebuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetFramebuffers([OutAttribute, CountAttribute(Parameter = "maxFramebuffers")] Int32* framebuffers, Int32 maxFramebuffers, [OutAttribute, CountAttribute(Count = 1)] Int32* numFramebuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="framebuffers">[length: maxFramebuffers]</param>
            /// <param name="maxFramebuffers"></param>
            /// <param name="numFramebuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetFramebuffers([OutAttribute, CountAttribute(Parameter = "maxFramebuffers")] UInt32[] framebuffers, Int32 maxFramebuffers, [OutAttribute, CountAttribute(Count = 1)] Int32[] numFramebuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="framebuffers">[length: maxFramebuffers]</param>
            /// <param name="maxFramebuffers"></param>
            /// <param name="numFramebuffers">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetFramebuffers([OutAttribute, CountAttribute(Parameter = "maxFramebuffers")] UInt32[] framebuffers, Int32 maxFramebuffers, [OutAttribute, CountAttribute(Count = 1)] out Int32 numFramebuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="framebuffers">[length: maxFramebuffers]</param>
            /// <param name="maxFramebuffers"></param>
            /// <param name="numFramebuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetFramebuffers([OutAttribute, CountAttribute(Parameter = "maxFramebuffers")] out UInt32 framebuffers, Int32 maxFramebuffers, [OutAttribute, CountAttribute(Count = 1)] out Int32 numFramebuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="framebuffers">[length: maxFramebuffers]</param>
            /// <param name="maxFramebuffers"></param>
            /// <param name="numFramebuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetFramebuffers([OutAttribute, CountAttribute(Parameter = "maxFramebuffers")] UInt32* framebuffers, Int32 maxFramebuffers, [OutAttribute, CountAttribute(Count = 1)] Int32* numFramebuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="program"></param>
            /// <param name="shadertype"></param>
            /// <param name="source"></param>
            /// <param name="length"></param>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramBinarySourceQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetProgramBinarySource(Int32 program, OpenTK.Graphics.ES31.All shadertype, [OutAttribute] out String source, [OutAttribute] Int32[] length) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="program"></param>
            /// <param name="shadertype"></param>
            /// <param name="source"></param>
            /// <param name="length"></param>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramBinarySourceQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetProgramBinarySource(Int32 program, OpenTK.Graphics.ES31.All shadertype, [OutAttribute] out String source, [OutAttribute] out Int32 length) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="program"></param>
            /// <param name="shadertype"></param>
            /// <param name="source"></param>
            /// <param name="length"></param>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramBinarySourceQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetProgramBinarySource(Int32 program, OpenTK.Graphics.ES31.All shadertype, [OutAttribute] out String source, [OutAttribute] Int32* length) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="program"></param>
            /// <param name="shadertype"></param>
            /// <param name="source"></param>
            /// <param name="length"></param>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramBinarySourceQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetProgramBinarySource(UInt32 program, OpenTK.Graphics.ES31.All shadertype, [OutAttribute] out String source, [OutAttribute] Int32[] length) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="program"></param>
            /// <param name="shadertype"></param>
            /// <param name="source"></param>
            /// <param name="length"></param>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramBinarySourceQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetProgramBinarySource(UInt32 program, OpenTK.Graphics.ES31.All shadertype, [OutAttribute] out String source, [OutAttribute] out Int32 length) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="program"></param>
            /// <param name="shadertype"></param>
            /// <param name="source"></param>
            /// <param name="length"></param>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramBinarySourceQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetProgramBinarySource(UInt32 program, OpenTK.Graphics.ES31.All shadertype, [OutAttribute] out String source, [OutAttribute] Int32* length) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="programs">[length: maxPrograms]</param>
            /// <param name="maxPrograms"></param>
            /// <param name="numPrograms">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetProgram([OutAttribute, CountAttribute(Parameter = "maxPrograms")] Int32[] programs, Int32 maxPrograms, [OutAttribute, CountAttribute(Count = 1)] Int32[] numPrograms) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="programs">[length: maxPrograms]</param>
            /// <param name="maxPrograms"></param>
            /// <param name="numPrograms">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetProgram([OutAttribute, CountAttribute(Parameter = "maxPrograms")] Int32[] programs, Int32 maxPrograms, [OutAttribute, CountAttribute(Count = 1)] out Int32 numPrograms) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="programs">[length: maxPrograms]</param>
            /// <param name="maxPrograms"></param>
            /// <param name="numPrograms">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetProgram([OutAttribute, CountAttribute(Parameter = "maxPrograms")] out Int32 programs, Int32 maxPrograms, [OutAttribute, CountAttribute(Count = 1)] out Int32 numPrograms) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="programs">[length: maxPrograms]</param>
            /// <param name="maxPrograms"></param>
            /// <param name="numPrograms">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetProgram([OutAttribute, CountAttribute(Parameter = "maxPrograms")] Int32* programs, Int32 maxPrograms, [OutAttribute, CountAttribute(Count = 1)] Int32* numPrograms) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="programs">[length: maxPrograms]</param>
            /// <param name="maxPrograms"></param>
            /// <param name="numPrograms">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetProgram([OutAttribute, CountAttribute(Parameter = "maxPrograms")] UInt32[] programs, Int32 maxPrograms, [OutAttribute, CountAttribute(Count = 1)] Int32[] numPrograms) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="programs">[length: maxPrograms]</param>
            /// <param name="maxPrograms"></param>
            /// <param name="numPrograms">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetProgram([OutAttribute, CountAttribute(Parameter = "maxPrograms")] UInt32[] programs, Int32 maxPrograms, [OutAttribute, CountAttribute(Count = 1)] out Int32 numPrograms) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="programs">[length: maxPrograms]</param>
            /// <param name="maxPrograms"></param>
            /// <param name="numPrograms">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetProgram([OutAttribute, CountAttribute(Parameter = "maxPrograms")] out UInt32 programs, Int32 maxPrograms, [OutAttribute, CountAttribute(Count = 1)] out Int32 numPrograms) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="programs">[length: maxPrograms]</param>
            /// <param name="maxPrograms"></param>
            /// <param name="numPrograms">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetProgram([OutAttribute, CountAttribute(Parameter = "maxPrograms")] UInt32* programs, Int32 maxPrograms, [OutAttribute, CountAttribute(Count = 1)] Int32* numPrograms) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="renderbuffers">[length: maxRenderbuffers]</param>
            /// <param name="maxRenderbuffers"></param>
            /// <param name="numRenderbuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetRenderbuffers([OutAttribute, CountAttribute(Parameter = "maxRenderbuffers")] Int32[] renderbuffers, Int32 maxRenderbuffers, [OutAttribute, CountAttribute(Count = 1)] Int32[] numRenderbuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="renderbuffers">[length: maxRenderbuffers]</param>
            /// <param name="maxRenderbuffers"></param>
            /// <param name="numRenderbuffers">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetRenderbuffers([OutAttribute, CountAttribute(Parameter = "maxRenderbuffers")] Int32[] renderbuffers, Int32 maxRenderbuffers, [OutAttribute, CountAttribute(Count = 1)] out Int32 numRenderbuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="renderbuffers">[length: maxRenderbuffers]</param>
            /// <param name="maxRenderbuffers"></param>
            /// <param name="numRenderbuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetRenderbuffers([OutAttribute, CountAttribute(Parameter = "maxRenderbuffers")] out Int32 renderbuffers, Int32 maxRenderbuffers, [OutAttribute, CountAttribute(Count = 1)] out Int32 numRenderbuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="renderbuffers">[length: maxRenderbuffers]</param>
            /// <param name="maxRenderbuffers"></param>
            /// <param name="numRenderbuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetRenderbuffers([OutAttribute, CountAttribute(Parameter = "maxRenderbuffers")] Int32* renderbuffers, Int32 maxRenderbuffers, [OutAttribute, CountAttribute(Count = 1)] Int32* numRenderbuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="renderbuffers">[length: maxRenderbuffers]</param>
            /// <param name="maxRenderbuffers"></param>
            /// <param name="numRenderbuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetRenderbuffers([OutAttribute, CountAttribute(Parameter = "maxRenderbuffers")] UInt32[] renderbuffers, Int32 maxRenderbuffers, [OutAttribute, CountAttribute(Count = 1)] Int32[] numRenderbuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="renderbuffers">[length: maxRenderbuffers]</param>
            /// <param name="maxRenderbuffers"></param>
            /// <param name="numRenderbuffers">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetRenderbuffers([OutAttribute, CountAttribute(Parameter = "maxRenderbuffers")] UInt32[] renderbuffers, Int32 maxRenderbuffers, [OutAttribute, CountAttribute(Count = 1)] out Int32 numRenderbuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="renderbuffers">[length: maxRenderbuffers]</param>
            /// <param name="maxRenderbuffers"></param>
            /// <param name="numRenderbuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetRenderbuffers([OutAttribute, CountAttribute(Parameter = "maxRenderbuffers")] out UInt32 renderbuffers, Int32 maxRenderbuffers, [OutAttribute, CountAttribute(Count = 1)] out Int32 numRenderbuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="renderbuffers">[length: maxRenderbuffers]</param>
            /// <param name="maxRenderbuffers"></param>
            /// <param name="numRenderbuffers">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetRenderbuffers([OutAttribute, CountAttribute(Parameter = "maxRenderbuffers")] UInt32* renderbuffers, Int32 maxRenderbuffers, [OutAttribute, CountAttribute(Count = 1)] Int32* numRenderbuffers) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="shaders">[length: maxShaders]</param>
            /// <param name="maxShaders"></param>
            /// <param name="numShaders">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetShaders([OutAttribute, CountAttribute(Parameter = "maxShaders")] Int32[] shaders, Int32 maxShaders, [OutAttribute, CountAttribute(Count = 1)] Int32[] numShaders) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="shaders">[length: maxShaders]</param>
            /// <param name="maxShaders"></param>
            /// <param name="numShaders">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetShaders([OutAttribute, CountAttribute(Parameter = "maxShaders")] Int32[] shaders, Int32 maxShaders, [OutAttribute, CountAttribute(Count = 1)] out Int32 numShaders) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="shaders">[length: maxShaders]</param>
            /// <param name="maxShaders"></param>
            /// <param name="numShaders">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetShaders([OutAttribute, CountAttribute(Parameter = "maxShaders")] out Int32 shaders, Int32 maxShaders, [OutAttribute, CountAttribute(Count = 1)] out Int32 numShaders) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="shaders">[length: maxShaders]</param>
            /// <param name="maxShaders"></param>
            /// <param name="numShaders">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetShaders([OutAttribute, CountAttribute(Parameter = "maxShaders")] Int32* shaders, Int32 maxShaders, [OutAttribute, CountAttribute(Count = 1)] Int32* numShaders) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="shaders">[length: maxShaders]</param>
            /// <param name="maxShaders"></param>
            /// <param name="numShaders">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetShaders([OutAttribute, CountAttribute(Parameter = "maxShaders")] UInt32[] shaders, Int32 maxShaders, [OutAttribute, CountAttribute(Count = 1)] Int32[] numShaders) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="shaders">[length: maxShaders]</param>
            /// <param name="maxShaders"></param>
            /// <param name="numShaders">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetShaders([OutAttribute, CountAttribute(Parameter = "maxShaders")] UInt32[] shaders, Int32 maxShaders, [OutAttribute, CountAttribute(Count = 1)] out Int32 numShaders) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="shaders">[length: maxShaders]</param>
            /// <param name="maxShaders"></param>
            /// <param name="numShaders">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetShaders([OutAttribute, CountAttribute(Parameter = "maxShaders")] out UInt32 shaders, Int32 maxShaders, [OutAttribute, CountAttribute(Count = 1)] out Int32 numShaders) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="shaders">[length: maxShaders]</param>
            /// <param name="maxShaders"></param>
            /// <param name="numShaders">[length: 1]</param>
            [Obsolete("Use out overload instead")]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetShaders([OutAttribute, CountAttribute(Parameter = "maxShaders")] UInt32* shaders, Int32 maxShaders, [OutAttribute, CountAttribute(Count = 1)] Int32* numShaders) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="texture"></param>
            /// <param name="face"></param>
            /// <param name="level"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexLevelParameterivQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetTexLevelParameter(Int32 texture, OpenTK.Graphics.ES31.All face, Int32 level, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="texture"></param>
            /// <param name="face"></param>
            /// <param name="level"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexLevelParameterivQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetTexLevelParameter(Int32 texture, OpenTK.Graphics.ES31.All face, Int32 level, OpenTK.Graphics.ES31.All pname, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="texture"></param>
            /// <param name="face"></param>
            /// <param name="level"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexLevelParameterivQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetTexLevelParameter(Int32 texture, OpenTK.Graphics.ES31.All face, Int32 level, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="texture"></param>
            /// <param name="face"></param>
            /// <param name="level"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexLevelParameterivQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetTexLevelParameter(UInt32 texture, OpenTK.Graphics.ES31.All face, Int32 level, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32[] @params) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="texture"></param>
            /// <param name="face"></param>
            /// <param name="level"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexLevelParameterivQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetTexLevelParameter(UInt32 texture, OpenTK.Graphics.ES31.All face, Int32 level, OpenTK.Graphics.ES31.All pname, [OutAttribute] out Int32 @params) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="texture"></param>
            /// <param name="face"></param>
            /// <param name="level"></param>
            /// <param name="pname"></param>
            /// <param name="@params"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexLevelParameterivQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetTexLevelParameter(UInt32 texture, OpenTK.Graphics.ES31.All face, Int32 level, OpenTK.Graphics.ES31.All pname, [OutAttribute] Int32* @params) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="target"></param>
            /// <param name="level"></param>
            /// <param name="xoffset"></param>
            /// <param name="yoffset"></param>
            /// <param name="zoffset"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="texels"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexSubImageQCOM")]
            public static void ExtGetTexSubImage(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [OutAttribute] IntPtr texels) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="target"></param>
            /// <param name="level"></param>
            /// <param name="xoffset"></param>
            /// <param name="yoffset"></param>
            /// <param name="zoffset"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="texels"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexSubImageQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetTexSubImage<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute] T10[] texels)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="target"></param>
            /// <param name="level"></param>
            /// <param name="xoffset"></param>
            /// <param name="yoffset"></param>
            /// <param name="zoffset"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="texels"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexSubImageQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetTexSubImage<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute] T10[,] texels)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="target"></param>
            /// <param name="level"></param>
            /// <param name="xoffset"></param>
            /// <param name="yoffset"></param>
            /// <param name="zoffset"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="texels"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexSubImageQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetTexSubImage<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute] T10[,,] texels)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="target"></param>
            /// <param name="level"></param>
            /// <param name="xoffset"></param>
            /// <param name="yoffset"></param>
            /// <param name="zoffset"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="depth"></param>
            /// <param name="format"></param>
            /// <param name="type"></param>
            /// <param name="texels"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexSubImageQCOM")]
            public static void ExtGetTexSubImage<T10>(OpenTK.Graphics.ES31.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES31.All format, OpenTK.Graphics.ES31.All type, [InAttribute, OutAttribute] ref T10 texels)
                where T10 : struct
             { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="textures"></param>
            /// <param name="maxTextures"></param>
            /// <param name="numTextures"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexturesQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetTextures([OutAttribute] Int32[] textures, Int32 maxTextures, [OutAttribute] Int32[] numTextures) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="textures"></param>
            /// <param name="maxTextures"></param>
            /// <param name="numTextures"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexturesQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetTextures([OutAttribute] out Int32 textures, Int32 maxTextures, [OutAttribute] out Int32 numTextures) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="textures"></param>
            /// <param name="maxTextures"></param>
            /// <param name="numTextures"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexturesQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetTextures([OutAttribute] Int32* textures, Int32 maxTextures, [OutAttribute] Int32* numTextures) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="textures"></param>
            /// <param name="maxTextures"></param>
            /// <param name="numTextures"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexturesQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetTextures([OutAttribute] UInt32[] textures, Int32 maxTextures, [OutAttribute] Int32[] numTextures) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="textures"></param>
            /// <param name="maxTextures"></param>
            /// <param name="numTextures"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexturesQCOM")]
            [CLSCompliant(false)]
            public static void ExtGetTextures([OutAttribute] out UInt32 textures, Int32 maxTextures, [OutAttribute] out Int32 numTextures) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="textures"></param>
            /// <param name="maxTextures"></param>
            /// <param name="numTextures"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexturesQCOM")]
            [CLSCompliant(false)]
            public static unsafe void ExtGetTextures([OutAttribute] UInt32* textures, Int32 maxTextures, [OutAttribute] Int32* numTextures) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="program"></param>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtIsProgramBinaryQCOM")]
            [CLSCompliant(false)]
            public static bool ExtIsProgramBinary(Int32 program) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            /// <param name="program"></param>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtIsProgramBinaryQCOM")]
            [CLSCompliant(false)]
            public static bool ExtIsProgramBinary(UInt32 program) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_extended_get]</summary>
            /// <param name="target"></param>
            /// <param name="pname"></param>
            /// <param name="param"></param>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtTexObjectStateOverrideiQCOM")]
            public static void ExtTexObjectStateOverride(OpenTK.Graphics.ES31.All target, OpenTK.Graphics.ES31.All pname, Int32 param) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_shader_framebuffer_fetch_noncoherent]</summary>
            [AutoGenerated(Category = "QCOM_shader_framebuffer_fetch_noncoherent", Version = "", EntryPoint = "glFramebufferFetchBarrierQCOM")]
            public static void FramebufferFetchBarrier() { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_framebuffer_foveated]</summary>
            /// <param name="framebuffer"></param>
            /// <param name="numLayers"></param>
            /// <param name="focalPointsPerLayer"></param>
            /// <param name="requestedFeatures"></param>
            /// <param name="providedFeatures">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_framebuffer_foveated", Version = "", EntryPoint = "glFramebufferFoveationConfigQCOM")]
            [CLSCompliant(false)]
            public static void FramebufferFoveationConfig(Int32 framebuffer, Int32 numLayers, Int32 focalPointsPerLayer, Int32 requestedFeatures, [OutAttribute, CountAttribute(Count = 1)] out Int32 providedFeatures) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_framebuffer_foveated]</summary>
            /// <param name="framebuffer"></param>
            /// <param name="numLayers"></param>
            /// <param name="focalPointsPerLayer"></param>
            /// <param name="requestedFeatures"></param>
            /// <param name="providedFeatures">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_framebuffer_foveated", Version = "", EntryPoint = "glFramebufferFoveationConfigQCOM")]
            [CLSCompliant(false)]
            public static unsafe void FramebufferFoveationConfig(Int32 framebuffer, Int32 numLayers, Int32 focalPointsPerLayer, Int32 requestedFeatures, [OutAttribute, CountAttribute(Count = 1)] Int32* providedFeatures) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_framebuffer_foveated]</summary>
            /// <param name="framebuffer"></param>
            /// <param name="numLayers"></param>
            /// <param name="focalPointsPerLayer"></param>
            /// <param name="requestedFeatures"></param>
            /// <param name="providedFeatures">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_framebuffer_foveated", Version = "", EntryPoint = "glFramebufferFoveationConfigQCOM")]
            [CLSCompliant(false)]
            public static void FramebufferFoveationConfig(UInt32 framebuffer, UInt32 numLayers, UInt32 focalPointsPerLayer, UInt32 requestedFeatures, [OutAttribute, CountAttribute(Count = 1)] out UInt32 providedFeatures) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_framebuffer_foveated]</summary>
            /// <param name="framebuffer"></param>
            /// <param name="numLayers"></param>
            /// <param name="focalPointsPerLayer"></param>
            /// <param name="requestedFeatures"></param>
            /// <param name="providedFeatures">[length: 1]</param>
            [AutoGenerated(Category = "QCOM_framebuffer_foveated", Version = "", EntryPoint = "glFramebufferFoveationConfigQCOM")]
            [CLSCompliant(false)]
            public static unsafe void FramebufferFoveationConfig(UInt32 framebuffer, UInt32 numLayers, UInt32 focalPointsPerLayer, UInt32 requestedFeatures, [OutAttribute, CountAttribute(Count = 1)] UInt32* providedFeatures) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_framebuffer_foveated]</summary>
            /// <param name="framebuffer"></param>
            /// <param name="layer"></param>
            /// <param name="focalPoint"></param>
            /// <param name="focalX"></param>
            /// <param name="focalY"></param>
            /// <param name="gainX"></param>
            /// <param name="gainY"></param>
            /// <param name="foveaArea"></param>
            [AutoGenerated(Category = "QCOM_framebuffer_foveated", Version = "", EntryPoint = "glFramebufferFoveationParametersQCOM")]
            [CLSCompliant(false)]
            public static void FramebufferFoveationParameters(Int32 framebuffer, Int32 layer, Int32 focalPoint, Single focalX, Single focalY, Single gainX, Single gainY, Single foveaArea) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_framebuffer_foveated]</summary>
            /// <param name="framebuffer"></param>
            /// <param name="layer"></param>
            /// <param name="focalPoint"></param>
            /// <param name="focalX"></param>
            /// <param name="focalY"></param>
            /// <param name="gainX"></param>
            /// <param name="gainY"></param>
            /// <param name="foveaArea"></param>
            [AutoGenerated(Category = "QCOM_framebuffer_foveated", Version = "", EntryPoint = "glFramebufferFoveationParametersQCOM")]
            [CLSCompliant(false)]
            public static void FramebufferFoveationParameters(UInt32 framebuffer, UInt32 layer, UInt32 focalPoint, Single focalX, Single focalY, Single gainX, Single gainY, Single foveaArea) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="num"></param>
            /// <param name="size"></param>
            /// <param name="driverControls">[length: size]</param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlsQCOM")]
            [CLSCompliant(false)]
            public static void GetDriverControl([OutAttribute] Int32[] num, Int32 size, [OutAttribute, CountAttribute(Parameter = "size")] Int32[] driverControls) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="num"></param>
            /// <param name="size"></param>
            /// <param name="driverControls">[length: size]</param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlsQCOM")]
            [CLSCompliant(false)]
            public static void GetDriverControl([OutAttribute] Int32[] num, Int32 size, [OutAttribute, CountAttribute(Parameter = "size")] UInt32[] driverControls) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="num"></param>
            /// <param name="size"></param>
            /// <param name="driverControls">[length: size]</param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlsQCOM")]
            [CLSCompliant(false)]
            public static void GetDriverControl([OutAttribute] out Int32 num, Int32 size, [OutAttribute, CountAttribute(Parameter = "size")] out Int32 driverControls) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="num"></param>
            /// <param name="size"></param>
            /// <param name="driverControls">[length: size]</param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlsQCOM")]
            [CLSCompliant(false)]
            public static void GetDriverControl([OutAttribute] out Int32 num, Int32 size, [OutAttribute, CountAttribute(Parameter = "size")] out UInt32 driverControls) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="num"></param>
            /// <param name="size"></param>
            /// <param name="driverControls">[length: size]</param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlsQCOM")]
            [CLSCompliant(false)]
            public static unsafe void GetDriverControl([OutAttribute] Int32* num, Int32 size, [OutAttribute, CountAttribute(Parameter = "size")] Int32* driverControls) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="num"></param>
            /// <param name="size"></param>
            /// <param name="driverControls">[length: size]</param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlsQCOM")]
            [CLSCompliant(false)]
            public static unsafe void GetDriverControl([OutAttribute] Int32* num, Int32 size, [OutAttribute, CountAttribute(Parameter = "size")] UInt32* driverControls) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="driverControl"></param>
            /// <param name="bufSize"></param>
            /// <param name="length"></param>
            /// <param name="driverControlString">[length: bufSize]</param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlStringQCOM")]
            [CLSCompliant(false)]
            public static void GetDriverControlString(Int32 driverControl, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String driverControlString) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="driverControl"></param>
            /// <param name="bufSize"></param>
            /// <param name="length"></param>
            /// <param name="driverControlString">[length: bufSize]</param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlStringQCOM")]
            [CLSCompliant(false)]
            public static void GetDriverControlString(Int32 driverControl, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String driverControlString) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="driverControl"></param>
            /// <param name="bufSize"></param>
            /// <param name="length"></param>
            /// <param name="driverControlString">[length: bufSize]</param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlStringQCOM")]
            [CLSCompliant(false)]
            public static unsafe void GetDriverControlString(Int32 driverControl, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String driverControlString) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="driverControl"></param>
            /// <param name="bufSize"></param>
            /// <param name="length"></param>
            /// <param name="driverControlString">[length: bufSize]</param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlStringQCOM")]
            [CLSCompliant(false)]
            public static void GetDriverControlString(UInt32 driverControl, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String driverControlString) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="driverControl"></param>
            /// <param name="bufSize"></param>
            /// <param name="length"></param>
            /// <param name="driverControlString">[length: bufSize]</param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlStringQCOM")]
            [CLSCompliant(false)]
            public static void GetDriverControlString(UInt32 driverControl, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String driverControlString) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_driver_control]</summary>
            /// <param name="driverControl"></param>
            /// <param name="bufSize"></param>
            /// <param name="length"></param>
            /// <param name="driverControlString">[length: bufSize]</param>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlStringQCOM")]
            [CLSCompliant(false)]
            public static unsafe void GetDriverControlString(UInt32 driverControl, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] out String driverControlString) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_tiled_rendering]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="preserveMask"></param>
            [AutoGenerated(Category = "QCOM_tiled_rendering", Version = "", EntryPoint = "glStartTilingQCOM")]
            [CLSCompliant(false)]
            public static void StartTiling(Int32 x, Int32 y, Int32 width, Int32 height, Int32 preserveMask) { throw new NotImplementedException(); }

            /// <summary>[requires: QCOM_tiled_rendering]</summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="width"></param>
            /// <param name="height"></param>
            /// <param name="preserveMask"></param>
            [AutoGenerated(Category = "QCOM_tiled_rendering", Version = "", EntryPoint = "glStartTilingQCOM")]
            [CLSCompliant(false)]
            public static void StartTiling(UInt32 x, UInt32 y, UInt32 width, UInt32 height, UInt32 preserveMask) { throw new NotImplementedException(); }
        }

        [Slot(9)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBeginPerfMonitorAMD(UInt32 monitor);
        [Slot(118)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeletePerfMonitorsAMD(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* monitors);
        [Slot(190)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEndPerfMonitorAMD(UInt32 monitor);
        [Slot(240)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenPerfMonitorsAMD(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* monitors);
        [Slot(323)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPerfMonitorCounterDataAMD(UInt32 monitor, System.Int32 pname, Int32 dataSize, [OutAttribute, CountAttribute(Parameter = "dataSize")] UInt32* data, [OutAttribute, CountAttribute(Count = 1)] Int32* bytesWritten);
        [Slot(324)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glGetPerfMonitorCounterInfoAMD(UInt32 group, UInt32 counter, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] IntPtr data);
        [Slot(325)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPerfMonitorCountersAMD(UInt32 group, [OutAttribute, CountAttribute(Count = 1)] Int32* numCounters, [OutAttribute, CountAttribute(Count = 1)] Int32* maxActiveCounters, Int32 counterSize, [OutAttribute, CountAttribute(Parameter = "counterSize")] UInt32* counters);
        [Slot(326)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPerfMonitorCounterStringAMD(UInt32 group, UInt32 counter, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr counterString);
        [Slot(327)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPerfMonitorGroupsAMD([OutAttribute, CountAttribute(Count = 1)] Int32* numGroups, Int32 groupsSize, [OutAttribute, CountAttribute(Parameter = "groupsSize")] UInt32* groups);
        [Slot(328)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPerfMonitorGroupStringAMD(UInt32 group, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr groupString);
        [Slot(638)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glSelectPerfMonitorCountersAMD(UInt32 monitor, bool enable, UInt32 group, Int32 numCounters, [OutAttribute, CountAttribute(Parameter = "numCounters")] UInt32* counterList);
        [Slot(49)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlitFramebufferANGLE(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, UInt32 mask, System.Int32 filter);
        [Slot(155)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawArraysInstancedANGLE(System.Int32 mode, Int32 first, Int32 count, Int32 primcount);
        [Slot(168)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawElementsInstancedANGLE(System.Int32 mode, Int32 count, System.Int32 type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 primcount);
        [Slot(385)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetTranslatedShaderSourceANGLE(UInt32 shader, Int32 bufsize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute] IntPtr source);
        [Slot(613)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glRenderbufferStorageMultisampleANGLE(System.Int32 target, Int32 samples, System.Int32 internalformat, Int32 width, Int32 height);
        [Slot(785)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttribDivisorANGLE(UInt32 index, UInt32 divisor);
        [Slot(69)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern System.Int32 glClientWaitSyncAPPLE(IntPtr sync, UInt32 flags, UInt64 timeout);
        [Slot(90)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCopyTextureLevelsAPPLE(UInt32 destinationTexture, UInt32 sourceTexture, Int32 sourceBaseLevel, Int32 sourceLevelCount);
        [Slot(130)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDeleteSyncAPPLE(IntPtr sync);
        [Slot(209)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr glFenceSyncAPPLE(System.Int32 condition, UInt32 flags);
        [Slot(287)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetInteger64vAPPLE(System.Int32 pname, [OutAttribute] Int64* @params);
        [Slot(371)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetSyncivAPPLE(IntPtr sync, System.Int32 pname, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* values);
        [Slot(434)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsSyncAPPLE(IntPtr sync);
        [Slot(614)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glRenderbufferStorageMultisampleAPPLE(System.Int32 target, Int32 samples, System.Int32 internalformat, Int32 width, Int32 height);
        [Slot(619)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glResolveMultisampleFramebufferAPPLE();
        [Slot(807)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glWaitSyncAPPLE(IntPtr sync, UInt32 flags, UInt64 timeout);
        [Slot(6)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glApplyFramebufferAttachmentCMAAINTEL();
        [Slot(2)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glActiveShaderProgram(UInt32 pipeline, UInt32 program);
        [Slot(4)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glActiveTexture(System.Int32 texture);
        [Slot(7)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glAttachShader(UInt32 program, UInt32 shader);
        [Slot(11)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBeginQuery(System.Int32 target, UInt32 id);
        [Slot(13)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBeginTransformFeedback(System.Int32 primitiveMode);
        [Slot(14)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindAttribLocation(UInt32 program, UInt32 index, IntPtr name);
        [Slot(15)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindBuffer(System.Int32 target, UInt32 buffer);
        [Slot(16)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindBufferBase(System.Int32 target, UInt32 index, UInt32 buffer);
        [Slot(17)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindBufferRange(System.Int32 target, UInt32 index, UInt32 buffer, IntPtr offset, IntPtr size);
        [Slot(20)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindFramebuffer(System.Int32 target, UInt32 framebuffer);
        [Slot(21)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindImageTexture(UInt32 unit, UInt32 texture, Int32 level, bool layered, Int32 layer, System.Int32 access, System.Int32 format);
        [Slot(22)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindProgramPipeline(UInt32 pipeline);
        [Slot(24)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindRenderbuffer(System.Int32 target, UInt32 renderbuffer);
        [Slot(25)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindSampler(UInt32 unit, UInt32 sampler);
        [Slot(26)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindTexture(System.Int32 target, UInt32 texture);
        [Slot(27)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindTransformFeedback(System.Int32 target, UInt32 id);
        [Slot(28)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindVertexArray(UInt32 array);
        [Slot(30)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindVertexBuffer(UInt32 bindingindex, UInt32 buffer, IntPtr offset, Int32 stride);
        [Slot(33)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendColor(Single red, Single green, Single blue, Single alpha);
        [Slot(34)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendEquation(System.Int32 mode);
        [Slot(38)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendEquationSeparate(System.Int32 modeRGB, System.Int32 modeAlpha);
        [Slot(41)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendFunc(System.Int32 sfactor, System.Int32 dfactor);
        [Slot(44)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendFuncSeparate(System.Int32 sfactorRGB, System.Int32 dfactorRGB, System.Int32 sfactorAlpha, System.Int32 dfactorAlpha);
        [Slot(48)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlitFramebuffer(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, System.Int32 mask, System.Int32 filter);
        [Slot(51)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBufferData(System.Int32 target, IntPtr size, [CountAttribute(Parameter = "size")] IntPtr data, System.Int32 usage);
        [Slot(55)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBufferSubData(System.Int32 target, IntPtr offset, IntPtr size, [CountAttribute(Parameter = "size")] IntPtr data);
        [Slot(56)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern System.Int32 glCheckFramebufferStatus(System.Int32 target);
        [Slot(57)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glClear(System.Int32 mask);
        [Slot(58)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glClearBufferfi(System.Int32 buffer, Int32 drawbuffer, Single depth, Int32 stencil);
        [Slot(59)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glClearBufferfv(System.Int32 buffer, Int32 drawbuffer, [CountAttribute(Computed = "buffer")] Single* value);
        [Slot(60)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glClearBufferiv(System.Int32 buffer, Int32 drawbuffer, [CountAttribute(Computed = "buffer")] Int32* value);
        [Slot(61)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glClearBufferuiv(System.Int32 buffer, Int32 drawbuffer, [CountAttribute(Computed = "buffer")] UInt32* value);
        [Slot(62)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glClearColor(Single red, Single green, Single blue, Single alpha);
        [Slot(63)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glClearDepthf(Single d);
        [Slot(65)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glClearStencil(Int32 s);
        [Slot(68)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern System.Int32 glClientWaitSync(IntPtr sync, UInt32 flags, UInt64 timeout);
        [Slot(70)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glColorMask(bool red, bool green, bool blue, bool alpha);
        [Slot(73)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCompileShader(UInt32 shader);
        [Slot(74)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCompressedTexImage2D(System.Int32 target, Int32 level, System.Int32 internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data);
        [Slot(75)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCompressedTexImage3D(System.Int32 target, Int32 level, System.Int32 internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data);
        [Slot(77)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCompressedTexSubImage2D(System.Int32 target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Int32 format, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data);
        [Slot(78)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCompressedTexSubImage3D(System.Int32 target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, System.Int32 format, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data);
        [Slot(81)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCopyBufferSubData(System.Int32 readTarget, System.Int32 writeTarget, IntPtr readOffset, IntPtr writeOffset, IntPtr size);
        [Slot(86)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCopyTexImage2D(System.Int32 target, Int32 level, System.Int32 internalformat, Int32 x, Int32 y, Int32 width, Int32 height, Int32 border);
        [Slot(87)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCopyTexSubImage2D(System.Int32 target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 x, Int32 y, Int32 width, Int32 height);
        [Slot(88)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCopyTexSubImage3D(System.Int32 target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height);
        [Slot(101)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glCreateProgram();
        [Slot(102)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glCreateShader(System.Int32 type);
        [Slot(104)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glCreateShaderProgramv(System.Int32 type, Int32 count, [CountAttribute(Parameter = "count")] IntPtr strings);
        [Slot(106)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCullFace(System.Int32 mode);
        [Slot(107)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDebugMessageCallback(DebugProc callback, IntPtr userParam);
        [Slot(109)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDebugMessageControl(System.Int32 source, System.Int32 type, System.Int32 severity, Int32 count, [CountAttribute(Parameter = "count")] UInt32* ids, bool enabled);
        [Slot(111)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDebugMessageInsert(System.Int32 source, System.Int32 type, UInt32 id, System.Int32 severity, Int32 length, [CountAttribute(Computed = "buf,length")] IntPtr buf);
        [Slot(113)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteBuffers(Int32 n, [CountAttribute(Parameter = "n")] UInt32* buffers);
        [Slot(115)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteFramebuffers(Int32 n, [CountAttribute(Parameter = "n")] UInt32* framebuffers);
        [Slot(120)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDeleteProgram(UInt32 program);
        [Slot(121)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteProgramPipelines(Int32 n, [CountAttribute(Parameter = "n")] UInt32* pipelines);
        [Slot(123)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteQueries(Int32 n, [CountAttribute(Parameter = "n")] UInt32* ids);
        [Slot(125)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteRenderbuffers(Int32 n, [CountAttribute(Parameter = "n")] UInt32* renderbuffers);
        [Slot(126)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteSamplers(Int32 count, [CountAttribute(Parameter = "count")] UInt32* samplers);
        [Slot(128)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDeleteShader(UInt32 shader);
        [Slot(129)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDeleteSync(IntPtr sync);
        [Slot(131)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteTextures(Int32 n, [CountAttribute(Parameter = "n")] UInt32* textures);
        [Slot(132)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteTransformFeedbacks(Int32 n, [CountAttribute(Parameter = "n")] UInt32* ids);
        [Slot(133)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteVertexArrays(Int32 n, [CountAttribute(Parameter = "n")] UInt32* arrays);
        [Slot(135)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDepthFunc(System.Int32 func);
        [Slot(136)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDepthMask(bool flag);
        [Slot(139)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDepthRangef(Single n, Single f);
        [Slot(142)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDetachShader(UInt32 program, UInt32 shader);
        [Slot(143)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDisable(System.Int32 cap);
        [Slot(148)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDisableVertexAttribArray(UInt32 index);
        [Slot(150)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDispatchCompute(UInt32 num_groups_x, UInt32 num_groups_y, UInt32 num_groups_z);
        [Slot(151)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDispatchComputeIndirect(IntPtr indirect);
        [Slot(152)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawArrays(System.Int32 mode, Int32 first, Int32 count);
        [Slot(153)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawArraysIndirect(System.Int32 mode, IntPtr indirect);
        [Slot(154)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawArraysInstanced(System.Int32 mode, Int32 first, Int32 count, Int32 instancecount);
        [Slot(159)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDrawBuffers(Int32 n, [CountAttribute(Parameter = "n")] System.Int32* bufs);
        [Slot(163)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawElements(System.Int32 mode, Int32 count, System.Int32 type, [CountAttribute(Computed = "count,type")] IntPtr indices);
        [Slot(166)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawElementsIndirect(System.Int32 mode, System.Int32 type, IntPtr indirect);
        [Slot(167)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawElementsInstanced(System.Int32 mode, Int32 count, System.Int32 type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 instancecount);
        [Slot(175)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawRangeElements(System.Int32 mode, UInt32 start, UInt32 end, Int32 count, System.Int32 type, [CountAttribute(Computed = "count,type")] IntPtr indices);
        [Slot(183)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEnable(System.Int32 cap);
        [Slot(188)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEnableVertexAttribArray(UInt32 index);
        [Slot(192)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEndQuery(System.Int32 target);
        [Slot(195)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEndTransformFeedback();
        [Slot(208)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr glFenceSync(System.Int32 condition, UInt32 flags);
        [Slot(210)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFinish();
        [Slot(212)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFlush();
        [Slot(213)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFlushMappedBufferRange(System.Int32 target, IntPtr offset, IntPtr length);
        [Slot(219)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferParameteri(System.Int32 target, System.Int32 pname, Int32 param);
        [Slot(221)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferRenderbuffer(System.Int32 target, System.Int32 attachment, System.Int32 renderbuffertarget, UInt32 renderbuffer);
        [Slot(223)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferTexture2D(System.Int32 target, System.Int32 attachment, System.Int32 textarget, UInt32 texture, Int32 level);
        [Slot(229)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferTextureLayer(System.Int32 target, System.Int32 attachment, UInt32 texture, Int32 level, Int32 layer);
        [Slot(234)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFrontFace(System.Int32 mode);
        [Slot(235)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenBuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* buffers);
        [Slot(236)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glGenerateMipmap(System.Int32 target);
        [Slot(238)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenFramebuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* framebuffers);
        [Slot(241)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenProgramPipelines(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* pipelines);
        [Slot(243)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenQueries(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* ids);
        [Slot(245)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenRenderbuffers(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* renderbuffers);
        [Slot(246)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenSamplers(Int32 count, [OutAttribute, CountAttribute(Parameter = "count")] UInt32* samplers);
        [Slot(248)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenTextures(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* textures);
        [Slot(249)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenTransformFeedbacks(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* ids);
        [Slot(250)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenVertexArrays(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* arrays);
        [Slot(252)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetActiveAttrib(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] Int32* size, [OutAttribute, CountAttribute(Count = 1)] System.Int32* type, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr name);
        [Slot(253)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetActiveUniform(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] Int32* size, [OutAttribute, CountAttribute(Count = 1)] System.Int32* type, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr name);
        [Slot(254)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetActiveUniformBlockiv(UInt32 program, UInt32 uniformBlockIndex, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "program,uniformBlockIndex,pname")] Int32* @params);
        [Slot(255)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetActiveUniformBlockName(UInt32 program, UInt32 uniformBlockIndex, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr uniformBlockName);
        [Slot(256)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetActiveUniformsiv(UInt32 program, Int32 uniformCount, [CountAttribute(Parameter = "uniformCount")] UInt32* uniformIndices, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "uniformCount,pname")] Int32* @params);
        [Slot(257)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetAttachedShaders(UInt32 program, Int32 maxCount, [OutAttribute, CountAttribute(Count = 1)] Int32* count, [OutAttribute, CountAttribute(Parameter = "maxCount")] UInt32* shaders);
        [Slot(258)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glGetAttribLocation(UInt32 program, IntPtr name);
        [Slot(259)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetBooleani_v(System.Int32 target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] bool* data);
        [Slot(260)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetBooleanv(System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] bool* data);
        [Slot(261)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetBufferParameteri64v(System.Int32 target, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int64* @params);
        [Slot(262)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetBufferParameteriv(System.Int32 target, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(263)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glGetBufferPointerv(System.Int32 target, System.Int32 pname, [OutAttribute, CountAttribute(Count = 1)] IntPtr @params);
        [Slot(266)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe Int32 glGetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] System.Int32* sources, [OutAttribute, CountAttribute(Parameter = "count")] System.Int32* types, [OutAttribute, CountAttribute(Parameter = "count")] UInt32* ids, [OutAttribute, CountAttribute(Parameter = "count")] System.Int32* severities, [OutAttribute, CountAttribute(Parameter = "count")] Int32* lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr messageLog);
        [Slot(270)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern System.Int32 glGetError();
        [Slot(275)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetFloatv(System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* data);
        [Slot(277)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glGetFragDataLocation(UInt32 program, [CountAttribute(Computed = "name")] IntPtr name);
        [Slot(278)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetFramebufferAttachmentParameteriv(System.Int32 target, System.Int32 attachment, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(279)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetFramebufferParameteriv(System.Int32 target, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(281)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern System.Int32 glGetGraphicsResetStatus();
        [Slot(285)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetInteger64i_v(System.Int32 target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Int64* data);
        [Slot(286)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetInteger64v(System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int64* data);
        [Slot(288)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetIntegeri_v(System.Int32 target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Int32* data);
        [Slot(290)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetIntegerv(System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* data);
        [Slot(291)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetInternalformativ(System.Int32 target, System.Int32 internalformat, System.Int32 pname, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* @params);
        [Slot(294)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetMultisamplefv(System.Int32 pname, UInt32 index, [OutAttribute, CountAttribute(Computed = "pname")] Single* val);
        [Slot(296)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetnUniformfv(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Single* @params);
        [Slot(299)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetnUniformiv(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32* @params);
        [Slot(302)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetnUniformuiv(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] UInt32* @params);
        [Slot(304)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetObjectLabel(System.Int32 identifier, UInt32 name, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr label);
        [Slot(307)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetObjectPtrLabel(IntPtr ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr label);
        [Slot(332)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glGetPointerv(System.Int32 pname, [OutAttribute, CountAttribute(Count = 1)] IntPtr @params);
        [Slot(334)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetProgramBinary(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] System.Int32* binaryFormat, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr binary);
        [Slot(336)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetProgramInfoLog(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr infoLog);
        [Slot(337)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetProgramInterfaceiv(UInt32 program, System.Int32 programInterface, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(338)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetProgramiv(UInt32 program, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(339)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetProgramPipelineInfoLog(UInt32 pipeline, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr infoLog);
        [Slot(341)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetProgramPipelineiv(UInt32 pipeline, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(344)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glGetProgramResourceIndex(UInt32 program, System.Int32 programInterface, [CountAttribute(Computed = "name")] IntPtr name);
        [Slot(345)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetProgramResourceiv(UInt32 program, System.Int32 programInterface, UInt32 index, Int32 propCount, [CountAttribute(Parameter = "propCount")] System.Int32* props, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* @params);
        [Slot(346)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glGetProgramResourceLocation(UInt32 program, System.Int32 programInterface, [CountAttribute(Computed = "name")] IntPtr name);
        [Slot(348)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetProgramResourceName(UInt32 program, System.Int32 programInterface, UInt32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr name);
        [Slot(349)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetQueryiv(System.Int32 target, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(354)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetQueryObjectuiv(UInt32 id, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32* @params);
        [Slot(356)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetRenderbufferParameteriv(System.Int32 target, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(357)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetSamplerParameterfv(UInt32 sampler, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* @params);
        [Slot(362)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetSamplerParameteriv(UInt32 sampler, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(364)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetShaderInfoLog(UInt32 shader, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr infoLog);
        [Slot(365)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetShaderiv(UInt32 shader, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(366)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetShaderPrecisionFormat(System.Int32 shadertype, System.Int32 precisiontype, [OutAttribute, CountAttribute(Count = 2)] Int32* range, [OutAttribute, CountAttribute(Count = 1)] Int32* precision);
        [Slot(367)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetShaderSource(UInt32 shader, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr source);
        [Slot(368)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr glGetString(System.Int32 name);
        [Slot(369)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr glGetStringi(System.Int32 name, UInt32 index);
        [Slot(370)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetSynciv(IntPtr sync, System.Int32 pname, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* values);
        [Slot(372)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetTexLevelParameterfv(System.Int32 target, Int32 level, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* @params);
        [Slot(373)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetTexLevelParameteriv(System.Int32 target, Int32 level, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(374)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetTexParameterfv(System.Int32 target, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* @params);
        [Slot(379)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetTexParameteriv(System.Int32 target, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(384)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetTransformFeedbackVarying(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] Int32* size, [OutAttribute, CountAttribute(Count = 1)] System.Int32* type, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr name);
        [Slot(386)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glGetUniformBlockIndex(UInt32 program, [CountAttribute(Computed = "")] IntPtr uniformBlockName);
        [Slot(387)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetUniformfv(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Single* @params);
        [Slot(389)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetUniformIndices(UInt32 program, Int32 uniformCount, [CountAttribute(Computed = "uniformCount")] IntPtr uniformNames, [OutAttribute, CountAttribute(Computed = "uniformCount")] UInt32* uniformIndices);
        [Slot(390)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetUniformiv(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Int32* @params);
        [Slot(391)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glGetUniformLocation(UInt32 program, IntPtr name);
        [Slot(392)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetUniformuiv(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] UInt32* @params);
        [Slot(395)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetVertexAttribfv(UInt32 index, System.Int32 pname, [OutAttribute, CountAttribute(Count = 4)] Single* @params);
        [Slot(396)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetVertexAttribIiv(UInt32 index, System.Int32 pname, [OutAttribute, CountAttribute(Count = 1)] Int32* @params);
        [Slot(397)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetVertexAttribIuiv(UInt32 index, System.Int32 pname, [OutAttribute, CountAttribute(Count = 1)] UInt32* @params);
        [Slot(398)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetVertexAttribiv(UInt32 index, System.Int32 pname, [OutAttribute, CountAttribute(Count = 4)] Int32* @params);
        [Slot(399)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glGetVertexAttribPointerv(UInt32 index, System.Int32 pname, [OutAttribute, CountAttribute(Count = 1)] IntPtr pointer);
        [Slot(401)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glHint(System.Int32 target, System.Int32 mode);
        [Slot(410)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glInvalidateFramebuffer(System.Int32 target, Int32 numAttachments, [CountAttribute(Parameter = "numAttachments")] System.Int32* attachments);
        [Slot(411)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glInvalidateSubFramebuffer(System.Int32 target, Int32 numAttachments, [CountAttribute(Parameter = "numAttachments")] System.Int32* attachments, Int32 x, Int32 y, Int32 width, Int32 height);
        [Slot(412)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsBuffer(UInt32 buffer);
        [Slot(413)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsEnabled(System.Int32 cap);
        [Slot(418)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsFramebuffer(UInt32 framebuffer);
        [Slot(424)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsProgram(UInt32 program);
        [Slot(425)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsProgramPipeline(UInt32 pipeline);
        [Slot(427)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsQuery(UInt32 id);
        [Slot(429)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsRenderbuffer(UInt32 renderbuffer);
        [Slot(430)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsSampler(UInt32 sampler);
        [Slot(432)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsShader(UInt32 shader);
        [Slot(433)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsSync(IntPtr sync);
        [Slot(435)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsTexture(UInt32 texture);
        [Slot(437)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsTransformFeedback(UInt32 id);
        [Slot(438)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsVertexArray(UInt32 array);
        [Slot(441)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glLineWidth(Single width);
        [Slot(442)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glLinkProgram(UInt32 program);
        [Slot(448)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr glMapBufferRange(System.Int32 target, IntPtr offset, IntPtr length, System.Int32 access);
        [Slot(456)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glMemoryBarrier(UInt32 barriers);
        [Slot(457)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glMemoryBarrierByRegion(UInt32 barriers);
        [Slot(468)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glObjectLabel(System.Int32 identifier, UInt32 name, Int32 length, [CountAttribute(Computed = "label,length")] IntPtr label);
        [Slot(470)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glObjectPtrLabel(IntPtr ptr, Int32 length, [CountAttribute(Computed = "label,length")] IntPtr label);
        [Slot(495)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPauseTransformFeedback();
        [Slot(496)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPixelStorei(System.Int32 pname, Int32 param);
        [Slot(499)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPolygonOffset(Single factor, Single units);
        [Slot(501)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPopDebugGroup();
        [Slot(506)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramBinary(UInt32 program, System.Int32 binaryFormat, [CountAttribute(Parameter = "length")] IntPtr binary, Int32 length);
        [Slot(508)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramParameteri(UInt32 program, System.Int32 pname, Int32 value);
        [Slot(511)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform1f(UInt32 program, Int32 location, Single v0);
        [Slot(513)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform1fv(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Single* value);
        [Slot(515)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform1i(UInt32 program, Int32 location, Int32 v0);
        [Slot(519)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform1iv(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int32* value);
        [Slot(521)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform1ui(UInt32 program, Int32 location, UInt32 v0);
        [Slot(525)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform1uiv(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt32* value);
        [Slot(527)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform2f(UInt32 program, Int32 location, Single v0, Single v1);
        [Slot(529)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform2fv(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Single* value);
        [Slot(531)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform2i(UInt32 program, Int32 location, Int32 v0, Int32 v1);
        [Slot(535)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform2iv(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int32* value);
        [Slot(537)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform2ui(UInt32 program, Int32 location, UInt32 v0, UInt32 v1);
        [Slot(541)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform2uiv(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt32* value);
        [Slot(543)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform3f(UInt32 program, Int32 location, Single v0, Single v1, Single v2);
        [Slot(545)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform3fv(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Single* value);
        [Slot(547)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform3i(UInt32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2);
        [Slot(551)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform3iv(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int32* value);
        [Slot(553)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform3ui(UInt32 program, Int32 location, UInt32 v0, UInt32 v1, UInt32 v2);
        [Slot(557)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform3uiv(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt32* value);
        [Slot(559)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform4f(UInt32 program, Int32 location, Single v0, Single v1, Single v2, Single v3);
        [Slot(561)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform4fv(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Single* value);
        [Slot(563)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform4i(UInt32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3);
        [Slot(567)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform4iv(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int32* value);
        [Slot(569)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform4ui(UInt32 program, Int32 location, UInt32 v0, UInt32 v1, UInt32 v2, UInt32 v3);
        [Slot(573)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform4uiv(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt32* value);
        [Slot(579)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix2fv(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] Single* value);
        [Slot(581)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix2x3fv(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value);
        [Slot(583)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix2x4fv(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value);
        [Slot(585)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix3fv(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] Single* value);
        [Slot(587)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix3x2fv(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value);
        [Slot(589)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix3x4fv(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value);
        [Slot(591)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix4fv(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] Single* value);
        [Slot(593)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix4x2fv(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value);
        [Slot(595)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix4x3fv(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value);
        [Slot(597)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPushDebugGroup(System.Int32 source, UInt32 id, Int32 length, [CountAttribute(Computed = "message,length")] IntPtr message);
        [Slot(602)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glReadBuffer(System.Int32 src);
        [Slot(605)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glReadnPixels(Int32 x, Int32 y, Int32 width, Int32 height, System.Int32 format, System.Int32 type, Int32 bufSize, [OutAttribute] IntPtr data);
        [Slot(608)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glReadPixels(Int32 x, Int32 y, Int32 width, Int32 height, System.Int32 format, System.Int32 type, [OutAttribute, CountAttribute(Computed = "format,type,width,height")] IntPtr pixels);
        [Slot(610)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glReleaseShaderCompiler();
        [Slot(611)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glRenderbufferStorage(System.Int32 target, System.Int32 internalformat, Int32 width, Int32 height);
        [Slot(612)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glRenderbufferStorageMultisample(System.Int32 target, Int32 samples, System.Int32 internalformat, Int32 width, Int32 height);
        [Slot(620)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glResumeTransformFeedback();
        [Slot(621)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glSampleCoverage(Single value, bool invert);
        [Slot(622)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glSampleMaski(UInt32 maskNumber, UInt32 mask);
        [Slot(623)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glSamplerParameterf(UInt32 sampler, System.Int32 pname, Single param);
        [Slot(624)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glSamplerParameterfv(UInt32 sampler, System.Int32 pname, [CountAttribute(Computed = "pname")] Single* param);
        [Slot(625)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glSamplerParameteri(UInt32 sampler, System.Int32 pname, Int32 param);
        [Slot(630)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glSamplerParameteriv(UInt32 sampler, System.Int32 pname, [CountAttribute(Computed = "pname")] Int32* param);
        [Slot(631)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glScissor(Int32 x, Int32 y, Int32 width, Int32 height);
        [Slot(641)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glShaderBinary(Int32 count, [CountAttribute(Parameter = "count")] UInt32* shaders, System.Int32 binaryformat, [CountAttribute(Parameter = "length")] IntPtr binary, Int32 length);
        [Slot(642)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glShaderSource(UInt32 shader, Int32 count, [CountAttribute(Parameter = "count")] IntPtr @string, [CountAttribute(Parameter = "count")] Int32* length);
        [Slot(649)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glStencilFunc(System.Int32 func, Int32 @ref, UInt32 mask);
        [Slot(650)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glStencilFuncSeparate(System.Int32 face, System.Int32 func, Int32 @ref, UInt32 mask);
        [Slot(651)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glStencilMask(UInt32 mask);
        [Slot(652)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glStencilMaskSeparate(System.Int32 face, UInt32 mask);
        [Slot(653)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glStencilOp(System.Int32 fail, System.Int32 zfail, System.Int32 zpass);
        [Slot(654)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glStencilOpSeparate(System.Int32 face, System.Int32 sfail, System.Int32 dpfail, System.Int32 dppass);
        [Slot(667)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexImage2D(System.Int32 target, Int32 level, System.Int32 internalformat, Int32 width, Int32 height, Int32 border, System.Int32 format, System.Int32 type, [CountAttribute(Computed = "format,type,width,height")] IntPtr pixels);
        [Slot(668)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexImage3D(System.Int32 target, Int32 level, System.Int32 internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, System.Int32 format, System.Int32 type, [CountAttribute(Computed = "format,type,width,height,depth")] IntPtr pixels);
        [Slot(671)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexParameterf(System.Int32 target, System.Int32 pname, Single param);
        [Slot(672)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glTexParameterfv(System.Int32 target, System.Int32 pname, [CountAttribute(Computed = "pname")] Single* @params);
        [Slot(673)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexParameteri(System.Int32 target, System.Int32 pname, Int32 param);
        [Slot(678)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glTexParameteriv(System.Int32 target, System.Int32 pname, [CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(680)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexStorage2D(System.Int32 target, Int32 levels, System.Int32 internalformat, Int32 width, Int32 height);
        [Slot(682)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexStorage2DMultisample(System.Int32 target, Int32 samples, System.Int32 internalformat, Int32 width, Int32 height, bool fixedsamplelocations);
        [Slot(683)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexStorage3D(System.Int32 target, Int32 levels, System.Int32 internalformat, Int32 width, Int32 height, Int32 depth);
        [Slot(691)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexSubImage2D(System.Int32 target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Int32 format, System.Int32 type, [CountAttribute(Computed = "format,type,width,height")] IntPtr pixels);
        [Slot(692)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexSubImage3D(System.Int32 target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, System.Int32 format, System.Int32 type, [CountAttribute(Computed = "format,type,width,height,depth")] IntPtr pixels);
        [Slot(704)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTransformFeedbackVaryings(UInt32 program, Int32 count, [CountAttribute(Parameter = "count")] IntPtr varyings, System.Int32 bufferMode);
        [Slot(706)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform1f(Int32 location, Single v0);
        [Slot(707)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform1fv(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] Single* value);
        [Slot(708)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform1i(Int32 location, Int32 v0);
        [Slot(711)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform1iv(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] Int32* value);
        [Slot(712)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform1ui(Int32 location, UInt32 v0);
        [Slot(715)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform1uiv(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] UInt32* value);
        [Slot(716)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform2f(Int32 location, Single v0, Single v1);
        [Slot(717)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform2fv(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Single* value);
        [Slot(718)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform2i(Int32 location, Int32 v0, Int32 v1);
        [Slot(721)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform2iv(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int32* value);
        [Slot(722)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform2ui(Int32 location, UInt32 v0, UInt32 v1);
        [Slot(725)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform2uiv(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt32* value);
        [Slot(726)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform3f(Int32 location, Single v0, Single v1, Single v2);
        [Slot(727)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform3fv(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Single* value);
        [Slot(728)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform3i(Int32 location, Int32 v0, Int32 v1, Int32 v2);
        [Slot(731)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform3iv(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int32* value);
        [Slot(732)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform3ui(Int32 location, UInt32 v0, UInt32 v1, UInt32 v2);
        [Slot(735)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform3uiv(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt32* value);
        [Slot(736)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform4f(Int32 location, Single v0, Single v1, Single v2, Single v3);
        [Slot(737)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform4fv(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Single* value);
        [Slot(738)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform4i(Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3);
        [Slot(741)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform4iv(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int32* value);
        [Slot(742)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform4ui(Int32 location, UInt32 v0, UInt32 v1, UInt32 v2, UInt32 v3);
        [Slot(745)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform4uiv(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt32* value);
        [Slot(746)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniformBlockBinding(UInt32 program, UInt32 uniformBlockIndex, UInt32 uniformBlockBinding);
        [Slot(751)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix2fv(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] Single* value);
        [Slot(752)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix2x3fv(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value);
        [Slot(754)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix2x4fv(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value);
        [Slot(756)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix3fv(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] Single* value);
        [Slot(757)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix3x2fv(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value);
        [Slot(759)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix3x4fv(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value);
        [Slot(761)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix4fv(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] Single* value);
        [Slot(762)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix4x2fv(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value);
        [Slot(764)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix4x3fv(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value);
        [Slot(766)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glUnmapBuffer(System.Int32 target);
        [Slot(768)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUseProgram(UInt32 program);
        [Slot(769)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUseProgramStages(UInt32 pipeline, UInt32 stages, UInt32 program);
        [Slot(772)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glValidateProgram(UInt32 program);
        [Slot(773)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glValidateProgramPipeline(UInt32 pipeline);
        [Slot(775)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttrib1f(UInt32 index, Single x);
        [Slot(776)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glVertexAttrib1fv(UInt32 index, [CountAttribute(Count = 1)] Single* v);
        [Slot(777)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttrib2f(UInt32 index, Single x, Single y);
        [Slot(778)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glVertexAttrib2fv(UInt32 index, [CountAttribute(Count = 2)] Single* v);
        [Slot(779)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttrib3f(UInt32 index, Single x, Single y, Single z);
        [Slot(780)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glVertexAttrib3fv(UInt32 index, [CountAttribute(Count = 3)] Single* v);
        [Slot(781)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttrib4f(UInt32 index, Single x, Single y, Single z, Single w);
        [Slot(782)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glVertexAttrib4fv(UInt32 index, [CountAttribute(Count = 4)] Single* v);
        [Slot(783)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttribBinding(UInt32 attribindex, UInt32 bindingindex);
        [Slot(784)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttribDivisor(UInt32 index, UInt32 divisor);
        [Slot(788)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttribFormat(UInt32 attribindex, Int32 size, System.Int32 type, bool normalized, UInt32 relativeoffset);
        [Slot(789)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttribI4i(UInt32 index, Int32 x, Int32 y, Int32 z, Int32 w);
        [Slot(790)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glVertexAttribI4iv(UInt32 index, [CountAttribute(Count = 4)] Int32* v);
        [Slot(791)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttribI4ui(UInt32 index, UInt32 x, UInt32 y, UInt32 z, UInt32 w);
        [Slot(792)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glVertexAttribI4uiv(UInt32 index, [CountAttribute(Count = 4)] UInt32* v);
        [Slot(793)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttribIFormat(UInt32 attribindex, Int32 size, System.Int32 type, UInt32 relativeoffset);
        [Slot(794)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttribIPointer(UInt32 index, Int32 size, System.Int32 type, Int32 stride, [CountAttribute(Computed = "size,type,stride")] IntPtr pointer);
        [Slot(795)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttribPointer(UInt32 index, Int32 size, System.Int32 type, bool normalized, Int32 stride, [CountAttribute(Computed = "size,type,stride")] IntPtr pointer);
        [Slot(796)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexBindingDivisor(UInt32 bindingindex, UInt32 divisor);
        [Slot(797)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glViewport(Int32 x, Int32 y, Int32 width, Int32 height);
        [Slot(806)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glWaitSync(IntPtr sync, UInt32 flags, UInt64 timeout);
        [Slot(0)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glAcquireKeyedMutexWin32EXT(UInt32 memory, UInt64 key, UInt32 timeout);
        [Slot(1)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glActiveProgramEXT(UInt32 program);
        [Slot(3)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glActiveShaderProgramEXT(UInt32 pipeline, UInt32 program);
        [Slot(12)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBeginQueryEXT(System.Int32 target, UInt32 id);
        [Slot(18)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindFragDataLocationEXT(UInt32 program, UInt32 color, [CountAttribute(Computed = "name")] IntPtr name);
        [Slot(19)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindFragDataLocationIndexedEXT(UInt32 program, UInt32 colorNumber, UInt32 index, IntPtr name);
        [Slot(23)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindProgramPipelineEXT(UInt32 pipeline);
        [Slot(35)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendEquationEXT(System.Int32 mode);
        [Slot(36)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendEquationiEXT(UInt32 buf, System.Int32 mode);
        [Slot(39)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendEquationSeparateiEXT(UInt32 buf, System.Int32 modeRGB, System.Int32 modeAlpha);
        [Slot(42)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendFunciEXT(UInt32 buf, System.Int32 src, System.Int32 dst);
        [Slot(45)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendFuncSeparateiEXT(UInt32 buf, System.Int32 srcRGB, System.Int32 dstRGB, System.Int32 srcAlpha, System.Int32 dstAlpha);
        [Slot(52)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBufferStorageEXT(System.Int32 target, IntPtr size, [CountAttribute(Parameter = "size")] IntPtr data, UInt32 flags);
        [Slot(53)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBufferStorageExternalEXT(System.Int32 target, IntPtr offset, IntPtr size, IntPtr clientBuffer, UInt32 flags);
        [Slot(54)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBufferStorageMemEXT(System.Int32 target, IntPtr size, UInt32 memory, UInt64 offset);
        [Slot(64)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glClearPixelLocalStorageuiEXT(Int32 offset, Int32 n, UInt32* values);
        [Slot(66)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glClearTexImageEXT(UInt32 texture, Int32 level, System.Int32 format, System.Int32 type, [CountAttribute(Computed = "format,type")] IntPtr data);
        [Slot(67)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glClearTexSubImageEXT(UInt32 texture, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, System.Int32 format, System.Int32 type, [CountAttribute(Computed = "format,type")] IntPtr data);
        [Slot(71)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glColorMaskiEXT(UInt32 index, bool r, bool g, bool b, bool a);
        [Slot(83)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCopyImageSubDataEXT(UInt32 srcName, System.Int32 srcTarget, Int32 srcLevel, Int32 srcX, Int32 srcY, Int32 srcZ, UInt32 dstName, System.Int32 dstTarget, Int32 dstLevel, Int32 dstX, Int32 dstY, Int32 dstZ, Int32 srcWidth, Int32 srcHeight, Int32 srcDepth);
        [Slot(99)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glCreateMemoryObjectsEXT(Int32 n, [OutAttribute] UInt32* memoryObjects);
        [Slot(103)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glCreateShaderProgramEXT(System.Int32 type, IntPtr @string);
        [Slot(105)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glCreateShaderProgramvEXT(System.Int32 type, Int32 count, [CountAttribute(Parameter = "count")] IntPtr strings);
        [Slot(116)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteMemoryObjectsEXT(Int32 n, [CountAttribute(Parameter = "n")] UInt32* memoryObjects);
        [Slot(122)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteProgramPipelinesEXT(Int32 n, [CountAttribute(Parameter = "n")] UInt32* pipelines);
        [Slot(124)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteQueriesEXT(Int32 n, [CountAttribute(Parameter = "n")] UInt32* ids);
        [Slot(127)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteSemaphoresEXT(Int32 n, [CountAttribute(Parameter = "count")] UInt32* semaphores);
        [Slot(145)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDisableiEXT(System.Int32 target, UInt32 index);
        [Slot(149)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDiscardFramebufferEXT(System.Int32 target, Int32 numAttachments, [CountAttribute(Parameter = "numAttachments")] System.Int32* attachments);
        [Slot(156)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawArraysInstancedBaseInstanceEXT(System.Int32 mode, Int32 first, Int32 count, Int32 instancecount, UInt32 baseinstance);
        [Slot(157)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawArraysInstancedEXT(System.Int32 mode, Int32 start, Int32 count, Int32 primcount);
        [Slot(160)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDrawBuffersEXT(Int32 n, System.Int32* bufs);
        [Slot(161)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDrawBuffersIndexedEXT(Int32 n, [CountAttribute(Parameter = "n")] System.Int32* location, [CountAttribute(Parameter = "n")] Int32* indices);
        [Slot(164)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawElementsBaseVertexEXT(System.Int32 mode, Int32 count, System.Int32 type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex);
        [Slot(169)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawElementsInstancedBaseInstanceEXT(System.Int32 mode, Int32 count, System.Int32 type, [CountAttribute(Parameter = "count")] IntPtr indices, Int32 instancecount, UInt32 baseinstance);
        [Slot(170)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawElementsInstancedBaseVertexBaseInstanceEXT(System.Int32 mode, Int32 count, System.Int32 type, [CountAttribute(Parameter = "count")] IntPtr indices, Int32 instancecount, Int32 basevertex, UInt32 baseinstance);
        [Slot(171)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawElementsInstancedBaseVertexEXT(System.Int32 mode, Int32 count, System.Int32 type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 instancecount, Int32 basevertex);
        [Slot(173)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawElementsInstancedEXT(System.Int32 mode, Int32 count, System.Int32 type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 primcount);
        [Slot(176)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawRangeElementsBaseVertexEXT(System.Int32 mode, UInt32 start, UInt32 end, Int32 count, System.Int32 type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex);
        [Slot(178)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawTransformFeedbackEXT(System.Int32 mode, UInt32 id);
        [Slot(179)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawTransformFeedbackInstancedEXT(System.Int32 mode, UInt32 id, Int32 instancecount);
        [Slot(185)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEnableiEXT(System.Int32 target, UInt32 index);
        [Slot(193)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEndQueryEXT(System.Int32 target);
        [Slot(214)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFlushMappedBufferRangeEXT(System.Int32 target, IntPtr offset, IntPtr length);
        [Slot(220)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferPixelLocalStorageSizeEXT(UInt32 target, Int32 size);
        [Slot(225)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferTexture2DMultisampleEXT(System.Int32 target, System.Int32 attachment, System.Int32 textarget, UInt32 texture, Int32 level, Int32 samples);
        [Slot(228)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferTextureEXT(System.Int32 target, System.Int32 attachment, UInt32 texture, Int32 level);
        [Slot(242)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenProgramPipelinesEXT(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* pipelines);
        [Slot(244)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenQueriesEXT(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* ids);
        [Slot(247)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenSemaphoresEXT(Int32 n, [OutAttribute, CountAttribute(Parameter = "count")] UInt32* semaphores);
        [Slot(276)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glGetFragDataIndexEXT(UInt32 program, IntPtr name);
        [Slot(280)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glGetFramebufferPixelLocalStorageSizeEXT(UInt32 target);
        [Slot(282)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern System.Int32 glGetGraphicsResetStatusEXT();
        [Slot(289)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetIntegeri_vEXT(System.Int32 target, UInt32 index, [OutAttribute] Int32* data);
        [Slot(293)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetMemoryObjectParameterivEXT(UInt32 memoryObject, System.Int32 pname, [OutAttribute] Int32* @params);
        [Slot(297)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetnUniformfvEXT(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Single* @params);
        [Slot(300)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetnUniformivEXT(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* @params);
        [Slot(305)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetObjectLabelEXT(System.Int32 type, UInt32 @object, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr label);
        [Slot(340)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetProgramPipelineInfoLogEXT(UInt32 pipeline, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr infoLog);
        [Slot(342)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetProgramPipelineivEXT(UInt32 pipeline, System.Int32 pname, [OutAttribute] Int32* @params);
        [Slot(347)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glGetProgramResourceLocationIndexEXT(UInt32 program, System.Int32 programInterface, [CountAttribute(Computed = "name")] IntPtr name);
        [Slot(350)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetQueryivEXT(System.Int32 target, System.Int32 pname, [OutAttribute] Int32* @params);
        [Slot(351)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetQueryObjecti64vEXT(UInt32 id, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int64* @params);
        [Slot(352)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetQueryObjectivEXT(UInt32 id, System.Int32 pname, [OutAttribute] Int32* @params);
        [Slot(353)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetQueryObjectui64vEXT(UInt32 id, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt64* @params);
        [Slot(355)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetQueryObjectuivEXT(UInt32 id, System.Int32 pname, [OutAttribute] UInt32* @params);
        [Slot(358)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetSamplerParameterIivEXT(UInt32 sampler, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(360)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetSamplerParameterIuivEXT(UInt32 sampler, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32* @params);
        [Slot(363)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetSemaphoreParameterui64vEXT(UInt32 semaphore, System.Int32 pname, [OutAttribute] UInt64* @params);
        [Slot(375)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetTexParameterIivEXT(System.Int32 target, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(377)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetTexParameterIuivEXT(System.Int32 target, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32* @params);
        [Slot(393)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetUnsignedBytei_vEXT(System.Int32 target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Byte* data);
        [Slot(394)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetUnsignedBytevEXT(System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Byte* data);
        [Slot(402)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glImportMemoryFdEXT(UInt32 memory, UInt64 size, System.Int32 handleType, Int32 fd);
        [Slot(403)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glImportMemoryWin32HandleEXT(UInt32 memory, UInt64 size, System.Int32 handleType, [OutAttribute] IntPtr handle);
        [Slot(404)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glImportMemoryWin32NameEXT(UInt32 memory, UInt64 size, System.Int32 handleType, IntPtr name);
        [Slot(405)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glImportSemaphoreFdEXT(UInt32 semaphore, System.Int32 handleType, Int32 fd);
        [Slot(406)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glImportSemaphoreWin32HandleEXT(UInt32 semaphore, System.Int32 handleType, [OutAttribute] IntPtr handle);
        [Slot(407)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glImportSemaphoreWin32NameEXT(UInt32 semaphore, System.Int32 handleType, IntPtr name);
        [Slot(408)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glInsertEventMarkerEXT(Int32 length, IntPtr marker);
        [Slot(414)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsEnablediEXT(System.Int32 target, UInt32 index);
        [Slot(420)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsMemoryObjectEXT(UInt32 memoryObject);
        [Slot(426)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsProgramPipelineEXT(UInt32 pipeline);
        [Slot(428)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsQueryEXT(UInt32 id);
        [Slot(431)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsSemaphoreEXT(UInt32 semaphore);
        [Slot(440)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glLabelObjectEXT(System.Int32 type, UInt32 @object, Int32 length, IntPtr label);
        [Slot(449)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr glMapBufferRangeEXT(System.Int32 target, IntPtr offset, IntPtr length, UInt32 access);
        [Slot(458)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glMemoryObjectParameterivEXT(UInt32 memoryObject, System.Int32 pname, Int32* @params);
        [Slot(460)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glMultiDrawArraysEXT(System.Int32 mode, [CountAttribute(Computed = "primcount")] Int32* first, [CountAttribute(Computed = "primcount")] Int32* count, Int32 primcount);
        [Slot(461)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glMultiDrawArraysIndirectEXT(System.Int32 mode, [CountAttribute(Computed = "drawcount,stride")] IntPtr indirect, Int32 drawcount, Int32 stride);
        [Slot(462)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glMultiDrawElementsBaseVertexEXT(System.Int32 mode, [CountAttribute(Computed = "drawcount")] Int32* count, System.Int32 type, [CountAttribute(Computed = "drawcount")] IntPtr indices, Int32 primcount, [CountAttribute(Computed = "drawcount")] Int32* basevertex);
        [Slot(463)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glMultiDrawElementsEXT(System.Int32 mode, [CountAttribute(Computed = "primcount")] Int32* count, System.Int32 type, [CountAttribute(Computed = "primcount")] IntPtr indices, Int32 primcount);
        [Slot(464)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glMultiDrawElementsIndirectEXT(System.Int32 mode, System.Int32 type, [CountAttribute(Computed = "drawcount,stride")] IntPtr indirect, Int32 drawcount, Int32 stride);
        [Slot(465)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glNamedBufferStorageExternalEXT(UInt32 buffer, IntPtr offset, IntPtr size, IntPtr clientBuffer, UInt32 flags);
        [Slot(466)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glNamedBufferStorageMemEXT(UInt32 buffer, IntPtr size, UInt32 memory, UInt64 offset);
        [Slot(472)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPatchParameteriEXT(System.Int32 pname, Int32 value);
        [Slot(500)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPolygonOffsetClampEXT(Single factor, Single units, Single clamp);
        [Slot(503)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPopGroupMarkerEXT();
        [Slot(504)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPrimitiveBoundingBoxEXT(Single minX, Single minY, Single minZ, Single minW, Single maxX, Single maxY, Single maxZ, Single maxW);
        [Slot(509)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramParameteriEXT(UInt32 program, System.Int32 pname, Int32 value);
        [Slot(512)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform1fEXT(UInt32 program, Int32 location, Single v0);
        [Slot(514)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform1fvEXT(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Single* value);
        [Slot(518)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform1iEXT(UInt32 program, Int32 location, Int32 v0);
        [Slot(520)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform1ivEXT(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int32* value);
        [Slot(524)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform1uiEXT(UInt32 program, Int32 location, UInt32 v0);
        [Slot(526)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform1uivEXT(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt32* value);
        [Slot(528)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform2fEXT(UInt32 program, Int32 location, Single v0, Single v1);
        [Slot(530)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform2fvEXT(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Single* value);
        [Slot(534)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform2iEXT(UInt32 program, Int32 location, Int32 v0, Int32 v1);
        [Slot(536)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform2ivEXT(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int32* value);
        [Slot(540)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform2uiEXT(UInt32 program, Int32 location, UInt32 v0, UInt32 v1);
        [Slot(542)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform2uivEXT(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt32* value);
        [Slot(544)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform3fEXT(UInt32 program, Int32 location, Single v0, Single v1, Single v2);
        [Slot(546)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform3fvEXT(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Single* value);
        [Slot(550)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform3iEXT(UInt32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2);
        [Slot(552)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform3ivEXT(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int32* value);
        [Slot(556)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform3uiEXT(UInt32 program, Int32 location, UInt32 v0, UInt32 v1, UInt32 v2);
        [Slot(558)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform3uivEXT(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt32* value);
        [Slot(560)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform4fEXT(UInt32 program, Int32 location, Single v0, Single v1, Single v2, Single v3);
        [Slot(562)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform4fvEXT(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Single* value);
        [Slot(566)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform4iEXT(UInt32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3);
        [Slot(568)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform4ivEXT(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int32* value);
        [Slot(572)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform4uiEXT(UInt32 program, Int32 location, UInt32 v0, UInt32 v1, UInt32 v2, UInt32 v3);
        [Slot(574)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform4uivEXT(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt32* value);
        [Slot(580)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix2fvEXT(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*4")] Single* value);
        [Slot(582)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix2x3fvEXT(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value);
        [Slot(584)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix2x4fvEXT(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value);
        [Slot(586)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix3fvEXT(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*9")] Single* value);
        [Slot(588)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix3x2fvEXT(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value);
        [Slot(590)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix3x4fvEXT(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value);
        [Slot(592)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix4fvEXT(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*16")] Single* value);
        [Slot(594)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix4x2fvEXT(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value);
        [Slot(596)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformMatrix4x3fvEXT(UInt32 program, Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value);
        [Slot(599)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPushGroupMarkerEXT(Int32 length, IntPtr marker);
        [Slot(600)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glQueryCounterEXT(UInt32 id, System.Int32 target);
        [Slot(601)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glRasterSamplesEXT(UInt32 samples, bool fixedsamplelocations);
        [Slot(603)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glReadBufferIndexedEXT(System.Int32 src, Int32 index);
        [Slot(606)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glReadnPixelsEXT(Int32 x, Int32 y, Int32 width, Int32 height, System.Int32 format, System.Int32 type, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr data);
        [Slot(609)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glReleaseKeyedMutexWin32EXT(UInt32 memory, UInt64 key);
        [Slot(615)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glRenderbufferStorageMultisampleEXT(System.Int32 target, Int32 samples, System.Int32 internalformat, Int32 width, Int32 height);
        [Slot(626)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glSamplerParameterIivEXT(UInt32 sampler, System.Int32 pname, [CountAttribute(Computed = "pname")] Int32* param);
        [Slot(628)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glSamplerParameterIuivEXT(UInt32 sampler, System.Int32 pname, [CountAttribute(Computed = "pname")] UInt32* param);
        [Slot(639)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glSemaphoreParameterui64vEXT(UInt32 semaphore, System.Int32 pname, UInt64* @params);
        [Slot(643)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glSignalSemaphoreEXT(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] UInt32* buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] UInt32* textures, [CountAttribute(Computed = "numTextureBarriers")] System.Int32* dstLayouts);
        [Slot(663)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexBufferEXT(System.Int32 target, System.Int32 internalformat, UInt32 buffer);
        [Slot(665)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexBufferRangeEXT(System.Int32 target, System.Int32 internalformat, UInt32 buffer, IntPtr offset, IntPtr size);
        [Slot(670)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexPageCommitmentEXT(System.Int32 target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, bool commit);
        [Slot(674)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glTexParameterIivEXT(System.Int32 target, System.Int32 pname, [CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(676)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glTexParameterIuivEXT(System.Int32 target, System.Int32 pname, [CountAttribute(Computed = "pname")] UInt32* @params);
        [Slot(679)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexStorage1DEXT(System.Int32 target, Int32 levels, System.Int32 internalformat, Int32 width);
        [Slot(681)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexStorage2DEXT(System.Int32 target, Int32 levels, System.Int32 internalformat, Int32 width, Int32 height);
        [Slot(684)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexStorage3DEXT(System.Int32 target, Int32 levels, System.Int32 internalformat, Int32 width, Int32 height, Int32 depth);
        [Slot(686)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexStorageMem1DEXT(System.Int32 target, Int32 levels, System.Int32 internalFormat, Int32 width, UInt32 memory, UInt64 offset);
        [Slot(687)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexStorageMem2DEXT(System.Int32 target, Int32 levels, System.Int32 internalFormat, Int32 width, Int32 height, UInt32 memory, UInt64 offset);
        [Slot(688)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexStorageMem2DMultisampleEXT(System.Int32 target, Int32 samples, System.Int32 internalFormat, Int32 width, Int32 height, bool fixedSampleLocations, UInt32 memory, UInt64 offset);
        [Slot(689)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexStorageMem3DEXT(System.Int32 target, Int32 levels, System.Int32 internalFormat, Int32 width, Int32 height, Int32 depth, UInt32 memory, UInt64 offset);
        [Slot(690)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexStorageMem3DMultisampleEXT(System.Int32 target, Int32 samples, System.Int32 internalFormat, Int32 width, Int32 height, Int32 depth, bool fixedSampleLocations, UInt32 memory, UInt64 offset);
        [Slot(694)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTextureStorage1DEXT(UInt32 texture, System.Int32 target, Int32 levels, System.Int32 internalformat, Int32 width);
        [Slot(695)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTextureStorage2DEXT(UInt32 texture, System.Int32 target, Int32 levels, System.Int32 internalformat, Int32 width, Int32 height);
        [Slot(696)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTextureStorage3DEXT(UInt32 texture, System.Int32 target, Int32 levels, System.Int32 internalformat, Int32 width, Int32 height, Int32 depth);
        [Slot(697)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTextureStorageMem1DEXT(UInt32 texture, Int32 levels, System.Int32 internalFormat, Int32 width, UInt32 memory, UInt64 offset);
        [Slot(698)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTextureStorageMem2DEXT(UInt32 texture, Int32 levels, System.Int32 internalFormat, Int32 width, Int32 height, UInt32 memory, UInt64 offset);
        [Slot(699)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTextureStorageMem2DMultisampleEXT(UInt32 texture, Int32 samples, System.Int32 internalFormat, Int32 width, Int32 height, bool fixedSampleLocations, UInt32 memory, UInt64 offset);
        [Slot(700)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTextureStorageMem3DEXT(UInt32 texture, Int32 levels, System.Int32 internalFormat, Int32 width, Int32 height, Int32 depth, UInt32 memory, UInt64 offset);
        [Slot(701)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTextureStorageMem3DMultisampleEXT(UInt32 texture, Int32 samples, System.Int32 internalFormat, Int32 width, Int32 height, Int32 depth, bool fixedSampleLocations, UInt32 memory, UInt64 offset);
        [Slot(702)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTextureViewEXT(UInt32 texture, System.Int32 target, UInt32 origtexture, System.Int32 internalformat, UInt32 minlevel, UInt32 numlevels, UInt32 minlayer, UInt32 numlayers);
        [Slot(770)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUseProgramStagesEXT(UInt32 pipeline, UInt32 stages, UInt32 program);
        [Slot(771)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUseShaderProgramEXT(System.Int32 type, UInt32 program);
        [Slot(774)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glValidateProgramPipelineEXT(UInt32 pipeline);
        [Slot(786)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttribDivisorEXT(UInt32 index, UInt32 divisor);
        [Slot(805)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glWaitSemaphoreEXT(UInt32 semaphore, UInt32 numBufferBarriers, [CountAttribute(Computed = "numBufferBarriers")] UInt32* buffers, UInt32 numTextureBarriers, [CountAttribute(Computed = "numTextureBarriers")] UInt32* textures, [CountAttribute(Computed = "numTextureBarriers")] System.Int32* srcLayouts);
        [Slot(810)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glWindowRectanglesEXT(System.Int32 mode, Int32 count, [CountAttribute(Computed = "count")] Int32* box);
        [Slot(224)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferTexture2DDownsampleIMG(System.Int32 target, System.Int32 attachment, System.Int32 textarget, UInt32 texture, Int32 level, Int32 xscale, Int32 yscale);
        [Slot(226)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferTexture2DMultisampleIMG(System.Int32 target, System.Int32 attachment, System.Int32 textarget, UInt32 texture, Int32 level, Int32 samples);
        [Slot(230)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferTextureLayerDownsampleIMG(System.Int32 target, System.Int32 attachment, UInt32 texture, Int32 level, Int32 layer, Int32 xscale, Int32 yscale);
        [Slot(380)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int64 glGetTextureHandleIMG(UInt32 texture);
        [Slot(382)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int64 glGetTextureSamplerHandleIMG(UInt32 texture, UInt32 sampler);
        [Slot(575)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniformHandleui64IMG(UInt32 program, Int32 location, UInt64 value);
        [Slot(577)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformHandleui64vIMG(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64* values);
        [Slot(616)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glRenderbufferStorageMultisampleIMG(System.Int32 target, Int32 samples, System.Int32 internalformat, Int32 width, Int32 height);
        [Slot(747)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniformHandleui64IMG(Int32 location, UInt64 value);
        [Slot(749)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformHandleui64vIMG(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64* value);
        [Slot(10)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBeginPerfQueryINTEL(UInt32 queryHandle);
        [Slot(100)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glCreatePerfQueryINTEL(UInt32 queryId, [OutAttribute] UInt32* queryHandle);
        [Slot(119)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDeletePerfQueryINTEL(UInt32 queryHandle);
        [Slot(191)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEndPerfQueryINTEL(UInt32 queryHandle);
        [Slot(272)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetFirstPerfQueryIdINTEL([OutAttribute] UInt32* queryId);
        [Slot(295)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetNextPerfQueryIdINTEL(UInt32 queryId, [OutAttribute] UInt32* nextQueryId);
        [Slot(322)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPerfCounterInfoINTEL(UInt32 queryId, UInt32 counterId, UInt32 counterNameLength, [OutAttribute] IntPtr counterName, UInt32 counterDescLength, [OutAttribute] IntPtr counterDesc, [OutAttribute] UInt32* counterOffset, [OutAttribute] UInt32* counterDataSize, [OutAttribute] UInt32* counterTypeEnum, [OutAttribute] UInt32* counterDataTypeEnum, [OutAttribute] UInt64* rawCounterMaxValue);
        [Slot(329)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPerfQueryDataINTEL(UInt32 queryHandle, UInt32 flags, Int32 dataSize, [OutAttribute] IntPtr data, [OutAttribute] UInt32* bytesWritten);
        [Slot(330)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPerfQueryIdByNameINTEL([OutAttribute] IntPtr queryName, [OutAttribute] UInt32* queryId);
        [Slot(331)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPerfQueryInfoINTEL(UInt32 queryId, UInt32 queryNameLength, [OutAttribute] IntPtr queryName, [OutAttribute] UInt32* dataSize, [OutAttribute] UInt32* noCounters, [OutAttribute] UInt32* noInstances, [OutAttribute] UInt32* capsMask);
        [Slot(31)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendBarrierKHR();
        [Slot(108)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDebugMessageCallbackKHR(DebugProcKhr callback, IntPtr userParam);
        [Slot(110)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDebugMessageControlKHR(System.Int32 source, System.Int32 type, System.Int32 severity, Int32 count, UInt32* ids, bool enabled);
        [Slot(112)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDebugMessageInsertKHR(System.Int32 source, System.Int32 type, UInt32 id, System.Int32 severity, Int32 length, IntPtr buf);
        [Slot(267)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe Int32 glGetDebugMessageLogKHR(UInt32 count, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "count")] System.Int32* sources, [OutAttribute, CountAttribute(Parameter = "count")] System.Int32* types, [OutAttribute, CountAttribute(Parameter = "count")] UInt32* ids, [OutAttribute, CountAttribute(Parameter = "count")] System.Int32* severities, [OutAttribute, CountAttribute(Parameter = "count")] Int32* lengths, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr messageLog);
        [Slot(283)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern System.Int32 glGetGraphicsResetStatusKHR();
        [Slot(298)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetnUniformfvKHR(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Single* @params);
        [Slot(301)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetnUniformivKHR(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32* @params);
        [Slot(303)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetnUniformuivKHR(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] UInt32* @params);
        [Slot(306)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetObjectLabelKHR(System.Int32 identifier, UInt32 name, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr label);
        [Slot(308)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetObjectPtrLabelKHR(IntPtr ptr, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr label);
        [Slot(333)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glGetPointervKHR(System.Int32 pname, [OutAttribute] IntPtr @params);
        [Slot(469)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glObjectLabelKHR(System.Int32 identifier, UInt32 name, Int32 length, IntPtr label);
        [Slot(471)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glObjectPtrLabelKHR(IntPtr ptr, Int32 length, IntPtr label);
        [Slot(502)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPopDebugGroupKHR();
        [Slot(598)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPushDebugGroupKHR(System.Int32 source, UInt32 id, Int32 length, IntPtr message);
        [Slot(607)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glReadnPixelsKHR(Int32 x, Int32 y, Int32 width, Int32 height, System.Int32 format, System.Int32 type, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr data);
        [Slot(8)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBeginConditionalRenderNV(UInt32 id, System.Int32 mode);
        [Slot(32)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendBarrierNV();
        [Slot(47)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendParameteriNV(System.Int32 pname, Int32 value);
        [Slot(50)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlitFramebufferNV(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, UInt32 mask, System.Int32 filter);
        [Slot(80)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glConservativeRasterParameteriNV(System.Int32 pname, Int32 param);
        [Slot(82)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCopyBufferSubDataNV(System.Int32 readTarget, System.Int32 writeTarget, IntPtr readOffset, IntPtr writeOffset, IntPtr size);
        [Slot(85)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCopyPathNV(UInt32 resultPath, UInt32 srcPath);
        [Slot(91)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCoverageMaskNV(bool mask);
        [Slot(92)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCoverageModulationNV(System.Int32 components);
        [Slot(93)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glCoverageModulationTableNV(Int32 n, Single* v);
        [Slot(94)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCoverageOperationNV(System.Int32 operation);
        [Slot(95)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glCoverFillPathInstancedNV(Int32 numPaths, System.Int32 pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, System.Int32 coverMode, System.Int32 transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues);
        [Slot(96)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCoverFillPathNV(UInt32 path, System.Int32 coverMode);
        [Slot(97)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glCoverStrokePathInstancedNV(Int32 numPaths, System.Int32 pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, System.Int32 coverMode, System.Int32 transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues);
        [Slot(98)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCoverStrokePathNV(UInt32 path, System.Int32 coverMode);
        [Slot(114)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteFencesNV(Int32 n, [CountAttribute(Parameter = "n")] UInt32* fences);
        [Slot(117)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDeletePathsNV(UInt32 path, Int32 range);
        [Slot(137)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDepthRangeArrayfvNV(UInt32 first, Int32 count, Single* v);
        [Slot(140)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDepthRangeIndexedfNV(UInt32 index, Single n, Single f);
        [Slot(146)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDisableiNV(System.Int32 target, UInt32 index);
        [Slot(158)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawArraysInstancedNV(System.Int32 mode, Int32 first, Int32 count, Int32 primcount);
        [Slot(162)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDrawBuffersNV(Int32 n, [CountAttribute(Parameter = "n")] System.Int32* bufs);
        [Slot(174)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawElementsInstancedNV(System.Int32 mode, Int32 count, System.Int32 type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 primcount);
        [Slot(180)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawVkImageNV(UInt64 vkImage, UInt32 sampler, Single x0, Single y0, Single x1, Single y1, Single z, Single s0, Single t0, Single s1, Single t1);
        [Slot(186)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEnableiNV(System.Int32 target, UInt32 index);
        [Slot(189)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEndConditionalRenderNV();
        [Slot(211)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFinishFenceNV(UInt32 fence);
        [Slot(215)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFragmentCoverageColorNV(UInt32 color);
        [Slot(222)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glFramebufferSampleLocationsfvNV(System.Int32 target, UInt32 start, Int32 count, Single* v);
        [Slot(237)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenFencesNV(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* fences);
        [Slot(239)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int32 glGenPathsNV(Int32 range);
        [Slot(265)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetCoverageModulationTableNV(Int32 bufsize, [OutAttribute] Single* v);
        [Slot(271)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetFenceivNV(UInt32 fence, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(273)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetFloati_vNV(System.Int32 target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Single* data);
        [Slot(284)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int64 glGetImageHandleNV(UInt32 texture, Int32 level, bool layered, Int32 layer, System.Int32 format);
        [Slot(292)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetInternalformatSampleivNV(System.Int32 target, System.Int32 internalformat, Int32 samples, System.Int32 pname, Int32 bufSize, [OutAttribute, CountAttribute(Parameter = "bufSize")] Int32* @params);
        [Slot(309)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPathColorGenfvNV(System.Int32 color, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* value);
        [Slot(310)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPathColorGenivNV(System.Int32 color, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* value);
        [Slot(311)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPathCommandsNV(UInt32 path, [OutAttribute, CountAttribute(Computed = "path")] Byte* commands);
        [Slot(312)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPathCoordsNV(UInt32 path, [OutAttribute, CountAttribute(Computed = "path")] Single* coords);
        [Slot(313)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPathDashArrayNV(UInt32 path, [OutAttribute, CountAttribute(Computed = "path")] Single* dashArray);
        [Slot(314)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Single glGetPathLengthNV(UInt32 path, Int32 startSegment, Int32 numSegments);
        [Slot(315)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPathMetricRangeNV(UInt32 metricQueryMask, UInt32 firstPathName, Int32 numPaths, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics);
        [Slot(316)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPathMetricsNV(UInt32 metricQueryMask, Int32 numPaths, System.Int32 pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, Int32 stride, [OutAttribute, CountAttribute(Computed = "metricQueryMask,numPaths,stride")] Single* metrics);
        [Slot(317)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPathParameterfvNV(UInt32 path, System.Int32 pname, [OutAttribute, CountAttribute(Count = 4)] Single* value);
        [Slot(318)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPathParameterivNV(UInt32 path, System.Int32 pname, [OutAttribute, CountAttribute(Count = 4)] Int32* value);
        [Slot(319)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPathSpacingNV(System.Int32 pathListMode, Int32 numPaths, System.Int32 pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, Single advanceScale, Single kerningScale, System.Int32 transformType, [OutAttribute, CountAttribute(Computed = "pathListMode,numPaths")] Single* returnedSpacing);
        [Slot(320)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPathTexGenfvNV(System.Int32 texCoordSet, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Single* value);
        [Slot(321)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetPathTexGenivNV(System.Int32 texCoordSet, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* value);
        [Slot(343)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetProgramResourcefvNV(UInt32 program, System.Int32 programInterface, UInt32 index, Int32 propCount, System.Int32* props, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Single* @params);
        [Slot(381)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int64 glGetTextureHandleNV(UInt32 texture);
        [Slot(383)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern Int64 glGetTextureSamplerHandleNV(UInt32 texture, UInt32 sampler);
        [Slot(388)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetUniformi64vNV(UInt32 program, Int32 location, [OutAttribute, CountAttribute(Computed = "program,location")] Int64* @params);
        [Slot(400)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr glGetVkProcAddrNV([CountAttribute(Computed = "name")] IntPtr name);
        [Slot(409)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glInterpolatePathsNV(UInt32 resultPath, UInt32 pathA, UInt32 pathB, Single weight);
        [Slot(415)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsEnablediNV(System.Int32 target, UInt32 index);
        [Slot(417)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsFenceNV(UInt32 fence);
        [Slot(419)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsImageHandleResidentNV(UInt64 handle);
        [Slot(421)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsPathNV(UInt32 path);
        [Slot(422)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsPointInFillPathNV(UInt32 path, UInt32 mask, Single x, Single y);
        [Slot(423)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsPointInStrokePathNV(UInt32 path, Single x, Single y);
        [Slot(436)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsTextureHandleResidentNV(UInt64 handle);
        [Slot(443)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glMakeImageHandleNonResidentNV(UInt64 handle);
        [Slot(444)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glMakeImageHandleResidentNV(UInt64 handle, System.Int32 access);
        [Slot(445)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glMakeTextureHandleNonResidentNV(UInt64 handle);
        [Slot(446)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glMakeTextureHandleResidentNV(UInt64 handle);
        [Slot(450)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glMatrixLoad3x2fNV(System.Int32 matrixMode, Single* m);
        [Slot(451)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glMatrixLoad3x3fNV(System.Int32 matrixMode, Single* m);
        [Slot(452)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glMatrixLoadTranspose3x3fNV(System.Int32 matrixMode, Single* m);
        [Slot(453)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glMatrixMult3x2fNV(System.Int32 matrixMode, Single* m);
        [Slot(454)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glMatrixMult3x3fNV(System.Int32 matrixMode, Single* m);
        [Slot(455)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glMatrixMultTranspose3x3fNV(System.Int32 matrixMode, Single* m);
        [Slot(467)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glNamedFramebufferSampleLocationsfvNV(UInt32 framebuffer, UInt32 start, Int32 count, Single* v);
        [Slot(474)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glPathColorGenNV(System.Int32 color, System.Int32 genMode, System.Int32 colorFormat, [CountAttribute(Computed = "genMode,colorFormat")] Single* coeffs);
        [Slot(475)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glPathCommandsNV(UInt32 path, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, System.Int32 coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords);
        [Slot(476)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPathCoordsNV(UInt32 path, Int32 numCoords, System.Int32 coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords);
        [Slot(477)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPathCoverDepthFuncNV(System.Int32 func);
        [Slot(478)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glPathDashArrayNV(UInt32 path, Int32 dashCount, [CountAttribute(Parameter = "dashCount")] Single* dashArray);
        [Slot(479)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPathFogGenNV(System.Int32 genMode);
        [Slot(480)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern System.Int32 glPathGlyphIndexArrayNV(UInt32 firstPathName, System.Int32 fontTarget, IntPtr fontName, UInt32 fontStyle, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale);
        [Slot(481)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern System.Int32 glPathGlyphIndexRangeNV(System.Int32 fontTarget, IntPtr fontName, UInt32 fontStyle, UInt32 pathParameterTemplate, Single emScale, UInt32 baseAndCount);
        [Slot(482)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPathGlyphRangeNV(UInt32 firstPathName, System.Int32 fontTarget, [CountAttribute(Computed = "fontTarget,fontName")] IntPtr fontName, UInt32 fontStyle, UInt32 firstGlyph, Int32 numGlyphs, System.Int32 handleMissingGlyphs, UInt32 pathParameterTemplate, Single emScale);
        [Slot(483)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPathGlyphsNV(UInt32 firstPathName, System.Int32 fontTarget, [CountAttribute(Computed = "fontTarget,fontName")] IntPtr fontName, UInt32 fontStyle, Int32 numGlyphs, System.Int32 type, [CountAttribute(Computed = "numGlyphs,type,charcodes")] IntPtr charcodes, System.Int32 handleMissingGlyphs, UInt32 pathParameterTemplate, Single emScale);
        [Slot(484)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern System.Int32 glPathMemoryGlyphIndexArrayNV(UInt32 firstPathName, System.Int32 fontTarget, IntPtr fontSize, IntPtr fontData, Int32 faceIndex, UInt32 firstGlyphIndex, Int32 numGlyphs, UInt32 pathParameterTemplate, Single emScale);
        [Slot(485)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPathParameterfNV(UInt32 path, System.Int32 pname, Single value);
        [Slot(486)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glPathParameterfvNV(UInt32 path, System.Int32 pname, [CountAttribute(Computed = "pname")] Single* value);
        [Slot(487)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPathParameteriNV(UInt32 path, System.Int32 pname, Int32 value);
        [Slot(488)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glPathParameterivNV(UInt32 path, System.Int32 pname, [CountAttribute(Computed = "pname")] Int32* value);
        [Slot(489)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPathStencilDepthOffsetNV(Single factor, Single units);
        [Slot(490)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPathStencilFuncNV(System.Int32 func, Int32 @ref, UInt32 mask);
        [Slot(491)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPathStringNV(UInt32 path, System.Int32 format, Int32 length, [CountAttribute(Parameter = "length")] IntPtr pathString);
        [Slot(492)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glPathSubCommandsNV(UInt32 path, Int32 commandStart, Int32 commandsToDelete, Int32 numCommands, [CountAttribute(Parameter = "numCommands")] Byte* commands, Int32 numCoords, System.Int32 coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords);
        [Slot(493)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPathSubCoordsNV(UInt32 path, Int32 coordStart, Int32 numCoords, System.Int32 coordType, [CountAttribute(Computed = "numCoords,coordType")] IntPtr coords);
        [Slot(494)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glPathTexGenNV(System.Int32 texCoordSet, System.Int32 genMode, Int32 components, [CountAttribute(Computed = "genMode,components")] Single* coeffs);
        [Slot(497)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe byte glPointAlongPathNV(UInt32 path, Int32 startSegment, Int32 numSegments, Single distance, [OutAttribute, CountAttribute(Count = 1)] Single* x, [OutAttribute, CountAttribute(Count = 1)] Single* y, [OutAttribute, CountAttribute(Count = 1)] Single* tangentX, [OutAttribute, CountAttribute(Count = 1)] Single* tangentY);
        [Slot(498)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPolygonModeNV(System.Int32 face, System.Int32 mode);
        [Slot(510)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramPathFragmentInputGenNV(UInt32 program, Int32 location, System.Int32 genMode, Int32 components, Single* coeffs);
        [Slot(516)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform1i64NV(UInt32 program, Int32 location, Int64 x);
        [Slot(517)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform1i64vNV(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] Int64* value);
        [Slot(522)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform1ui64NV(UInt32 program, Int32 location, UInt64 x);
        [Slot(523)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform1ui64vNV(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64* value);
        [Slot(532)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform2i64NV(UInt32 program, Int32 location, Int64 x, Int64 y);
        [Slot(533)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform2i64vNV(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int64* value);
        [Slot(538)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform2ui64NV(UInt32 program, Int32 location, UInt64 x, UInt64 y);
        [Slot(539)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform2ui64vNV(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt64* value);
        [Slot(548)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform3i64NV(UInt32 program, Int32 location, Int64 x, Int64 y, Int64 z);
        [Slot(549)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform3i64vNV(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int64* value);
        [Slot(554)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform3ui64NV(UInt32 program, Int32 location, UInt64 x, UInt64 y, UInt64 z);
        [Slot(555)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform3ui64vNV(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt64* value);
        [Slot(564)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform4i64NV(UInt32 program, Int32 location, Int64 x, Int64 y, Int64 z, Int64 w);
        [Slot(565)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform4i64vNV(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int64* value);
        [Slot(570)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniform4ui64NV(UInt32 program, Int32 location, UInt64 x, UInt64 y, UInt64 z, UInt64 w);
        [Slot(571)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniform4ui64vNV(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt64* value);
        [Slot(576)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramUniformHandleui64NV(UInt32 program, Int32 location, UInt64 value);
        [Slot(578)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glProgramUniformHandleui64vNV(UInt32 program, Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64* values);
        [Slot(604)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glReadBufferNV(System.Int32 mode);
        [Slot(617)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glRenderbufferStorageMultisampleNV(System.Int32 target, Int32 samples, System.Int32 internalformat, Int32 width, Int32 height);
        [Slot(618)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glResolveDepthValuesNV();
        [Slot(632)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glScissorArrayvNV(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] Int32* v);
        [Slot(634)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glScissorIndexedNV(UInt32 index, Int32 left, Int32 bottom, Int32 width, Int32 height);
        [Slot(636)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glScissorIndexedvNV(UInt32 index, [CountAttribute(Count = 4)] Int32* v);
        [Slot(640)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glSetFenceNV(UInt32 fence, System.Int32 condition);
        [Slot(644)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glSignalVkFenceNV(UInt64 vkFence);
        [Slot(645)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glSignalVkSemaphoreNV(UInt64 vkSemaphore);
        [Slot(647)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glStencilFillPathInstancedNV(Int32 numPaths, System.Int32 pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, System.Int32 fillMode, UInt32 mask, System.Int32 transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues);
        [Slot(648)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glStencilFillPathNV(UInt32 path, System.Int32 fillMode, UInt32 mask);
        [Slot(655)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glStencilStrokePathInstancedNV(Int32 numPaths, System.Int32 pathNameType, [CountAttribute(Computed = "numPaths,pathNameType,paths")] IntPtr paths, UInt32 pathBase, Int32 reference, UInt32 mask, System.Int32 transformType, [CountAttribute(Computed = "numPaths,transformType")] Single* transformValues);
        [Slot(656)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glStencilStrokePathNV(UInt32 path, Int32 reference, UInt32 mask);
        [Slot(657)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glStencilThenCoverFillPathInstancedNV(Int32 numPaths, System.Int32 pathNameType, IntPtr paths, UInt32 pathBase, System.Int32 fillMode, UInt32 mask, System.Int32 coverMode, System.Int32 transformType, Single* transformValues);
        [Slot(658)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glStencilThenCoverFillPathNV(UInt32 path, System.Int32 fillMode, UInt32 mask, System.Int32 coverMode);
        [Slot(659)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glStencilThenCoverStrokePathInstancedNV(Int32 numPaths, System.Int32 pathNameType, IntPtr paths, UInt32 pathBase, Int32 reference, UInt32 mask, System.Int32 coverMode, System.Int32 transformType, Single* transformValues);
        [Slot(660)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glStencilThenCoverStrokePathNV(UInt32 path, Int32 reference, UInt32 mask, System.Int32 coverMode);
        [Slot(661)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glSubpixelPrecisionBiasNV(UInt32 xbits, UInt32 ybits);
        [Slot(662)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glTestFenceNV(UInt32 fence);
        [Slot(705)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glTransformPathNV(UInt32 resultPath, UInt32 srcPath, System.Int32 transformType, [CountAttribute(Computed = "transformType")] Single* transformValues);
        [Slot(709)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform1i64NV(Int32 location, Int64 x);
        [Slot(710)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform1i64vNV(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] Int64* value);
        [Slot(713)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform1ui64NV(Int32 location, UInt64 x);
        [Slot(714)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform1ui64vNV(Int32 location, Int32 count, [CountAttribute(Parameter = "count*1")] UInt64* value);
        [Slot(719)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform2i64NV(Int32 location, Int64 x, Int64 y);
        [Slot(720)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform2i64vNV(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] Int64* value);
        [Slot(723)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform2ui64NV(Int32 location, UInt64 x, UInt64 y);
        [Slot(724)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform2ui64vNV(Int32 location, Int32 count, [CountAttribute(Parameter = "count*2")] UInt64* value);
        [Slot(729)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform3i64NV(Int32 location, Int64 x, Int64 y, Int64 z);
        [Slot(730)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform3i64vNV(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] Int64* value);
        [Slot(733)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform3ui64NV(Int32 location, UInt64 x, UInt64 y, UInt64 z);
        [Slot(734)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform3ui64vNV(Int32 location, Int32 count, [CountAttribute(Parameter = "count*3")] UInt64* value);
        [Slot(739)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform4i64NV(Int32 location, Int64 x, Int64 y, Int64 z, Int64 w);
        [Slot(740)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform4i64vNV(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] Int64* value);
        [Slot(743)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniform4ui64NV(Int32 location, UInt64 x, UInt64 y, UInt64 z, UInt64 w);
        [Slot(744)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniform4ui64vNV(Int32 location, Int32 count, [CountAttribute(Parameter = "count*4")] UInt64* value);
        [Slot(748)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glUniformHandleui64NV(Int32 location, UInt64 value);
        [Slot(750)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformHandleui64vNV(Int32 location, Int32 count, [CountAttribute(Parameter = "count")] UInt64* value);
        [Slot(753)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix2x3fvNV(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value);
        [Slot(755)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix2x4fvNV(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value);
        [Slot(758)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix3x2fvNV(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*6")] Single* value);
        [Slot(760)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix3x4fvNV(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value);
        [Slot(763)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix4x2fvNV(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*8")] Single* value);
        [Slot(765)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glUniformMatrix4x3fvNV(Int32 location, Int32 count, bool transpose, [CountAttribute(Parameter = "count*12")] Single* value);
        [Slot(787)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glVertexAttribDivisorNV(UInt32 index, UInt32 divisor);
        [Slot(798)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glViewportArrayvNV(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] Single* v);
        [Slot(800)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glViewportIndexedfNV(UInt32 index, Single x, Single y, Single w, Single h);
        [Slot(802)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glViewportIndexedfvNV(UInt32 index, [CountAttribute(Count = 4)] Single* v);
        [Slot(804)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glViewportSwizzleNV(UInt32 index, System.Int32 swizzlex, System.Int32 swizzley, System.Int32 swizzlez, System.Int32 swizzlew);
        [Slot(808)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glWaitVkSemaphoreNV(UInt64 vkSemaphore);
        [Slot(809)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glWeightPathsNV(UInt32 resultPath, Int32 numPaths, [CountAttribute(Parameter = "numPaths")] UInt32* paths, [CountAttribute(Parameter = "numPaths")] Single* weights);
        [Slot(29)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBindVertexArrayOES(UInt32 array);
        [Slot(37)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendEquationiOES(UInt32 buf, System.Int32 mode);
        [Slot(40)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendEquationSeparateiOES(UInt32 buf, System.Int32 modeRGB, System.Int32 modeAlpha);
        [Slot(43)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendFunciOES(UInt32 buf, System.Int32 src, System.Int32 dst);
        [Slot(46)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glBlendFuncSeparateiOES(UInt32 buf, System.Int32 srcRGB, System.Int32 dstRGB, System.Int32 srcAlpha, System.Int32 dstAlpha);
        [Slot(72)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glColorMaskiOES(UInt32 index, bool r, bool g, bool b, bool a);
        [Slot(76)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCompressedTexImage3DOES(System.Int32 target, Int32 level, System.Int32 internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data);
        [Slot(79)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCompressedTexSubImage3DOES(System.Int32 target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, System.Int32 format, Int32 imageSize, [CountAttribute(Parameter = "imageSize")] IntPtr data);
        [Slot(84)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCopyImageSubDataOES(UInt32 srcName, System.Int32 srcTarget, Int32 srcLevel, Int32 srcX, Int32 srcY, Int32 srcZ, UInt32 dstName, System.Int32 dstTarget, Int32 dstLevel, Int32 dstX, Int32 dstY, Int32 dstZ, Int32 srcWidth, Int32 srcHeight, Int32 srcDepth);
        [Slot(89)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glCopyTexSubImage3DOES(System.Int32 target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height);
        [Slot(134)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDeleteVertexArraysOES(Int32 n, [CountAttribute(Parameter = "n")] UInt32* arrays);
        [Slot(138)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glDepthRangeArrayfvOES(UInt32 first, Int32 count, Single* v);
        [Slot(141)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDepthRangeIndexedfOES(UInt32 index, Single n, Single f);
        [Slot(147)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDisableiOES(System.Int32 target, UInt32 index);
        [Slot(165)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawElementsBaseVertexOES(System.Int32 mode, Int32 count, System.Int32 type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex);
        [Slot(172)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawElementsInstancedBaseVertexOES(System.Int32 mode, Int32 count, System.Int32 type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 instancecount, Int32 basevertex);
        [Slot(177)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDrawRangeElementsBaseVertexOES(System.Int32 mode, UInt32 start, UInt32 end, Int32 count, System.Int32 type, [CountAttribute(Computed = "count,type")] IntPtr indices, Int32 basevertex);
        [Slot(181)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEGLImageTargetRenderbufferStorageOES(System.Int32 target, IntPtr image);
        [Slot(182)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEGLImageTargetTexture2DOES(System.Int32 target, IntPtr image);
        [Slot(187)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEnableiOES(System.Int32 target, UInt32 index);
        [Slot(227)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferTexture3DOES(System.Int32 target, System.Int32 attachment, System.Int32 textarget, UInt32 texture, Int32 level, Int32 zoffset);
        [Slot(233)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferTextureOES(System.Int32 target, System.Int32 attachment, UInt32 texture, Int32 level);
        [Slot(251)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGenVertexArraysOES(Int32 n, [OutAttribute, CountAttribute(Parameter = "n")] UInt32* arrays);
        [Slot(264)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glGetBufferPointervOES(System.Int32 target, System.Int32 pname, [OutAttribute] IntPtr @params);
        [Slot(274)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetFloati_vOES(System.Int32 target, UInt32 index, [OutAttribute, CountAttribute(Computed = "target")] Single* data);
        [Slot(335)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetProgramBinaryOES(UInt32 program, Int32 bufSize, [OutAttribute, CountAttribute(Count = 1)] Int32* length, [OutAttribute, CountAttribute(Count = 1)] System.Int32* binaryFormat, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr binary);
        [Slot(359)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetSamplerParameterIivOES(UInt32 sampler, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(361)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetSamplerParameterIuivOES(UInt32 sampler, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32* @params);
        [Slot(376)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetTexParameterIivOES(System.Int32 target, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(378)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetTexParameterIuivOES(System.Int32 target, System.Int32 pname, [OutAttribute, CountAttribute(Computed = "pname")] UInt32* @params);
        [Slot(416)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsEnablediOES(System.Int32 target, UInt32 index);
        [Slot(439)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glIsVertexArrayOES(UInt32 array);
        [Slot(447)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr glMapBufferOES(System.Int32 target, System.Int32 access);
        [Slot(459)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glMinSampleShadingOES(Single value);
        [Slot(473)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPatchParameteriOES(System.Int32 pname, Int32 value);
        [Slot(505)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glPrimitiveBoundingBoxOES(Single minX, Single minY, Single minZ, Single minW, Single maxX, Single maxY, Single maxZ, Single maxW);
        [Slot(507)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glProgramBinaryOES(UInt32 program, System.Int32 binaryFormat, [CountAttribute(Parameter = "length")] IntPtr binary, Int32 length);
        [Slot(627)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glSamplerParameterIivOES(UInt32 sampler, System.Int32 pname, [CountAttribute(Computed = "pname")] Int32* param);
        [Slot(629)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glSamplerParameterIuivOES(UInt32 sampler, System.Int32 pname, [CountAttribute(Computed = "pname")] UInt32* param);
        [Slot(633)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glScissorArrayvOES(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] Int32* v);
        [Slot(635)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glScissorIndexedOES(UInt32 index, Int32 left, Int32 bottom, Int32 width, Int32 height);
        [Slot(637)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glScissorIndexedvOES(UInt32 index, [CountAttribute(Count = 4)] Int32* v);
        [Slot(664)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexBufferOES(System.Int32 target, System.Int32 internalformat, UInt32 buffer);
        [Slot(666)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexBufferRangeOES(System.Int32 target, System.Int32 internalformat, UInt32 buffer, IntPtr offset, IntPtr size);
        [Slot(669)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexImage3DOES(System.Int32 target, Int32 level, System.Int32 internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, System.Int32 format, System.Int32 type, [CountAttribute(Computed = "format,type,width,height,depth")] IntPtr pixels);
        [Slot(675)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glTexParameterIivOES(System.Int32 target, System.Int32 pname, [CountAttribute(Computed = "pname")] Int32* @params);
        [Slot(677)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glTexParameterIuivOES(System.Int32 target, System.Int32 pname, [CountAttribute(Computed = "pname")] UInt32* @params);
        [Slot(685)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexStorage3DMultisampleOES(System.Int32 target, Int32 samples, System.Int32 internalformat, Int32 width, Int32 height, Int32 depth, bool fixedsamplelocations);
        [Slot(693)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTexSubImage3DOES(System.Int32 target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, System.Int32 format, System.Int32 type, [CountAttribute(Computed = "format,type,width,height,depth")] IntPtr pixels);
        [Slot(703)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glTextureViewOES(UInt32 texture, System.Int32 target, UInt32 origtexture, System.Int32 internalformat, UInt32 minlevel, UInt32 numlevels, UInt32 minlayer, UInt32 numlayers);
        [Slot(767)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glUnmapBufferOES(System.Int32 target);
        [Slot(799)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glViewportArrayvOES(UInt32 first, Int32 count, [CountAttribute(Computed = "count")] Single* v);
        [Slot(801)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glViewportIndexedfOES(UInt32 index, Single x, Single y, Single w, Single h);
        [Slot(803)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glViewportIndexedfvOES(UInt32 index, [CountAttribute(Count = 4)] Single* v);
        [Slot(231)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferTextureMultisampleMultiviewOVR(System.Int32 target, System.Int32 attachment, UInt32 texture, Int32 level, Int32 samples, Int32 baseViewIndex, Int32 numViews);
        [Slot(232)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferTextureMultiviewOVR(System.Int32 target, System.Int32 attachment, UInt32 texture, Int32 level, Int32 baseViewIndex, Int32 numViews);
        [Slot(5)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glAlphaFuncQCOM(System.Int32 func, Single @ref);
        [Slot(144)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glDisableDriverControlQCOM(UInt32 driverControl);
        [Slot(184)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEnableDriverControlQCOM(UInt32 driverControl);
        [Slot(194)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glEndTilingQCOM(UInt32 preserveMask);
        [Slot(196)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glExtGetBufferPointervQCOM(System.Int32 target, [OutAttribute] IntPtr @params);
        [Slot(197)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glExtGetBuffersQCOM([OutAttribute, CountAttribute(Parameter = "maxBuffers")] UInt32* buffers, Int32 maxBuffers, [OutAttribute, CountAttribute(Count = 1)] Int32* numBuffers);
        [Slot(198)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glExtGetFramebuffersQCOM([OutAttribute, CountAttribute(Parameter = "maxFramebuffers")] UInt32* framebuffers, Int32 maxFramebuffers, [OutAttribute, CountAttribute(Count = 1)] Int32* numFramebuffers);
        [Slot(199)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glExtGetProgramBinarySourceQCOM(UInt32 program, System.Int32 shadertype, [OutAttribute] IntPtr source, [OutAttribute] Int32* length);
        [Slot(200)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glExtGetProgramsQCOM([OutAttribute, CountAttribute(Parameter = "maxPrograms")] UInt32* programs, Int32 maxPrograms, [OutAttribute, CountAttribute(Count = 1)] Int32* numPrograms);
        [Slot(201)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glExtGetRenderbuffersQCOM([OutAttribute, CountAttribute(Parameter = "maxRenderbuffers")] UInt32* renderbuffers, Int32 maxRenderbuffers, [OutAttribute, CountAttribute(Count = 1)] Int32* numRenderbuffers);
        [Slot(202)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glExtGetShadersQCOM([OutAttribute, CountAttribute(Parameter = "maxShaders")] UInt32* shaders, Int32 maxShaders, [OutAttribute, CountAttribute(Count = 1)] Int32* numShaders);
        [Slot(203)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glExtGetTexLevelParameterivQCOM(UInt32 texture, System.Int32 face, Int32 level, System.Int32 pname, [OutAttribute] Int32* @params);
        [Slot(204)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glExtGetTexSubImageQCOM(System.Int32 target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, System.Int32 format, System.Int32 type, [OutAttribute] IntPtr texels);
        [Slot(205)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glExtGetTexturesQCOM([OutAttribute] UInt32* textures, Int32 maxTextures, [OutAttribute] Int32* numTextures);
        [Slot(206)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern byte glExtIsProgramBinaryQCOM(UInt32 program);
        [Slot(207)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glExtTexObjectStateOverrideiQCOM(System.Int32 target, System.Int32 pname, Int32 param);
        [Slot(216)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferFetchBarrierQCOM();
        [Slot(217)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glFramebufferFoveationConfigQCOM(UInt32 framebuffer, UInt32 numLayers, UInt32 focalPointsPerLayer, UInt32 requestedFeatures, [OutAttribute, CountAttribute(Count = 1)] UInt32* providedFeatures);
        [Slot(218)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glFramebufferFoveationParametersQCOM(UInt32 framebuffer, UInt32 layer, UInt32 focalPoint, Single focalX, Single focalY, Single gainX, Single gainY, Single foveaArea);
        [Slot(268)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetDriverControlsQCOM([OutAttribute] Int32* num, Int32 size, [OutAttribute, CountAttribute(Parameter = "size")] UInt32* driverControls);
        [Slot(269)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern unsafe void glGetDriverControlStringQCOM(UInt32 driverControl, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute, CountAttribute(Parameter = "bufSize")] IntPtr driverControlString);
        [Slot(646)]
        [DllImport(Library, ExactSpelling = true, CallingConvention = CallingConvention.Winapi)]
        private static extern void glStartTilingQCOM(UInt32 x, UInt32 y, UInt32 width, UInt32 height, UInt32 preserveMask);
    }
}
