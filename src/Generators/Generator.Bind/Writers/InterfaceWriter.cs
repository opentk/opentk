//
// InterfaceWriter.cs
//
// Copyright (C) 2019 OpenTK
//
// This software may be modified and distributed under the terms
// of the MIT license. See the LICENSE file for details.
//

using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Bind.Structure;
using Bind.XML.Documentation;
using Bind.XML.Signatures.Functions;

namespace Bind.Writers
{
    /// <summary>
    /// Writes C# interfaces and meta-interfaces from <see cref="FunctionSignature"/>s.
    /// </summary>
    public static class InterfaceWriter
    {
        /// <summary>
        /// Writes a meta-interface (an empty interface implementing the given child interfaces) to a C# source file.
        /// </summary>
        /// <param name="ns">The namespace of the meta-interface.</param>
        /// <param name="file">The source file to write the meta-interface to.</param>
        /// <param name="name">The name of the meta-interface, without the "I" prefix.</param>
        /// <param name="ints">A set of child interfaces to implement.</param>
        /// <returns>An asynchronous task.</returns>
        public static async Task WriteMetaInterfaceAsync(string ns, string file, string name, IEnumerable<string> ints)
        {
            var interfaces = ints.ToArray();
            using (var sw = new StreamWriter(File.Open(file, FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable)))
            {
                sw.WriteLine("// <auto-generated />");
                sw.Write(EmbeddedResources.LicenseText(Path.GetFileName(file)));
                sw.WriteLine();
                sw.WriteLine("namespace " + ns);
                sw.WriteLine("{");
                sw.Write("    internal interface I" + name + " : " + interfaces[0]);
                for (var i = 1; i < interfaces.Length; i++)
                {
                    sw.WriteLine(",");
                    sw.Write("        " + interfaces[i]);
                }

                sw.WriteLine();
                sw.WriteLine("    {");
                sw.WriteLine("    }");
                sw.WriteLine("}");
                await sw.FlushAsync();
            }
        }

        /// <summary>
        /// Asynchronously writes this interface to a file.
        /// </summary>
        /// <param name="i">The interface.</param>
        /// <param name="file">The file to write to.</param>
        /// <param name="ns">This interface's namespace.</param>
        /// <param name="prefix">The function prefix for this interface.</param>
        /// <param name="doc">The profile's documentation.</param>
        /// <param name="rootNamespace">The profile's root namespace.</param>
        /// <returns>The asynchronous task.</returns>
        public static async Task WriteInterfaceAsync(this Interface i, string file, string ns, string prefix, ProfileDocumentation doc, string rootNamespace)
        {
            using (var sw = new StreamWriter(File.Open(file, FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable)))
            {
                sw.WriteLine("// <auto-generated />");
                sw.WriteLine(EmbeddedResources.LicenseText(Path.GetFileName(file)));
                sw.WriteLine("using AdvancedDLSupport;");
                sw.WriteLine("using " + rootNamespace + ";");
                sw.WriteLine("using OpenToolkit.Core.Native;");
                sw.WriteLine("using System;");
                sw.WriteLine("using System.Runtime.InteropServices;");
                sw.WriteLine("using System.Text;");
                sw.WriteLine();
                sw.WriteLine("namespace " + ns);
                sw.WriteLine("{");
                sw.WriteLine("    internal interface " + i.InterfaceName);
                sw.Write("    {");
                foreach (var function in i.Functions)
                {
                    sw.WriteLine();
                    using (var sr = new StringReader(Utilities.GetDocumentation(function, doc)))
                    {
                        string line;
                        while ((line = await sr.ReadLineAsync()) != null)
                        {
                            sw.WriteLine("        " + line);
                        }
                    }

                    if (function.IsDeprecated)
                    {
                        var str = "Deprecated";
                        if (function.DeprecatedIn != null)
                        {
                            str += " since " + function.DeprecatedIn.ToString(2);
                        }

                        if (!string.IsNullOrWhiteSpace(function.DeprecationReason))
                        {
                            str += " - " + function.DeprecationReason;
                        }

                        sw.WriteLine($"        [Obsolete(\"{str}\")]");
                    }

                    sw.WriteLine
                    (
                        "        [NativeSymbol(\"" + prefix + function.NativeEntrypoint + "\")]"
                    );

                    sw.WriteLine
                    (
                        "        " +
                        "[AutoGenerated(" +
                        $"Category = \"{function.Categories.First()}\", " +
                        $"Version = \"{function.IntroducedIn}\", " +
                        $"EntryPoint = \"{prefix}{function.NativeEntrypoint}\", " +
                        $"Source = \"{function.Source}\"" +
                        ")]"
                    );

                    using (var sr = new StringReader(Utilities.GetDeclarationString(function) + ";"))
                    {
                        string line;
                        while ((line = await sr.ReadLineAsync()) != null)
                        {
                            sw.WriteLine("        " + line);
                        }
                    }
                }

                sw.WriteLine("    }");
                sw.WriteLine("}");
                await sw.FlushAsync();
            }
        }
    }
}
