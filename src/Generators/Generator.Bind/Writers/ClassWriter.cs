//
// ClassWriter.cs
//
// Copyright (C) 2019 OpenTK
//
// This software may be modified and distributed under the terms
// of the MIT license. See the LICENSE file for details.
//

using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Bind.Generators;
using Bind.Structure;
using Bind.Translation.Translators;
using Bind.XML.Documentation;

namespace Bind.Writers
{
    /// <summary>
    /// Contains methods to write mixed-mode classes for projects, to be used with AdvancedDLSupport.
    /// </summary>
    internal static class ClassWriter
    {
        /// <summary>
        /// Writes a mixed mode class for the given project.
        /// </summary>
        /// <param name="project">The project to write a mixed-mode class for.</param>
        /// <param name="settings">The generator settings used to configure the mixed-mode class writer.</param>
        /// <param name="docs">The profile's documentation, used to write summaries to overloads.</param>
        /// <returns>An asynchronous task.</returns>
        public static async Task WriteMixedModeClassAsync(Project project, IGeneratorSettings settings, ProfileDocumentation docs)
        {
            var ext = project.Extension != "Core";
            var ns = project.Extension == "Core"
                ? settings.Namespace
                : settings.ExtensionNamespace + "." + Utilities.ConvertExtensionNameToNamespace(project.Extension);
            var dir = project.Extension == "Core"
                ? Path.Combine(Program.Arguments.OutputPath, settings.OutputSubfolder, settings.Namespace, settings.ClassName)
                : Path.Combine(Program.Arguments.OutputPath, settings.OutputSubfolder, ProfileWriter.ExtensionsFolder, ns);
            await WriteOverloadsMixedModePartAsync(project, settings, docs);
            await WriteNativeMixedModePartAsync(project, settings);
            if (!File.Exists(Path.Combine(dir, $"{settings.ClassName}.cs")) && !ext)
            {
                await WriteTemplateMixedModePartAsync(project, settings);
            }
        }

        private static async Task WriteNativeMixedModePartAsync(Project project, IGeneratorSettings settings)
        {
            var ns = project.Extension == "Core"
                ? settings.Namespace
                : settings.ExtensionNamespace + "." + Utilities.ConvertExtensionNameToNamespace(project.Extension);
            var dir = project.Extension == "Core"
                ? Path.Combine(Program.Arguments.OutputPath, settings.OutputSubfolder, settings.Namespace, settings.ClassName)
                : Path.Combine(Program.Arguments.OutputPath, settings.OutputSubfolder, ProfileWriter.ExtensionsFolder, ns);
            var file = project.Extension == "Core"
                ? settings.ClassName
                : NativeIdentifierTranslator.TranslateIdentifierName(project.Extension);
            using (var sw = new StreamWriter(File.Open(Path.Combine(dir, file + ".Native.cs"), FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable)))
            {
                sw.WriteLine("// <auto-generated />");
                sw.WriteLine(EmbeddedResources.LicenseText(Path.GetFileName(file)));
                sw.WriteLine("using AdvancedDLSupport;");
                sw.WriteLine("using OpenToolkit.Core.Native;");
                sw.WriteLine("using OpenToolkit.Core.Loader;");
                sw.WriteLine("using OpenToolkit.Core.Extensions;");
                sw.WriteLine("using " + settings.Namespace + ";");
                sw.WriteLine("using System;");
                sw.WriteLine("using System.Runtime.InteropServices;");
                sw.WriteLine("using System.Text;");
                sw.WriteLine();
                sw.WriteLine("namespace " + ns);
                sw.WriteLine("{");
                if (project.Extension != "Core")
                {
                    sw.WriteLine($"    [Extension(\"{settings.ConstantPrefix}{project.Extension}\")]");
                }

                sw.Write("    public abstract partial class " + file);
                if (project.Extension != "Core")
                {
                    sw.WriteLine(" : ExtensionBase, I" + file);
                    sw.WriteLine("    {");
                    sw.WriteLine("        /// <inheritdoc cref=\"ExtensionBase\"/>");
                    sw.WriteLine($"        protected {file}(string path, ImplementationOptions options)");
                    sw.WriteLine("            : base(path, options)");
                    sw.WriteLine("        {");
                    sw.WriteLine("        }");
                    sw.WriteLine();
                }
                else
                {
                    sw.WriteLine();
                    sw.WriteLine("    {");
                }

                foreach (var function in project.Interfaces.SelectMany(x => x.Functions))
                {
                    sw.WriteLine("        /// <inheritdoc/>");

                    if (function.IsDeprecated)
                    {
                        var str = "Deprecated";
                        if (function.DeprecatedIn != null)
                        {
                            str += " since " + function.DeprecatedIn.ToString(2);
                        }

                        if (!string.IsNullOrWhiteSpace(function.DeprecationReason))
                        {
                            str += " - " + function.DeprecationReason;
                        }

                        sw.WriteLine($"        [Obsolete(\"{str}\")]");
                    }

                    sw.Write("        public abstract ");
                    sw.WriteLine(Utilities.GetDeclarationString(function) + ";");
                    sw.WriteLine();
                }

                sw.WriteLine("    }");
                sw.WriteLine("}");
                await sw.FlushAsync();
            }
        }

        private static async Task WriteOverloadsMixedModePartAsync(Project project, IGeneratorSettings settings, ProfileDocumentation docs)
        {
            var file = project.Extension == "Core"
                ? settings.ClassName
                : NativeIdentifierTranslator.TranslateIdentifierName(project.Extension);
            var ns = project.Extension == "Core"
                ? settings.Namespace
                : settings.ExtensionNamespace + "." + Utilities.ConvertExtensionNameToNamespace(project.Extension);
            var dir = project.Extension == "Core"
                ? Path.Combine(Program.Arguments.OutputPath, settings.OutputSubfolder, settings.Namespace, settings.ClassName)
                : Path.Combine(Program.Arguments.OutputPath, settings.OutputSubfolder, ProfileWriter.ExtensionsFolder, ns);
            using (var sw = new StreamWriter(File.Open(Path.Combine(dir, file + ".Overloads.cs"), FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable)))
            {
                sw.WriteLine("// <auto-generated />");
                sw.WriteLine(EmbeddedResources.LicenseText(Path.GetFileName(file)));
                sw.WriteLine("using AdvancedDLSupport;");
                sw.WriteLine("using OpenToolkit.Core.Native;");
                sw.WriteLine("using OpenToolkit.Core.Extensions;");
                sw.WriteLine("using System;");
                sw.WriteLine("using System.Runtime.InteropServices;");
                sw.WriteLine("using System.Text;");
                sw.WriteLine("using " + settings.Namespace + ";");
                sw.WriteLine();
                sw.WriteLine("namespace " + ns);
                sw.WriteLine("{");
                sw.WriteLine("    /// <summary>");
                sw.WriteLine("    /// Contains bindings to the " + settings.APIIdentifier + " API.");
                sw.WriteLine("    /// </summary>");
                sw.WriteLine("    public partial class " + file);
                sw.WriteLine("    {");
                foreach (var overload in project.Overloads)
                {
                    sw.WriteLine("        /// <summary>");
                    if (docs.HasDocumentation(overload.Item1))
                    {
                        sw.WriteLine("        /// " + docs.GetDocumentation(overload.Item1)?.Purpose);
                    }
                    else
                    {
                        sw.WriteLine("        /// To be added.");
                    }

                    sw.WriteLine("        /// </summary>");

                    if (overload.Item1.IsDeprecated)
                    {
                        var str = "Deprecated";
                        if (overload.Item1.DeprecatedIn != null)
                        {
                            str += " since " + overload.Item1.DeprecatedIn.ToString(2);
                        }

                        if (!string.IsNullOrWhiteSpace(overload.Item1.DeprecationReason))
                        {
                            str += " - " + overload.Item1.DeprecationReason;
                        }

                        sw.WriteLine($"        [Obsolete(\"{str}\")]");
                    }

                    sw.WriteLine(
                        "        " +
                        "[AutoGenerated(" +
                        $"Category = \"{overload.Item1.Categories.First()}\", " +
                        $"Version = \"{overload.Item1.IntroducedIn}\", " +
                        $"EntryPoint = \"{settings.FunctionPrefix}{overload.Item1.NativeEntrypoint}\", " +
                        $"Source = \"{overload.Item1.Source}\"" +
                        ")]");

                    sw.Write("        public ");
                    var decl = Utilities.GetDeclarationString(overload.Item1);
                    if (!decl.Contains("unsafe "))
                    {
                        sw.Write("unsafe ");
                    }

                    sw.WriteLine(decl);
                    sw.WriteLine("        {");
                    foreach (var line in overload.Item2.ToString()
                        .Split(new[] { '\n' }, StringSplitOptions.RemoveEmptyEntries))
                    {
                        sw.Write("            " + line);
                    }

                    sw.WriteLine("        }");
                    sw.WriteLine();
                }

                sw.WriteLine("    }");
                sw.WriteLine("}");
                await sw.FlushAsync();
            }
        }

        private static async Task WriteTemplateMixedModePartAsync(
            Project project,
            IGeneratorSettings settings)
        {
            var dir = Path.Combine(Program.Arguments.OutputPath, settings.OutputSubfolder, settings.Namespace, settings.ClassName);
            using (var sw = new StreamWriter(File.Open(Path.Combine(dir, settings.ClassName + ".cs"), FileMode.Create, FileAccess.ReadWrite, FileShare.Inheritable)))
            {
                sw.WriteLine(EmbeddedResources.LicenseText(Path.GetFileName(settings.ClassName + ".cs")));
                sw.WriteLine("using System;");
                sw.WriteLine("using System.Runtime.InteropServices;");
                sw.WriteLine("using System.Text;");
                sw.WriteLine("using AdvancedDLSupport;");
                sw.WriteLine("using OpenToolkit.Core.Loader;");
                sw.WriteLine("using OpenToolkit.Core.Native;");
                sw.WriteLine();
                sw.WriteLine("namespace " + settings.Namespace);
                sw.WriteLine("{");
                var nm = settings.NameContainer.ClassName;
                sw.WriteLine("    public partial class " + settings.ClassName + " : NativeLibraryBase, I" + settings.ClassName);
                sw.WriteLine("    {");
                sw.WriteLine("        /// <inheritdoc cref=\"NativeLibraryBase\"/>");
                sw.WriteLine("        protected " + settings.ClassName + "(string path, ImplementationOptions options)");
                sw.WriteLine("            : base(path, options)");
                sw.WriteLine("        {");
                sw.WriteLine("        }");
                sw.WriteLine();
                sw.WriteLine("        /// <summary>");
                sw.WriteLine("        /// Gets the library name container for this profile.");
                sw.WriteLine("        /// </summary>");
                sw.Write("        public IPlatformLibraryNameContainer NameContainer => new");
                sw.WriteLine(" " + nm + "();");
                sw.WriteLine("    }");
                sw.WriteLine("}");
                await sw.FlushAsync();
            }
        }
    }
}
