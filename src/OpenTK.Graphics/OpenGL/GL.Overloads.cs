// This file is auto generated, do not edit.
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using OpenTK.Mathematics;
using OpenTK.Graphics;

namespace OpenTK.Graphics.OpenGL
{
    public static unsafe partial class GL
    {
        public static unsafe void TexParameterf(TextureTarget target, TextureParameterName pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                TexParameterfv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void TexParameterf(TextureTarget target, TextureParameterName pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                TexParameterfv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void TexParameterf(TextureTarget target, TextureParameterName pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters)
            {
                TexParameterfv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void TexParameteri(TextureTarget target, TextureParameterName pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                TexParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void TexParameteri(TextureTarget target, TextureParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                TexParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void TexParameteri(TextureTarget target, TextureParameterName pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                TexParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void TexImage1D(TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            TexImage1D(target, level, internalformat, width, border, format, type, pixels_vptr);
        }
        public static unsafe void TexImage1D<T1>(TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                TexImage1D(target, level, internalformat, width, border, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexImage1D<T1>(TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                TexImage1D(target, level, internalformat, width, border, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexImage1D<T1>(TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                TexImage1D(target, level, internalformat, width, border, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexImage2D(TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            TexImage2D(target, level, internalformat, width, height, border, format, type, pixels_vptr);
        }
        public static unsafe void TexImage2D<T1>(TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                TexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexImage2D<T1>(TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                TexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexImage2D<T1>(TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                TexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
            }
        }
        public static unsafe void ColorMask(bool red, bool green, bool blue, bool alpha)
        {
            byte red_byte = (byte)(red ? 1 : 0);
            byte green_byte = (byte)(green ? 1 : 0);
            byte blue_byte = (byte)(blue ? 1 : 0);
            byte alpha_byte = (byte)(alpha ? 1 : 0);
            ColorMask(red_byte, green_byte, blue_byte, alpha_byte);
        }
        public static unsafe void DepthMask(bool flag)
        {
            byte flag_byte = (byte)(flag ? 1 : 0);
            DepthMask(flag_byte);
        }
        public static unsafe void ReadPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            ReadPixels(x, y, width, height, format, type, pixels_vptr);
        }
        public static unsafe void ReadPixels<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, Span<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                ReadPixels(x, y, width, height, format, type, pixels_ptr);
            }
        }
        public static unsafe void ReadPixels<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                ReadPixels(x, y, width, height, format, type, pixels_ptr);
            }
        }
        public static unsafe void ReadPixels<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                ReadPixels(x, y, width, height, format, type, pixels_ptr);
            }
        }
        public static unsafe void GetBoolean(GetPName pname, Span<byte> data)
        {
            fixed (byte* data_ptr = data)
            {
                GetBooleanv(pname, data_ptr);
            }
        }
        public static unsafe void GetBoolean(GetPName pname, byte[] data)
        {
            fixed (byte* data_ptr = data)
            {
                GetBooleanv(pname, data_ptr);
            }
        }
        public static unsafe void GetBoolean(GetPName pname, ref byte data)
        {
            fixed (byte* data_ptr = &data)
            {
                GetBooleanv(pname, data_ptr);
            }
        }
        public static unsafe void GetDouble(GetPName pname, Span<double> data)
        {
            fixed (double* data_ptr = data)
            {
                GetDoublev(pname, data_ptr);
            }
        }
        public static unsafe void GetDouble(GetPName pname, double[] data)
        {
            fixed (double* data_ptr = data)
            {
                GetDoublev(pname, data_ptr);
            }
        }
        public static unsafe void GetDouble(GetPName pname, ref double data)
        {
            fixed (double* data_ptr = &data)
            {
                GetDoublev(pname, data_ptr);
            }
        }
        public static unsafe void GetFloat(GetPName pname, Span<float> data)
        {
            fixed (float* data_ptr = data)
            {
                GetFloatv(pname, data_ptr);
            }
        }
        public static unsafe void GetFloat(GetPName pname, float[] data)
        {
            fixed (float* data_ptr = data)
            {
                GetFloatv(pname, data_ptr);
            }
        }
        public static unsafe void GetFloat(GetPName pname, ref float data)
        {
            fixed (float* data_ptr = &data)
            {
                GetFloatv(pname, data_ptr);
            }
        }
        public static unsafe void GetInteger(GetPName pname, Span<int> data)
        {
            fixed (int* data_ptr = data)
            {
                GetIntegerv(pname, data_ptr);
            }
        }
        public static unsafe void GetInteger(GetPName pname, int[] data)
        {
            fixed (int* data_ptr = data)
            {
                GetIntegerv(pname, data_ptr);
            }
        }
        public static unsafe void GetInteger(GetPName pname, ref int data)
        {
            fixed (int* data_ptr = &data)
            {
                GetIntegerv(pname, data_ptr);
            }
        }
        public static unsafe string? GetString(StringName name)
        {
            byte* returnValue;
            string? returnValue_str;
            returnValue = GetString_(name);
            returnValue_str = Marshal.PtrToStringAnsi((IntPtr)returnValue);
            return returnValue_str;
        }
        public static unsafe void GetTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            GetTexImage(target, level, format, type, pixels_vptr);
        }
        public static unsafe void GetTexImage<T1>(TextureTarget target, int level, PixelFormat format, PixelType type, Span<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                GetTexImage(target, level, format, type, pixels_ptr);
            }
        }
        public static unsafe void GetTexImage<T1>(TextureTarget target, int level, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                GetTexImage(target, level, format, type, pixels_ptr);
            }
        }
        public static unsafe void GetTexImage<T1>(TextureTarget target, int level, PixelFormat format, PixelType type, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                GetTexImage(target, level, format, type, pixels_ptr);
            }
        }
        public static unsafe void GetTexParameterf(TextureTarget target, GetTextureParameter pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                GetTexParameterfv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexParameterf(TextureTarget target, GetTextureParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                GetTexParameterfv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexParameterf(TextureTarget target, GetTextureParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters)
            {
                GetTexParameterfv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexParameteri(TextureTarget target, GetTextureParameter pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetTexParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexParameteri(TextureTarget target, GetTextureParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetTexParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexParameteri(TextureTarget target, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetTexParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexLevelParameterf(TextureTarget target, int level, GetTextureParameter pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                GetTexLevelParameterfv(target, level, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexLevelParameterf(TextureTarget target, int level, GetTextureParameter pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                GetTexLevelParameterfv(target, level, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexLevelParameterf(TextureTarget target, int level, GetTextureParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters)
            {
                GetTexLevelParameterfv(target, level, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexLevelParameteri(TextureTarget target, int level, GetTextureParameter pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetTexLevelParameteriv(target, level, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexLevelParameteri(TextureTarget target, int level, GetTextureParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetTexLevelParameteriv(target, level, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexLevelParameteri(TextureTarget target, int level, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetTexLevelParameteriv(target, level, pname, parameters_ptr);
            }
        }
        public static unsafe void DrawElements(PrimitiveType mode, int count, DrawElementsType type, nint offset)
        {
            void* indices = (void*)offset;
            DrawElements(mode, count, type, indices);
        }
        public static unsafe void TexSubImage1D(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            TexSubImage1D(target, level, xoffset, width, format, type, pixels_vptr);
        }
        public static unsafe void TexSubImage1D<T1>(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                TexSubImage1D(target, level, xoffset, width, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexSubImage1D<T1>(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                TexSubImage1D(target, level, xoffset, width, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexSubImage1D<T1>(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                TexSubImage1D(target, level, xoffset, width, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_vptr);
        }
        public static unsafe void TexSubImage2D<T1>(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexSubImage2D<T1>(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexSubImage2D<T1>(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
            }
        }
        public static unsafe void DeleteTexture(in TextureHandle textures)
        {
            int n = 1;
            fixed(TextureHandle* textures_handle = &textures)
            {
                DeleteTextures(n, textures_handle);
            }
        }
        public static unsafe void DeleteTextures(ReadOnlySpan<TextureHandle> textures)
        {
            int n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures)
            {
                DeleteTextures(n, textures_ptr);
            }
        }
        public static unsafe void DeleteTextures(TextureHandle[] textures)
        {
            int n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures)
            {
                DeleteTextures(n, textures_ptr);
            }
        }
        public static unsafe void DeleteTextures(int n, in TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures)
            {
                DeleteTextures(n, textures_ptr);
            }
        }
        public static unsafe TextureHandle GenTexture()
        {
            TextureHandle textures;
            int n = 1;
            Unsafe.SkipInit(out textures);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
            GenTextures(n, textures_handle);
            return textures;
        }
        public static unsafe void GenTexture(out TextureHandle textures)
        {
            int n = 1;
            Unsafe.SkipInit(out textures);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
            GenTextures(n, textures_handle);
        }
        public static unsafe void GenTextures(Span<TextureHandle> textures)
        {
            int n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures)
            {
                GenTextures(n, textures_ptr);
            }
        }
        public static unsafe void GenTextures(TextureHandle[] textures)
        {
            int n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures)
            {
                GenTextures(n, textures_ptr);
            }
        }
        public static unsafe void GenTextures(int n, ref TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures)
            {
                GenTextures(n, textures_ptr);
            }
        }
        public static unsafe void DrawRangeElements(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, nint offset)
        {
            void* indices = (void*)offset;
            DrawRangeElements(mode, start, end, count, type, indices);
        }
        public static unsafe void TexImage3D(TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels_vptr);
        }
        public static unsafe void TexImage3D<T1>(TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexImage3D<T1>(TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexImage3D<T1>(TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_vptr);
        }
        public static unsafe void TexSubImage3D<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexSubImage3D<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = pixels)
            {
                TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
            }
        }
        public static unsafe void TexSubImage3D<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
            }
        }
        public static unsafe void SampleCoverage(float value, bool invert)
        {
            byte invert_byte = (byte)(invert ? 1 : 0);
            SampleCoverage(value, invert_byte);
        }
        public static unsafe void CompressedTexImage3D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data)
        {
            void* data_vptr = (void*)data;
            CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data_vptr);
        }
        public static unsafe void CompressedTexImage3D<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            int imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexImage3D<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, T1[] data)
            where T1 : unmanaged
        {
            int imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexImage3D<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, IntPtr data)
        {
            void* data_vptr = (void*)data;
            CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data_vptr);
        }
        public static unsafe void CompressedTexImage2D<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            int imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexImage2D<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, T1[] data)
            where T1 : unmanaged
        {
            int imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexImage2D<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, IntPtr data)
        {
            void* data_vptr = (void*)data;
            CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data_vptr);
        }
        public static unsafe void CompressedTexImage1D<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int border, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            int imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexImage1D<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int border, T1[] data)
            where T1 : unmanaged
        {
            int imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexImage1D<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, IntPtr data)
        {
            void* data_vptr = (void*)data;
            CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_vptr);
        }
        public static unsafe void CompressedTexSubImage3D<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            int imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexSubImage3D<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, T1[] data)
            where T1 : unmanaged
        {
            int imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexSubImage3D<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, IntPtr data)
        {
            void* data_vptr = (void*)data;
            CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data_vptr);
        }
        public static unsafe void CompressedTexSubImage2D<T1>(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            int imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexSubImage2D<T1>(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, T1[] data)
            where T1 : unmanaged
        {
            int imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexSubImage2D<T1>(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexSubImage1D(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, IntPtr data)
        {
            void* data_vptr = (void*)data;
            CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data_vptr);
        }
        public static unsafe void CompressedTexSubImage1D<T1>(TextureTarget target, int level, int xoffset, int width, InternalFormat format, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            int imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexSubImage1D<T1>(TextureTarget target, int level, int xoffset, int width, InternalFormat format, T1[] data)
            where T1 : unmanaged
        {
            int imageSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTexSubImage1D<T1>(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data_ptr);
            }
        }
        public static unsafe void GetCompressedTexImage(TextureTarget target, int level, IntPtr img)
        {
            void* img_vptr = (void*)img;
            GetCompressedTexImage(target, level, img_vptr);
        }
        public static unsafe void GetCompressedTexImage<T1>(TextureTarget target, int level, Span<T1> img)
            where T1 : unmanaged
        {
            fixed (void* img_ptr = img)
            {
                GetCompressedTexImage(target, level, img_ptr);
            }
        }
        public static unsafe void GetCompressedTexImage<T1>(TextureTarget target, int level, T1[] img)
            where T1 : unmanaged
        {
            fixed (void* img_ptr = img)
            {
                GetCompressedTexImage(target, level, img_ptr);
            }
        }
        public static unsafe void GetCompressedTexImage<T1>(TextureTarget target, int level, ref T1 img)
            where T1 : unmanaged
        {
            fixed (void* img_ptr = &img)
            {
                GetCompressedTexImage(target, level, img_ptr);
            }
        }
        public static unsafe void MultiDrawArrays(PrimitiveType mode, ReadOnlySpan<int> first, ReadOnlySpan<int> count, int drawcount)
        {
            fixed (int* first_ptr = first)
            {
                fixed (int* count_ptr = count)
                {
                    MultiDrawArrays(mode, first_ptr, count_ptr, drawcount);
                }
            }
        }
        public static unsafe void MultiDrawArrays(PrimitiveType mode, int[] first, int[] count, int drawcount)
        {
            fixed (int* first_ptr = first)
            {
                fixed (int* count_ptr = count)
                {
                    MultiDrawArrays(mode, first_ptr, count_ptr, drawcount);
                }
            }
        }
        public static unsafe void MultiDrawArrays(PrimitiveType mode, in int first, in int count, int drawcount)
        {
            fixed (int* first_ptr = &first)
            fixed (int* count_ptr = &count)
            {
                MultiDrawArrays(mode, first_ptr, count_ptr, drawcount);
            }
        }
        public static unsafe void MultiDrawElements(PrimitiveType mode, ReadOnlySpan<int> count, DrawElementsType type, void** indices, int drawcount)
        {
            fixed (int* count_ptr = count)
            {
                MultiDrawElements(mode, count_ptr, type, indices, drawcount);
            }
        }
        public static unsafe void MultiDrawElements(PrimitiveType mode, int[] count, DrawElementsType type, void** indices, int drawcount)
        {
            fixed (int* count_ptr = count)
            {
                MultiDrawElements(mode, count_ptr, type, indices, drawcount);
            }
        }
        public static unsafe void MultiDrawElements(PrimitiveType mode, in int count, DrawElementsType type, void** indices, int drawcount)
        {
            fixed (int* count_ptr = &count)
            {
                MultiDrawElements(mode, count_ptr, type, indices, drawcount);
            }
        }
        public static unsafe void PointParameterf(PointParameterNameARB pname, ReadOnlySpan<float> parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                PointParameterfv(pname, parameters_ptr);
            }
        }
        public static unsafe void PointParameterf(PointParameterNameARB pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                PointParameterfv(pname, parameters_ptr);
            }
        }
        public static unsafe void PointParameterf(PointParameterNameARB pname, in float parameters)
        {
            fixed (float* parameters_ptr = &parameters)
            {
                PointParameterfv(pname, parameters_ptr);
            }
        }
        public static unsafe void PointParameteri(PointParameterNameARB pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                PointParameteriv(pname, parameters_ptr);
            }
        }
        public static unsafe void PointParameteri(PointParameterNameARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                PointParameteriv(pname, parameters_ptr);
            }
        }
        public static unsafe void PointParameteri(PointParameterNameARB pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                PointParameteriv(pname, parameters_ptr);
            }
        }
        public static unsafe QueryHandle GenQuerie()
        {
            QueryHandle ids;
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
            GenQueries(n, ids_handle);
            return ids;
        }
        public static unsafe void GenQuerie(out QueryHandle ids)
        {
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
            GenQueries(n, ids_handle);
        }
        public static unsafe void GenQueries(Span<QueryHandle> ids)
        {
            int n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids)
            {
                GenQueries(n, ids_ptr);
            }
        }
        public static unsafe void GenQueries(QueryHandle[] ids)
        {
            int n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids)
            {
                GenQueries(n, ids_ptr);
            }
        }
        public static unsafe void GenQueries(int n, ref QueryHandle ids)
        {
            fixed (QueryHandle* ids_ptr = &ids)
            {
                GenQueries(n, ids_ptr);
            }
        }
        public static unsafe void DeleteQuerie(in QueryHandle ids)
        {
            int n = 1;
            fixed(QueryHandle* ids_handle = &ids)
            {
                DeleteQueries(n, ids_handle);
            }
        }
        public static unsafe void DeleteQueries(ReadOnlySpan<QueryHandle> ids)
        {
            int n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids)
            {
                DeleteQueries(n, ids_ptr);
            }
        }
        public static unsafe void DeleteQueries(QueryHandle[] ids)
        {
            int n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids)
            {
                DeleteQueries(n, ids_ptr);
            }
        }
        public static unsafe void DeleteQueries(int n, in QueryHandle ids)
        {
            fixed (QueryHandle* ids_ptr = &ids)
            {
                DeleteQueries(n, ids_ptr);
            }
        }
        public static unsafe void GetQueryi(QueryTarget target, QueryParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetQueryiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryi(QueryTarget target, QueryParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetQueryiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryi(QueryTarget target, QueryParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetQueryiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryObjecti(QueryHandle id, QueryObjectParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetQueryObjectiv(id, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryObjecti(QueryHandle id, QueryObjectParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetQueryObjectiv(id, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryObjecti(QueryHandle id, QueryObjectParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetQueryObjectiv(id, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryObjectui(QueryHandle id, QueryObjectParameterName pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                GetQueryObjectuiv(id, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryObjectui(QueryHandle id, QueryObjectParameterName pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                GetQueryObjectuiv(id, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryObjectui(QueryHandle id, QueryObjectParameterName pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters)
            {
                GetQueryObjectuiv(id, pname, parameters_ptr);
            }
        }
        public static unsafe void DeleteBuffer(in BufferHandle buffers)
        {
            int n = 1;
            fixed(BufferHandle* buffers_handle = &buffers)
            {
                DeleteBuffers(n, buffers_handle);
            }
        }
        public static unsafe void DeleteBuffers(ReadOnlySpan<BufferHandle> buffers)
        {
            int n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers)
            {
                DeleteBuffers(n, buffers_ptr);
            }
        }
        public static unsafe void DeleteBuffers(BufferHandle[] buffers)
        {
            int n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers)
            {
                DeleteBuffers(n, buffers_ptr);
            }
        }
        public static unsafe void DeleteBuffers(int n, in BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers)
            {
                DeleteBuffers(n, buffers_ptr);
            }
        }
        public static unsafe BufferHandle GenBuffer()
        {
            BufferHandle buffers;
            int n = 1;
            Unsafe.SkipInit(out buffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
            GenBuffers(n, buffers_handle);
            return buffers;
        }
        public static unsafe void GenBuffer(out BufferHandle buffers)
        {
            int n = 1;
            Unsafe.SkipInit(out buffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
            GenBuffers(n, buffers_handle);
        }
        public static unsafe void GenBuffers(Span<BufferHandle> buffers)
        {
            int n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers)
            {
                GenBuffers(n, buffers_ptr);
            }
        }
        public static unsafe void GenBuffers(BufferHandle[] buffers)
        {
            int n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers)
            {
                GenBuffers(n, buffers_ptr);
            }
        }
        public static unsafe void GenBuffers(int n, ref BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers)
            {
                GenBuffers(n, buffers_ptr);
            }
        }
        public static unsafe void BufferData(BufferTargetARB target, nint size, IntPtr data, BufferUsageARB usage)
        {
            void* data_vptr = (void*)data;
            BufferData(target, size, data_vptr, usage);
        }
        public static unsafe void BufferData<T1>(BufferTargetARB target, ReadOnlySpan<T1> data, BufferUsageARB usage)
            where T1 : unmanaged
        {
            nint size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                BufferData(target, size, data_ptr, usage);
            }
        }
        public static unsafe void BufferData<T1>(BufferTargetARB target, T1[] data, BufferUsageARB usage)
            where T1 : unmanaged
        {
            nint size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                BufferData(target, size, data_ptr, usage);
            }
        }
        public static unsafe void BufferData<T1>(BufferTargetARB target, nint size, in T1 data, BufferUsageARB usage)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                BufferData(target, size, data_ptr, usage);
            }
        }
        public static unsafe void BufferSubData(BufferTargetARB target, IntPtr offset, nint size, IntPtr data)
        {
            void* data_vptr = (void*)data;
            BufferSubData(target, offset, size, data_vptr);
        }
        public static unsafe void BufferSubData<T1>(BufferTargetARB target, IntPtr offset, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            nint size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                BufferSubData(target, offset, size, data_ptr);
            }
        }
        public static unsafe void BufferSubData<T1>(BufferTargetARB target, IntPtr offset, T1[] data)
            where T1 : unmanaged
        {
            nint size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                BufferSubData(target, offset, size, data_ptr);
            }
        }
        public static unsafe void BufferSubData<T1>(BufferTargetARB target, IntPtr offset, nint size, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                BufferSubData(target, offset, size, data_ptr);
            }
        }
        public static unsafe void GetBufferSubData(BufferTargetARB target, IntPtr offset, nint size, IntPtr data)
        {
            void* data_vptr = (void*)data;
            GetBufferSubData(target, offset, size, data_vptr);
        }
        public static unsafe void GetBufferSubData<T1>(BufferTargetARB target, IntPtr offset, Span<T1> data)
            where T1 : unmanaged
        {
            nint size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                GetBufferSubData(target, offset, size, data_ptr);
            }
        }
        public static unsafe void GetBufferSubData<T1>(BufferTargetARB target, IntPtr offset, T1[] data)
            where T1 : unmanaged
        {
            nint size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                GetBufferSubData(target, offset, size, data_ptr);
            }
        }
        public static unsafe void GetBufferSubData<T1>(BufferTargetARB target, IntPtr offset, nint size, ref T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                GetBufferSubData(target, offset, size, data_ptr);
            }
        }
        public static unsafe void GetBufferParameteri(BufferTargetARB target, BufferPNameARB pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetBufferParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetBufferParameteri(BufferTargetARB target, BufferPNameARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetBufferParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetBufferParameteri(BufferTargetARB target, BufferPNameARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetBufferParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetBufferPointer(BufferTargetARB target, BufferPointerNameARB pname, void** parameters)
        {
            GetBufferPointerv(target, pname, parameters);
        }
        public static unsafe void DrawBuffers(ReadOnlySpan<DrawBufferMode> bufs)
        {
            int n = (int)(bufs.Length);
            fixed (DrawBufferMode* bufs_ptr = bufs)
            {
                DrawBuffers(n, bufs_ptr);
            }
        }
        public static unsafe void DrawBuffers(DrawBufferMode[] bufs)
        {
            int n = (int)(bufs.Length);
            fixed (DrawBufferMode* bufs_ptr = bufs)
            {
                DrawBuffers(n, bufs_ptr);
            }
        }
        public static unsafe void DrawBuffers(int n, in DrawBufferMode bufs)
        {
            fixed (DrawBufferMode* bufs_ptr = &bufs)
            {
                DrawBuffers(n, bufs_ptr);
            }
        }
        public static unsafe void BindAttribLocation(ProgramHandle program, uint index, string name)
        {
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            BindAttribLocation(program, index, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
        }
        public static unsafe string GetActiveAttrib(ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type)
        {
            string name;
            fixed (int* length_ptr = length)
            {
                fixed (int* size_ptr = size)
                {
                    fixed (AttributeType* type_ptr = type)
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }
        public static unsafe void GetActiveAttrib(ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type, out string name)
        {
            fixed (int* length_ptr = length)
            {
                fixed (int* size_ptr = size)
                {
                    fixed (AttributeType* type_ptr = type)
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }
        public static unsafe string GetActiveAttrib(ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type)
        {
            string name;
            fixed (int* length_ptr = length)
            {
                fixed (int* size_ptr = size)
                {
                    fixed (AttributeType* type_ptr = type)
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }
        public static unsafe void GetActiveAttrib(ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type, out string name)
        {
            fixed (int* length_ptr = length)
            {
                fixed (int* size_ptr = size)
                {
                    fixed (AttributeType* type_ptr = type)
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }
        public static unsafe string GetActiveAttrib(ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type)
        {
            string name;
            fixed (int* length_ptr = &length)
            fixed (int* size_ptr = &size)
            fixed (AttributeType* type_ptr = &type)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }
        public static unsafe void GetActiveAttrib(ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type, out string name)
        {
            fixed (int* length_ptr = &length)
            fixed (int* size_ptr = &size)
            fixed (AttributeType* type_ptr = &type)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveAttrib(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }
        public static unsafe string GetActiveUniform(ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<UniformType> type)
        {
            string name;
            fixed (int* length_ptr = length)
            {
                fixed (int* size_ptr = size)
                {
                    fixed (UniformType* type_ptr = type)
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }
        public static unsafe void GetActiveUniform(ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<UniformType> type, out string name)
        {
            fixed (int* length_ptr = length)
            {
                fixed (int* size_ptr = size)
                {
                    fixed (UniformType* type_ptr = type)
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }
        public static unsafe string GetActiveUniform(ProgramHandle program, uint index, int bufSize, int[] length, int[] size, UniformType[] type)
        {
            string name;
            fixed (int* length_ptr = length)
            {
                fixed (int* size_ptr = size)
                {
                    fixed (UniformType* type_ptr = type)
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }
        public static unsafe void GetActiveUniform(ProgramHandle program, uint index, int bufSize, int[] length, int[] size, UniformType[] type, out string name)
        {
            fixed (int* length_ptr = length)
            {
                fixed (int* size_ptr = size)
                {
                    fixed (UniformType* type_ptr = type)
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }
        public static unsafe string GetActiveUniform(ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref UniformType type)
        {
            string name;
            fixed (int* length_ptr = &length)
            fixed (int* size_ptr = &size)
            fixed (UniformType* type_ptr = &type)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }
        public static unsafe void GetActiveUniform(ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref UniformType type, out string name)
        {
            fixed (int* length_ptr = &length)
            fixed (int* size_ptr = &size)
            fixed (UniformType* type_ptr = &type)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniform(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }
        public static unsafe void GetAttachedShaders(ProgramHandle program, Span<int> count, Span<ShaderHandle> shaders)
        {
            fixed (int* count_ptr = count)
            {
                int maxCount = (int)(shaders.Length);
                fixed (ShaderHandle* shaders_ptr = shaders)
                {
                    GetAttachedShaders(program, maxCount, count_ptr, shaders_ptr);
                }
            }
        }
        public static unsafe void GetAttachedShaders(ProgramHandle program, int[] count, ShaderHandle[] shaders)
        {
            fixed (int* count_ptr = count)
            {
                int maxCount = (int)(shaders.Length);
                fixed (ShaderHandle* shaders_ptr = shaders)
                {
                    GetAttachedShaders(program, maxCount, count_ptr, shaders_ptr);
                }
            }
        }
        public static unsafe void GetAttachedShaders(ProgramHandle program, int maxCount, ref int count, ref ShaderHandle shaders)
        {
            fixed (int* count_ptr = &count)
            fixed (ShaderHandle* shaders_ptr = &shaders)
            {
                GetAttachedShaders(program, maxCount, count_ptr, shaders_ptr);
            }
        }
        public static unsafe int GetAttribLocation(ProgramHandle program, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = GetAttribLocation(program, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }
        public static unsafe void GetProgrami(ProgramHandle program, ProgramPropertyARB pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetProgramiv(program, pname, parameters_ptr);
            }
        }
        public static unsafe void GetProgrami(ProgramHandle program, ProgramPropertyARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetProgramiv(program, pname, parameters_ptr);
            }
        }
        public static unsafe void GetProgrami(ProgramHandle program, ProgramPropertyARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetProgramiv(program, pname, parameters_ptr);
            }
        }
        public static unsafe string GetProgramInfoLog(ProgramHandle program, int bufSize, Span<int> length)
        {
            string infoLog;
            fixed (int* length_ptr = length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }
        public static unsafe void GetProgramInfoLog(ProgramHandle program, int bufSize, Span<int> length, out string infoLog)
        {
            fixed (int* length_ptr = length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }
        public static unsafe string GetProgramInfoLog(ProgramHandle program, int bufSize, int[] length)
        {
            string infoLog;
            fixed (int* length_ptr = length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }
        public static unsafe void GetProgramInfoLog(ProgramHandle program, int bufSize, int[] length, out string infoLog)
        {
            fixed (int* length_ptr = length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }
        public static unsafe string GetProgramInfoLog(ProgramHandle program, int bufSize, ref int length)
        {
            string infoLog;
            fixed (int* length_ptr = &length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }
        public static unsafe void GetProgramInfoLog(ProgramHandle program, int bufSize, ref int length, out string infoLog)
        {
            fixed (int* length_ptr = &length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramInfoLog(program, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }
        public static unsafe void GetShaderi(ShaderHandle shader, ShaderParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetShaderiv(shader, pname, parameters_ptr);
            }
        }
        public static unsafe void GetShaderi(ShaderHandle shader, ShaderParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetShaderiv(shader, pname, parameters_ptr);
            }
        }
        public static unsafe void GetShaderi(ShaderHandle shader, ShaderParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetShaderiv(shader, pname, parameters_ptr);
            }
        }
        public static unsafe string GetShaderInfoLog(ShaderHandle shader, int bufSize, Span<int> length)
        {
            string infoLog;
            fixed (int* length_ptr = length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }
        public static unsafe void GetShaderInfoLog(ShaderHandle shader, int bufSize, Span<int> length, out string infoLog)
        {
            fixed (int* length_ptr = length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }
        public static unsafe string GetShaderInfoLog(ShaderHandle shader, int bufSize, int[] length)
        {
            string infoLog;
            fixed (int* length_ptr = length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }
        public static unsafe void GetShaderInfoLog(ShaderHandle shader, int bufSize, int[] length, out string infoLog)
        {
            fixed (int* length_ptr = length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }
        public static unsafe string GetShaderInfoLog(ShaderHandle shader, int bufSize, ref int length)
        {
            string infoLog;
            fixed (int* length_ptr = &length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }
        public static unsafe void GetShaderInfoLog(ShaderHandle shader, int bufSize, ref int length, out string infoLog)
        {
            fixed (int* length_ptr = &length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetShaderInfoLog(shader, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }
        public static unsafe string GetShaderSource(ShaderHandle shader, int bufSize, Span<int> length)
        {
            string source;
            fixed (int* length_ptr = length)
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
            return source;
        }
        public static unsafe void GetShaderSource(ShaderHandle shader, int bufSize, Span<int> length, out string source)
        {
            fixed (int* length_ptr = length)
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
        }
        public static unsafe string GetShaderSource(ShaderHandle shader, int bufSize, int[] length)
        {
            string source;
            fixed (int* length_ptr = length)
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
            return source;
        }
        public static unsafe void GetShaderSource(ShaderHandle shader, int bufSize, int[] length, out string source)
        {
            fixed (int* length_ptr = length)
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
        }
        public static unsafe string GetShaderSource(ShaderHandle shader, int bufSize, ref int length)
        {
            string source;
            fixed (int* length_ptr = &length)
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
            return source;
        }
        public static unsafe void GetShaderSource(ShaderHandle shader, int bufSize, ref int length, out string source)
        {
            fixed (int* length_ptr = &length)
            {
                var source_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetShaderSource(shader, bufSize, length_ptr, source_ptr);
                source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)source_ptr);
            }
        }
        public static unsafe int GetUniformLocation(ProgramHandle program, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = GetUniformLocation(program, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }
        public static unsafe void GetUniformf(ProgramHandle program, int location, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                GetUniformfv(program, location, parameters_ptr);
            }
        }
        public static unsafe void GetUniformf(ProgramHandle program, int location, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                GetUniformfv(program, location, parameters_ptr);
            }
        }
        public static unsafe void GetUniformf(ProgramHandle program, int location, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters)
            {
                GetUniformfv(program, location, parameters_ptr);
            }
        }
        public static unsafe void GetUniformi(ProgramHandle program, int location, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetUniformiv(program, location, parameters_ptr);
            }
        }
        public static unsafe void GetUniformi(ProgramHandle program, int location, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetUniformiv(program, location, parameters_ptr);
            }
        }
        public static unsafe void GetUniformi(ProgramHandle program, int location, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetUniformiv(program, location, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribd(uint index, VertexAttribPropertyARB pname, Span<double> parameters)
        {
            fixed (double* parameters_ptr = parameters)
            {
                GetVertexAttribdv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribd(uint index, VertexAttribPropertyARB pname, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters)
            {
                GetVertexAttribdv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribd(uint index, VertexAttribPropertyARB pname, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters)
            {
                GetVertexAttribdv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribf(uint index, VertexAttribPropertyARB pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                GetVertexAttribfv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribf(uint index, VertexAttribPropertyARB pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                GetVertexAttribfv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribf(uint index, VertexAttribPropertyARB pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters)
            {
                GetVertexAttribfv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribi(uint index, VertexAttribPropertyARB pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetVertexAttribiv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribi(uint index, VertexAttribPropertyARB pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetVertexAttribiv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribi(uint index, VertexAttribPropertyARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetVertexAttribiv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribPointer(uint index, VertexAttribPointerPropertyARB pname, void** pointer)
        {
            GetVertexAttribPointerv(index, pname, pointer);
        }
        public static unsafe void ShaderSource(ShaderHandle shader, int count, byte** str, ReadOnlySpan<int> length)
        {
            fixed (int* length_ptr = length)
            {
                ShaderSource(shader, count, str, length_ptr);
            }
        }
        public static unsafe void ShaderSource(ShaderHandle shader, int count, byte** str, int[] length)
        {
            fixed (int* length_ptr = length)
            {
                ShaderSource(shader, count, str, length_ptr);
            }
        }
        public static unsafe void ShaderSource(ShaderHandle shader, int count, byte** str, in int length)
        {
            fixed (int* length_ptr = &length)
            {
                ShaderSource(shader, count, str, length_ptr);
            }
        }
        public static unsafe void Uniform1f(int location, in float value)
        {
            int count = 1;
            fixed (float* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                Uniform1fv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform1f(int location, int count, ReadOnlySpan<float> value)
        {
            fixed (float* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                Uniform1fv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform1f(int location, int count, float[] value)
        {
            fixed (float* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                Uniform1fv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform2f(int location, in Vector2 value)
        {
            int count = 1;
            fixed (Vector2* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                Uniform2fv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform2f(int location, int count, ReadOnlySpan<Vector2> value)
        {
            fixed (Vector2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                Uniform2fv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform2f(int location, int count, Vector2[] value)
        {
            fixed (Vector2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                Uniform2fv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform3f(int location, in Vector3 value)
        {
            int count = 1;
            fixed (Vector3* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                Uniform3fv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform3f(int location, int count, ReadOnlySpan<Vector3> value)
        {
            fixed (Vector3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                Uniform3fv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform3f(int location, int count, Vector3[] value)
        {
            fixed (Vector3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                Uniform3fv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform4f(int location, in Vector4 value)
        {
            int count = 1;
            fixed (Vector4* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                Uniform4fv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform4f(int location, int count, ReadOnlySpan<Vector4> value)
        {
            fixed (Vector4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                Uniform4fv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform4f(int location, int count, Vector4[] value)
        {
            fixed (Vector4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                Uniform4fv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform1i(int location, in int value)
        {
            int count = 1;
            fixed (int* tmp_vecPtr = &value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                Uniform1iv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform1i(int location, int count, ReadOnlySpan<int> value)
        {
            fixed (int* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                Uniform1iv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform1i(int location, int count, int[] value)
        {
            fixed (int* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                Uniform1iv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform2i(int location, in Vector2i value)
        {
            int count = 1;
            fixed (Vector2i* tmp_vecPtr = &value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                Uniform2iv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform2i(int location, int count, ReadOnlySpan<Vector2i> value)
        {
            fixed (Vector2i* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                Uniform2iv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform2i(int location, int count, Vector2i[] value)
        {
            fixed (Vector2i* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                Uniform2iv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform3i(int location, in Vector3i value)
        {
            int count = 1;
            fixed (Vector3i* tmp_vecPtr = &value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                Uniform3iv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform3i(int location, int count, ReadOnlySpan<Vector3i> value)
        {
            fixed (Vector3i* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                Uniform3iv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform3i(int location, int count, Vector3i[] value)
        {
            fixed (Vector3i* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                Uniform3iv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform4i(int location, in Vector4i value)
        {
            int count = 1;
            fixed (Vector4i* tmp_vecPtr = &value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                Uniform4iv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform4i(int location, int count, ReadOnlySpan<Vector4i> value)
        {
            fixed (Vector4i* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                Uniform4iv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform4i(int location, int count, Vector4i[] value)
        {
            fixed (Vector4i* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                Uniform4iv(location, count, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2f(int location, bool transpose, in Matrix2 value)
        {
            int count = 1;
            fixed (Matrix2* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2f(int location, int count, bool transpose, ReadOnlySpan<Matrix2> value)
        {
            fixed (Matrix2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2f(int location, int count, bool transpose, Matrix2[] value)
        {
            fixed (Matrix2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3f(int location, bool transpose, in Matrix3 value)
        {
            int count = 1;
            fixed (Matrix3* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3f(int location, int count, bool transpose, ReadOnlySpan<Matrix3> value)
        {
            fixed (Matrix3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3f(int location, int count, bool transpose, Matrix3[] value)
        {
            fixed (Matrix3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4f(int location, bool transpose, in Matrix4 value)
        {
            int count = 1;
            fixed (Matrix4* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4f(int location, int count, bool transpose, ReadOnlySpan<Matrix4> value)
        {
            fixed (Matrix4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4f(int location, int count, bool transpose, Matrix4[] value)
        {
            fixed (Matrix4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void VertexAttrib1dv(uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttrib1dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib1dv(uint index, double[] v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttrib1dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib1dv(uint index, in double v)
        {
            fixed (double* v_ptr = &v)
            {
                VertexAttrib1dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib1fv(uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v)
            {
                VertexAttrib1fv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib1fv(uint index, float[] v)
        {
            fixed (float* v_ptr = v)
            {
                VertexAttrib1fv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib1fv(uint index, in float v)
        {
            fixed (float* v_ptr = &v)
            {
                VertexAttrib1fv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib1(uint index, short x)
        {
            VertexAttrib1s(index, x);
        }
        public static unsafe void VertexAttrib1(uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v)
            {
                VertexAttrib1sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib1(uint index, short[] v)
        {
            fixed (short* v_ptr = v)
            {
                VertexAttrib1sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib1(uint index, in short v)
        {
            fixed (short* v_ptr = &v)
            {
                VertexAttrib1sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib2dv(uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttrib2dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib2dv(uint index, double[] v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttrib2dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib2dv(uint index, in double v)
        {
            fixed (double* v_ptr = &v)
            {
                VertexAttrib2dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib2fv(uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v)
            {
                VertexAttrib2fv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib2fv(uint index, float[] v)
        {
            fixed (float* v_ptr = v)
            {
                VertexAttrib2fv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib2fv(uint index, in float v)
        {
            fixed (float* v_ptr = &v)
            {
                VertexAttrib2fv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib2(uint index, short x, short y)
        {
            VertexAttrib2s(index, x, y);
        }
        public static unsafe void VertexAttrib2(uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v)
            {
                VertexAttrib2sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib2(uint index, short[] v)
        {
            fixed (short* v_ptr = v)
            {
                VertexAttrib2sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib2(uint index, in short v)
        {
            fixed (short* v_ptr = &v)
            {
                VertexAttrib2sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib3dv(uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttrib3dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib3dv(uint index, double[] v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttrib3dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib3dv(uint index, in double v)
        {
            fixed (double* v_ptr = &v)
            {
                VertexAttrib3dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib3fv(uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v)
            {
                VertexAttrib3fv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib3fv(uint index, float[] v)
        {
            fixed (float* v_ptr = v)
            {
                VertexAttrib3fv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib3fv(uint index, in float v)
        {
            fixed (float* v_ptr = &v)
            {
                VertexAttrib3fv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib3(uint index, short x, short y, short z)
        {
            VertexAttrib3s(index, x, y, z);
        }
        public static unsafe void VertexAttrib3(uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v)
            {
                VertexAttrib3sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib3(uint index, short[] v)
        {
            fixed (short* v_ptr = v)
            {
                VertexAttrib3sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib3(uint index, in short v)
        {
            fixed (short* v_ptr = &v)
            {
                VertexAttrib3sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4N(uint index, ReadOnlySpan<sbyte> v)
        {
            fixed (sbyte* v_ptr = v)
            {
                VertexAttrib4Nbv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4N(uint index, sbyte[] v)
        {
            fixed (sbyte* v_ptr = v)
            {
                VertexAttrib4Nbv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4N(uint index, in sbyte v)
        {
            fixed (sbyte* v_ptr = &v)
            {
                VertexAttrib4Nbv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4Ni(uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v)
            {
                VertexAttrib4Niv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4Ni(uint index, int[] v)
        {
            fixed (int* v_ptr = v)
            {
                VertexAttrib4Niv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4Ni(uint index, in int v)
        {
            fixed (int* v_ptr = &v)
            {
                VertexAttrib4Niv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4N(uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v)
            {
                VertexAttrib4Nsv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4N(uint index, short[] v)
        {
            fixed (short* v_ptr = v)
            {
                VertexAttrib4Nsv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4N(uint index, in short v)
        {
            fixed (short* v_ptr = &v)
            {
                VertexAttrib4Nsv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4N(uint index, byte x, byte y, byte z, byte w)
        {
            VertexAttrib4Nub(index, x, y, z, w);
        }
        public static unsafe void VertexAttrib4N(uint index, ReadOnlySpan<byte> v)
        {
            fixed (byte* v_ptr = v)
            {
                VertexAttrib4Nubv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4N(uint index, byte[] v)
        {
            fixed (byte* v_ptr = v)
            {
                VertexAttrib4Nubv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4N(uint index, in byte v)
        {
            fixed (byte* v_ptr = &v)
            {
                VertexAttrib4Nubv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4Nui(uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v)
            {
                VertexAttrib4Nuiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4Nui(uint index, uint[] v)
        {
            fixed (uint* v_ptr = v)
            {
                VertexAttrib4Nuiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4Nui(uint index, in uint v)
        {
            fixed (uint* v_ptr = &v)
            {
                VertexAttrib4Nuiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4N(uint index, ReadOnlySpan<ushort> v)
        {
            fixed (ushort* v_ptr = v)
            {
                VertexAttrib4Nusv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4N(uint index, ushort[] v)
        {
            fixed (ushort* v_ptr = v)
            {
                VertexAttrib4Nusv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4N(uint index, in ushort v)
        {
            fixed (ushort* v_ptr = &v)
            {
                VertexAttrib4Nusv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4(uint index, ReadOnlySpan<sbyte> v)
        {
            fixed (sbyte* v_ptr = v)
            {
                VertexAttrib4bv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4(uint index, sbyte[] v)
        {
            fixed (sbyte* v_ptr = v)
            {
                VertexAttrib4bv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4(uint index, in sbyte v)
        {
            fixed (sbyte* v_ptr = &v)
            {
                VertexAttrib4bv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4dv(uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttrib4dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4dv(uint index, double[] v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttrib4dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4dv(uint index, in double v)
        {
            fixed (double* v_ptr = &v)
            {
                VertexAttrib4dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4fv(uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v)
            {
                VertexAttrib4fv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4fv(uint index, float[] v)
        {
            fixed (float* v_ptr = v)
            {
                VertexAttrib4fv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4fv(uint index, in float v)
        {
            fixed (float* v_ptr = &v)
            {
                VertexAttrib4fv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4iv(uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v)
            {
                VertexAttrib4iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4iv(uint index, int[] v)
        {
            fixed (int* v_ptr = v)
            {
                VertexAttrib4iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4iv(uint index, in int v)
        {
            fixed (int* v_ptr = &v)
            {
                VertexAttrib4iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4(uint index, short x, short y, short z, short w)
        {
            VertexAttrib4s(index, x, y, z, w);
        }
        public static unsafe void VertexAttrib4(uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v)
            {
                VertexAttrib4sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4(uint index, short[] v)
        {
            fixed (short* v_ptr = v)
            {
                VertexAttrib4sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4(uint index, in short v)
        {
            fixed (short* v_ptr = &v)
            {
                VertexAttrib4sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4(uint index, ReadOnlySpan<byte> v)
        {
            fixed (byte* v_ptr = v)
            {
                VertexAttrib4ubv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4(uint index, byte[] v)
        {
            fixed (byte* v_ptr = v)
            {
                VertexAttrib4ubv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4(uint index, in byte v)
        {
            fixed (byte* v_ptr = &v)
            {
                VertexAttrib4ubv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4ui(uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v)
            {
                VertexAttrib4uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4ui(uint index, uint[] v)
        {
            fixed (uint* v_ptr = v)
            {
                VertexAttrib4uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4ui(uint index, in uint v)
        {
            fixed (uint* v_ptr = &v)
            {
                VertexAttrib4uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4(uint index, ReadOnlySpan<ushort> v)
        {
            fixed (ushort* v_ptr = v)
            {
                VertexAttrib4usv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4(uint index, ushort[] v)
        {
            fixed (ushort* v_ptr = v)
            {
                VertexAttrib4usv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttrib4(uint index, in ushort v)
        {
            fixed (ushort* v_ptr = &v)
            {
                VertexAttrib4usv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribPointer(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, nint offset)
        {
            void* pointer = (void*)offset;
            byte normalized_byte = (byte)(normalized ? 1 : 0);
            VertexAttribPointer(index, size, type, normalized_byte, stride, pointer);
        }
        public static unsafe void UniformMatrix2x3f(int location, bool transpose, in Matrix2x3 value)
        {
            int count = 1;
            fixed (Matrix2x3* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2x3fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2x3f(int location, int count, bool transpose, ReadOnlySpan<Matrix2x3> value)
        {
            fixed (Matrix2x3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2x3fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2x3f(int location, int count, bool transpose, Matrix2x3[] value)
        {
            fixed (Matrix2x3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2x3fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3x2f(int location, bool transpose, in Matrix3x2 value)
        {
            int count = 1;
            fixed (Matrix3x2* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3x2fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3x2f(int location, int count, bool transpose, ReadOnlySpan<Matrix3x2> value)
        {
            fixed (Matrix3x2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3x2fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3x2f(int location, int count, bool transpose, Matrix3x2[] value)
        {
            fixed (Matrix3x2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3x2fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2x4f(int location, bool transpose, in Matrix2x4 value)
        {
            int count = 1;
            fixed (Matrix2x4* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2x4fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2x4f(int location, int count, bool transpose, ReadOnlySpan<Matrix2x4> value)
        {
            fixed (Matrix2x4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2x4fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2x4f(int location, int count, bool transpose, Matrix2x4[] value)
        {
            fixed (Matrix2x4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2x4fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4x2f(int location, bool transpose, in Matrix4x2 value)
        {
            int count = 1;
            fixed (Matrix4x2* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4x2fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4x2f(int location, int count, bool transpose, ReadOnlySpan<Matrix4x2> value)
        {
            fixed (Matrix4x2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4x2fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4x2f(int location, int count, bool transpose, Matrix4x2[] value)
        {
            fixed (Matrix4x2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4x2fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3x4f(int location, bool transpose, in Matrix3x4 value)
        {
            int count = 1;
            fixed (Matrix3x4* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3x4fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3x4f(int location, int count, bool transpose, ReadOnlySpan<Matrix3x4> value)
        {
            fixed (Matrix3x4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3x4fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3x4f(int location, int count, bool transpose, Matrix3x4[] value)
        {
            fixed (Matrix3x4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3x4fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4x3f(int location, bool transpose, in Matrix4x3 value)
        {
            int count = 1;
            fixed (Matrix4x3* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4x3fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4x3f(int location, int count, bool transpose, ReadOnlySpan<Matrix4x3> value)
        {
            fixed (Matrix4x3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4x3fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4x3f(int location, int count, bool transpose, Matrix4x3[] value)
        {
            fixed (Matrix4x3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4x3fv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ColorMaski(uint index, bool r, bool g, bool b, bool a)
        {
            byte r_byte = (byte)(r ? 1 : 0);
            byte g_byte = (byte)(g ? 1 : 0);
            byte b_byte = (byte)(b ? 1 : 0);
            byte a_byte = (byte)(a ? 1 : 0);
            ColorMaski(index, r_byte, g_byte, b_byte, a_byte);
        }
        public static unsafe void GetBoolean(BufferTargetARB target, uint index, Span<byte> data)
        {
            fixed (byte* data_ptr = data)
            {
                GetBooleani_v(target, index, data_ptr);
            }
        }
        public static unsafe void GetBoolean(BufferTargetARB target, uint index, byte[] data)
        {
            fixed (byte* data_ptr = data)
            {
                GetBooleani_v(target, index, data_ptr);
            }
        }
        public static unsafe void GetBoolean(BufferTargetARB target, uint index, ref byte data)
        {
            fixed (byte* data_ptr = &data)
            {
                GetBooleani_v(target, index, data_ptr);
            }
        }
        public static unsafe void GetInteger(GetPName target, uint index, Span<int> data)
        {
            fixed (int* data_ptr = data)
            {
                GetIntegeri_v(target, index, data_ptr);
            }
        }
        public static unsafe void GetInteger(GetPName target, uint index, int[] data)
        {
            fixed (int* data_ptr = data)
            {
                GetIntegeri_v(target, index, data_ptr);
            }
        }
        public static unsafe void GetInteger(GetPName target, uint index, ref int data)
        {
            fixed (int* data_ptr = &data)
            {
                GetIntegeri_v(target, index, data_ptr);
            }
        }
        public static unsafe string GetTransformFeedbackVarying(ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type)
        {
            string name;
            fixed (int* length_ptr = length)
            {
                fixed (int* size_ptr = size)
                {
                    fixed (AttributeType* type_ptr = type)
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }
        public static unsafe void GetTransformFeedbackVarying(ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type, out string name)
        {
            fixed (int* length_ptr = length)
            {
                fixed (int* size_ptr = size)
                {
                    fixed (AttributeType* type_ptr = type)
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }
        public static unsafe string GetTransformFeedbackVarying(ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type)
        {
            string name;
            fixed (int* length_ptr = length)
            {
                fixed (int* size_ptr = size)
                {
                    fixed (AttributeType* type_ptr = type)
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
            return name;
        }
        public static unsafe void GetTransformFeedbackVarying(ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type, out string name)
        {
            fixed (int* length_ptr = length)
            {
                fixed (int* size_ptr = size)
                {
                    fixed (AttributeType* type_ptr = type)
                    {
                        var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                        name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                    }
                }
            }
        }
        public static unsafe string GetTransformFeedbackVarying(ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type)
        {
            string name;
            fixed (int* length_ptr = &length)
            fixed (int* size_ptr = &size)
            fixed (AttributeType* type_ptr = &type)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }
        public static unsafe void GetTransformFeedbackVarying(ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type, out string name)
        {
            fixed (int* length_ptr = &length)
            fixed (int* size_ptr = &size)
            fixed (AttributeType* type_ptr = &type)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetTransformFeedbackVarying(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }
        public static unsafe void VertexAttribIPointer(uint index, int size, VertexAttribIType type, int stride, nint offset)
        {
            void* pointer = (void*)offset;
            VertexAttribIPointer(index, size, type, stride, pointer);
        }
        public static unsafe void GetVertexAttribIi(uint index, VertexAttribEnum pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetVertexAttribIiv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribIi(uint index, VertexAttribEnum pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetVertexAttribIiv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribIi(uint index, VertexAttribEnum pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetVertexAttribIiv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribIui(uint index, VertexAttribEnum pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                GetVertexAttribIuiv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribIui(uint index, VertexAttribEnum pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                GetVertexAttribIuiv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribIui(uint index, VertexAttribEnum pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters)
            {
                GetVertexAttribIuiv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void VertexAttribI1iv(uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v)
            {
                VertexAttribI1iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI1iv(uint index, int[] v)
        {
            fixed (int* v_ptr = v)
            {
                VertexAttribI1iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI1iv(uint index, in int v)
        {
            fixed (int* v_ptr = &v)
            {
                VertexAttribI1iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI2iv(uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v)
            {
                VertexAttribI2iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI2iv(uint index, int[] v)
        {
            fixed (int* v_ptr = v)
            {
                VertexAttribI2iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI2iv(uint index, in int v)
        {
            fixed (int* v_ptr = &v)
            {
                VertexAttribI2iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI3iv(uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v)
            {
                VertexAttribI3iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI3iv(uint index, int[] v)
        {
            fixed (int* v_ptr = v)
            {
                VertexAttribI3iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI3iv(uint index, in int v)
        {
            fixed (int* v_ptr = &v)
            {
                VertexAttribI3iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4iv(uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v)
            {
                VertexAttribI4iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4iv(uint index, int[] v)
        {
            fixed (int* v_ptr = v)
            {
                VertexAttribI4iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4iv(uint index, in int v)
        {
            fixed (int* v_ptr = &v)
            {
                VertexAttribI4iv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI1ui(uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v)
            {
                VertexAttribI1uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI1ui(uint index, uint[] v)
        {
            fixed (uint* v_ptr = v)
            {
                VertexAttribI1uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI1ui(uint index, in uint v)
        {
            fixed (uint* v_ptr = &v)
            {
                VertexAttribI1uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI2ui(uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v)
            {
                VertexAttribI2uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI2ui(uint index, uint[] v)
        {
            fixed (uint* v_ptr = v)
            {
                VertexAttribI2uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI2ui(uint index, in uint v)
        {
            fixed (uint* v_ptr = &v)
            {
                VertexAttribI2uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI3ui(uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v)
            {
                VertexAttribI3uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI3ui(uint index, uint[] v)
        {
            fixed (uint* v_ptr = v)
            {
                VertexAttribI3uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI3ui(uint index, in uint v)
        {
            fixed (uint* v_ptr = &v)
            {
                VertexAttribI3uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4ui(uint index, ReadOnlySpan<uint> v)
        {
            fixed (uint* v_ptr = v)
            {
                VertexAttribI4uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4ui(uint index, uint[] v)
        {
            fixed (uint* v_ptr = v)
            {
                VertexAttribI4uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4ui(uint index, in uint v)
        {
            fixed (uint* v_ptr = &v)
            {
                VertexAttribI4uiv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4(uint index, ReadOnlySpan<sbyte> v)
        {
            fixed (sbyte* v_ptr = v)
            {
                VertexAttribI4bv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4(uint index, sbyte[] v)
        {
            fixed (sbyte* v_ptr = v)
            {
                VertexAttribI4bv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4(uint index, in sbyte v)
        {
            fixed (sbyte* v_ptr = &v)
            {
                VertexAttribI4bv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4(uint index, ReadOnlySpan<short> v)
        {
            fixed (short* v_ptr = v)
            {
                VertexAttribI4sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4(uint index, short[] v)
        {
            fixed (short* v_ptr = v)
            {
                VertexAttribI4sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4(uint index, in short v)
        {
            fixed (short* v_ptr = &v)
            {
                VertexAttribI4sv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4(uint index, ReadOnlySpan<byte> v)
        {
            fixed (byte* v_ptr = v)
            {
                VertexAttribI4ubv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4(uint index, byte[] v)
        {
            fixed (byte* v_ptr = v)
            {
                VertexAttribI4ubv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4(uint index, in byte v)
        {
            fixed (byte* v_ptr = &v)
            {
                VertexAttribI4ubv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4(uint index, ReadOnlySpan<ushort> v)
        {
            fixed (ushort* v_ptr = v)
            {
                VertexAttribI4usv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4(uint index, ushort[] v)
        {
            fixed (ushort* v_ptr = v)
            {
                VertexAttribI4usv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribI4(uint index, in ushort v)
        {
            fixed (ushort* v_ptr = &v)
            {
                VertexAttribI4usv(index, v_ptr);
            }
        }
        public static unsafe void GetUniformui(ProgramHandle program, int location, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                GetUniformuiv(program, location, parameters_ptr);
            }
        }
        public static unsafe void GetUniformui(ProgramHandle program, int location, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                GetUniformuiv(program, location, parameters_ptr);
            }
        }
        public static unsafe void GetUniformui(ProgramHandle program, int location, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters)
            {
                GetUniformuiv(program, location, parameters_ptr);
            }
        }
        public static unsafe void BindFragDataLocation(ProgramHandle program, uint color, string name)
        {
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            BindFragDataLocation(program, color, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
        }
        public static unsafe int GetFragDataLocation(ProgramHandle program, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = GetFragDataLocation(program, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }
        public static unsafe void Uniform1ui(int location, ReadOnlySpan<uint> value)
        {
            int count = (int)(value.Length / 1);
            fixed (uint* value_ptr = value)
            {
                Uniform1uiv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform1ui(int location, uint[] value)
        {
            int count = (int)(value.Length / 1);
            fixed (uint* value_ptr = value)
            {
                Uniform1uiv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform1ui(int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                Uniform1uiv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform2ui(int location, ReadOnlySpan<uint> value)
        {
            int count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value)
            {
                Uniform2uiv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform2ui(int location, uint[] value)
        {
            int count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value)
            {
                Uniform2uiv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform2ui(int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                Uniform2uiv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform3ui(int location, ReadOnlySpan<uint> value)
        {
            int count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value)
            {
                Uniform3uiv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform3ui(int location, uint[] value)
        {
            int count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value)
            {
                Uniform3uiv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform3ui(int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                Uniform3uiv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform4ui(int location, ReadOnlySpan<uint> value)
        {
            int count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value)
            {
                Uniform4uiv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform4ui(int location, uint[] value)
        {
            int count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value)
            {
                Uniform4uiv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform4ui(int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                Uniform4uiv(location, count, value_ptr);
            }
        }
        public static unsafe void TexParameterIi(TextureTarget target, TextureParameterName pname, ReadOnlySpan<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                TexParameterIiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void TexParameterIi(TextureTarget target, TextureParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                TexParameterIiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void TexParameterIi(TextureTarget target, TextureParameterName pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                TexParameterIiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void TexParameterIui(TextureTarget target, TextureParameterName pname, ReadOnlySpan<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                TexParameterIuiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void TexParameterIui(TextureTarget target, TextureParameterName pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                TexParameterIuiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void TexParameterIui(TextureTarget target, TextureParameterName pname, in uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters)
            {
                TexParameterIuiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexParameterIi(TextureTarget target, GetTextureParameter pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetTexParameterIiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexParameterIi(TextureTarget target, GetTextureParameter pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetTexParameterIiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexParameterIi(TextureTarget target, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetTexParameterIiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexParameterIui(TextureTarget target, GetTextureParameter pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                GetTexParameterIuiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexParameterIui(TextureTarget target, GetTextureParameter pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                GetTexParameterIuiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTexParameterIui(TextureTarget target, GetTextureParameter pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters)
            {
                GetTexParameterIuiv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void ClearBufferi(Buffer buffer, int drawbuffer, ReadOnlySpan<int> value)
        {
            fixed (int* value_ptr = value)
            {
                ClearBufferiv(buffer, drawbuffer, value_ptr);
            }
        }
        public static unsafe void ClearBufferi(Buffer buffer, int drawbuffer, int[] value)
        {
            fixed (int* value_ptr = value)
            {
                ClearBufferiv(buffer, drawbuffer, value_ptr);
            }
        }
        public static unsafe void ClearBufferi(Buffer buffer, int drawbuffer, in int value)
        {
            fixed (int* value_ptr = &value)
            {
                ClearBufferiv(buffer, drawbuffer, value_ptr);
            }
        }
        public static unsafe void ClearBufferui(Buffer buffer, int drawbuffer, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value)
            {
                ClearBufferuiv(buffer, drawbuffer, value_ptr);
            }
        }
        public static unsafe void ClearBufferui(Buffer buffer, int drawbuffer, uint[] value)
        {
            fixed (uint* value_ptr = value)
            {
                ClearBufferuiv(buffer, drawbuffer, value_ptr);
            }
        }
        public static unsafe void ClearBufferui(Buffer buffer, int drawbuffer, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                ClearBufferuiv(buffer, drawbuffer, value_ptr);
            }
        }
        public static unsafe void ClearBufferf(Buffer buffer, int drawbuffer, ReadOnlySpan<float> value)
        {
            fixed (float* value_ptr = value)
            {
                ClearBufferfv(buffer, drawbuffer, value_ptr);
            }
        }
        public static unsafe void ClearBufferf(Buffer buffer, int drawbuffer, float[] value)
        {
            fixed (float* value_ptr = value)
            {
                ClearBufferfv(buffer, drawbuffer, value_ptr);
            }
        }
        public static unsafe void ClearBufferf(Buffer buffer, int drawbuffer, in float value)
        {
            fixed (float* value_ptr = &value)
            {
                ClearBufferfv(buffer, drawbuffer, value_ptr);
            }
        }
        public static unsafe void ClearBuffer(Buffer buffer, int drawbuffer, float depth, int stencil)
        {
            ClearBufferfi(buffer, drawbuffer, depth, stencil);
        }
        public static unsafe string? GetStringi(StringName name, uint index)
        {
            byte* returnValue;
            string? returnValue_str;
            returnValue = GetStringi_(name, index);
            returnValue_str = Marshal.PtrToStringAnsi((IntPtr)returnValue);
            return returnValue_str;
        }
        public static unsafe void DeleteRenderbuffer(in RenderbufferHandle renderbuffers)
        {
            int n = 1;
            fixed(RenderbufferHandle* renderbuffers_handle = &renderbuffers)
            {
                DeleteRenderbuffers(n, renderbuffers_handle);
            }
        }
        public static unsafe void DeleteRenderbuffers(ReadOnlySpan<RenderbufferHandle> renderbuffers)
        {
            int n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
            {
                DeleteRenderbuffers(n, renderbuffers_ptr);
            }
        }
        public static unsafe void DeleteRenderbuffers(RenderbufferHandle[] renderbuffers)
        {
            int n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
            {
                DeleteRenderbuffers(n, renderbuffers_ptr);
            }
        }
        public static unsafe void DeleteRenderbuffers(int n, in RenderbufferHandle renderbuffers)
        {
            fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers)
            {
                DeleteRenderbuffers(n, renderbuffers_ptr);
            }
        }
        public static unsafe RenderbufferHandle GenRenderbuffer()
        {
            RenderbufferHandle renderbuffers;
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            GenRenderbuffers(n, renderbuffers_handle);
            return renderbuffers;
        }
        public static unsafe void GenRenderbuffer(out RenderbufferHandle renderbuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            GenRenderbuffers(n, renderbuffers_handle);
        }
        public static unsafe void GenRenderbuffers(Span<RenderbufferHandle> renderbuffers)
        {
            int n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
            {
                GenRenderbuffers(n, renderbuffers_ptr);
            }
        }
        public static unsafe void GenRenderbuffers(RenderbufferHandle[] renderbuffers)
        {
            int n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
            {
                GenRenderbuffers(n, renderbuffers_ptr);
            }
        }
        public static unsafe void GenRenderbuffers(int n, ref RenderbufferHandle renderbuffers)
        {
            fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers)
            {
                GenRenderbuffers(n, renderbuffers_ptr);
            }
        }
        public static unsafe void GetRenderbufferParameteri(RenderbufferTarget target, RenderbufferParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetRenderbufferParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetRenderbufferParameteri(RenderbufferTarget target, RenderbufferParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetRenderbufferParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetRenderbufferParameteri(RenderbufferTarget target, RenderbufferParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetRenderbufferParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void DeleteFramebuffer(in FramebufferHandle framebuffers)
        {
            int n = 1;
            fixed(FramebufferHandle* framebuffers_handle = &framebuffers)
            {
                DeleteFramebuffers(n, framebuffers_handle);
            }
        }
        public static unsafe void DeleteFramebuffers(ReadOnlySpan<FramebufferHandle> framebuffers)
        {
            int n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
            {
                DeleteFramebuffers(n, framebuffers_ptr);
            }
        }
        public static unsafe void DeleteFramebuffers(FramebufferHandle[] framebuffers)
        {
            int n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
            {
                DeleteFramebuffers(n, framebuffers_ptr);
            }
        }
        public static unsafe void DeleteFramebuffers(int n, in FramebufferHandle framebuffers)
        {
            fixed (FramebufferHandle* framebuffers_ptr = &framebuffers)
            {
                DeleteFramebuffers(n, framebuffers_ptr);
            }
        }
        public static unsafe FramebufferHandle GenFramebuffer()
        {
            FramebufferHandle framebuffers;
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            GenFramebuffers(n, framebuffers_handle);
            return framebuffers;
        }
        public static unsafe void GenFramebuffer(out FramebufferHandle framebuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            GenFramebuffers(n, framebuffers_handle);
        }
        public static unsafe void GenFramebuffers(Span<FramebufferHandle> framebuffers)
        {
            int n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
            {
                GenFramebuffers(n, framebuffers_ptr);
            }
        }
        public static unsafe void GenFramebuffers(FramebufferHandle[] framebuffers)
        {
            int n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
            {
                GenFramebuffers(n, framebuffers_ptr);
            }
        }
        public static unsafe void GenFramebuffers(int n, ref FramebufferHandle framebuffers)
        {
            fixed (FramebufferHandle* framebuffers_ptr = &framebuffers)
            {
                GenFramebuffers(n, framebuffers_ptr);
            }
        }
        public static unsafe void GetFramebufferAttachmentParameteri(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
            }
        }
        public static unsafe void GetFramebufferAttachmentParameteri(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
            }
        }
        public static unsafe void GetFramebufferAttachmentParameteri(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
            }
        }
        public static unsafe void DeleteVertexArray(in VertexArrayHandle arrays)
        {
            int n = 1;
            fixed(VertexArrayHandle* arrays_handle = &arrays)
            {
                DeleteVertexArrays(n, arrays_handle);
            }
        }
        public static unsafe void DeleteVertexArrays(ReadOnlySpan<VertexArrayHandle> arrays)
        {
            int n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays)
            {
                DeleteVertexArrays(n, arrays_ptr);
            }
        }
        public static unsafe void DeleteVertexArrays(VertexArrayHandle[] arrays)
        {
            int n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays)
            {
                DeleteVertexArrays(n, arrays_ptr);
            }
        }
        public static unsafe void DeleteVertexArrays(int n, in VertexArrayHandle arrays)
        {
            fixed (VertexArrayHandle* arrays_ptr = &arrays)
            {
                DeleteVertexArrays(n, arrays_ptr);
            }
        }
        public static unsafe VertexArrayHandle GenVertexArray()
        {
            VertexArrayHandle arrays;
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            GenVertexArrays(n, arrays_handle);
            return arrays;
        }
        public static unsafe void GenVertexArray(out VertexArrayHandle arrays)
        {
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            GenVertexArrays(n, arrays_handle);
        }
        public static unsafe void GenVertexArrays(Span<VertexArrayHandle> arrays)
        {
            int n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays)
            {
                GenVertexArrays(n, arrays_ptr);
            }
        }
        public static unsafe void GenVertexArrays(VertexArrayHandle[] arrays)
        {
            int n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays)
            {
                GenVertexArrays(n, arrays_ptr);
            }
        }
        public static unsafe void GenVertexArrays(int n, ref VertexArrayHandle arrays)
        {
            fixed (VertexArrayHandle* arrays_ptr = &arrays)
            {
                GenVertexArrays(n, arrays_ptr);
            }
        }
        public static unsafe void DrawElementsInstanced(PrimitiveType mode, int count, DrawElementsType type, nint offset, int instancecount)
        {
            void* indices = (void*)offset;
            DrawElementsInstanced(mode, count, type, indices, instancecount);
        }
        public static unsafe void GetUniformIndices(ProgramHandle program, int uniformCount, byte** uniformNames, Span<uint> uniformIndices)
        {
            fixed (uint* uniformIndices_ptr = uniformIndices)
            {
                GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
            }
        }
        public static unsafe void GetUniformIndices(ProgramHandle program, int uniformCount, byte** uniformNames, uint[] uniformIndices)
        {
            fixed (uint* uniformIndices_ptr = uniformIndices)
            {
                GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
            }
        }
        public static unsafe void GetUniformIndices(ProgramHandle program, int uniformCount, byte** uniformNames, ref uint uniformIndices)
        {
            fixed (uint* uniformIndices_ptr = &uniformIndices)
            {
                GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
            }
        }
        public static unsafe void GetActiveUniformsi(ProgramHandle program, ReadOnlySpan<uint> uniformIndices, UniformPName pname, Span<int> parameters)
        {
            int uniformCount = (int)(uniformIndices.Length);
            fixed (uint* uniformIndices_ptr = uniformIndices)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
                }
            }
        }
        public static unsafe void GetActiveUniformsi(ProgramHandle program, uint[] uniformIndices, UniformPName pname, int[] parameters)
        {
            int uniformCount = (int)(uniformIndices.Length);
            fixed (uint* uniformIndices_ptr = uniformIndices)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
                }
            }
        }
        public static unsafe void GetActiveUniformsi(ProgramHandle program, int uniformCount, in uint uniformIndices, UniformPName pname, ref int parameters)
        {
            fixed (uint* uniformIndices_ptr = &uniformIndices)
            fixed (int* parameters_ptr = &parameters)
            {
                GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
            }
        }
        public static unsafe string GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, Span<int> length)
        {
            string uniformName;
            fixed (int* length_ptr = length)
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
            return uniformName;
        }
        public static unsafe void GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, Span<int> length, out string uniformName)
        {
            fixed (int* length_ptr = length)
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
        }
        public static unsafe string GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, int[] length)
        {
            string uniformName;
            fixed (int* length_ptr = length)
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
            return uniformName;
        }
        public static unsafe void GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, int[] length, out string uniformName)
        {
            fixed (int* length_ptr = length)
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
        }
        public static unsafe string GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, ref int length)
        {
            string uniformName;
            fixed (int* length_ptr = &length)
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
            return uniformName;
        }
        public static unsafe void GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, ref int length, out string uniformName)
        {
            fixed (int* length_ptr = &length)
            {
                var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
            }
        }
        public static unsafe uint GetUniformBlockIndex(ProgramHandle program, string uniformBlockName)
        {
            uint returnValue;
            byte* uniformBlockName_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(uniformBlockName);
            returnValue = GetUniformBlockIndex(program, uniformBlockName_ptr);
            Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            return returnValue;
        }
        public static unsafe void GetActiveUniformBlocki(ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
            }
        }
        public static unsafe void GetActiveUniformBlocki(ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
            }
        }
        public static unsafe void GetActiveUniformBlocki(ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
            }
        }
        public static unsafe string GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, Span<int> length)
        {
            string uniformBlockName;
            fixed (int* length_ptr = length)
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
            return uniformBlockName;
        }
        public static unsafe void GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, Span<int> length, out string uniformBlockName)
        {
            fixed (int* length_ptr = length)
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
        }
        public static unsafe string GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, int[] length)
        {
            string uniformBlockName;
            fixed (int* length_ptr = length)
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
            return uniformBlockName;
        }
        public static unsafe void GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, int[] length, out string uniformBlockName)
        {
            fixed (int* length_ptr = length)
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
        }
        public static unsafe string GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, ref int length)
        {
            string uniformBlockName;
            fixed (int* length_ptr = &length)
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
            return uniformBlockName;
        }
        public static unsafe void GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, ref int length, out string uniformBlockName)
        {
            fixed (int* length_ptr = &length)
            {
                var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
            }
        }
        public static unsafe void DrawElementsBaseVertex(PrimitiveType mode, int count, DrawElementsType type, nint offset, int basevertex)
        {
            void* indices = (void*)offset;
            DrawElementsBaseVertex(mode, count, type, indices, basevertex);
        }
        public static unsafe void DrawRangeElementsBaseVertex(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, nint offset, int basevertex)
        {
            void* indices = (void*)offset;
            DrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
        }
        public static unsafe void DrawElementsInstancedBaseVertex(PrimitiveType mode, int count, DrawElementsType type, nint offset, int instancecount, int basevertex)
        {
            void* indices = (void*)offset;
            DrawElementsInstancedBaseVertex(mode, count, type, indices, instancecount, basevertex);
        }
        public static unsafe void MultiDrawElementsBaseVertex(PrimitiveType mode, ReadOnlySpan<int> count, DrawElementsType type, void** indices, int drawcount, ReadOnlySpan<int> basevertex)
        {
            fixed (int* count_ptr = count)
            {
                fixed (int* basevertex_ptr = basevertex)
                {
                    MultiDrawElementsBaseVertex(mode, count_ptr, type, indices, drawcount, basevertex_ptr);
                }
            }
        }
        public static unsafe void MultiDrawElementsBaseVertex(PrimitiveType mode, int[] count, DrawElementsType type, void** indices, int drawcount, int[] basevertex)
        {
            fixed (int* count_ptr = count)
            {
                fixed (int* basevertex_ptr = basevertex)
                {
                    MultiDrawElementsBaseVertex(mode, count_ptr, type, indices, drawcount, basevertex_ptr);
                }
            }
        }
        public static unsafe void MultiDrawElementsBaseVertex(PrimitiveType mode, in int count, DrawElementsType type, void** indices, int drawcount, in int basevertex)
        {
            fixed (int* count_ptr = &count)
            fixed (int* basevertex_ptr = &basevertex)
            {
                MultiDrawElementsBaseVertex(mode, count_ptr, type, indices, drawcount, basevertex_ptr);
            }
        }
        public static unsafe void GetInteger64(GetPName pname, Span<long> data)
        {
            fixed (long* data_ptr = data)
            {
                GetInteger64v(pname, data_ptr);
            }
        }
        public static unsafe void GetInteger64(GetPName pname, long[] data)
        {
            fixed (long* data_ptr = data)
            {
                GetInteger64v(pname, data_ptr);
            }
        }
        public static unsafe void GetInteger64(GetPName pname, ref long data)
        {
            fixed (long* data_ptr = &data)
            {
                GetInteger64v(pname, data_ptr);
            }
        }
        public static unsafe void GetSynci(GLSync sync, SyncParameterName pname, Span<int> length, Span<int> values)
        {
            fixed (int* length_ptr = length)
            {
                int count = (int)(values.Length);
                fixed (int* values_ptr = values)
                {
                    GetSynciv(sync, pname, count, length_ptr, values_ptr);
                }
            }
        }
        public static unsafe void GetSynci(GLSync sync, SyncParameterName pname, int[] length, int[] values)
        {
            fixed (int* length_ptr = length)
            {
                int count = (int)(values.Length);
                fixed (int* values_ptr = values)
                {
                    GetSynciv(sync, pname, count, length_ptr, values_ptr);
                }
            }
        }
        public static unsafe void GetSynci(GLSync sync, SyncParameterName pname, int count, ref int length, ref int values)
        {
            fixed (int* length_ptr = &length)
            fixed (int* values_ptr = &values)
            {
                GetSynciv(sync, pname, count, length_ptr, values_ptr);
            }
        }
        public static unsafe void GetInteger64(GetPName target, uint index, Span<long> data)
        {
            fixed (long* data_ptr = data)
            {
                GetInteger64i_v(target, index, data_ptr);
            }
        }
        public static unsafe void GetInteger64(GetPName target, uint index, long[] data)
        {
            fixed (long* data_ptr = data)
            {
                GetInteger64i_v(target, index, data_ptr);
            }
        }
        public static unsafe void GetInteger64(GetPName target, uint index, ref long data)
        {
            fixed (long* data_ptr = &data)
            {
                GetInteger64i_v(target, index, data_ptr);
            }
        }
        public static unsafe void GetBufferParameteri64(BufferTargetARB target, BufferPNameARB pname, Span<long> parameters)
        {
            fixed (long* parameters_ptr = parameters)
            {
                GetBufferParameteri64v(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetBufferParameteri64(BufferTargetARB target, BufferPNameARB pname, long[] parameters)
        {
            fixed (long* parameters_ptr = parameters)
            {
                GetBufferParameteri64v(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetBufferParameteri64(BufferTargetARB target, BufferPNameARB pname, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters)
            {
                GetBufferParameteri64v(target, pname, parameters_ptr);
            }
        }
        public static unsafe void TexImage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations)
        {
            byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            TexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations_byte);
        }
        public static unsafe void TexImage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
        {
            byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            TexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
        }
        public static unsafe void GetMultisamplef(GetMultisamplePNameNV pname, uint index, Span<float> val)
        {
            fixed (float* val_ptr = val)
            {
                GetMultisamplefv(pname, index, val_ptr);
            }
        }
        public static unsafe void GetMultisamplef(GetMultisamplePNameNV pname, uint index, float[] val)
        {
            fixed (float* val_ptr = val)
            {
                GetMultisamplefv(pname, index, val_ptr);
            }
        }
        public static unsafe void GetMultisamplef(GetMultisamplePNameNV pname, uint index, ref float val)
        {
            fixed (float* val_ptr = &val)
            {
                GetMultisamplefv(pname, index, val_ptr);
            }
        }
        public static unsafe void BindFragDataLocationIndexed(ProgramHandle program, uint colorNumber, uint index, string name)
        {
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            BindFragDataLocationIndexed(program, colorNumber, index, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
        }
        public static unsafe int GetFragDataIndex(ProgramHandle program, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = GetFragDataIndex(program, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }
        public static unsafe SamplerHandle GenSampler()
        {
            SamplerHandle samplers;
            int count = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            GenSamplers(count, samplers_handle);
            return samplers;
        }
        public static unsafe void GenSampler(out SamplerHandle samplers)
        {
            int count = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            GenSamplers(count, samplers_handle);
        }
        public static unsafe void GenSamplers(Span<SamplerHandle> samplers)
        {
            int count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers)
            {
                GenSamplers(count, samplers_ptr);
            }
        }
        public static unsafe void GenSamplers(SamplerHandle[] samplers)
        {
            int count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers)
            {
                GenSamplers(count, samplers_ptr);
            }
        }
        public static unsafe void GenSamplers(int count, ref SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers)
            {
                GenSamplers(count, samplers_ptr);
            }
        }
        public static unsafe void DeleteSampler(in SamplerHandle samplers)
        {
            int count = 1;
            fixed(SamplerHandle* samplers_handle = &samplers)
            {
                DeleteSamplers(count, samplers_handle);
            }
        }
        public static unsafe void DeleteSamplers(ReadOnlySpan<SamplerHandle> samplers)
        {
            int count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers)
            {
                DeleteSamplers(count, samplers_ptr);
            }
        }
        public static unsafe void DeleteSamplers(SamplerHandle[] samplers)
        {
            int count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers)
            {
                DeleteSamplers(count, samplers_ptr);
            }
        }
        public static unsafe void DeleteSamplers(int count, in SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers)
            {
                DeleteSamplers(count, samplers_ptr);
            }
        }
        public static unsafe void SamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<int> param)
        {
            fixed (int* param_ptr = param)
            {
                SamplerParameteriv(sampler, pname, param_ptr);
            }
        }
        public static unsafe void SamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, int[] param)
        {
            fixed (int* param_ptr = param)
            {
                SamplerParameteriv(sampler, pname, param_ptr);
            }
        }
        public static unsafe void SamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, in int param)
        {
            fixed (int* param_ptr = &param)
            {
                SamplerParameteriv(sampler, pname, param_ptr);
            }
        }
        public static unsafe void SamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, ReadOnlySpan<float> param)
        {
            fixed (float* param_ptr = param)
            {
                SamplerParameterfv(sampler, pname, param_ptr);
            }
        }
        public static unsafe void SamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, float[] param)
        {
            fixed (float* param_ptr = param)
            {
                SamplerParameterfv(sampler, pname, param_ptr);
            }
        }
        public static unsafe void SamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, in float param)
        {
            fixed (float* param_ptr = &param)
            {
                SamplerParameterfv(sampler, pname, param_ptr);
            }
        }
        public static unsafe void SamplerParameterIi(SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<int> param)
        {
            fixed (int* param_ptr = param)
            {
                SamplerParameterIiv(sampler, pname, param_ptr);
            }
        }
        public static unsafe void SamplerParameterIi(SamplerHandle sampler, SamplerParameterI pname, int[] param)
        {
            fixed (int* param_ptr = param)
            {
                SamplerParameterIiv(sampler, pname, param_ptr);
            }
        }
        public static unsafe void SamplerParameterIi(SamplerHandle sampler, SamplerParameterI pname, in int param)
        {
            fixed (int* param_ptr = &param)
            {
                SamplerParameterIiv(sampler, pname, param_ptr);
            }
        }
        public static unsafe void SamplerParameterIui(SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<uint> param)
        {
            fixed (uint* param_ptr = param)
            {
                SamplerParameterIuiv(sampler, pname, param_ptr);
            }
        }
        public static unsafe void SamplerParameterIui(SamplerHandle sampler, SamplerParameterI pname, uint[] param)
        {
            fixed (uint* param_ptr = param)
            {
                SamplerParameterIuiv(sampler, pname, param_ptr);
            }
        }
        public static unsafe void SamplerParameterIui(SamplerHandle sampler, SamplerParameterI pname, in uint param)
        {
            fixed (uint* param_ptr = &param)
            {
                SamplerParameterIuiv(sampler, pname, param_ptr);
            }
        }
        public static unsafe void GetSamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetSamplerParameteriv(sampler, pname, parameters_ptr);
            }
        }
        public static unsafe void GetSamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetSamplerParameteriv(sampler, pname, parameters_ptr);
            }
        }
        public static unsafe void GetSamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetSamplerParameteriv(sampler, pname, parameters_ptr);
            }
        }
        public static unsafe void GetSamplerParameterIi(SamplerHandle sampler, SamplerParameterI pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetSamplerParameterIiv(sampler, pname, parameters_ptr);
            }
        }
        public static unsafe void GetSamplerParameterIi(SamplerHandle sampler, SamplerParameterI pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetSamplerParameterIiv(sampler, pname, parameters_ptr);
            }
        }
        public static unsafe void GetSamplerParameterIi(SamplerHandle sampler, SamplerParameterI pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetSamplerParameterIiv(sampler, pname, parameters_ptr);
            }
        }
        public static unsafe void GetSamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, Span<float> parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                GetSamplerParameterfv(sampler, pname, parameters_ptr);
            }
        }
        public static unsafe void GetSamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, float[] parameters)
        {
            fixed (float* parameters_ptr = parameters)
            {
                GetSamplerParameterfv(sampler, pname, parameters_ptr);
            }
        }
        public static unsafe void GetSamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters)
            {
                GetSamplerParameterfv(sampler, pname, parameters_ptr);
            }
        }
        public static unsafe void GetSamplerParameterIui(SamplerHandle sampler, SamplerParameterI pname, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
            }
        }
        public static unsafe void GetSamplerParameterIui(SamplerHandle sampler, SamplerParameterI pname, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
            }
        }
        public static unsafe void GetSamplerParameterIui(SamplerHandle sampler, SamplerParameterI pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters)
            {
                GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryObjecti64(QueryHandle id, QueryObjectParameterName pname, Span<long> parameters)
        {
            fixed (long* parameters_ptr = parameters)
            {
                GetQueryObjecti64v(id, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryObjecti64(QueryHandle id, QueryObjectParameterName pname, long[] parameters)
        {
            fixed (long* parameters_ptr = parameters)
            {
                GetQueryObjecti64v(id, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryObjecti64(QueryHandle id, QueryObjectParameterName pname, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters)
            {
                GetQueryObjecti64v(id, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryObjectui64(QueryHandle id, QueryObjectParameterName pname, Span<ulong> parameters)
        {
            fixed (ulong* parameters_ptr = parameters)
            {
                GetQueryObjectui64v(id, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryObjectui64(QueryHandle id, QueryObjectParameterName pname, ulong[] parameters)
        {
            fixed (ulong* parameters_ptr = parameters)
            {
                GetQueryObjectui64v(id, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryObjectui64(QueryHandle id, QueryObjectParameterName pname, ref ulong parameters)
        {
            fixed (ulong* parameters_ptr = &parameters)
            {
                GetQueryObjectui64v(id, pname, parameters_ptr);
            }
        }
        public static unsafe void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, uint value)
        {
            byte normalized_byte = (byte)(normalized ? 1 : 0);
            VertexAttribP1ui(index, type, normalized_byte, value);
        }
        public static unsafe void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP1uiv(index, type, normalized_byte, value_ptr);
            }
        }
        public static unsafe void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, uint[] value)
        {
            fixed (uint* value_ptr = value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP1uiv(index, type, normalized_byte, value_ptr);
            }
        }
        public static unsafe void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP1uiv(index, type, normalized_byte, value_ptr);
            }
        }
        public static unsafe void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, uint value)
        {
            byte normalized_byte = (byte)(normalized ? 1 : 0);
            VertexAttribP2ui(index, type, normalized_byte, value);
        }
        public static unsafe void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP2uiv(index, type, normalized_byte, value_ptr);
            }
        }
        public static unsafe void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, uint[] value)
        {
            fixed (uint* value_ptr = value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP2uiv(index, type, normalized_byte, value_ptr);
            }
        }
        public static unsafe void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP2uiv(index, type, normalized_byte, value_ptr);
            }
        }
        public static unsafe void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, uint value)
        {
            byte normalized_byte = (byte)(normalized ? 1 : 0);
            VertexAttribP3ui(index, type, normalized_byte, value);
        }
        public static unsafe void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP3uiv(index, type, normalized_byte, value_ptr);
            }
        }
        public static unsafe void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, uint[] value)
        {
            fixed (uint* value_ptr = value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP3uiv(index, type, normalized_byte, value_ptr);
            }
        }
        public static unsafe void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP3uiv(index, type, normalized_byte, value_ptr);
            }
        }
        public static unsafe void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, uint value)
        {
            byte normalized_byte = (byte)(normalized ? 1 : 0);
            VertexAttribP4ui(index, type, normalized_byte, value);
        }
        public static unsafe void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
        {
            fixed (uint* value_ptr = value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP4uiv(index, type, normalized_byte, value_ptr);
            }
        }
        public static unsafe void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, uint[] value)
        {
            fixed (uint* value_ptr = value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP4uiv(index, type, normalized_byte, value_ptr);
            }
        }
        public static unsafe void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP4uiv(index, type, normalized_byte, value_ptr);
            }
        }
        public static unsafe void DrawArraysIndirect(PrimitiveType mode, IntPtr indirect)
        {
            void* indirect_vptr = (void*)indirect;
            DrawArraysIndirect(mode, indirect_vptr);
        }
        public static unsafe void DrawArraysIndirect<T1>(PrimitiveType mode, in T1 indirect)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect)
            {
                DrawArraysIndirect(mode, indirect_ptr);
            }
        }
        public static unsafe void DrawElementsIndirect(PrimitiveType mode, DrawElementsType type, IntPtr indirect)
        {
            void* indirect_vptr = (void*)indirect;
            DrawElementsIndirect(mode, type, indirect_vptr);
        }
        public static unsafe void DrawElementsIndirect<T1>(PrimitiveType mode, DrawElementsType type, in T1 indirect)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect)
            {
                DrawElementsIndirect(mode, type, indirect_ptr);
            }
        }
        public static unsafe void Uniform1d(int location, in double value)
        {
            int count = 1;
            fixed (double* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                Uniform1dv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform1d(int location, int count, ReadOnlySpan<double> value)
        {
            fixed (double* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                Uniform1dv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform1d(int location, int count, double[] value)
        {
            fixed (double* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                Uniform1dv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform2d(int location, in Vector2d value)
        {
            int count = 1;
            fixed (Vector2d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                Uniform2dv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform2d(int location, int count, ReadOnlySpan<Vector2d> value)
        {
            fixed (Vector2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                Uniform2dv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform2d(int location, int count, Vector2d[] value)
        {
            fixed (Vector2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                Uniform2dv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform3d(int location, in Vector3d value)
        {
            int count = 1;
            fixed (Vector3d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                Uniform3dv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform3d(int location, int count, ReadOnlySpan<Vector3d> value)
        {
            fixed (Vector3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                Uniform3dv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform3d(int location, int count, Vector3d[] value)
        {
            fixed (Vector3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                Uniform3dv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform4d(int location, in Vector4d value)
        {
            int count = 1;
            fixed (Vector4d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                Uniform4dv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform4d(int location, int count, ReadOnlySpan<Vector4d> value)
        {
            fixed (Vector4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                Uniform4dv(location, count, value_ptr);
            }
        }
        public static unsafe void Uniform4d(int location, int count, Vector4d[] value)
        {
            fixed (Vector4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                Uniform4dv(location, count, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2d(int location, bool transpose, in Matrix2d value)
        {
            int count = 1;
            fixed (Matrix2d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2d(int location, int count, bool transpose, ReadOnlySpan<Matrix2d> value)
        {
            fixed (Matrix2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2d(int location, int count, bool transpose, Matrix2d[] value)
        {
            fixed (Matrix2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3d(int location, bool transpose, in Matrix3d value)
        {
            int count = 1;
            fixed (Matrix3d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3d(int location, int count, bool transpose, ReadOnlySpan<Matrix3d> value)
        {
            fixed (Matrix3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3d(int location, int count, bool transpose, Matrix3d[] value)
        {
            fixed (Matrix3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4d(int location, bool transpose, in Matrix4d value)
        {
            int count = 1;
            fixed (Matrix4d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4d(int location, int count, bool transpose, ReadOnlySpan<Matrix4d> value)
        {
            fixed (Matrix4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4d(int location, int count, bool transpose, Matrix4d[] value)
        {
            fixed (Matrix4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2x3d(int location, bool transpose, in Matrix2x3d value)
        {
            int count = 1;
            fixed (Matrix2x3d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2x3dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2x3d(int location, int count, bool transpose, ReadOnlySpan<Matrix2x3d> value)
        {
            fixed (Matrix2x3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2x3dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2x3d(int location, int count, bool transpose, Matrix2x3d[] value)
        {
            fixed (Matrix2x3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2x3dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2x4d(int location, bool transpose, in Matrix2x4d value)
        {
            int count = 1;
            fixed (Matrix2x4d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2x4dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2x4d(int location, int count, bool transpose, ReadOnlySpan<Matrix2x4d> value)
        {
            fixed (Matrix2x4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2x4dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix2x4d(int location, int count, bool transpose, Matrix2x4d[] value)
        {
            fixed (Matrix2x4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix2x4dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3x2d(int location, bool transpose, in Matrix3x2d value)
        {
            int count = 1;
            fixed (Matrix3x2d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3x2dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3x2d(int location, int count, bool transpose, ReadOnlySpan<Matrix3x2d> value)
        {
            fixed (Matrix3x2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3x2dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3x2d(int location, int count, bool transpose, Matrix3x2d[] value)
        {
            fixed (Matrix3x2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3x2dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3x4d(int location, bool transpose, in Matrix3x4d value)
        {
            int count = 1;
            fixed (Matrix3x4d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3x4dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3x4d(int location, int count, bool transpose, ReadOnlySpan<Matrix3x4d> value)
        {
            fixed (Matrix3x4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3x4dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix3x4d(int location, int count, bool transpose, Matrix3x4d[] value)
        {
            fixed (Matrix3x4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix3x4dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4x2d(int location, bool transpose, in Matrix4x2d value)
        {
            int count = 1;
            fixed (Matrix4x2d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4x2dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4x2d(int location, int count, bool transpose, ReadOnlySpan<Matrix4x2d> value)
        {
            fixed (Matrix4x2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4x2dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4x2d(int location, int count, bool transpose, Matrix4x2d[] value)
        {
            fixed (Matrix4x2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4x2dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4x3d(int location, bool transpose, in Matrix4x3d value)
        {
            int count = 1;
            fixed (Matrix4x3d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4x3dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4x3d(int location, int count, bool transpose, ReadOnlySpan<Matrix4x3d> value)
        {
            fixed (Matrix4x3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4x3dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void UniformMatrix4x3d(int location, int count, bool transpose, Matrix4x3d[] value)
        {
            fixed (Matrix4x3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                UniformMatrix4x3dv(location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void GetUniformd(ProgramHandle program, int location, Span<double> parameters)
        {
            fixed (double* parameters_ptr = parameters)
            {
                GetUniformdv(program, location, parameters_ptr);
            }
        }
        public static unsafe void GetUniformd(ProgramHandle program, int location, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters)
            {
                GetUniformdv(program, location, parameters_ptr);
            }
        }
        public static unsafe void GetUniformd(ProgramHandle program, int location, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters)
            {
                GetUniformdv(program, location, parameters_ptr);
            }
        }
        public static unsafe int GetSubroutineUniformLocation(ProgramHandle program, ShaderType shadertype, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = GetSubroutineUniformLocation(program, shadertype, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }
        public static unsafe uint GetSubroutineIndex(ProgramHandle program, ShaderType shadertype, string name)
        {
            uint returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = GetSubroutineIndex(program, shadertype, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }
        public static unsafe void GetActiveSubroutineUniformi(ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, Span<int> values)
        {
            fixed (int* values_ptr = values)
            {
                GetActiveSubroutineUniformiv(program, shadertype, index, pname, values_ptr);
            }
        }
        public static unsafe void GetActiveSubroutineUniformi(ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, int[] values)
        {
            fixed (int* values_ptr = values)
            {
                GetActiveSubroutineUniformiv(program, shadertype, index, pname, values_ptr);
            }
        }
        public static unsafe void GetActiveSubroutineUniformi(ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, ref int values)
        {
            fixed (int* values_ptr = &values)
            {
                GetActiveSubroutineUniformiv(program, shadertype, index, pname, values_ptr);
            }
        }
        public static unsafe string GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length)
        {
            string name;
            fixed (int* length_ptr = length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }
        public static unsafe void GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length, out string name)
        {
            fixed (int* length_ptr = length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }
        public static unsafe string GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length)
        {
            string name;
            fixed (int* length_ptr = length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }
        public static unsafe void GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length, out string name)
        {
            fixed (int* length_ptr = length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }
        public static unsafe string GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length)
        {
            string name;
            fixed (int* length_ptr = &length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }
        public static unsafe void GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length, out string name)
        {
            fixed (int* length_ptr = &length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }
        public static unsafe string GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length)
        {
            string name;
            fixed (int* length_ptr = length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }
        public static unsafe void GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length, out string name)
        {
            fixed (int* length_ptr = length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }
        public static unsafe string GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length)
        {
            string name;
            fixed (int* length_ptr = length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }
        public static unsafe void GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length, out string name)
        {
            fixed (int* length_ptr = length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }
        public static unsafe string GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length)
        {
            string name;
            fixed (int* length_ptr = &length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }
        public static unsafe void GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length, out string name)
        {
            fixed (int* length_ptr = &length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }
        public static unsafe void UniformSubroutinesui(ShaderType shadertype, ReadOnlySpan<uint> indices)
        {
            int count = (int)(indices.Length);
            fixed (uint* indices_ptr = indices)
            {
                UniformSubroutinesuiv(shadertype, count, indices_ptr);
            }
        }
        public static unsafe void UniformSubroutinesui(ShaderType shadertype, uint[] indices)
        {
            int count = (int)(indices.Length);
            fixed (uint* indices_ptr = indices)
            {
                UniformSubroutinesuiv(shadertype, count, indices_ptr);
            }
        }
        public static unsafe void UniformSubroutinesui(ShaderType shadertype, int count, in uint indices)
        {
            fixed (uint* indices_ptr = &indices)
            {
                UniformSubroutinesuiv(shadertype, count, indices_ptr);
            }
        }
        public static unsafe void GetUniformSubroutineui(ShaderType shadertype, int location, Span<uint> parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                GetUniformSubroutineuiv(shadertype, location, parameters_ptr);
            }
        }
        public static unsafe void GetUniformSubroutineui(ShaderType shadertype, int location, uint[] parameters)
        {
            fixed (uint* parameters_ptr = parameters)
            {
                GetUniformSubroutineuiv(shadertype, location, parameters_ptr);
            }
        }
        public static unsafe void GetUniformSubroutineui(ShaderType shadertype, int location, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters)
            {
                GetUniformSubroutineuiv(shadertype, location, parameters_ptr);
            }
        }
        public static unsafe void GetProgramStagei(ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, Span<int> values)
        {
            fixed (int* values_ptr = values)
            {
                GetProgramStageiv(program, shadertype, pname, values_ptr);
            }
        }
        public static unsafe void GetProgramStagei(ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, int[] values)
        {
            fixed (int* values_ptr = values)
            {
                GetProgramStageiv(program, shadertype, pname, values_ptr);
            }
        }
        public static unsafe void GetProgramStagei(ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, ref int values)
        {
            fixed (int* values_ptr = &values)
            {
                GetProgramStageiv(program, shadertype, pname, values_ptr);
            }
        }
        public static unsafe void PatchParameterf(PatchParameterName pname, ReadOnlySpan<float> values)
        {
            fixed (float* values_ptr = values)
            {
                PatchParameterfv(pname, values_ptr);
            }
        }
        public static unsafe void PatchParameterf(PatchParameterName pname, float[] values)
        {
            fixed (float* values_ptr = values)
            {
                PatchParameterfv(pname, values_ptr);
            }
        }
        public static unsafe void PatchParameterf(PatchParameterName pname, in float values)
        {
            fixed (float* values_ptr = &values)
            {
                PatchParameterfv(pname, values_ptr);
            }
        }
        public static unsafe void DeleteTransformFeedback(in TransformFeedbackHandle ids)
        {
            int n = 1;
            fixed(TransformFeedbackHandle* ids_handle = &ids)
            {
                DeleteTransformFeedbacks(n, ids_handle);
            }
        }
        public static unsafe void DeleteTransformFeedbacks(ReadOnlySpan<TransformFeedbackHandle> ids)
        {
            int n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids)
            {
                DeleteTransformFeedbacks(n, ids_ptr);
            }
        }
        public static unsafe void DeleteTransformFeedbacks(TransformFeedbackHandle[] ids)
        {
            int n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids)
            {
                DeleteTransformFeedbacks(n, ids_ptr);
            }
        }
        public static unsafe void DeleteTransformFeedbacks(int n, in TransformFeedbackHandle ids)
        {
            fixed (TransformFeedbackHandle* ids_ptr = &ids)
            {
                DeleteTransformFeedbacks(n, ids_ptr);
            }
        }
        public static unsafe TransformFeedbackHandle GenTransformFeedback()
        {
            TransformFeedbackHandle ids;
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            GenTransformFeedbacks(n, ids_handle);
            return ids;
        }
        public static unsafe void GenTransformFeedback(out TransformFeedbackHandle ids)
        {
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            GenTransformFeedbacks(n, ids_handle);
        }
        public static unsafe void GenTransformFeedbacks(Span<TransformFeedbackHandle> ids)
        {
            int n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids)
            {
                GenTransformFeedbacks(n, ids_ptr);
            }
        }
        public static unsafe void GenTransformFeedbacks(TransformFeedbackHandle[] ids)
        {
            int n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids)
            {
                GenTransformFeedbacks(n, ids_ptr);
            }
        }
        public static unsafe void GenTransformFeedbacks(int n, ref TransformFeedbackHandle ids)
        {
            fixed (TransformFeedbackHandle* ids_ptr = &ids)
            {
                GenTransformFeedbacks(n, ids_ptr);
            }
        }
        public static unsafe void GetQueryIndexedi(QueryTarget target, uint index, QueryParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetQueryIndexediv(target, index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryIndexedi(QueryTarget target, uint index, QueryParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetQueryIndexediv(target, index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetQueryIndexedi(QueryTarget target, uint index, QueryParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetQueryIndexediv(target, index, pname, parameters_ptr);
            }
        }
        public static unsafe void ShaderBinary(ReadOnlySpan<ShaderHandle> shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
        {
            int count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders)
            {
                void* binary_vptr = (void*)binary;
                ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
            }
        }
        public static unsafe void ShaderBinary(ShaderHandle[] shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
        {
            int count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders)
            {
                void* binary_vptr = (void*)binary;
                ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
            }
        }
        public static unsafe void ShaderBinary(int count, in ShaderHandle shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
        {
            fixed (ShaderHandle* shaders_ptr = &shaders)
            {
                void* binary_vptr = (void*)binary;
                ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
            }
        }
        public static unsafe void ShaderBinary<T1>(ReadOnlySpan<ShaderHandle> shaders, ShaderBinaryFormat binaryFormat, ReadOnlySpan<T1> binary)
            where T1 : unmanaged
        {
            int count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders)
            {
                int length = (int)(binary.Length * sizeof(T1));
                fixed (void* binary_ptr = binary)
                {
                    ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
                }
            }
        }
        public static unsafe void ShaderBinary<T1>(ShaderHandle[] shaders, ShaderBinaryFormat binaryFormat, T1[] binary)
            where T1 : unmanaged
        {
            int count = (int)(shaders.Length);
            fixed (ShaderHandle* shaders_ptr = shaders)
            {
                int length = (int)(binary.Length * sizeof(T1));
                fixed (void* binary_ptr = binary)
                {
                    ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
                }
            }
        }
        public static unsafe void ShaderBinary<T1>(int count, in ShaderHandle shaders, ShaderBinaryFormat binaryFormat, in T1 binary, int length)
            where T1 : unmanaged
        {
            fixed (ShaderHandle* shaders_ptr = &shaders)
            fixed (void* binary_ptr = &binary)
            {
                ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
            }
        }
        public static unsafe void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, Span<int> range, Span<int> precision)
        {
            fixed (int* range_ptr = range)
            {
                fixed (int* precision_ptr = precision)
                {
                    GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
                }
            }
        }
        public static unsafe void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, int[] range, int[] precision)
        {
            fixed (int* range_ptr = range)
            {
                fixed (int* precision_ptr = precision)
                {
                    GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
                }
            }
        }
        public static unsafe void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, ref int range, ref int precision)
        {
            fixed (int* range_ptr = &range)
            fixed (int* precision_ptr = &precision)
            {
                GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
            }
        }
        public static unsafe void GetProgramBinary(ProgramHandle program, int bufSize, Span<int> length, Span<All> binaryFormat, IntPtr binary)
        {
            fixed (int* length_ptr = length)
            {
                fixed (All* binaryFormat_ptr = binaryFormat)
                {
                    void* binary_vptr = (void*)binary;
                    GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
                }
            }
        }
        public static unsafe void GetProgramBinary(ProgramHandle program, int bufSize, int[] length, All[] binaryFormat, IntPtr binary)
        {
            fixed (int* length_ptr = length)
            {
                fixed (All* binaryFormat_ptr = binaryFormat)
                {
                    void* binary_vptr = (void*)binary;
                    GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
                }
            }
        }
        public static unsafe void GetProgramBinary(ProgramHandle program, int bufSize, ref int length, ref All binaryFormat, IntPtr binary)
        {
            fixed (int* length_ptr = &length)
            fixed (All* binaryFormat_ptr = &binaryFormat)
            {
                void* binary_vptr = (void*)binary;
                GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
            }
        }
        public static unsafe void GetProgramBinary<T1>(ProgramHandle program, Span<int> length, Span<All> binaryFormat, Span<T1> binary)
            where T1 : unmanaged
        {
            fixed (int* length_ptr = length)
            {
                fixed (All* binaryFormat_ptr = binaryFormat)
                {
                    int bufSize = (int)(binary.Length * sizeof(T1));
                    fixed (void* binary_ptr = binary)
                    {
                        GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
                    }
                }
            }
        }
        public static unsafe void GetProgramBinary<T1>(ProgramHandle program, int[] length, All[] binaryFormat, T1[] binary)
            where T1 : unmanaged
        {
            fixed (int* length_ptr = length)
            {
                fixed (All* binaryFormat_ptr = binaryFormat)
                {
                    int bufSize = (int)(binary.Length * sizeof(T1));
                    fixed (void* binary_ptr = binary)
                    {
                        GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
                    }
                }
            }
        }
        public static unsafe void GetProgramBinary<T1>(ProgramHandle program, int bufSize, ref int length, ref All binaryFormat, ref T1 binary)
            where T1 : unmanaged
        {
            fixed (int* length_ptr = &length)
            fixed (All* binaryFormat_ptr = &binaryFormat)
            fixed (void* binary_ptr = &binary)
            {
                GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
            }
        }
        public static unsafe void ProgramBinary(ProgramHandle program, All binaryFormat, IntPtr binary, int length)
        {
            void* binary_vptr = (void*)binary;
            ProgramBinary(program, binaryFormat, binary_vptr, length);
        }
        public static unsafe void ProgramBinary<T1>(ProgramHandle program, All binaryFormat, ReadOnlySpan<T1> binary)
            where T1 : unmanaged
        {
            int length = (int)(binary.Length * sizeof(T1));
            fixed (void* binary_ptr = binary)
            {
                ProgramBinary(program, binaryFormat, binary_ptr, length);
            }
        }
        public static unsafe void ProgramBinary<T1>(ProgramHandle program, All binaryFormat, T1[] binary)
            where T1 : unmanaged
        {
            int length = (int)(binary.Length * sizeof(T1));
            fixed (void* binary_ptr = binary)
            {
                ProgramBinary(program, binaryFormat, binary_ptr, length);
            }
        }
        public static unsafe void ProgramBinary<T1>(ProgramHandle program, All binaryFormat, in T1 binary, int length)
            where T1 : unmanaged
        {
            fixed (void* binary_ptr = &binary)
            {
                ProgramBinary(program, binaryFormat, binary_ptr, length);
            }
        }
        public static unsafe ProgramHandle CreateShaderProgram(ShaderType type, int count, byte** strings)
        {
            ProgramHandle returnValue;
            returnValue = CreateShaderProgramv(type, count, strings);
            return returnValue;
        }
        public static unsafe void DeleteProgramPipeline(in ProgramPipelineHandle pipelines)
        {
            int n = 1;
            fixed(ProgramPipelineHandle* pipelines_handle = &pipelines)
            {
                DeleteProgramPipelines(n, pipelines_handle);
            }
        }
        public static unsafe void DeleteProgramPipelines(ReadOnlySpan<ProgramPipelineHandle> pipelines)
        {
            int n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
            {
                DeleteProgramPipelines(n, pipelines_ptr);
            }
        }
        public static unsafe void DeleteProgramPipelines(ProgramPipelineHandle[] pipelines)
        {
            int n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
            {
                DeleteProgramPipelines(n, pipelines_ptr);
            }
        }
        public static unsafe void DeleteProgramPipelines(int n, in ProgramPipelineHandle pipelines)
        {
            fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines)
            {
                DeleteProgramPipelines(n, pipelines_ptr);
            }
        }
        public static unsafe ProgramPipelineHandle GenProgramPipeline()
        {
            ProgramPipelineHandle pipelines;
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            GenProgramPipelines(n, pipelines_handle);
            return pipelines;
        }
        public static unsafe void GenProgramPipeline(out ProgramPipelineHandle pipelines)
        {
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            GenProgramPipelines(n, pipelines_handle);
        }
        public static unsafe void GenProgramPipelines(Span<ProgramPipelineHandle> pipelines)
        {
            int n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
            {
                GenProgramPipelines(n, pipelines_ptr);
            }
        }
        public static unsafe void GenProgramPipelines(ProgramPipelineHandle[] pipelines)
        {
            int n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
            {
                GenProgramPipelines(n, pipelines_ptr);
            }
        }
        public static unsafe void GenProgramPipelines(int n, ref ProgramPipelineHandle pipelines)
        {
            fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines)
            {
                GenProgramPipelines(n, pipelines_ptr);
            }
        }
        public static unsafe void GetProgramPipelinei(ProgramPipelineHandle pipeline, PipelineParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetProgramPipelineiv(pipeline, pname, parameters_ptr);
            }
        }
        public static unsafe void GetProgramPipelinei(ProgramPipelineHandle pipeline, PipelineParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetProgramPipelineiv(pipeline, pname, parameters_ptr);
            }
        }
        public static unsafe void GetProgramPipelinei(ProgramPipelineHandle pipeline, PipelineParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetProgramPipelineiv(pipeline, pname, parameters_ptr);
            }
        }
        public static unsafe void ProgramUniform1iv(ProgramHandle program, int location, ReadOnlySpan<int> value)
        {
            int count = (int)(value.Length);
            fixed (int* value_ptr = value)
            {
                ProgramUniform1iv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform1iv(ProgramHandle program, int location, int[] value)
        {
            int count = (int)(value.Length);
            fixed (int* value_ptr = value)
            {
                ProgramUniform1iv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform1iv(ProgramHandle program, int location, int count, in int value)
        {
            fixed (int* value_ptr = &value)
            {
                ProgramUniform1iv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform1fv(ProgramHandle program, int location, ReadOnlySpan<float> value)
        {
            int count = (int)(value.Length);
            fixed (float* value_ptr = value)
            {
                ProgramUniform1fv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform1fv(ProgramHandle program, int location, float[] value)
        {
            int count = (int)(value.Length);
            fixed (float* value_ptr = value)
            {
                ProgramUniform1fv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform1fv(ProgramHandle program, int location, int count, in float value)
        {
            fixed (float* value_ptr = &value)
            {
                ProgramUniform1fv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform1dv(ProgramHandle program, int location, ReadOnlySpan<double> value)
        {
            int count = (int)(value.Length);
            fixed (double* value_ptr = value)
            {
                ProgramUniform1dv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform1dv(ProgramHandle program, int location, double[] value)
        {
            int count = (int)(value.Length);
            fixed (double* value_ptr = value)
            {
                ProgramUniform1dv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform1dv(ProgramHandle program, int location, int count, in double value)
        {
            fixed (double* value_ptr = &value)
            {
                ProgramUniform1dv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform1ui(ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            int count = (int)(value.Length);
            fixed (uint* value_ptr = value)
            {
                ProgramUniform1uiv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform1ui(ProgramHandle program, int location, uint[] value)
        {
            int count = (int)(value.Length);
            fixed (uint* value_ptr = value)
            {
                ProgramUniform1uiv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform1ui(ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                ProgramUniform1uiv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform2i(ProgramHandle program, int location, in Vector2i value)
        {
            int count = 1;
            fixed (Vector2i* tmp_vecPtr = &value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                ProgramUniform2iv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform2i(ProgramHandle program, int location, int count, ReadOnlySpan<Vector2i> value)
        {
            fixed (Vector2i* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                ProgramUniform2iv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform2i(ProgramHandle program, int location, int count, Vector2i[] value)
        {
            fixed (Vector2i* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                ProgramUniform2iv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform2f(ProgramHandle program, int location, in Vector2 value)
        {
            int count = 1;
            fixed (Vector2* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                ProgramUniform2fv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform2f(ProgramHandle program, int location, int count, ReadOnlySpan<Vector2> value)
        {
            fixed (Vector2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                ProgramUniform2fv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform2f(ProgramHandle program, int location, int count, Vector2[] value)
        {
            fixed (Vector2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                ProgramUniform2fv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform2d(ProgramHandle program, int location, in Vector2d value)
        {
            int count = 1;
            fixed (Vector2d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                ProgramUniform2dv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform2d(ProgramHandle program, int location, int count, ReadOnlySpan<Vector2d> value)
        {
            fixed (Vector2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                ProgramUniform2dv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform2d(ProgramHandle program, int location, int count, Vector2d[] value)
        {
            fixed (Vector2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                ProgramUniform2dv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform2ui(ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            int count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value)
            {
                ProgramUniform2uiv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform2ui(ProgramHandle program, int location, uint[] value)
        {
            int count = (int)(value.Length / 2);
            fixed (uint* value_ptr = value)
            {
                ProgramUniform2uiv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform2ui(ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                ProgramUniform2uiv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform3i(ProgramHandle program, int location, in Vector3i value)
        {
            int count = 1;
            fixed (Vector3i* tmp_vecPtr = &value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                ProgramUniform3iv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform3i(ProgramHandle program, int location, int count, ReadOnlySpan<Vector3i> value)
        {
            fixed (Vector3i* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                ProgramUniform3iv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform3i(ProgramHandle program, int location, int count, Vector3i[] value)
        {
            fixed (Vector3i* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                ProgramUniform3iv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform3f(ProgramHandle program, int location, in Vector3 value)
        {
            int count = 1;
            fixed (Vector3* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                ProgramUniform3fv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform3f(ProgramHandle program, int location, int count, ReadOnlySpan<Vector3> value)
        {
            fixed (Vector3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                ProgramUniform3fv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform3f(ProgramHandle program, int location, int count, Vector3[] value)
        {
            fixed (Vector3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                ProgramUniform3fv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform3d(ProgramHandle program, int location, in Vector3d value)
        {
            int count = 1;
            fixed (Vector3d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                ProgramUniform3dv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform3d(ProgramHandle program, int location, int count, ReadOnlySpan<Vector3d> value)
        {
            fixed (Vector3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                ProgramUniform3dv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform3d(ProgramHandle program, int location, int count, Vector3d[] value)
        {
            fixed (Vector3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                ProgramUniform3dv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform3ui(ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            int count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value)
            {
                ProgramUniform3uiv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform3ui(ProgramHandle program, int location, uint[] value)
        {
            int count = (int)(value.Length / 3);
            fixed (uint* value_ptr = value)
            {
                ProgramUniform3uiv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform3ui(ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                ProgramUniform3uiv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform4i(ProgramHandle program, int location, in Vector4i value)
        {
            int count = 1;
            fixed (Vector4i* tmp_vecPtr = &value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                ProgramUniform4iv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform4i(ProgramHandle program, int location, int count, ReadOnlySpan<Vector4i> value)
        {
            fixed (Vector4i* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                ProgramUniform4iv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform4i(ProgramHandle program, int location, int count, Vector4i[] value)
        {
            fixed (Vector4i* tmp_vecPtr = value)
            {
                int* value_ptr = (int*)tmp_vecPtr;
                ProgramUniform4iv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform4f(ProgramHandle program, int location, in Vector4 value)
        {
            int count = 1;
            fixed (Vector4* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                ProgramUniform4fv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform4f(ProgramHandle program, int location, int count, ReadOnlySpan<Vector4> value)
        {
            fixed (Vector4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                ProgramUniform4fv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform4f(ProgramHandle program, int location, int count, Vector4[] value)
        {
            fixed (Vector4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                ProgramUniform4fv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform4d(ProgramHandle program, int location, in Vector4d value)
        {
            int count = 1;
            fixed (Vector4d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                ProgramUniform4dv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform4d(ProgramHandle program, int location, int count, ReadOnlySpan<Vector4d> value)
        {
            fixed (Vector4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                ProgramUniform4dv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform4d(ProgramHandle program, int location, int count, Vector4d[] value)
        {
            fixed (Vector4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                ProgramUniform4dv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform4ui(ProgramHandle program, int location, ReadOnlySpan<uint> value)
        {
            int count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value)
            {
                ProgramUniform4uiv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform4ui(ProgramHandle program, int location, uint[] value)
        {
            int count = (int)(value.Length / 4);
            fixed (uint* value_ptr = value)
            {
                ProgramUniform4uiv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniform4ui(ProgramHandle program, int location, int count, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                ProgramUniform4uiv(program, location, count, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2f(ProgramHandle program, int location, bool transpose, in Matrix2 value)
        {
            int count = 1;
            fixed (Matrix2* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix2> value)
        {
            fixed (Matrix2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2f(ProgramHandle program, int location, int count, bool transpose, Matrix2[] value)
        {
            fixed (Matrix2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3f(ProgramHandle program, int location, bool transpose, in Matrix3 value)
        {
            int count = 1;
            fixed (Matrix3* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix3> value)
        {
            fixed (Matrix3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3f(ProgramHandle program, int location, int count, bool transpose, Matrix3[] value)
        {
            fixed (Matrix3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4f(ProgramHandle program, int location, bool transpose, in Matrix4 value)
        {
            int count = 1;
            fixed (Matrix4* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix4> value)
        {
            fixed (Matrix4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4f(ProgramHandle program, int location, int count, bool transpose, Matrix4[] value)
        {
            fixed (Matrix4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2d(ProgramHandle program, int location, bool transpose, in Matrix2d value)
        {
            int count = 1;
            fixed (Matrix2d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix2d> value)
        {
            fixed (Matrix2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2d(ProgramHandle program, int location, int count, bool transpose, Matrix2d[] value)
        {
            fixed (Matrix2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3d(ProgramHandle program, int location, bool transpose, in Matrix3d value)
        {
            int count = 1;
            fixed (Matrix3d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix3d> value)
        {
            fixed (Matrix3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3d(ProgramHandle program, int location, int count, bool transpose, Matrix3d[] value)
        {
            fixed (Matrix3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4d(ProgramHandle program, int location, bool transpose, in Matrix4d value)
        {
            int count = 1;
            fixed (Matrix4d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix4d> value)
        {
            fixed (Matrix4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4d(ProgramHandle program, int location, int count, bool transpose, Matrix4d[] value)
        {
            fixed (Matrix4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2x3f(ProgramHandle program, int location, bool transpose, in Matrix2x3 value)
        {
            int count = 1;
            fixed (Matrix2x3* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2x3f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix2x3> value)
        {
            fixed (Matrix2x3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2x3f(ProgramHandle program, int location, int count, bool transpose, Matrix2x3[] value)
        {
            fixed (Matrix2x3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3x2f(ProgramHandle program, int location, bool transpose, in Matrix3x2 value)
        {
            int count = 1;
            fixed (Matrix3x2* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3x2f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix3x2> value)
        {
            fixed (Matrix3x2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3x2f(ProgramHandle program, int location, int count, bool transpose, Matrix3x2[] value)
        {
            fixed (Matrix3x2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2x4f(ProgramHandle program, int location, bool transpose, in Matrix2x4 value)
        {
            int count = 1;
            fixed (Matrix2x4* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2x4f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix2x4> value)
        {
            fixed (Matrix2x4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2x4f(ProgramHandle program, int location, int count, bool transpose, Matrix2x4[] value)
        {
            fixed (Matrix2x4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4x2f(ProgramHandle program, int location, bool transpose, in Matrix4x2 value)
        {
            int count = 1;
            fixed (Matrix4x2* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4x2f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix4x2> value)
        {
            fixed (Matrix4x2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4x2f(ProgramHandle program, int location, int count, bool transpose, Matrix4x2[] value)
        {
            fixed (Matrix4x2* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3x4f(ProgramHandle program, int location, bool transpose, in Matrix3x4 value)
        {
            int count = 1;
            fixed (Matrix3x4* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3x4f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix3x4> value)
        {
            fixed (Matrix3x4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3x4f(ProgramHandle program, int location, int count, bool transpose, Matrix3x4[] value)
        {
            fixed (Matrix3x4* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4x3f(ProgramHandle program, int location, bool transpose, in Matrix4x3 value)
        {
            int count = 1;
            fixed (Matrix4x3* tmp_vecPtr = &value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4x3f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix4x3> value)
        {
            fixed (Matrix4x3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4x3f(ProgramHandle program, int location, int count, bool transpose, Matrix4x3[] value)
        {
            fixed (Matrix4x3* tmp_vecPtr = value)
            {
                float* value_ptr = (float*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2x3d(ProgramHandle program, int location, bool transpose, in Matrix2x3d value)
        {
            int count = 1;
            fixed (Matrix2x3d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2x3d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix2x3d> value)
        {
            fixed (Matrix2x3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2x3d(ProgramHandle program, int location, int count, bool transpose, Matrix2x3d[] value)
        {
            fixed (Matrix2x3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3x2d(ProgramHandle program, int location, bool transpose, in Matrix3x2d value)
        {
            int count = 1;
            fixed (Matrix3x2d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3x2d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix3x2d> value)
        {
            fixed (Matrix3x2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3x2d(ProgramHandle program, int location, int count, bool transpose, Matrix3x2d[] value)
        {
            fixed (Matrix3x2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2x4d(ProgramHandle program, int location, bool transpose, in Matrix2x4d value)
        {
            int count = 1;
            fixed (Matrix2x4d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2x4d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix2x4d> value)
        {
            fixed (Matrix2x4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix2x4d(ProgramHandle program, int location, int count, bool transpose, Matrix2x4d[] value)
        {
            fixed (Matrix2x4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix2x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4x2d(ProgramHandle program, int location, bool transpose, in Matrix4x2d value)
        {
            int count = 1;
            fixed (Matrix4x2d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4x2d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix4x2d> value)
        {
            fixed (Matrix4x2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4x2d(ProgramHandle program, int location, int count, bool transpose, Matrix4x2d[] value)
        {
            fixed (Matrix4x2d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4x2dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3x4d(ProgramHandle program, int location, bool transpose, in Matrix3x4d value)
        {
            int count = 1;
            fixed (Matrix3x4d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3x4d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix3x4d> value)
        {
            fixed (Matrix3x4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix3x4d(ProgramHandle program, int location, int count, bool transpose, Matrix3x4d[] value)
        {
            fixed (Matrix3x4d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix3x4dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4x3d(ProgramHandle program, int location, bool transpose, in Matrix4x3d value)
        {
            int count = 1;
            fixed (Matrix4x3d* tmp_vecPtr = &value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4x3d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix4x3d> value)
        {
            fixed (Matrix4x3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe void ProgramUniformMatrix4x3d(ProgramHandle program, int location, int count, bool transpose, Matrix4x3d[] value)
        {
            fixed (Matrix4x3d* tmp_vecPtr = value)
            {
                double* value_ptr = (double*)tmp_vecPtr;
                byte transpose_byte = (byte)(transpose ? 1 : 0);
                ProgramUniformMatrix4x3dv(program, location, count, transpose_byte, value_ptr);
            }
        }
        public static unsafe string GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, Span<int> length)
        {
            string infoLog;
            fixed (int* length_ptr = length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }
        public static unsafe void GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, Span<int> length, out string infoLog)
        {
            fixed (int* length_ptr = length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }
        public static unsafe string GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, int[] length)
        {
            string infoLog;
            fixed (int* length_ptr = length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }
        public static unsafe void GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, int[] length, out string infoLog)
        {
            fixed (int* length_ptr = length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }
        public static unsafe string GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, ref int length)
        {
            string infoLog;
            fixed (int* length_ptr = &length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
            return infoLog;
        }
        public static unsafe void GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, ref int length, out string infoLog)
        {
            fixed (int* length_ptr = &length)
            {
                var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
            }
        }
        public static unsafe void VertexAttribL1dv(uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttribL1dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribL1dv(uint index, double[] v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttribL1dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribL1dv(uint index, in double v)
        {
            fixed (double* v_ptr = &v)
            {
                VertexAttribL1dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribL2dv(uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttribL2dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribL2dv(uint index, double[] v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttribL2dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribL2dv(uint index, in double v)
        {
            fixed (double* v_ptr = &v)
            {
                VertexAttribL2dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribL3dv(uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttribL3dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribL3dv(uint index, double[] v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttribL3dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribL3dv(uint index, in double v)
        {
            fixed (double* v_ptr = &v)
            {
                VertexAttribL3dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribL4dv(uint index, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttribL4dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribL4dv(uint index, double[] v)
        {
            fixed (double* v_ptr = v)
            {
                VertexAttribL4dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribL4dv(uint index, in double v)
        {
            fixed (double* v_ptr = &v)
            {
                VertexAttribL4dv(index, v_ptr);
            }
        }
        public static unsafe void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, nint offset)
        {
            void* pointer = (void*)offset;
            VertexAttribLPointer(index, size, type, stride, pointer);
        }
        public static unsafe void GetVertexAttribLd(uint index, VertexAttribEnum pname, Span<double> parameters)
        {
            fixed (double* parameters_ptr = parameters)
            {
                GetVertexAttribLdv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribLd(uint index, VertexAttribEnum pname, double[] parameters)
        {
            fixed (double* parameters_ptr = parameters)
            {
                GetVertexAttribLdv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void GetVertexAttribLd(uint index, VertexAttribEnum pname, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters)
            {
                GetVertexAttribLdv(index, pname, parameters_ptr);
            }
        }
        public static unsafe void ViewportArray(uint first, int count, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v)
            {
                ViewportArrayv(first, count, v_ptr);
            }
        }
        public static unsafe void ViewportArray(uint first, int count, float[] v)
        {
            fixed (float* v_ptr = v)
            {
                ViewportArrayv(first, count, v_ptr);
            }
        }
        public static unsafe void ViewportArray(uint first, int count, in float v)
        {
            fixed (float* v_ptr = &v)
            {
                ViewportArrayv(first, count, v_ptr);
            }
        }
        public static unsafe void ViewportIndexedf(uint index, ReadOnlySpan<float> v)
        {
            fixed (float* v_ptr = v)
            {
                ViewportIndexedfv(index, v_ptr);
            }
        }
        public static unsafe void ViewportIndexedf(uint index, float[] v)
        {
            fixed (float* v_ptr = v)
            {
                ViewportIndexedfv(index, v_ptr);
            }
        }
        public static unsafe void ViewportIndexedf(uint index, in float v)
        {
            fixed (float* v_ptr = &v)
            {
                ViewportIndexedfv(index, v_ptr);
            }
        }
        public static unsafe void ScissorArray(uint first, int count, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v)
            {
                ScissorArrayv(first, count, v_ptr);
            }
        }
        public static unsafe void ScissorArray(uint first, int count, int[] v)
        {
            fixed (int* v_ptr = v)
            {
                ScissorArrayv(first, count, v_ptr);
            }
        }
        public static unsafe void ScissorArray(uint first, int count, in int v)
        {
            fixed (int* v_ptr = &v)
            {
                ScissorArrayv(first, count, v_ptr);
            }
        }
        public static unsafe void ScissorIndexedv(uint index, ReadOnlySpan<int> v)
        {
            fixed (int* v_ptr = v)
            {
                ScissorIndexedv(index, v_ptr);
            }
        }
        public static unsafe void ScissorIndexedv(uint index, int[] v)
        {
            fixed (int* v_ptr = v)
            {
                ScissorIndexedv(index, v_ptr);
            }
        }
        public static unsafe void ScissorIndexedv(uint index, in int v)
        {
            fixed (int* v_ptr = &v)
            {
                ScissorIndexedv(index, v_ptr);
            }
        }
        public static unsafe void DepthRangeArray(uint first, int count, ReadOnlySpan<double> v)
        {
            fixed (double* v_ptr = v)
            {
                DepthRangeArrayv(first, count, v_ptr);
            }
        }
        public static unsafe void DepthRangeArray(uint first, int count, double[] v)
        {
            fixed (double* v_ptr = v)
            {
                DepthRangeArrayv(first, count, v_ptr);
            }
        }
        public static unsafe void DepthRangeArray(uint first, int count, in double v)
        {
            fixed (double* v_ptr = &v)
            {
                DepthRangeArrayv(first, count, v_ptr);
            }
        }
        public static unsafe void GetFloat(GetPName target, uint index, Span<float> data)
        {
            fixed (float* data_ptr = data)
            {
                GetFloati_v(target, index, data_ptr);
            }
        }
        public static unsafe void GetFloat(GetPName target, uint index, float[] data)
        {
            fixed (float* data_ptr = data)
            {
                GetFloati_v(target, index, data_ptr);
            }
        }
        public static unsafe void GetFloat(GetPName target, uint index, ref float data)
        {
            fixed (float* data_ptr = &data)
            {
                GetFloati_v(target, index, data_ptr);
            }
        }
        public static unsafe void GetDouble(GetPName target, uint index, Span<double> data)
        {
            fixed (double* data_ptr = data)
            {
                GetDoublei_v(target, index, data_ptr);
            }
        }
        public static unsafe void GetDouble(GetPName target, uint index, double[] data)
        {
            fixed (double* data_ptr = data)
            {
                GetDoublei_v(target, index, data_ptr);
            }
        }
        public static unsafe void GetDouble(GetPName target, uint index, ref double data)
        {
            fixed (double* data_ptr = &data)
            {
                GetDoublei_v(target, index, data_ptr);
            }
        }
        public static unsafe void DrawElementsInstancedBaseInstance(PrimitiveType mode, int count, PrimitiveType type, nint offset, int instancecount, uint baseinstance)
        {
            void* indices = (void*)offset;
            DrawElementsInstancedBaseInstance(mode, count, type, indices, instancecount, baseinstance);
        }
        public static unsafe void DrawElementsInstancedBaseVertexBaseInstance(PrimitiveType mode, int count, DrawElementsType type, nint offset, int instancecount, int basevertex, uint baseinstance)
        {
            void* indices = (void*)offset;
            DrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, instancecount, basevertex, baseinstance);
        }
        public static unsafe void GetInternalformati(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, Span<int> parameters)
        {
            int count = (int)(parameters.Length);
            fixed (int* parameters_ptr = parameters)
            {
                GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
            }
        }
        public static unsafe void GetInternalformati(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int[] parameters)
        {
            int count = (int)(parameters.Length);
            fixed (int* parameters_ptr = parameters)
            {
                GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
            }
        }
        public static unsafe void GetInternalformati(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
            }
        }
        public static unsafe void GetActiveAtomicCounterBufferi(ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, parameters_ptr);
            }
        }
        public static unsafe void GetActiveAtomicCounterBufferi(ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, parameters_ptr);
            }
        }
        public static unsafe void GetActiveAtomicCounterBufferi(ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, parameters_ptr);
            }
        }
        public static unsafe void BindImageTexture(uint unit, TextureHandle texture, int level, bool layered, int layer, BufferAccessARB access, InternalFormat format)
        {
            byte layered_byte = (byte)(layered ? 1 : 0);
            BindImageTexture(unit, texture, level, layered_byte, layer, access, format);
        }
        public static unsafe void ClearBufferData(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, IntPtr data)
        {
            void* data_vptr = (void*)data;
            ClearBufferData(target, internalformat, format, type, data_vptr);
        }
        public static unsafe void ClearBufferData<T1>(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data)
            {
                ClearBufferData(target, internalformat, format, type, data_ptr);
            }
        }
        public static unsafe void ClearBufferData<T1>(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data)
            {
                ClearBufferData(target, internalformat, format, type, data_ptr);
            }
        }
        public static unsafe void ClearBufferData<T1>(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                ClearBufferData(target, internalformat, format, type, data_ptr);
            }
        }
        public static unsafe void ClearBufferSubData(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, IntPtr data)
        {
            void* data_vptr = (void*)data;
            ClearBufferSubData(target, internalformat, offset, size, format, type, data_vptr);
        }
        public static unsafe void ClearBufferSubData<T1>(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data)
            {
                ClearBufferSubData(target, internalformat, offset, size, format, type, data_ptr);
            }
        }
        public static unsafe void ClearBufferSubData<T1>(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data)
            {
                ClearBufferSubData(target, internalformat, offset, size, format, type, data_ptr);
            }
        }
        public static unsafe void ClearBufferSubData<T1>(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                ClearBufferSubData(target, internalformat, offset, size, format, type, data_ptr);
            }
        }
        public static unsafe void GetFramebufferParameteri(FramebufferTarget target, FramebufferAttachmentParameterName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetFramebufferParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetFramebufferParameteri(FramebufferTarget target, FramebufferAttachmentParameterName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetFramebufferParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetFramebufferParameteri(FramebufferTarget target, FramebufferAttachmentParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetFramebufferParameteriv(target, pname, parameters_ptr);
            }
        }
        public static unsafe void GetInternalformati64(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, Span<long> parameters)
        {
            int count = (int)(parameters.Length);
            fixed (long* parameters_ptr = parameters)
            {
                GetInternalformati64v(target, internalformat, pname, count, parameters_ptr);
            }
        }
        public static unsafe void GetInternalformati64(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, long[] parameters)
        {
            int count = (int)(parameters.Length);
            fixed (long* parameters_ptr = parameters)
            {
                GetInternalformati64v(target, internalformat, pname, count, parameters_ptr);
            }
        }
        public static unsafe void GetInternalformati64(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters)
            {
                GetInternalformati64v(target, internalformat, pname, count, parameters_ptr);
            }
        }
        public static unsafe void InvalidateFramebuffer(FramebufferTarget target, ReadOnlySpan<InvalidateFramebufferAttachment> attachments)
        {
            int numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments)
            {
                InvalidateFramebuffer(target, numAttachments, attachments_ptr);
            }
        }
        public static unsafe void InvalidateFramebuffer(FramebufferTarget target, InvalidateFramebufferAttachment[] attachments)
        {
            int numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments)
            {
                InvalidateFramebuffer(target, numAttachments, attachments_ptr);
            }
        }
        public static unsafe void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, in InvalidateFramebufferAttachment attachments)
        {
            fixed (InvalidateFramebufferAttachment* attachments_ptr = &attachments)
            {
                InvalidateFramebuffer(target, numAttachments, attachments_ptr);
            }
        }
        public static unsafe void InvalidateSubFramebuffer(FramebufferTarget target, ReadOnlySpan<InvalidateFramebufferAttachment> attachments, int x, int y, int width, int height)
        {
            int numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments)
            {
                InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
            }
        }
        public static unsafe void InvalidateSubFramebuffer(FramebufferTarget target, InvalidateFramebufferAttachment[] attachments, int x, int y, int width, int height)
        {
            int numAttachments = (int)(attachments.Length);
            fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments)
            {
                InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
            }
        }
        public static unsafe void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, in InvalidateFramebufferAttachment attachments, int x, int y, int width, int height)
        {
            fixed (InvalidateFramebufferAttachment* attachments_ptr = &attachments)
            {
                InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
            }
        }
        public static unsafe void MultiDrawArraysIndirect(PrimitiveType mode, IntPtr indirect, int drawcount, int stride)
        {
            void* indirect_vptr = (void*)indirect;
            MultiDrawArraysIndirect(mode, indirect_vptr, drawcount, stride);
        }
        public static unsafe void MultiDrawArraysIndirect<T1>(PrimitiveType mode, ReadOnlySpan<T1> indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = indirect)
            {
                MultiDrawArraysIndirect(mode, indirect_ptr, drawcount, stride);
            }
        }
        public static unsafe void MultiDrawArraysIndirect<T1>(PrimitiveType mode, T1[] indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = indirect)
            {
                MultiDrawArraysIndirect(mode, indirect_ptr, drawcount, stride);
            }
        }
        public static unsafe void MultiDrawArraysIndirect<T1>(PrimitiveType mode, in T1 indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect)
            {
                MultiDrawArraysIndirect(mode, indirect_ptr, drawcount, stride);
            }
        }
        public static unsafe void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, IntPtr indirect, int drawcount, int stride)
        {
            void* indirect_vptr = (void*)indirect;
            MultiDrawElementsIndirect(mode, type, indirect_vptr, drawcount, stride);
        }
        public static unsafe void MultiDrawElementsIndirect<T1>(PrimitiveType mode, DrawElementsType type, ReadOnlySpan<T1> indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = indirect)
            {
                MultiDrawElementsIndirect(mode, type, indirect_ptr, drawcount, stride);
            }
        }
        public static unsafe void MultiDrawElementsIndirect<T1>(PrimitiveType mode, DrawElementsType type, T1[] indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = indirect)
            {
                MultiDrawElementsIndirect(mode, type, indirect_ptr, drawcount, stride);
            }
        }
        public static unsafe void MultiDrawElementsIndirect<T1>(PrimitiveType mode, DrawElementsType type, in T1 indirect, int drawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect)
            {
                MultiDrawElementsIndirect(mode, type, indirect_ptr, drawcount, stride);
            }
        }
        public static unsafe void GetProgramInterfacei(ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, Span<int> parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
            }
        }
        public static unsafe void GetProgramInterfacei(ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, int[] parameters)
        {
            fixed (int* parameters_ptr = parameters)
            {
                GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
            }
        }
        public static unsafe void GetProgramInterfacei(ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
            }
        }
        public static unsafe uint GetProgramResourceIndex(ProgramHandle program, ProgramInterface programInterface, string name)
        {
            uint returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = GetProgramResourceIndex(program, programInterface, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }
        public static unsafe string GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, Span<int> length)
        {
            string name;
            fixed (int* length_ptr = length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }
        public static unsafe void GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, Span<int> length, out string name)
        {
            fixed (int* length_ptr = length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }
        public static unsafe string GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int[] length)
        {
            string name;
            fixed (int* length_ptr = length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }
        public static unsafe void GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int[] length, out string name)
        {
            fixed (int* length_ptr = length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }
        public static unsafe string GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, ref int length)
        {
            string name;
            fixed (int* length_ptr = &length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            return name;
        }
        public static unsafe void GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, ref int length, out string name)
        {
            fixed (int* length_ptr = &length)
            {
                var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
        }
        public static unsafe void GetProgramResourcei(ProgramHandle program, ProgramInterface programInterface, uint index, ReadOnlySpan<ProgramResourceProperty> props, Span<int> length, Span<int> parameters)
        {
            int propCount = (int)(props.Length);
            fixed (ProgramResourceProperty* props_ptr = props)
            {
                fixed (int* length_ptr = length)
                {
                    int count = (int)(parameters.Length);
                    fixed (int* parameters_ptr = parameters)
                    {
                        GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                    }
                }
            }
        }
        public static unsafe void GetProgramResourcei(ProgramHandle program, ProgramInterface programInterface, uint index, ProgramResourceProperty[] props, int[] length, int[] parameters)
        {
            int propCount = (int)(props.Length);
            fixed (ProgramResourceProperty* props_ptr = props)
            {
                fixed (int* length_ptr = length)
                {
                    int count = (int)(parameters.Length);
                    fixed (int* parameters_ptr = parameters)
                    {
                        GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                    }
                }
            }
        }
        public static unsafe void GetProgramResourcei(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, in ProgramResourceProperty props, int count, ref int length, ref int parameters)
        {
            fixed (ProgramResourceProperty* props_ptr = &props)
            fixed (int* length_ptr = &length)
            fixed (int* parameters_ptr = &parameters)
            {
                GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
            }
        }
        public static unsafe int GetProgramResourceLocation(ProgramHandle program, ProgramInterface programInterface, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = GetProgramResourceLocation(program, programInterface, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }
        public static unsafe int GetProgramResourceLocationIndex(ProgramHandle program, ProgramInterface programInterface, string name)
        {
            int returnValue;
            byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
            returnValue = GetProgramResourceLocationIndex(program, programInterface, name_ptr);
            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            return returnValue;
        }
        public static unsafe void TexStorage2DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
        {
            byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            TexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations_byte);
        }
        public static unsafe void TexStorage3DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
        {
            byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            TexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
        }
        public static unsafe void VertexAttribFormat(uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset)
        {
            byte normalized_byte = (byte)(normalized ? 1 : 0);
            VertexAttribFormat(attribindex, size, type, normalized_byte, relativeoffset);
        }
        public static unsafe void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, ReadOnlySpan<uint> ids, bool enabled)
        {
            int count = (int)(ids.Length);
            fixed (uint* ids_ptr = ids)
            {
                byte enabled_byte = (byte)(enabled ? 1 : 0);
                DebugMessageControl(source, type, severity, count, ids_ptr, enabled_byte);
            }
        }
        public static unsafe void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, uint[] ids, bool enabled)
        {
            int count = (int)(ids.Length);
            fixed (uint* ids_ptr = ids)
            {
                byte enabled_byte = (byte)(enabled ? 1 : 0);
                DebugMessageControl(source, type, severity, count, ids_ptr, enabled_byte);
            }
        }
        public static unsafe void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, in uint ids, bool enabled)
        {
            fixed (uint* ids_ptr = &ids)
            {
                byte enabled_byte = (byte)(enabled ? 1 : 0);
                DebugMessageControl(source, type, severity, count, ids_ptr, enabled_byte);
            }
        }
        public static unsafe void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, string buf)
        {
            byte* buf_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(buf);
            DebugMessageInsert(source, type, id, severity, length, buf_ptr);
            Marshal.FreeCoTaskMem((IntPtr)buf_ptr);
        }
        public static unsafe void DebugMessageCallback(GLDebugProc callback, IntPtr userParam)
        {
            void* userParam_vptr = (void*)userParam;
            IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
            DebugMessageCallback(callback_ptr, userParam_vptr);
        }
        public static unsafe void DebugMessageCallback<T1>(GLDebugProc callback, in T1 userParam)
            where T1 : unmanaged
        {
            fixed (void* userParam_ptr = &userParam)
            {
                IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                DebugMessageCallback(callback_ptr, userParam_ptr);
            }
        }
        public static unsafe uint GetDebugMessageLog(uint count, int bufSize, Span<DebugSource> sources, Span<DebugType> types, Span<uint> ids, Span<DebugSeverity> severities, Span<int> lengths, out string messageLog)
        {
            uint returnValue;
            fixed (DebugSource* sources_ptr = sources)
            {
                fixed (DebugType* types_ptr = types)
                {
                    fixed (uint* ids_ptr = ids)
                    {
                        fixed (DebugSeverity* severities_ptr = severities)
                        {
                            fixed (int* lengths_ptr = lengths)
                            {
                                var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                returnValue = GetDebugMessageLog(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                            }
                        }
                    }
                }
            }
            return returnValue;
        }
        public static unsafe uint GetDebugMessageLog(uint count, int bufSize, DebugSource[] sources, DebugType[] types, uint[] ids, DebugSeverity[] severities, int[] lengths, out string messageLog)
        {
            uint returnValue;
            fixed (DebugSource* sources_ptr = sources)
            {
                fixed (DebugType* types_ptr = types)
                {
                    fixed (uint* ids_ptr = ids)
                    {
                        fixed (DebugSeverity* severities_ptr = severities)
                        {
                            fixed (int* lengths_ptr = lengths)
                            {
                                var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                returnValue = GetDebugMessageLog(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                            }
                        }
                    }
                }
            }
            return returnValue;
        }
        public static unsafe uint GetDebugMessageLog(uint count, int bufSize, ref DebugSource sources, ref DebugType types, ref uint ids, ref DebugSeverity severities, ref int lengths, out string messageLog)
        {
            uint returnValue;
            fixed (DebugSource* sources_ptr = &sources)
            fixed (DebugType* types_ptr = &types)
            fixed (uint* ids_ptr = &ids)
            fixed (DebugSeverity* severities_ptr = &severities)
            fixed (int* lengths_ptr = &lengths)
            {
                var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                returnValue = GetDebugMessageLog(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
            }
            return returnValue;
        }
        public static unsafe void PushDebugGroup(DebugSource source, uint id, int length, string message)
        {
            byte* message_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(message);
            PushDebugGroup(source, id, length, message_ptr);
            Marshal.FreeCoTaskMem((IntPtr)message_ptr);
        }
        public static unsafe void ObjectLabel(ObjectIdentifier identifier, uint name, int length, string label)
        {
            byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
            ObjectLabel(identifier, name, length, label_ptr);
            Marshal.FreeCoTaskMem((IntPtr)label_ptr);
        }
        public static unsafe string GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, Span<int> length)
        {
            string label;
            fixed (int* length_ptr = length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }
        public static unsafe void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, Span<int> length, out string label)
        {
            fixed (int* length_ptr = length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }
        public static unsafe string GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int[] length)
        {
            string label;
            fixed (int* length_ptr = length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }
        public static unsafe void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int[] length, out string label)
        {
            fixed (int* length_ptr = length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }
        public static unsafe string GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, ref int length)
        {
            string label;
            fixed (int* length_ptr = &length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }
        public static unsafe void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, ref int length, out string label)
        {
            fixed (int* length_ptr = &length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }
        public static unsafe void ObjectPtrLabel(IntPtr ptr, int length, string label)
        {
            byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
            void* ptr_vptr = (void*)ptr;
            ObjectPtrLabel(ptr_vptr, length, label_ptr);
            Marshal.FreeCoTaskMem((IntPtr)label_ptr);
        }
        public static unsafe void ObjectPtrLabel<T1>(in T1 ptr, int length, string label)
            where T1 : unmanaged
        {
            fixed (void* ptr_ptr = &ptr)
            {
                byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
                ObjectPtrLabel(ptr_ptr, length, label_ptr);
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }
        public static unsafe string GetObjectPtrLabel(IntPtr ptr, int bufSize, Span<int> length)
        {
            string label;
            fixed (int* length_ptr = length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                void* ptr_vptr = (void*)ptr;
                GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }
        public static unsafe void GetObjectPtrLabel(IntPtr ptr, int bufSize, Span<int> length, out string label)
        {
            fixed (int* length_ptr = length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                void* ptr_vptr = (void*)ptr;
                GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }
        public static unsafe string GetObjectPtrLabel(IntPtr ptr, int bufSize, int[] length)
        {
            string label;
            fixed (int* length_ptr = length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                void* ptr_vptr = (void*)ptr;
                GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }
        public static unsafe void GetObjectPtrLabel(IntPtr ptr, int bufSize, int[] length, out string label)
        {
            fixed (int* length_ptr = length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                void* ptr_vptr = (void*)ptr;
                GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }
        public static unsafe string GetObjectPtrLabel(IntPtr ptr, int bufSize, ref int length)
        {
            string label;
            fixed (int* length_ptr = &length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                void* ptr_vptr = (void*)ptr;
                GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }
        public static unsafe void GetObjectPtrLabel(IntPtr ptr, int bufSize, ref int length, out string label)
        {
            fixed (int* length_ptr = &length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                void* ptr_vptr = (void*)ptr;
                GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }
        public static unsafe string GetObjectPtrLabel<T1>(in T1 ptr, int bufSize, Span<int> length)
            where T1 : unmanaged
        {
            string label;
            fixed (void* ptr_ptr = &ptr)
            {
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            return label;
        }
        public static unsafe void GetObjectPtrLabel<T1>(in T1 ptr, int bufSize, Span<int> length, out string label)
            where T1 : unmanaged
        {
            fixed (void* ptr_ptr = &ptr)
            {
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
        }
        public static unsafe string GetObjectPtrLabel<T1>(in T1 ptr, int bufSize, int[] length)
            where T1 : unmanaged
        {
            string label;
            fixed (void* ptr_ptr = &ptr)
            {
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            return label;
        }
        public static unsafe void GetObjectPtrLabel<T1>(in T1 ptr, int bufSize, int[] length, out string label)
            where T1 : unmanaged
        {
            fixed (void* ptr_ptr = &ptr)
            {
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
        }
        public static unsafe string GetObjectPtrLabel<T1>(in T1 ptr, int bufSize, ref int length)
            where T1 : unmanaged
        {
            string label;
            fixed (void* ptr_ptr = &ptr)
            fixed (int* length_ptr = &length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            return label;
        }
        public static unsafe void GetObjectPtrLabel<T1>(in T1 ptr, int bufSize, ref int length, out string label)
            where T1 : unmanaged
        {
            fixed (void* ptr_ptr = &ptr)
            fixed (int* length_ptr = &length)
            {
                var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
        }
        public static unsafe void BufferStorage(BufferStorageTarget target, nint size, IntPtr data, BufferStorageMask flags)
        {
            void* data_vptr = (void*)data;
            BufferStorage(target, size, data_vptr, flags);
        }
        public static unsafe void BufferStorage<T1>(BufferStorageTarget target, ReadOnlySpan<T1> data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            nint size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                BufferStorage(target, size, data_ptr, flags);
            }
        }
        public static unsafe void BufferStorage<T1>(BufferStorageTarget target, T1[] data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            nint size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                BufferStorage(target, size, data_ptr, flags);
            }
        }
        public static unsafe void BufferStorage<T1>(BufferStorageTarget target, nint size, in T1 data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                BufferStorage(target, size, data_ptr, flags);
            }
        }
        public static unsafe void ClearTexImage(TextureHandle texture, int level, PixelFormat format, PixelType type, IntPtr data)
        {
            void* data_vptr = (void*)data;
            ClearTexImage(texture, level, format, type, data_vptr);
        }
        public static unsafe void ClearTexImage<T1>(TextureHandle texture, int level, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data)
            {
                ClearTexImage(texture, level, format, type, data_ptr);
            }
        }
        public static unsafe void ClearTexImage<T1>(TextureHandle texture, int level, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data)
            {
                ClearTexImage(texture, level, format, type, data_ptr);
            }
        }
        public static unsafe void ClearTexImage<T1>(TextureHandle texture, int level, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                ClearTexImage(texture, level, format, type, data_ptr);
            }
        }
        public static unsafe void ClearTexSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr data)
        {
            void* data_vptr = (void*)data;
            ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_vptr);
        }
        public static unsafe void ClearTexSubImage<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data)
            {
                ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_ptr);
            }
        }
        public static unsafe void ClearTexSubImage<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data)
            {
                ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_ptr);
            }
        }
        public static unsafe void ClearTexSubImage<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_ptr);
            }
        }
        public static unsafe void BindBuffersBase(BufferTargetARB target, uint first, ReadOnlySpan<BufferHandle> buffers)
        {
            int count = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers)
            {
                BindBuffersBase(target, first, count, buffers_ptr);
            }
        }
        public static unsafe void BindBuffersBase(BufferTargetARB target, uint first, BufferHandle[] buffers)
        {
            int count = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers)
            {
                BindBuffersBase(target, first, count, buffers_ptr);
            }
        }
        public static unsafe void BindBuffersBase(BufferTargetARB target, uint first, int count, in BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers)
            {
                BindBuffersBase(target, first, count, buffers_ptr);
            }
        }
        public static unsafe void BindBuffersRange(BufferTargetARB target, uint first, int count, ReadOnlySpan<BufferHandle> buffers, ReadOnlySpan<IntPtr> offsets, ReadOnlySpan<nint> sizes)
        {
            fixed (BufferHandle* buffers_ptr = buffers)
            {
                fixed (IntPtr* offsets_ptr = offsets)
                {
                    fixed (nint* sizes_ptr = sizes)
                    {
                        BindBuffersRange(target, first, count, buffers_ptr, offsets_ptr, sizes_ptr);
                    }
                }
            }
        }
        public static unsafe void BindBuffersRange(BufferTargetARB target, uint first, int count, BufferHandle[] buffers, IntPtr[] offsets, nint[] sizes)
        {
            fixed (BufferHandle* buffers_ptr = buffers)
            {
                fixed (IntPtr* offsets_ptr = offsets)
                {
                    fixed (nint* sizes_ptr = sizes)
                    {
                        BindBuffersRange(target, first, count, buffers_ptr, offsets_ptr, sizes_ptr);
                    }
                }
            }
        }
        public static unsafe void BindBuffersRange(BufferTargetARB target, uint first, int count, in BufferHandle buffers, in IntPtr offsets, in nint sizes)
        {
            fixed (BufferHandle* buffers_ptr = &buffers)
            fixed (IntPtr* offsets_ptr = &offsets)
            fixed (nint* sizes_ptr = &sizes)
            {
                BindBuffersRange(target, first, count, buffers_ptr, offsets_ptr, sizes_ptr);
            }
        }
        public static unsafe void BindTextures(uint first, ReadOnlySpan<TextureHandle> textures)
        {
            int count = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures)
            {
                BindTextures(first, count, textures_ptr);
            }
        }
        public static unsafe void BindTextures(uint first, TextureHandle[] textures)
        {
            int count = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures)
            {
                BindTextures(first, count, textures_ptr);
            }
        }
        public static unsafe void BindTextures(uint first, int count, in TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures)
            {
                BindTextures(first, count, textures_ptr);
            }
        }
        public static unsafe void BindSamplers(uint first, ReadOnlySpan<SamplerHandle> samplers)
        {
            int count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers)
            {
                BindSamplers(first, count, samplers_ptr);
            }
        }
        public static unsafe void BindSamplers(uint first, SamplerHandle[] samplers)
        {
            int count = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers)
            {
                BindSamplers(first, count, samplers_ptr);
            }
        }
        public static unsafe void BindSamplers(uint first, int count, in SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers)
            {
                BindSamplers(first, count, samplers_ptr);
            }
        }
        public static unsafe void BindImageTextures(uint first, ReadOnlySpan<TextureHandle> textures)
        {
            int count = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures)
            {
                BindImageTextures(first, count, textures_ptr);
            }
        }
        public static unsafe void BindImageTextures(uint first, TextureHandle[] textures)
        {
            int count = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures)
            {
                BindImageTextures(first, count, textures_ptr);
            }
        }
        public static unsafe void BindImageTextures(uint first, int count, in TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures)
            {
                BindImageTextures(first, count, textures_ptr);
            }
        }
        public static unsafe void BindVertexBuffers(uint first, int count, ReadOnlySpan<BufferHandle> buffers, ReadOnlySpan<IntPtr> offsets, ReadOnlySpan<int> strides)
        {
            fixed (BufferHandle* buffers_ptr = buffers)
            {
                fixed (IntPtr* offsets_ptr = offsets)
                {
                    fixed (int* strides_ptr = strides)
                    {
                        BindVertexBuffers(first, count, buffers_ptr, offsets_ptr, strides_ptr);
                    }
                }
            }
        }
        public static unsafe void BindVertexBuffers(uint first, int count, BufferHandle[] buffers, IntPtr[] offsets, int[] strides)
        {
            fixed (BufferHandle* buffers_ptr = buffers)
            {
                fixed (IntPtr* offsets_ptr = offsets)
                {
                    fixed (int* strides_ptr = strides)
                    {
                        BindVertexBuffers(first, count, buffers_ptr, offsets_ptr, strides_ptr);
                    }
                }
            }
        }
        public static unsafe void BindVertexBuffers(uint first, int count, in BufferHandle buffers, in IntPtr offsets, in int strides)
        {
            fixed (BufferHandle* buffers_ptr = &buffers)
            fixed (IntPtr* offsets_ptr = &offsets)
            fixed (int* strides_ptr = &strides)
            {
                BindVertexBuffers(first, count, buffers_ptr, offsets_ptr, strides_ptr);
            }
        }
        public static unsafe TransformFeedbackHandle CreateTransformFeedback()
        {
            TransformFeedbackHandle ids;
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            CreateTransformFeedbacks(n, ids_handle);
            return ids;
        }
        public static unsafe void CreateTransformFeedback(out TransformFeedbackHandle ids)
        {
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
            CreateTransformFeedbacks(n, ids_handle);
        }
        public static unsafe void CreateTransformFeedbacks(Span<TransformFeedbackHandle> ids)
        {
            int n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids)
            {
                CreateTransformFeedbacks(n, ids_ptr);
            }
        }
        public static unsafe void CreateTransformFeedbacks(TransformFeedbackHandle[] ids)
        {
            int n = (int)(ids.Length);
            fixed (TransformFeedbackHandle* ids_ptr = ids)
            {
                CreateTransformFeedbacks(n, ids_ptr);
            }
        }
        public static unsafe void CreateTransformFeedbacks(int n, ref TransformFeedbackHandle ids)
        {
            fixed (TransformFeedbackHandle* ids_ptr = &ids)
            {
                CreateTransformFeedbacks(n, ids_ptr);
            }
        }
        public static unsafe void GetTransformFeedbacki(TransformFeedbackHandle xfb, TransformFeedbackPName pname, ref int param)
        {
            fixed (int* param_ptr = &param)
            {
                GetTransformFeedbackiv(xfb, pname, param_ptr);
            }
        }
        public static unsafe void GetTransformFeedback(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, ref int param)
        {
            fixed (int* param_ptr = &param)
            {
                GetTransformFeedbacki_v(xfb, pname, index, param_ptr);
            }
        }
        public static unsafe void GetTransformFeedbacki64_(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, ref long param)
        {
            fixed (long* param_ptr = &param)
            {
                GetTransformFeedbacki64_v(xfb, pname, index, param_ptr);
            }
        }
        public static unsafe BufferHandle CreateBuffer()
        {
            BufferHandle buffers;
            int n = 1;
            Unsafe.SkipInit(out buffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
            CreateBuffers(n, buffers_handle);
            return buffers;
        }
        public static unsafe void CreateBuffer(out BufferHandle buffers)
        {
            int n = 1;
            Unsafe.SkipInit(out buffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
            CreateBuffers(n, buffers_handle);
        }
        public static unsafe void CreateBuffers(Span<BufferHandle> buffers)
        {
            int n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers)
            {
                CreateBuffers(n, buffers_ptr);
            }
        }
        public static unsafe void CreateBuffers(BufferHandle[] buffers)
        {
            int n = (int)(buffers.Length);
            fixed (BufferHandle* buffers_ptr = buffers)
            {
                CreateBuffers(n, buffers_ptr);
            }
        }
        public static unsafe void CreateBuffers(int n, ref BufferHandle buffers)
        {
            fixed (BufferHandle* buffers_ptr = &buffers)
            {
                CreateBuffers(n, buffers_ptr);
            }
        }
        public static unsafe void NamedBufferStorage(BufferHandle buffer, nint size, IntPtr data, BufferStorageMask flags)
        {
            void* data_vptr = (void*)data;
            NamedBufferStorage(buffer, size, data_vptr, flags);
        }
        public static unsafe void NamedBufferStorage<T1>(BufferHandle buffer, ReadOnlySpan<T1> data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            nint size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                NamedBufferStorage(buffer, size, data_ptr, flags);
            }
        }
        public static unsafe void NamedBufferStorage<T1>(BufferHandle buffer, T1[] data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            nint size = (nint)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                NamedBufferStorage(buffer, size, data_ptr, flags);
            }
        }
        public static unsafe void NamedBufferStorage<T1>(BufferHandle buffer, nint size, in T1 data, BufferStorageMask flags)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                NamedBufferStorage(buffer, size, data_ptr, flags);
            }
        }
        public static unsafe void NamedBufferData(BufferHandle buffer, nint size, IntPtr data, VertexBufferObjectUsage usage)
        {
            void* data_vptr = (void*)data;
            NamedBufferData(buffer, size, data_vptr, usage);
        }
        public static unsafe void NamedBufferData<T1>(BufferHandle buffer, nint size, in T1 data, VertexBufferObjectUsage usage)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                NamedBufferData(buffer, size, data_ptr, usage);
            }
        }
        public static unsafe void NamedBufferSubData(BufferHandle buffer, IntPtr offset, nint size, IntPtr data)
        {
            void* data_vptr = (void*)data;
            NamedBufferSubData(buffer, offset, size, data_vptr);
        }
        public static unsafe void NamedBufferSubData<T1>(BufferHandle buffer, IntPtr offset, nint size, ReadOnlySpan<T1> data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data)
            {
                NamedBufferSubData(buffer, offset, size, data_ptr);
            }
        }
        public static unsafe void NamedBufferSubData<T1>(BufferHandle buffer, IntPtr offset, nint size, T1[] data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = data)
            {
                NamedBufferSubData(buffer, offset, size, data_ptr);
            }
        }
        public static unsafe void NamedBufferSubData<T1>(BufferHandle buffer, IntPtr offset, nint size, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                NamedBufferSubData(buffer, offset, size, data_ptr);
            }
        }
        public static unsafe void ClearNamedBufferData(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, IntPtr data)
        {
            void* data_vptr = (void*)data;
            ClearNamedBufferData(buffer, internalformat, format, type, data_vptr);
        }
        public static unsafe void ClearNamedBufferData<T1>(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                ClearNamedBufferData(buffer, internalformat, format, type, data_ptr);
            }
        }
        public static unsafe void ClearNamedBufferSubData(BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, IntPtr data)
        {
            void* data_vptr = (void*)data;
            ClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data_vptr);
        }
        public static unsafe void ClearNamedBufferSubData<T1>(BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                ClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data_ptr);
            }
        }
        public static unsafe void GetNamedBufferParameteri(BufferHandle buffer, BufferPNameARB pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetNamedBufferParameteriv(buffer, pname, parameters_ptr);
            }
        }
        public static unsafe void GetNamedBufferParameteri64(BufferHandle buffer, BufferPNameARB pname, ref long parameters)
        {
            fixed (long* parameters_ptr = &parameters)
            {
                GetNamedBufferParameteri64v(buffer, pname, parameters_ptr);
            }
        }
        public static unsafe void GetNamedBufferPointer(BufferHandle buffer, BufferPointerNameARB pname, void** parameters)
        {
            GetNamedBufferPointerv(buffer, pname, parameters);
        }
        public static unsafe void GetNamedBufferSubData(BufferHandle buffer, IntPtr offset, nint size, IntPtr data)
        {
            void* data_vptr = (void*)data;
            GetNamedBufferSubData(buffer, offset, size, data_vptr);
        }
        public static unsafe void GetNamedBufferSubData<T1>(BufferHandle buffer, IntPtr offset, nint size, ref T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                GetNamedBufferSubData(buffer, offset, size, data_ptr);
            }
        }
        public static unsafe FramebufferHandle CreateFramebuffer()
        {
            FramebufferHandle framebuffers;
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            CreateFramebuffers(n, framebuffers_handle);
            return framebuffers;
        }
        public static unsafe void CreateFramebuffer(out FramebufferHandle framebuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out framebuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
            CreateFramebuffers(n, framebuffers_handle);
        }
        public static unsafe void CreateFramebuffers(Span<FramebufferHandle> framebuffers)
        {
            int n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
            {
                CreateFramebuffers(n, framebuffers_ptr);
            }
        }
        public static unsafe void CreateFramebuffers(FramebufferHandle[] framebuffers)
        {
            int n = (int)(framebuffers.Length);
            fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
            {
                CreateFramebuffers(n, framebuffers_ptr);
            }
        }
        public static unsafe void CreateFramebuffers(int n, ref FramebufferHandle framebuffers)
        {
            fixed (FramebufferHandle* framebuffers_ptr = &framebuffers)
            {
                CreateFramebuffers(n, framebuffers_ptr);
            }
        }
        public static unsafe void NamedFramebufferDrawBuffers(FramebufferHandle framebuffer, int n, in ColorBuffer bufs)
        {
            fixed (ColorBuffer* bufs_ptr = &bufs)
            {
                NamedFramebufferDrawBuffers(framebuffer, n, bufs_ptr);
            }
        }
        public static unsafe void InvalidateNamedFramebufferData(FramebufferHandle framebuffer, int numAttachments, in FramebufferAttachment attachments)
        {
            fixed (FramebufferAttachment* attachments_ptr = &attachments)
            {
                InvalidateNamedFramebufferData(framebuffer, numAttachments, attachments_ptr);
            }
        }
        public static unsafe void InvalidateNamedFramebufferSubData(FramebufferHandle framebuffer, int numAttachments, in FramebufferAttachment attachments, int x, int y, int width, int height)
        {
            fixed (FramebufferAttachment* attachments_ptr = &attachments)
            {
                InvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments_ptr, x, y, width, height);
            }
        }
        public static unsafe void ClearNamedFramebufferi(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, in int value)
        {
            fixed (int* value_ptr = &value)
            {
                ClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value_ptr);
            }
        }
        public static unsafe void ClearNamedFramebufferui(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, in uint value)
        {
            fixed (uint* value_ptr = &value)
            {
                ClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value_ptr);
            }
        }
        public static unsafe void ClearNamedFramebufferf(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, in float value)
        {
            fixed (float* value_ptr = &value)
            {
                ClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value_ptr);
            }
        }
        public static unsafe void ClearNamedFramebuffer(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil)
        {
            ClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil);
        }
        public static unsafe void GetNamedFramebufferParameteri(FramebufferHandle framebuffer, GetFramebufferParameter pname, ref int param)
        {
            fixed (int* param_ptr = &param)
            {
                GetNamedFramebufferParameteriv(framebuffer, pname, param_ptr);
            }
        }
        public static unsafe void GetNamedFramebufferAttachmentParameteri(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, parameters_ptr);
            }
        }
        public static unsafe RenderbufferHandle CreateRenderbuffer()
        {
            RenderbufferHandle renderbuffers;
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            CreateRenderbuffers(n, renderbuffers_handle);
            return renderbuffers;
        }
        public static unsafe void CreateRenderbuffer(out RenderbufferHandle renderbuffers)
        {
            int n = 1;
            Unsafe.SkipInit(out renderbuffers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
            CreateRenderbuffers(n, renderbuffers_handle);
        }
        public static unsafe void CreateRenderbuffers(Span<RenderbufferHandle> renderbuffers)
        {
            int n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
            {
                CreateRenderbuffers(n, renderbuffers_ptr);
            }
        }
        public static unsafe void CreateRenderbuffers(RenderbufferHandle[] renderbuffers)
        {
            int n = (int)(renderbuffers.Length);
            fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
            {
                CreateRenderbuffers(n, renderbuffers_ptr);
            }
        }
        public static unsafe void CreateRenderbuffers(int n, ref RenderbufferHandle renderbuffers)
        {
            fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers)
            {
                CreateRenderbuffers(n, renderbuffers_ptr);
            }
        }
        public static unsafe void GetNamedRenderbufferParameteri(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetNamedRenderbufferParameteriv(renderbuffer, pname, parameters_ptr);
            }
        }
        public static unsafe TextureHandle CreateTexture(TextureTarget target)
        {
            TextureHandle textures;
            int n = 1;
            Unsafe.SkipInit(out textures);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
            CreateTextures(target, n, textures_handle);
            return textures;
        }
        public static unsafe void CreateTexture(TextureTarget target, out TextureHandle textures)
        {
            int n = 1;
            Unsafe.SkipInit(out textures);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
            CreateTextures(target, n, textures_handle);
        }
        public static unsafe void CreateTextures(TextureTarget target, Span<TextureHandle> textures)
        {
            int n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures)
            {
                CreateTextures(target, n, textures_ptr);
            }
        }
        public static unsafe void CreateTextures(TextureTarget target, TextureHandle[] textures)
        {
            int n = (int)(textures.Length);
            fixed (TextureHandle* textures_ptr = textures)
            {
                CreateTextures(target, n, textures_ptr);
            }
        }
        public static unsafe void CreateTextures(TextureTarget target, int n, ref TextureHandle textures)
        {
            fixed (TextureHandle* textures_ptr = &textures)
            {
                CreateTextures(target, n, textures_ptr);
            }
        }
        public static unsafe void TextureStorage2DMultisample(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
        {
            byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            TextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations_byte);
        }
        public static unsafe void TextureStorage3DMultisample(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
        {
            byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
            TextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
        }
        public static unsafe void TextureSubImage1D(TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            TextureSubImage1D(texture, level, xoffset, width, format, type, pixels_vptr);
        }
        public static unsafe void TextureSubImage1D<T1>(TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                TextureSubImage1D(texture, level, xoffset, width, format, type, pixels_ptr);
            }
        }
        public static unsafe void TextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels_vptr);
        }
        public static unsafe void TextureSubImage2D<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
            }
        }
        public static unsafe void TextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_vptr);
        }
        public static unsafe void TextureSubImage3D<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
            }
        }
        public static unsafe void CompressedTextureSubImage1D(TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, IntPtr data)
        {
            void* data_vptr = (void*)data;
            CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data_vptr);
        }
        public static unsafe void CompressedTextureSubImage1D<T1>(TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, IntPtr data)
        {
            void* data_vptr = (void*)data;
            CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data_vptr);
        }
        public static unsafe void CompressedTextureSubImage2D<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
            }
        }
        public static unsafe void CompressedTextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, IntPtr data)
        {
            void* data_vptr = (void*)data;
            CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_vptr);
        }
        public static unsafe void CompressedTextureSubImage3D<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, in T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
            }
        }
        public static unsafe void TextureParameterf(TextureHandle texture, TextureParameterName pname, in float param)
        {
            fixed (float* param_ptr = &param)
            {
                TextureParameterfv(texture, pname, param_ptr);
            }
        }
        public static unsafe void TextureParameterIi(TextureHandle texture, TextureParameterName pname, in int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                TextureParameterIiv(texture, pname, parameters_ptr);
            }
        }
        public static unsafe void TextureParameterIui(TextureHandle texture, TextureParameterName pname, in uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters)
            {
                TextureParameterIuiv(texture, pname, parameters_ptr);
            }
        }
        public static unsafe void TextureParameteri(TextureHandle texture, TextureParameterName pname, in int param)
        {
            fixed (int* param_ptr = &param)
            {
                TextureParameteriv(texture, pname, param_ptr);
            }
        }
        public static unsafe void GetTextureImage(TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            GetTextureImage(texture, level, format, type, bufSize, pixels_vptr);
        }
        public static unsafe void GetTextureImage<T1>(TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                GetTextureImage(texture, level, format, type, bufSize, pixels_ptr);
            }
        }
        public static unsafe void GetCompressedTextureImage(TextureHandle texture, int level, int bufSize, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            GetCompressedTextureImage(texture, level, bufSize, pixels_vptr);
        }
        public static unsafe void GetCompressedTextureImage<T1>(TextureHandle texture, int level, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                GetCompressedTextureImage(texture, level, bufSize, pixels_ptr);
            }
        }
        public static unsafe void GetTextureLevelParameterf(TextureHandle texture, int level, GetTextureParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters)
            {
                GetTextureLevelParameterfv(texture, level, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTextureLevelParameteri(TextureHandle texture, int level, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetTextureLevelParameteriv(texture, level, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTextureParameterf(TextureHandle texture, GetTextureParameter pname, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters)
            {
                GetTextureParameterfv(texture, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTextureParameterIi(TextureHandle texture, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetTextureParameterIiv(texture, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTextureParameterIui(TextureHandle texture, GetTextureParameter pname, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters)
            {
                GetTextureParameterIuiv(texture, pname, parameters_ptr);
            }
        }
        public static unsafe void GetTextureParameteri(TextureHandle texture, GetTextureParameter pname, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetTextureParameteriv(texture, pname, parameters_ptr);
            }
        }
        public static unsafe VertexArrayHandle CreateVertexArray()
        {
            VertexArrayHandle arrays;
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            CreateVertexArrays(n, arrays_handle);
            return arrays;
        }
        public static unsafe void CreateVertexArray(out VertexArrayHandle arrays)
        {
            int n = 1;
            Unsafe.SkipInit(out arrays);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
            CreateVertexArrays(n, arrays_handle);
        }
        public static unsafe void CreateVertexArrays(Span<VertexArrayHandle> arrays)
        {
            int n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays)
            {
                CreateVertexArrays(n, arrays_ptr);
            }
        }
        public static unsafe void CreateVertexArrays(VertexArrayHandle[] arrays)
        {
            int n = (int)(arrays.Length);
            fixed (VertexArrayHandle* arrays_ptr = arrays)
            {
                CreateVertexArrays(n, arrays_ptr);
            }
        }
        public static unsafe void CreateVertexArrays(int n, ref VertexArrayHandle arrays)
        {
            fixed (VertexArrayHandle* arrays_ptr = &arrays)
            {
                CreateVertexArrays(n, arrays_ptr);
            }
        }
        public static unsafe void VertexArrayVertexBuffers(VertexArrayHandle vaobj, uint first, int count, in BufferHandle buffers, in IntPtr offsets, in int strides)
        {
            fixed (BufferHandle* buffers_ptr = &buffers)
            fixed (IntPtr* offsets_ptr = &offsets)
            fixed (int* strides_ptr = &strides)
            {
                VertexArrayVertexBuffers(vaobj, first, count, buffers_ptr, offsets_ptr, strides_ptr);
            }
        }
        public static unsafe void VertexArrayAttribFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset)
        {
            byte normalized_byte = (byte)(normalized ? 1 : 0);
            VertexArrayAttribFormat(vaobj, attribindex, size, type, normalized_byte, relativeoffset);
        }
        public static unsafe void GetVertexArrayi(VertexArrayHandle vaobj, VertexArrayPName pname, ref int param)
        {
            fixed (int* param_ptr = &param)
            {
                GetVertexArrayiv(vaobj, pname, param_ptr);
            }
        }
        public static unsafe void GetVertexArrayIndexedi(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, ref int param)
        {
            fixed (int* param_ptr = &param)
            {
                GetVertexArrayIndexediv(vaobj, index, pname, param_ptr);
            }
        }
        public static unsafe void GetVertexArrayIndexed64iv(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, ref long param)
        {
            fixed (long* param_ptr = &param)
            {
                GetVertexArrayIndexed64iv(vaobj, index, pname, param_ptr);
            }
        }
        public static unsafe SamplerHandle CreateSampler()
        {
            SamplerHandle samplers;
            int n = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            CreateSamplers(n, samplers_handle);
            return samplers;
        }
        public static unsafe void CreateSampler(out SamplerHandle samplers)
        {
            int n = 1;
            Unsafe.SkipInit(out samplers);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
            CreateSamplers(n, samplers_handle);
        }
        public static unsafe void CreateSamplers(Span<SamplerHandle> samplers)
        {
            int n = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers)
            {
                CreateSamplers(n, samplers_ptr);
            }
        }
        public static unsafe void CreateSamplers(SamplerHandle[] samplers)
        {
            int n = (int)(samplers.Length);
            fixed (SamplerHandle* samplers_ptr = samplers)
            {
                CreateSamplers(n, samplers_ptr);
            }
        }
        public static unsafe void CreateSamplers(int n, ref SamplerHandle samplers)
        {
            fixed (SamplerHandle* samplers_ptr = &samplers)
            {
                CreateSamplers(n, samplers_ptr);
            }
        }
        public static unsafe ProgramPipelineHandle CreateProgramPipeline()
        {
            ProgramPipelineHandle pipelines;
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            CreateProgramPipelines(n, pipelines_handle);
            return pipelines;
        }
        public static unsafe void CreateProgramPipeline(out ProgramPipelineHandle pipelines)
        {
            int n = 1;
            Unsafe.SkipInit(out pipelines);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
            CreateProgramPipelines(n, pipelines_handle);
        }
        public static unsafe void CreateProgramPipelines(Span<ProgramPipelineHandle> pipelines)
        {
            int n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
            {
                CreateProgramPipelines(n, pipelines_ptr);
            }
        }
        public static unsafe void CreateProgramPipelines(ProgramPipelineHandle[] pipelines)
        {
            int n = (int)(pipelines.Length);
            fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
            {
                CreateProgramPipelines(n, pipelines_ptr);
            }
        }
        public static unsafe void CreateProgramPipelines(int n, ref ProgramPipelineHandle pipelines)
        {
            fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines)
            {
                CreateProgramPipelines(n, pipelines_ptr);
            }
        }
        public static unsafe QueryHandle CreateQuerie(QueryTarget target)
        {
            QueryHandle ids;
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
            CreateQueries(target, n, ids_handle);
            return ids;
        }
        public static unsafe void CreateQuerie(QueryTarget target, out QueryHandle ids)
        {
            int n = 1;
            Unsafe.SkipInit(out ids);
            // FIXME: This could be a problem for the overloads that take an out parameter
            // as this parameter could *potentially* move while inside of this function
            // which would mean that the new value never gets written to the out parameter.
            // Making for a nasty bug.
            // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
            // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
            // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
            // - 2021-05-18
            QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
            CreateQueries(target, n, ids_handle);
        }
        public static unsafe void CreateQueries(QueryTarget target, Span<QueryHandle> ids)
        {
            int n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids)
            {
                CreateQueries(target, n, ids_ptr);
            }
        }
        public static unsafe void CreateQueries(QueryTarget target, QueryHandle[] ids)
        {
            int n = (int)(ids.Length);
            fixed (QueryHandle* ids_ptr = ids)
            {
                CreateQueries(target, n, ids_ptr);
            }
        }
        public static unsafe void CreateQueries(QueryTarget target, int n, ref QueryHandle ids)
        {
            fixed (QueryHandle* ids_ptr = &ids)
            {
                CreateQueries(target, n, ids_ptr);
            }
        }
        public static unsafe void GetQueryBufferObjecti64(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
        {
            GetQueryBufferObjecti64v(id, buffer, pname, offset);
        }
        public static unsafe void GetQueryBufferObjecti(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
        {
            GetQueryBufferObjectiv(id, buffer, pname, offset);
        }
        public static unsafe void GetQueryBufferObjectui64(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
        {
            GetQueryBufferObjectui64v(id, buffer, pname, offset);
        }
        public static unsafe void GetQueryBufferObjectui(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
        {
            GetQueryBufferObjectuiv(id, buffer, pname, offset);
        }
        public static unsafe void GetTextureSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels_vptr);
        }
        public static unsafe void GetTextureSubImage<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels_ptr);
            }
        }
        public static unsafe void GetCompressedTextureSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels_vptr);
        }
        public static unsafe void GetCompressedTextureSubImage<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels_ptr);
            }
        }
        public static unsafe void GetnCompressedTexImage(TextureTarget target, int lod, int bufSize, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            GetnCompressedTexImage(target, lod, bufSize, pixels_vptr);
        }
        public static unsafe void GetnCompressedTexImage<T1>(TextureTarget target, int lod, Span<T1> pixels)
            where T1 : unmanaged
        {
            int bufSize = (int)(pixels.Length * sizeof(T1));
            fixed (void* pixels_ptr = pixels)
            {
                GetnCompressedTexImage(target, lod, bufSize, pixels_ptr);
            }
        }
        public static unsafe void GetnCompressedTexImage<T1>(TextureTarget target, int lod, T1[] pixels)
            where T1 : unmanaged
        {
            int bufSize = (int)(pixels.Length * sizeof(T1));
            fixed (void* pixels_ptr = pixels)
            {
                GetnCompressedTexImage(target, lod, bufSize, pixels_ptr);
            }
        }
        public static unsafe void GetnCompressedTexImage<T1>(TextureTarget target, int lod, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                GetnCompressedTexImage(target, lod, bufSize, pixels_ptr);
            }
        }
        public static unsafe void GetnTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, IntPtr pixels)
        {
            void* pixels_vptr = (void*)pixels;
            GetnTexImage(target, level, format, type, bufSize, pixels_vptr);
        }
        public static unsafe void GetnTexImage<T1>(TextureTarget target, int level, PixelFormat format, PixelType type, Span<T1> pixels)
            where T1 : unmanaged
        {
            int bufSize = (int)(pixels.Length * sizeof(T1));
            fixed (void* pixels_ptr = pixels)
            {
                GetnTexImage(target, level, format, type, bufSize, pixels_ptr);
            }
        }
        public static unsafe void GetnTexImage<T1>(TextureTarget target, int level, PixelFormat format, PixelType type, T1[] pixels)
            where T1 : unmanaged
        {
            int bufSize = (int)(pixels.Length * sizeof(T1));
            fixed (void* pixels_ptr = pixels)
            {
                GetnTexImage(target, level, format, type, bufSize, pixels_ptr);
            }
        }
        public static unsafe void GetnTexImage<T1>(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, ref T1 pixels)
            where T1 : unmanaged
        {
            fixed (void* pixels_ptr = &pixels)
            {
                GetnTexImage(target, level, format, type, bufSize, pixels_ptr);
            }
        }
        public static unsafe void GetnUniformd(ProgramHandle program, int location, Span<double> parameters)
        {
            int bufSize = (int)(parameters.Length * 8);
            fixed (double* parameters_ptr = parameters)
            {
                GetnUniformdv(program, location, bufSize, parameters_ptr);
            }
        }
        public static unsafe void GetnUniformd(ProgramHandle program, int location, double[] parameters)
        {
            int bufSize = (int)(parameters.Length * 8);
            fixed (double* parameters_ptr = parameters)
            {
                GetnUniformdv(program, location, bufSize, parameters_ptr);
            }
        }
        public static unsafe void GetnUniformd(ProgramHandle program, int location, int bufSize, ref double parameters)
        {
            fixed (double* parameters_ptr = &parameters)
            {
                GetnUniformdv(program, location, bufSize, parameters_ptr);
            }
        }
        public static unsafe void GetnUniformf(ProgramHandle program, int location, Span<float> parameters)
        {
            int bufSize = (int)(parameters.Length * 4);
            fixed (float* parameters_ptr = parameters)
            {
                GetnUniformfv(program, location, bufSize, parameters_ptr);
            }
        }
        public static unsafe void GetnUniformf(ProgramHandle program, int location, float[] parameters)
        {
            int bufSize = (int)(parameters.Length * 4);
            fixed (float* parameters_ptr = parameters)
            {
                GetnUniformfv(program, location, bufSize, parameters_ptr);
            }
        }
        public static unsafe void GetnUniformf(ProgramHandle program, int location, int bufSize, ref float parameters)
        {
            fixed (float* parameters_ptr = &parameters)
            {
                GetnUniformfv(program, location, bufSize, parameters_ptr);
            }
        }
        public static unsafe void GetnUniformi(ProgramHandle program, int location, Span<int> parameters)
        {
            int bufSize = (int)(parameters.Length * 4);
            fixed (int* parameters_ptr = parameters)
            {
                GetnUniformiv(program, location, bufSize, parameters_ptr);
            }
        }
        public static unsafe void GetnUniformi(ProgramHandle program, int location, int[] parameters)
        {
            int bufSize = (int)(parameters.Length * 4);
            fixed (int* parameters_ptr = parameters)
            {
                GetnUniformiv(program, location, bufSize, parameters_ptr);
            }
        }
        public static unsafe void GetnUniformi(ProgramHandle program, int location, int bufSize, ref int parameters)
        {
            fixed (int* parameters_ptr = &parameters)
            {
                GetnUniformiv(program, location, bufSize, parameters_ptr);
            }
        }
        public static unsafe void GetnUniformui(ProgramHandle program, int location, Span<uint> parameters)
        {
            int bufSize = (int)(parameters.Length * 4);
            fixed (uint* parameters_ptr = parameters)
            {
                GetnUniformuiv(program, location, bufSize, parameters_ptr);
            }
        }
        public static unsafe void GetnUniformui(ProgramHandle program, int location, uint[] parameters)
        {
            int bufSize = (int)(parameters.Length * 4);
            fixed (uint* parameters_ptr = parameters)
            {
                GetnUniformuiv(program, location, bufSize, parameters_ptr);
            }
        }
        public static unsafe void GetnUniformui(ProgramHandle program, int location, int bufSize, ref uint parameters)
        {
            fixed (uint* parameters_ptr = &parameters)
            {
                GetnUniformuiv(program, location, bufSize, parameters_ptr);
            }
        }
        public static unsafe void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, IntPtr data)
        {
            void* data_vptr = (void*)data;
            ReadnPixels(x, y, width, height, format, type, bufSize, data_vptr);
        }
        public static unsafe void ReadnPixels<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, Span<T1> data)
            where T1 : unmanaged
        {
            int bufSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                ReadnPixels(x, y, width, height, format, type, bufSize, data_ptr);
            }
        }
        public static unsafe void ReadnPixels<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, T1[] data)
            where T1 : unmanaged
        {
            int bufSize = (int)(data.Length * sizeof(T1));
            fixed (void* data_ptr = data)
            {
                ReadnPixels(x, y, width, height, format, type, bufSize, data_ptr);
            }
        }
        public static unsafe void ReadnPixels<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, ref T1 data)
            where T1 : unmanaged
        {
            fixed (void* data_ptr = &data)
            {
                ReadnPixels(x, y, width, height, format, type, bufSize, data_ptr);
            }
        }
        public static unsafe void SpecializeShader(ShaderHandle shader, string pEntryPoint, uint numSpecializationConstants, in uint pConstantIndex, in uint pConstantValue)
        {
            fixed (uint* pConstantIndex_ptr = &pConstantIndex)
            fixed (uint* pConstantValue_ptr = &pConstantValue)
            {
                byte* pEntryPoint_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(pEntryPoint);
                SpecializeShader(shader, pEntryPoint_ptr, numSpecializationConstants, pConstantIndex_ptr, pConstantValue_ptr);
                Marshal.FreeCoTaskMem((IntPtr)pEntryPoint_ptr);
            }
        }
        public static unsafe void MultiDrawArraysIndirectCount(PrimitiveType mode, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride)
        {
            void* indirect_vptr = (void*)indirect;
            MultiDrawArraysIndirectCount(mode, indirect_vptr, drawcount, maxdrawcount, stride);
        }
        public static unsafe void MultiDrawArraysIndirectCount<T1>(PrimitiveType mode, in T1 indirect, IntPtr drawcount, int maxdrawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect)
            {
                MultiDrawArraysIndirectCount(mode, indirect_ptr, drawcount, maxdrawcount, stride);
            }
        }
        public static unsafe void MultiDrawElementsIndirectCount(PrimitiveType mode, DrawElementsType type, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride)
        {
            void* indirect_vptr = (void*)indirect;
            MultiDrawElementsIndirectCount(mode, type, indirect_vptr, drawcount, maxdrawcount, stride);
        }
        public static unsafe void MultiDrawElementsIndirectCount<T1>(PrimitiveType mode, DrawElementsType type, in T1 indirect, IntPtr drawcount, int maxdrawcount, int stride)
            where T1 : unmanaged
        {
            fixed (void* indirect_ptr = &indirect)
            {
                MultiDrawElementsIndirectCount(mode, type, indirect_ptr, drawcount, maxdrawcount, stride);
            }
        }
        public static unsafe partial class _3DFX
        {
        }
        public static unsafe partial class AMD
        {
            public static unsafe void DebugMessageEnableAMD(All category, DebugSeverity severity, ReadOnlySpan<uint> ids, bool enabled)
            {
                int count = (int)(ids.Length);
                fixed (uint* ids_ptr = ids)
                {
                    byte enabled_byte = (byte)(enabled ? 1 : 0);
                    DebugMessageEnableAMD(category, severity, count, ids_ptr, enabled_byte);
                }
            }
            public static unsafe void DebugMessageEnableAMD(All category, DebugSeverity severity, uint[] ids, bool enabled)
            {
                int count = (int)(ids.Length);
                fixed (uint* ids_ptr = ids)
                {
                    byte enabled_byte = (byte)(enabled ? 1 : 0);
                    DebugMessageEnableAMD(category, severity, count, ids_ptr, enabled_byte);
                }
            }
            public static unsafe void DebugMessageEnableAMD(All category, DebugSeverity severity, int count, in uint ids, bool enabled)
            {
                fixed (uint* ids_ptr = &ids)
                {
                    byte enabled_byte = (byte)(enabled ? 1 : 0);
                    DebugMessageEnableAMD(category, severity, count, ids_ptr, enabled_byte);
                }
            }
            public static unsafe void DebugMessageInsertAMD(All category, DebugSeverity severity, uint id, int length, string buf)
            {
                byte* buf_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(buf);
                DebugMessageInsertAMD(category, severity, id, length, buf_ptr);
                Marshal.FreeCoTaskMem((IntPtr)buf_ptr);
            }
            public static unsafe void DebugMessageCallbackAMD(GLDebugProcAMD callback, IntPtr userParam)
            {
                void* userParam_vptr = (void*)userParam;
                IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                DebugMessageCallbackAMD(callback_ptr, userParam_vptr);
            }
            public static unsafe void DebugMessageCallbackAMD<T1>(GLDebugProcAMD callback, ref T1 userParam)
                where T1 : unmanaged
            {
                fixed (void* userParam_ptr = &userParam)
                {
                    IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                    DebugMessageCallbackAMD(callback_ptr, userParam_ptr);
                }
            }
            public static unsafe uint GetDebugMessageLogAMD(uint count, int bufSize, Span<All> categories, Span<uint> severities, Span<uint> ids, Span<int> lengths, out string message)
            {
                uint returnValue;
                fixed (All* categories_ptr = categories)
                {
                    fixed (uint* severities_ptr = severities)
                    {
                        fixed (uint* ids_ptr = ids)
                        {
                            fixed (int* lengths_ptr = lengths)
                            {
                                var message_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                returnValue = GetDebugMessageLogAMD(count, bufSize, categories_ptr, severities_ptr, ids_ptr, lengths_ptr, message_ptr);
                                message = Marshal.PtrToStringUTF8((IntPtr)message_ptr)!;
                                Marshal.FreeCoTaskMem((IntPtr)message_ptr);
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe uint GetDebugMessageLogAMD(uint count, int bufSize, All[] categories, uint[] severities, uint[] ids, int[] lengths, out string message)
            {
                uint returnValue;
                fixed (All* categories_ptr = categories)
                {
                    fixed (uint* severities_ptr = severities)
                    {
                        fixed (uint* ids_ptr = ids)
                        {
                            fixed (int* lengths_ptr = lengths)
                            {
                                var message_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                returnValue = GetDebugMessageLogAMD(count, bufSize, categories_ptr, severities_ptr, ids_ptr, lengths_ptr, message_ptr);
                                message = Marshal.PtrToStringUTF8((IntPtr)message_ptr)!;
                                Marshal.FreeCoTaskMem((IntPtr)message_ptr);
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe uint GetDebugMessageLogAMD(uint count, int bufSize, ref All categories, ref uint severities, ref uint ids, ref int lengths, out string message)
            {
                uint returnValue;
                fixed (All* categories_ptr = &categories)
                fixed (uint* severities_ptr = &severities)
                fixed (uint* ids_ptr = &ids)
                fixed (int* lengths_ptr = &lengths)
                {
                    var message_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    returnValue = GetDebugMessageLogAMD(count, bufSize, categories_ptr, severities_ptr, ids_ptr, lengths_ptr, message_ptr);
                    message = Marshal.PtrToStringUTF8((IntPtr)message_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)message_ptr);
                }
                return returnValue;
            }
            public static unsafe void FramebufferSamplePositionsfvAMD(FramebufferTarget target, uint numsamples, uint pixelindex, in float values)
            {
                fixed (float* values_ptr = &values)
                {
                    FramebufferSamplePositionsfvAMD(target, numsamples, pixelindex, values_ptr);
                }
            }
            public static unsafe void NamedFramebufferSamplePositionsfvAMD(FramebufferHandle framebuffer, uint numsamples, uint pixelindex, in float values)
            {
                fixed (float* values_ptr = &values)
                {
                    NamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, values_ptr);
                }
            }
            public static unsafe void GetFramebufferParameterfvAMD(FramebufferTarget target, FramebufferAttachmentParameterName pname, uint numsamples, uint pixelindex, int size, ref float values)
            {
                fixed (float* values_ptr = &values)
                {
                    GetFramebufferParameterfvAMD(target, pname, numsamples, pixelindex, size, values_ptr);
                }
            }
            public static unsafe void GetNamedFramebufferParameterfvAMD(FramebufferHandle framebuffer, All pname, uint numsamples, uint pixelindex, int size, ref float values)
            {
                fixed (float* values_ptr = &values)
                {
                    GetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, values_ptr);
                }
            }
            public static unsafe void Uniform1i64vNV(int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 1);
                fixed (long* value_ptr = value)
                {
                    Uniform1i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1i64vNV(int location, long[] value)
            {
                int count = (int)(value.Length / 1);
                fixed (long* value_ptr = value)
                {
                    Uniform1i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1i64vNV(int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    Uniform1i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2i64vNV(int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 2);
                fixed (long* value_ptr = value)
                {
                    Uniform2i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2i64vNV(int location, long[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (long* value_ptr = value)
                {
                    Uniform2i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2i64vNV(int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    Uniform2i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3i64vNV(int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 3);
                fixed (long* value_ptr = value)
                {
                    Uniform3i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3i64vNV(int location, long[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (long* value_ptr = value)
                {
                    Uniform3i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3i64vNV(int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    Uniform3i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4i64vNV(int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 4);
                fixed (long* value_ptr = value)
                {
                    Uniform4i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4i64vNV(int location, long[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (long* value_ptr = value)
                {
                    Uniform4i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4i64vNV(int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    Uniform4i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1ui64vNV(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 1);
                fixed (ulong* value_ptr = value)
                {
                    Uniform1ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1ui64vNV(int location, ulong[] value)
            {
                int count = (int)(value.Length / 1);
                fixed (ulong* value_ptr = value)
                {
                    Uniform1ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1ui64vNV(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    Uniform1ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2ui64vNV(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 2);
                fixed (ulong* value_ptr = value)
                {
                    Uniform2ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2ui64vNV(int location, ulong[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (ulong* value_ptr = value)
                {
                    Uniform2ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2ui64vNV(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    Uniform2ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3ui64vNV(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 3);
                fixed (ulong* value_ptr = value)
                {
                    Uniform3ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3ui64vNV(int location, ulong[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (ulong* value_ptr = value)
                {
                    Uniform3ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3ui64vNV(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    Uniform3ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4ui64vNV(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 4);
                fixed (ulong* value_ptr = value)
                {
                    Uniform4ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4ui64vNV(int location, ulong[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (ulong* value_ptr = value)
                {
                    Uniform4ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4ui64vNV(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    Uniform4ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void GetUniformi64vNV(ProgramHandle program, int location, Span<long> parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetUniformi64vNV(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformi64vNV(ProgramHandle program, int location, long[] parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetUniformi64vNV(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformi64vNV(ProgramHandle program, int location, ref long parameters)
            {
                fixed (long* parameters_ptr = &parameters)
                {
                    GetUniformi64vNV(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformui64vNV(ProgramHandle program, int location, Span<ulong> parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetUniformui64vNV(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformui64vNV(ProgramHandle program, int location, ulong[] parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetUniformui64vNV(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformui64vNV(ProgramHandle program, int location, ref ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    GetUniformui64vNV(program, location, parameters_ptr);
                }
            }
            public static unsafe void ProgramUniform1i64vNV(ProgramHandle program, int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform1i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1i64vNV(ProgramHandle program, int location, long[] value)
            {
                int count = (int)(value.Length);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform1i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1i64vNV(ProgramHandle program, int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    ProgramUniform1i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2i64vNV(ProgramHandle program, int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 2);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform2i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2i64vNV(ProgramHandle program, int location, long[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform2i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2i64vNV(ProgramHandle program, int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    ProgramUniform2i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3i64vNV(ProgramHandle program, int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 3);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform3i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3i64vNV(ProgramHandle program, int location, long[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform3i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3i64vNV(ProgramHandle program, int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    ProgramUniform3i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4i64vNV(ProgramHandle program, int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 4);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform4i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4i64vNV(ProgramHandle program, int location, long[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform4i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4i64vNV(ProgramHandle program, int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    ProgramUniform4i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ui64vNV(ProgramHandle program, int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform1ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ui64vNV(ProgramHandle program, int location, ulong[] value)
            {
                int count = (int)(value.Length);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform1ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ui64vNV(ProgramHandle program, int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    ProgramUniform1ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ui64vNV(ProgramHandle program, int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 2);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform2ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ui64vNV(ProgramHandle program, int location, ulong[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform2ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ui64vNV(ProgramHandle program, int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    ProgramUniform2ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ui64vNV(ProgramHandle program, int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 3);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform3ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ui64vNV(ProgramHandle program, int location, ulong[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform3ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ui64vNV(ProgramHandle program, int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    ProgramUniform3ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ui64vNV(ProgramHandle program, int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 4);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform4ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ui64vNV(ProgramHandle program, int location, ulong[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform4ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ui64vNV(ProgramHandle program, int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    ProgramUniform4ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void MultiDrawArraysIndirectAMD(PrimitiveType mode, IntPtr indirect, int primcount, int stride)
            {
                void* indirect_vptr = (void*)indirect;
                MultiDrawArraysIndirectAMD(mode, indirect_vptr, primcount, stride);
            }
            public static unsafe void MultiDrawArraysIndirectAMD<T1>(PrimitiveType mode, ReadOnlySpan<T1> indirect, int primcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = indirect)
                {
                    MultiDrawArraysIndirectAMD(mode, indirect_ptr, primcount, stride);
                }
            }
            public static unsafe void MultiDrawArraysIndirectAMD<T1>(PrimitiveType mode, T1[] indirect, int primcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = indirect)
                {
                    MultiDrawArraysIndirectAMD(mode, indirect_ptr, primcount, stride);
                }
            }
            public static unsafe void MultiDrawArraysIndirectAMD<T1>(PrimitiveType mode, in T1 indirect, int primcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = &indirect)
                {
                    MultiDrawArraysIndirectAMD(mode, indirect_ptr, primcount, stride);
                }
            }
            public static unsafe void MultiDrawElementsIndirectAMD(PrimitiveType mode, DrawElementsType type, IntPtr indirect, int primcount, int stride)
            {
                void* indirect_vptr = (void*)indirect;
                MultiDrawElementsIndirectAMD(mode, type, indirect_vptr, primcount, stride);
            }
            public static unsafe void MultiDrawElementsIndirectAMD<T1>(PrimitiveType mode, DrawElementsType type, ReadOnlySpan<T1> indirect, int primcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = indirect)
                {
                    MultiDrawElementsIndirectAMD(mode, type, indirect_ptr, primcount, stride);
                }
            }
            public static unsafe void MultiDrawElementsIndirectAMD<T1>(PrimitiveType mode, DrawElementsType type, T1[] indirect, int primcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = indirect)
                {
                    MultiDrawElementsIndirectAMD(mode, type, indirect_ptr, primcount, stride);
                }
            }
            public static unsafe void MultiDrawElementsIndirectAMD<T1>(PrimitiveType mode, DrawElementsType type, in T1 indirect, int primcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = &indirect)
                {
                    MultiDrawElementsIndirectAMD(mode, type, indirect_ptr, primcount, stride);
                }
            }
            public static unsafe void GenNamesAMD(All identifier, Span<uint> names)
            {
                uint num = (uint)(names.Length);
                fixed (uint* names_ptr = names)
                {
                    GenNamesAMD(identifier, num, names_ptr);
                }
            }
            public static unsafe void GenNamesAMD(All identifier, uint[] names)
            {
                uint num = (uint)(names.Length);
                fixed (uint* names_ptr = names)
                {
                    GenNamesAMD(identifier, num, names_ptr);
                }
            }
            public static unsafe void GenNamesAMD(All identifier, uint num, ref uint names)
            {
                fixed (uint* names_ptr = &names)
                {
                    GenNamesAMD(identifier, num, names_ptr);
                }
            }
            public static unsafe void DeleteNamesAMD(All identifier, ReadOnlySpan<uint> names)
            {
                uint num = (uint)(names.Length);
                fixed (uint* names_ptr = names)
                {
                    DeleteNamesAMD(identifier, num, names_ptr);
                }
            }
            public static unsafe void DeleteNamesAMD(All identifier, uint[] names)
            {
                uint num = (uint)(names.Length);
                fixed (uint* names_ptr = names)
                {
                    DeleteNamesAMD(identifier, num, names_ptr);
                }
            }
            public static unsafe void DeleteNamesAMD(All identifier, uint num, in uint names)
            {
                fixed (uint* names_ptr = &names)
                {
                    DeleteNamesAMD(identifier, num, names_ptr);
                }
            }
            public static unsafe void GetPerfMonitorGroupsAMD(Span<int> numGroups, Span<uint> groups)
            {
                fixed (int* numGroups_ptr = numGroups)
                {
                    int groupsSize = (int)(groups.Length);
                    fixed (uint* groups_ptr = groups)
                    {
                        GetPerfMonitorGroupsAMD(numGroups_ptr, groupsSize, groups_ptr);
                    }
                }
            }
            public static unsafe void GetPerfMonitorGroupsAMD(int[] numGroups, uint[] groups)
            {
                fixed (int* numGroups_ptr = numGroups)
                {
                    int groupsSize = (int)(groups.Length);
                    fixed (uint* groups_ptr = groups)
                    {
                        GetPerfMonitorGroupsAMD(numGroups_ptr, groupsSize, groups_ptr);
                    }
                }
            }
            public static unsafe void GetPerfMonitorGroupsAMD(ref int numGroups, int groupsSize, ref uint groups)
            {
                fixed (int* numGroups_ptr = &numGroups)
                fixed (uint* groups_ptr = &groups)
                {
                    GetPerfMonitorGroupsAMD(numGroups_ptr, groupsSize, groups_ptr);
                }
            }
            public static unsafe void GetPerfMonitorCountersAMD(uint group, Span<int> numCounters, Span<int> maxActiveCounters, Span<uint> counters)
            {
                fixed (int* numCounters_ptr = numCounters)
                {
                    fixed (int* maxActiveCounters_ptr = maxActiveCounters)
                    {
                        int counterSize = (int)(counters.Length);
                        fixed (uint* counters_ptr = counters)
                        {
                            GetPerfMonitorCountersAMD(group, numCounters_ptr, maxActiveCounters_ptr, counterSize, counters_ptr);
                        }
                    }
                }
            }
            public static unsafe void GetPerfMonitorCountersAMD(uint group, int[] numCounters, int[] maxActiveCounters, uint[] counters)
            {
                fixed (int* numCounters_ptr = numCounters)
                {
                    fixed (int* maxActiveCounters_ptr = maxActiveCounters)
                    {
                        int counterSize = (int)(counters.Length);
                        fixed (uint* counters_ptr = counters)
                        {
                            GetPerfMonitorCountersAMD(group, numCounters_ptr, maxActiveCounters_ptr, counterSize, counters_ptr);
                        }
                    }
                }
            }
            public static unsafe void GetPerfMonitorCountersAMD(uint group, ref int numCounters, ref int maxActiveCounters, int counterSize, ref uint counters)
            {
                fixed (int* numCounters_ptr = &numCounters)
                fixed (int* maxActiveCounters_ptr = &maxActiveCounters)
                fixed (uint* counters_ptr = &counters)
                {
                    GetPerfMonitorCountersAMD(group, numCounters_ptr, maxActiveCounters_ptr, counterSize, counters_ptr);
                }
            }
            public static unsafe string GetPerfMonitorGroupStringAMD(uint group, int bufSize, Span<int> length)
            {
                string groupString;
                fixed (int* length_ptr = length)
                {
                    var groupString_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetPerfMonitorGroupStringAMD(group, bufSize, length_ptr, groupString_ptr);
                    groupString = Marshal.PtrToStringUTF8((IntPtr)groupString_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)groupString_ptr);
                }
                return groupString;
            }
            public static unsafe void GetPerfMonitorGroupStringAMD(uint group, int bufSize, Span<int> length, out string groupString)
            {
                fixed (int* length_ptr = length)
                {
                    var groupString_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetPerfMonitorGroupStringAMD(group, bufSize, length_ptr, groupString_ptr);
                    groupString = Marshal.PtrToStringUTF8((IntPtr)groupString_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)groupString_ptr);
                }
            }
            public static unsafe string GetPerfMonitorGroupStringAMD(uint group, int bufSize, int[] length)
            {
                string groupString;
                fixed (int* length_ptr = length)
                {
                    var groupString_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetPerfMonitorGroupStringAMD(group, bufSize, length_ptr, groupString_ptr);
                    groupString = Marshal.PtrToStringUTF8((IntPtr)groupString_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)groupString_ptr);
                }
                return groupString;
            }
            public static unsafe void GetPerfMonitorGroupStringAMD(uint group, int bufSize, int[] length, out string groupString)
            {
                fixed (int* length_ptr = length)
                {
                    var groupString_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetPerfMonitorGroupStringAMD(group, bufSize, length_ptr, groupString_ptr);
                    groupString = Marshal.PtrToStringUTF8((IntPtr)groupString_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)groupString_ptr);
                }
            }
            public static unsafe string GetPerfMonitorGroupStringAMD(uint group, int bufSize, ref int length)
            {
                string groupString;
                fixed (int* length_ptr = &length)
                {
                    var groupString_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetPerfMonitorGroupStringAMD(group, bufSize, length_ptr, groupString_ptr);
                    groupString = Marshal.PtrToStringUTF8((IntPtr)groupString_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)groupString_ptr);
                }
                return groupString;
            }
            public static unsafe void GetPerfMonitorGroupStringAMD(uint group, int bufSize, ref int length, out string groupString)
            {
                fixed (int* length_ptr = &length)
                {
                    var groupString_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetPerfMonitorGroupStringAMD(group, bufSize, length_ptr, groupString_ptr);
                    groupString = Marshal.PtrToStringUTF8((IntPtr)groupString_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)groupString_ptr);
                }
            }
            public static unsafe string GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, Span<int> length)
            {
                string counterString;
                fixed (int* length_ptr = length)
                {
                    var counterString_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetPerfMonitorCounterStringAMD(group, counter, bufSize, length_ptr, counterString_ptr);
                    counterString = Marshal.PtrToStringUTF8((IntPtr)counterString_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)counterString_ptr);
                }
                return counterString;
            }
            public static unsafe void GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, Span<int> length, out string counterString)
            {
                fixed (int* length_ptr = length)
                {
                    var counterString_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetPerfMonitorCounterStringAMD(group, counter, bufSize, length_ptr, counterString_ptr);
                    counterString = Marshal.PtrToStringUTF8((IntPtr)counterString_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)counterString_ptr);
                }
            }
            public static unsafe string GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, int[] length)
            {
                string counterString;
                fixed (int* length_ptr = length)
                {
                    var counterString_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetPerfMonitorCounterStringAMD(group, counter, bufSize, length_ptr, counterString_ptr);
                    counterString = Marshal.PtrToStringUTF8((IntPtr)counterString_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)counterString_ptr);
                }
                return counterString;
            }
            public static unsafe void GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, int[] length, out string counterString)
            {
                fixed (int* length_ptr = length)
                {
                    var counterString_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetPerfMonitorCounterStringAMD(group, counter, bufSize, length_ptr, counterString_ptr);
                    counterString = Marshal.PtrToStringUTF8((IntPtr)counterString_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)counterString_ptr);
                }
            }
            public static unsafe string GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, ref int length)
            {
                string counterString;
                fixed (int* length_ptr = &length)
                {
                    var counterString_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetPerfMonitorCounterStringAMD(group, counter, bufSize, length_ptr, counterString_ptr);
                    counterString = Marshal.PtrToStringUTF8((IntPtr)counterString_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)counterString_ptr);
                }
                return counterString;
            }
            public static unsafe void GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, ref int length, out string counterString)
            {
                fixed (int* length_ptr = &length)
                {
                    var counterString_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetPerfMonitorCounterStringAMD(group, counter, bufSize, length_ptr, counterString_ptr);
                    counterString = Marshal.PtrToStringUTF8((IntPtr)counterString_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)counterString_ptr);
                }
            }
            public static unsafe void GetPerfMonitorCounterInfoAMD(uint group, uint counter, All pname, IntPtr data)
            {
                void* data_vptr = (void*)data;
                GetPerfMonitorCounterInfoAMD(group, counter, pname, data_vptr);
            }
            public static unsafe void GetPerfMonitorCounterInfoAMD<T1>(uint group, uint counter, All pname, Span<T1> data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    GetPerfMonitorCounterInfoAMD(group, counter, pname, data_ptr);
                }
            }
            public static unsafe void GetPerfMonitorCounterInfoAMD<T1>(uint group, uint counter, All pname, T1[] data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    GetPerfMonitorCounterInfoAMD(group, counter, pname, data_ptr);
                }
            }
            public static unsafe void GetPerfMonitorCounterInfoAMD<T1>(uint group, uint counter, All pname, ref T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    GetPerfMonitorCounterInfoAMD(group, counter, pname, data_ptr);
                }
            }
            public static unsafe void GenPerfMonitorsAMD(Span<uint> monitors)
            {
                int n = (int)(monitors.Length);
                fixed (uint* monitors_ptr = monitors)
                {
                    GenPerfMonitorsAMD(n, monitors_ptr);
                }
            }
            public static unsafe void GenPerfMonitorsAMD(uint[] monitors)
            {
                int n = (int)(monitors.Length);
                fixed (uint* monitors_ptr = monitors)
                {
                    GenPerfMonitorsAMD(n, monitors_ptr);
                }
            }
            public static unsafe void GenPerfMonitorsAMD(int n, ref uint monitors)
            {
                fixed (uint* monitors_ptr = &monitors)
                {
                    GenPerfMonitorsAMD(n, monitors_ptr);
                }
            }
            public static unsafe void DeletePerfMonitorsAMD(Span<uint> monitors)
            {
                int n = (int)(monitors.Length);
                fixed (uint* monitors_ptr = monitors)
                {
                    DeletePerfMonitorsAMD(n, monitors_ptr);
                }
            }
            public static unsafe void DeletePerfMonitorsAMD(uint[] monitors)
            {
                int n = (int)(monitors.Length);
                fixed (uint* monitors_ptr = monitors)
                {
                    DeletePerfMonitorsAMD(n, monitors_ptr);
                }
            }
            public static unsafe void DeletePerfMonitorsAMD(int n, ref uint monitors)
            {
                fixed (uint* monitors_ptr = &monitors)
                {
                    DeletePerfMonitorsAMD(n, monitors_ptr);
                }
            }
            public static unsafe void SelectPerfMonitorCountersAMD(uint monitor, bool enable, uint group, Span<uint> counterList)
            {
                int numCounters = (int)(counterList.Length);
                fixed (uint* counterList_ptr = counterList)
                {
                    byte enable_byte = (byte)(enable ? 1 : 0);
                    SelectPerfMonitorCountersAMD(monitor, enable_byte, group, numCounters, counterList_ptr);
                }
            }
            public static unsafe void SelectPerfMonitorCountersAMD(uint monitor, bool enable, uint group, uint[] counterList)
            {
                int numCounters = (int)(counterList.Length);
                fixed (uint* counterList_ptr = counterList)
                {
                    byte enable_byte = (byte)(enable ? 1 : 0);
                    SelectPerfMonitorCountersAMD(monitor, enable_byte, group, numCounters, counterList_ptr);
                }
            }
            public static unsafe void SelectPerfMonitorCountersAMD(uint monitor, bool enable, uint group, int numCounters, ref uint counterList)
            {
                fixed (uint* counterList_ptr = &counterList)
                {
                    byte enable_byte = (byte)(enable ? 1 : 0);
                    SelectPerfMonitorCountersAMD(monitor, enable_byte, group, numCounters, counterList_ptr);
                }
            }
            public static unsafe void GetPerfMonitorCounterDataAMD(uint monitor, All pname, Span<uint> data, Span<int> bytesWritten)
            {
                int dataSize = (int)(data.Length * 4);
                fixed (uint* data_ptr = data)
                {
                    fixed (int* bytesWritten_ptr = bytesWritten)
                    {
                        GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data_ptr, bytesWritten_ptr);
                    }
                }
            }
            public static unsafe void GetPerfMonitorCounterDataAMD(uint monitor, All pname, uint[] data, int[] bytesWritten)
            {
                int dataSize = (int)(data.Length * 4);
                fixed (uint* data_ptr = data)
                {
                    fixed (int* bytesWritten_ptr = bytesWritten)
                    {
                        GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data_ptr, bytesWritten_ptr);
                    }
                }
            }
            public static unsafe void GetPerfMonitorCounterDataAMD(uint monitor, All pname, int dataSize, ref uint data, ref int bytesWritten)
            {
                fixed (uint* data_ptr = &data)
                fixed (int* bytesWritten_ptr = &bytesWritten)
                {
                    GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data_ptr, bytesWritten_ptr);
                }
            }
            public static unsafe void SetMultisamplefvAMD(All pname, uint index, ReadOnlySpan<float> val)
            {
                fixed (float* val_ptr = val)
                {
                    SetMultisamplefvAMD(pname, index, val_ptr);
                }
            }
            public static unsafe void SetMultisamplefvAMD(All pname, uint index, float[] val)
            {
                fixed (float* val_ptr = val)
                {
                    SetMultisamplefvAMD(pname, index, val_ptr);
                }
            }
            public static unsafe void SetMultisamplefvAMD(All pname, uint index, in float val)
            {
                fixed (float* val_ptr = &val)
                {
                    SetMultisamplefvAMD(pname, index, val_ptr);
                }
            }
        }
        public static unsafe partial class APPLE
        {
            public static unsafe void ElementPointerAPPLE(ElementPointerTypeATI type, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                ElementPointerAPPLE(type, pointer_vptr);
            }
            public static unsafe void ElementPointerAPPLE<T1>(ElementPointerTypeATI type, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    ElementPointerAPPLE(type, pointer_ptr);
                }
            }
            public static unsafe void ElementPointerAPPLE<T1>(ElementPointerTypeATI type, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    ElementPointerAPPLE(type, pointer_ptr);
                }
            }
            public static unsafe void ElementPointerAPPLE<T1>(ElementPointerTypeATI type, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    ElementPointerAPPLE(type, pointer_ptr);
                }
            }
            public static unsafe void MultiDrawElementArrayAPPLE(PrimitiveType mode, ReadOnlySpan<int> first, ReadOnlySpan<int> count, int primcount)
            {
                fixed (int* first_ptr = first)
                {
                    fixed (int* count_ptr = count)
                    {
                        MultiDrawElementArrayAPPLE(mode, first_ptr, count_ptr, primcount);
                    }
                }
            }
            public static unsafe void MultiDrawElementArrayAPPLE(PrimitiveType mode, int[] first, int[] count, int primcount)
            {
                fixed (int* first_ptr = first)
                {
                    fixed (int* count_ptr = count)
                    {
                        MultiDrawElementArrayAPPLE(mode, first_ptr, count_ptr, primcount);
                    }
                }
            }
            public static unsafe void MultiDrawElementArrayAPPLE(PrimitiveType mode, in int first, in int count, int primcount)
            {
                fixed (int* first_ptr = &first)
                fixed (int* count_ptr = &count)
                {
                    MultiDrawElementArrayAPPLE(mode, first_ptr, count_ptr, primcount);
                }
            }
            public static unsafe void MultiDrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, ReadOnlySpan<int> first, ReadOnlySpan<int> count, int primcount)
            {
                fixed (int* first_ptr = first)
                {
                    fixed (int* count_ptr = count)
                    {
                        MultiDrawRangeElementArrayAPPLE(mode, start, end, first_ptr, count_ptr, primcount);
                    }
                }
            }
            public static unsafe void MultiDrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, int[] first, int[] count, int primcount)
            {
                fixed (int* first_ptr = first)
                {
                    fixed (int* count_ptr = count)
                    {
                        MultiDrawRangeElementArrayAPPLE(mode, start, end, first_ptr, count_ptr, primcount);
                    }
                }
            }
            public static unsafe void MultiDrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, in int first, in int count, int primcount)
            {
                fixed (int* first_ptr = &first)
                fixed (int* count_ptr = &count)
                {
                    MultiDrawRangeElementArrayAPPLE(mode, start, end, first_ptr, count_ptr, primcount);
                }
            }
            public static unsafe void GenFencesAPPLE(Span<uint> fences)
            {
                int n = (int)(fences.Length);
                fixed (uint* fences_ptr = fences)
                {
                    GenFencesAPPLE(n, fences_ptr);
                }
            }
            public static unsafe void GenFencesAPPLE(uint[] fences)
            {
                int n = (int)(fences.Length);
                fixed (uint* fences_ptr = fences)
                {
                    GenFencesAPPLE(n, fences_ptr);
                }
            }
            public static unsafe void GenFencesAPPLE(int n, ref uint fences)
            {
                fixed (uint* fences_ptr = &fences)
                {
                    GenFencesAPPLE(n, fences_ptr);
                }
            }
            public static unsafe void DeleteFencesAPPLE(ReadOnlySpan<uint> fences)
            {
                int n = (int)(fences.Length);
                fixed (uint* fences_ptr = fences)
                {
                    DeleteFencesAPPLE(n, fences_ptr);
                }
            }
            public static unsafe void DeleteFencesAPPLE(uint[] fences)
            {
                int n = (int)(fences.Length);
                fixed (uint* fences_ptr = fences)
                {
                    DeleteFencesAPPLE(n, fences_ptr);
                }
            }
            public static unsafe void DeleteFencesAPPLE(int n, in uint fences)
            {
                fixed (uint* fences_ptr = &fences)
                {
                    DeleteFencesAPPLE(n, fences_ptr);
                }
            }
            public static unsafe void GetObjectParameterivAPPLE(All objectType, uint name, All pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetObjectParameterivAPPLE(objectType, name, pname, parameters_ptr);
                }
            }
            public static unsafe void GetObjectParameterivAPPLE(All objectType, uint name, All pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetObjectParameterivAPPLE(objectType, name, pname, parameters_ptr);
                }
            }
            public static unsafe void GetObjectParameterivAPPLE(All objectType, uint name, All pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetObjectParameterivAPPLE(objectType, name, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureRangeAPPLE(All target, int length, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                TextureRangeAPPLE(target, length, pointer_vptr);
            }
            public static unsafe void TextureRangeAPPLE<T1>(All target, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                int length = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    TextureRangeAPPLE(target, length, pointer_ptr);
                }
            }
            public static unsafe void TextureRangeAPPLE<T1>(All target, T1[] pointer)
                where T1 : unmanaged
            {
                int length = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    TextureRangeAPPLE(target, length, pointer_ptr);
                }
            }
            public static unsafe void TextureRangeAPPLE<T1>(All target, int length, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    TextureRangeAPPLE(target, length, pointer_ptr);
                }
            }
            public static unsafe void DeleteVertexArraysAPPLE(ReadOnlySpan<VertexArrayHandle> arrays)
            {
                int n = (int)(arrays.Length);
                fixed (VertexArrayHandle* arrays_ptr = arrays)
                {
                    DeleteVertexArraysAPPLE(n, arrays_ptr);
                }
            }
            public static unsafe void DeleteVertexArraysAPPLE(VertexArrayHandle[] arrays)
            {
                int n = (int)(arrays.Length);
                fixed (VertexArrayHandle* arrays_ptr = arrays)
                {
                    DeleteVertexArraysAPPLE(n, arrays_ptr);
                }
            }
            public static unsafe void DeleteVertexArraysAPPLE(int n, in VertexArrayHandle arrays)
            {
                fixed (VertexArrayHandle* arrays_ptr = &arrays)
                {
                    DeleteVertexArraysAPPLE(n, arrays_ptr);
                }
            }
            public static unsafe void GenVertexArraysAPPLE(Span<VertexArrayHandle> arrays)
            {
                int n = (int)(arrays.Length);
                fixed (VertexArrayHandle* arrays_ptr = arrays)
                {
                    GenVertexArraysAPPLE(n, arrays_ptr);
                }
            }
            public static unsafe void GenVertexArraysAPPLE(VertexArrayHandle[] arrays)
            {
                int n = (int)(arrays.Length);
                fixed (VertexArrayHandle* arrays_ptr = arrays)
                {
                    GenVertexArraysAPPLE(n, arrays_ptr);
                }
            }
            public static unsafe void GenVertexArraysAPPLE(int n, ref VertexArrayHandle arrays)
            {
                fixed (VertexArrayHandle* arrays_ptr = &arrays)
                {
                    GenVertexArraysAPPLE(n, arrays_ptr);
                }
            }
            public static unsafe void VertexArrayRangeAPPLE(int length, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                VertexArrayRangeAPPLE(length, pointer_vptr);
            }
            public static unsafe void VertexArrayRangeAPPLE<T1>(Span<T1> pointer)
                where T1 : unmanaged
            {
                int length = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    VertexArrayRangeAPPLE(length, pointer_ptr);
                }
            }
            public static unsafe void VertexArrayRangeAPPLE<T1>(T1[] pointer)
                where T1 : unmanaged
            {
                int length = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    VertexArrayRangeAPPLE(length, pointer_ptr);
                }
            }
            public static unsafe void VertexArrayRangeAPPLE<T1>(int length, ref T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    VertexArrayRangeAPPLE(length, pointer_ptr);
                }
            }
            public static unsafe void FlushVertexArrayRangeAPPLE(int length, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                FlushVertexArrayRangeAPPLE(length, pointer_vptr);
            }
            public static unsafe void FlushVertexArrayRangeAPPLE<T1>(Span<T1> pointer)
                where T1 : unmanaged
            {
                int length = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    FlushVertexArrayRangeAPPLE(length, pointer_ptr);
                }
            }
            public static unsafe void FlushVertexArrayRangeAPPLE<T1>(T1[] pointer)
                where T1 : unmanaged
            {
                int length = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    FlushVertexArrayRangeAPPLE(length, pointer_ptr);
                }
            }
            public static unsafe void FlushVertexArrayRangeAPPLE<T1>(int length, ref T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    FlushVertexArrayRangeAPPLE(length, pointer_ptr);
                }
            }
            public static unsafe void MapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, ReadOnlySpan<double> points)
            {
                fixed (double* points_ptr = points)
                {
                    MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points_ptr);
                }
            }
            public static unsafe void MapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, double[] points)
            {
                fixed (double* points_ptr = points)
                {
                    MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points_ptr);
                }
            }
            public static unsafe void MapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, in double points)
            {
                fixed (double* points_ptr = &points)
                {
                    MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points_ptr);
                }
            }
            public static unsafe void MapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, ReadOnlySpan<float> points)
            {
                fixed (float* points_ptr = points)
                {
                    MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points_ptr);
                }
            }
            public static unsafe void MapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, float[] points)
            {
                fixed (float* points_ptr = points)
                {
                    MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points_ptr);
                }
            }
            public static unsafe void MapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, in float points)
            {
                fixed (float* points_ptr = &points)
                {
                    MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points_ptr);
                }
            }
            public static unsafe void MapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, ReadOnlySpan<double> points)
            {
                fixed (double* points_ptr = points)
                {
                    MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
                }
            }
            public static unsafe void MapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points)
            {
                fixed (double* points_ptr = points)
                {
                    MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
                }
            }
            public static unsafe void MapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, in double points)
            {
                fixed (double* points_ptr = &points)
                {
                    MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
                }
            }
            public static unsafe void MapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, ReadOnlySpan<float> points)
            {
                fixed (float* points_ptr = points)
                {
                    MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
                }
            }
            public static unsafe void MapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points)
            {
                fixed (float* points_ptr = points)
                {
                    MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
                }
            }
            public static unsafe void MapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, in float points)
            {
                fixed (float* points_ptr = &points)
                {
                    MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_ptr);
                }
            }
        }
        public static unsafe partial class ARB
        {
            public static unsafe void ShaderBinary(ReadOnlySpan<ShaderHandle> shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
            {
                int count = (int)(shaders.Length);
                fixed (ShaderHandle* shaders_ptr = shaders)
                {
                    void* binary_vptr = (void*)binary;
                    ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
                }
            }
            public static unsafe void ShaderBinary(ShaderHandle[] shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
            {
                int count = (int)(shaders.Length);
                fixed (ShaderHandle* shaders_ptr = shaders)
                {
                    void* binary_vptr = (void*)binary;
                    ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
                }
            }
            public static unsafe void ShaderBinary(int count, in ShaderHandle shaders, ShaderBinaryFormat binaryFormat, IntPtr binary, int length)
            {
                fixed (ShaderHandle* shaders_ptr = &shaders)
                {
                    void* binary_vptr = (void*)binary;
                    ShaderBinary(count, shaders_ptr, binaryFormat, binary_vptr, length);
                }
            }
            public static unsafe void ShaderBinary<T1>(ReadOnlySpan<ShaderHandle> shaders, ShaderBinaryFormat binaryFormat, ReadOnlySpan<T1> binary)
                where T1 : unmanaged
            {
                int count = (int)(shaders.Length);
                fixed (ShaderHandle* shaders_ptr = shaders)
                {
                    int length = (int)(binary.Length * sizeof(T1));
                    fixed (void* binary_ptr = binary)
                    {
                        ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
                    }
                }
            }
            public static unsafe void ShaderBinary<T1>(ShaderHandle[] shaders, ShaderBinaryFormat binaryFormat, T1[] binary)
                where T1 : unmanaged
            {
                int count = (int)(shaders.Length);
                fixed (ShaderHandle* shaders_ptr = shaders)
                {
                    int length = (int)(binary.Length * sizeof(T1));
                    fixed (void* binary_ptr = binary)
                    {
                        ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
                    }
                }
            }
            public static unsafe void ShaderBinary<T1>(int count, in ShaderHandle shaders, ShaderBinaryFormat binaryFormat, in T1 binary, int length)
                where T1 : unmanaged
            {
                fixed (ShaderHandle* shaders_ptr = &shaders)
                fixed (void* binary_ptr = &binary)
                {
                    ShaderBinary(count, shaders_ptr, binaryFormat, binary_ptr, length);
                }
            }
            public static unsafe void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, Span<int> range, Span<int> precision)
            {
                fixed (int* range_ptr = range)
                {
                    fixed (int* precision_ptr = precision)
                    {
                        GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
                    }
                }
            }
            public static unsafe void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, int[] range, int[] precision)
            {
                fixed (int* range_ptr = range)
                {
                    fixed (int* precision_ptr = precision)
                    {
                        GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
                    }
                }
            }
            public static unsafe void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, ref int range, ref int precision)
            {
                fixed (int* range_ptr = &range)
                fixed (int* precision_ptr = &precision)
                {
                    GetShaderPrecisionFormat(shadertype, precisiontype, range_ptr, precision_ptr);
                }
            }
            public static unsafe void DrawElementsInstancedBaseInstance(PrimitiveType mode, int count, PrimitiveType type, nint offset, int instancecount, uint baseinstance)
            {
                void* indices = (void*)offset;
                DrawElementsInstancedBaseInstance(mode, count, type, indices, instancecount, baseinstance);
            }
            public static unsafe void DrawElementsInstancedBaseVertexBaseInstance(PrimitiveType mode, int count, DrawElementsType type, nint offset, int instancecount, int basevertex, uint baseinstance)
            {
                void* indices = (void*)offset;
                DrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, instancecount, basevertex, baseinstance);
            }
            public static unsafe ulong GetImageHandleARB(TextureHandle texture, int level, bool layered, int layer, PixelFormat format)
            {
                ulong returnValue;
                byte layered_byte = (byte)(layered ? 1 : 0);
                returnValue = GetImageHandleARB(texture, level, layered_byte, layer, format);
                return returnValue;
            }
            public static unsafe void UniformHandleui64vARB(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length);
                fixed (ulong* value_ptr = value)
                {
                    UniformHandleui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void UniformHandleui64vARB(int location, ulong[] value)
            {
                int count = (int)(value.Length);
                fixed (ulong* value_ptr = value)
                {
                    UniformHandleui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void UniformHandleui64vARB(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    UniformHandleui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniformHandleui64vARB(ProgramHandle program, int location, ReadOnlySpan<ulong> values)
            {
                int count = (int)(values.Length);
                fixed (ulong* values_ptr = values)
                {
                    ProgramUniformHandleui64vARB(program, location, count, values_ptr);
                }
            }
            public static unsafe void ProgramUniformHandleui64vARB(ProgramHandle program, int location, ulong[] values)
            {
                int count = (int)(values.Length);
                fixed (ulong* values_ptr = values)
                {
                    ProgramUniformHandleui64vARB(program, location, count, values_ptr);
                }
            }
            public static unsafe void ProgramUniformHandleui64vARB(ProgramHandle program, int location, int count, in ulong values)
            {
                fixed (ulong* values_ptr = &values)
                {
                    ProgramUniformHandleui64vARB(program, location, count, values_ptr);
                }
            }
            public static unsafe void VertexAttribL1ui64vARB(uint index, in ulong v)
            {
                fixed (ulong* v_ptr = &v)
                {
                    VertexAttribL1ui64vARB(index, v_ptr);
                }
            }
            public static unsafe void GetVertexAttribLui64vARB(uint index, VertexAttribEnum pname, ref ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    GetVertexAttribLui64vARB(index, pname, parameters_ptr);
                }
            }
            public static unsafe void BindFragDataLocationIndexed(ProgramHandle program, uint colorNumber, uint index, string name)
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                BindFragDataLocationIndexed(program, colorNumber, index, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            public static unsafe int GetFragDataIndex(ProgramHandle program, string name)
            {
                int returnValue;
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                returnValue = GetFragDataIndex(program, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                return returnValue;
            }
            public static unsafe void BufferStorage(BufferStorageTarget target, nint size, IntPtr data, BufferStorageMask flags)
            {
                void* data_vptr = (void*)data;
                BufferStorage(target, size, data_vptr, flags);
            }
            public static unsafe void BufferStorage<T1>(BufferStorageTarget target, ReadOnlySpan<T1> data, BufferStorageMask flags)
                where T1 : unmanaged
            {
                nint size = (nint)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    BufferStorage(target, size, data_ptr, flags);
                }
            }
            public static unsafe void BufferStorage<T1>(BufferStorageTarget target, T1[] data, BufferStorageMask flags)
                where T1 : unmanaged
            {
                nint size = (nint)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    BufferStorage(target, size, data_ptr, flags);
                }
            }
            public static unsafe void BufferStorage<T1>(BufferStorageTarget target, nint size, in T1 data, BufferStorageMask flags)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    BufferStorage(target, size, data_ptr, flags);
                }
            }
            public static unsafe GLSync CreateSyncFromCLeventARB(ref CLContext context, ref CLEvent @event, All flags)
            {
                GLSync returnValue;
                fixed (CLContext* context_ptr = &context)
                fixed (CLEvent* @event_ptr = &@event)
                {
                    returnValue = CreateSyncFromCLeventARB(context_ptr, @event_ptr, flags);
                }
                return returnValue;
            }
            public static unsafe void ClearBufferData(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, IntPtr data)
            {
                void* data_vptr = (void*)data;
                ClearBufferData(target, internalformat, format, type, data_vptr);
            }
            public static unsafe void ClearBufferData<T1>(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ClearBufferData(target, internalformat, format, type, data_ptr);
                }
            }
            public static unsafe void ClearBufferData<T1>(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, T1[] data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ClearBufferData(target, internalformat, format, type, data_ptr);
                }
            }
            public static unsafe void ClearBufferData<T1>(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    ClearBufferData(target, internalformat, format, type, data_ptr);
                }
            }
            public static unsafe void ClearBufferSubData(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, IntPtr data)
            {
                void* data_vptr = (void*)data;
                ClearBufferSubData(target, internalformat, offset, size, format, type, data_vptr);
            }
            public static unsafe void ClearBufferSubData<T1>(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ClearBufferSubData(target, internalformat, offset, size, format, type, data_ptr);
                }
            }
            public static unsafe void ClearBufferSubData<T1>(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, T1[] data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ClearBufferSubData(target, internalformat, offset, size, format, type, data_ptr);
                }
            }
            public static unsafe void ClearBufferSubData<T1>(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    ClearBufferSubData(target, internalformat, offset, size, format, type, data_ptr);
                }
            }
            public static unsafe void ClearTexImage(TextureHandle texture, int level, PixelFormat format, PixelType type, IntPtr data)
            {
                void* data_vptr = (void*)data;
                ClearTexImage(texture, level, format, type, data_vptr);
            }
            public static unsafe void ClearTexImage<T1>(TextureHandle texture, int level, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ClearTexImage(texture, level, format, type, data_ptr);
                }
            }
            public static unsafe void ClearTexImage<T1>(TextureHandle texture, int level, PixelFormat format, PixelType type, T1[] data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ClearTexImage(texture, level, format, type, data_ptr);
                }
            }
            public static unsafe void ClearTexImage<T1>(TextureHandle texture, int level, PixelFormat format, PixelType type, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    ClearTexImage(texture, level, format, type, data_ptr);
                }
            }
            public static unsafe void ClearTexSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr data)
            {
                void* data_vptr = (void*)data;
                ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_vptr);
            }
            public static unsafe void ClearTexSubImage<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_ptr);
                }
            }
            public static unsafe void ClearTexSubImage<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, T1[] data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_ptr);
                }
            }
            public static unsafe void ClearTexSubImage<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_ptr);
                }
            }
            public static unsafe void DebugMessageControlARB(DebugSource source, DebugType type, DebugSeverity severity, ReadOnlySpan<uint> ids, bool enabled)
            {
                int count = (int)(ids.Length);
                fixed (uint* ids_ptr = ids)
                {
                    byte enabled_byte = (byte)(enabled ? 1 : 0);
                    DebugMessageControlARB(source, type, severity, count, ids_ptr, enabled_byte);
                }
            }
            public static unsafe void DebugMessageControlARB(DebugSource source, DebugType type, DebugSeverity severity, uint[] ids, bool enabled)
            {
                int count = (int)(ids.Length);
                fixed (uint* ids_ptr = ids)
                {
                    byte enabled_byte = (byte)(enabled ? 1 : 0);
                    DebugMessageControlARB(source, type, severity, count, ids_ptr, enabled_byte);
                }
            }
            public static unsafe void DebugMessageControlARB(DebugSource source, DebugType type, DebugSeverity severity, int count, in uint ids, bool enabled)
            {
                fixed (uint* ids_ptr = &ids)
                {
                    byte enabled_byte = (byte)(enabled ? 1 : 0);
                    DebugMessageControlARB(source, type, severity, count, ids_ptr, enabled_byte);
                }
            }
            public static unsafe void DebugMessageInsertARB(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, string buf)
            {
                byte* buf_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(buf);
                DebugMessageInsertARB(source, type, id, severity, length, buf_ptr);
                Marshal.FreeCoTaskMem((IntPtr)buf_ptr);
            }
            public static unsafe void DebugMessageCallbackARB(GLDebugProcARB callback, IntPtr userParam)
            {
                void* userParam_vptr = (void*)userParam;
                IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                DebugMessageCallbackARB(callback_ptr, userParam_vptr);
            }
            public static unsafe void DebugMessageCallbackARB<T1>(GLDebugProcARB callback, ReadOnlySpan<T1> userParam)
                where T1 : unmanaged
            {
                fixed (void* userParam_ptr = userParam)
                {
                    IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                    DebugMessageCallbackARB(callback_ptr, userParam_ptr);
                }
            }
            public static unsafe void DebugMessageCallbackARB<T1>(GLDebugProcARB callback, T1[] userParam)
                where T1 : unmanaged
            {
                fixed (void* userParam_ptr = userParam)
                {
                    IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                    DebugMessageCallbackARB(callback_ptr, userParam_ptr);
                }
            }
            public static unsafe void DebugMessageCallbackARB<T1>(GLDebugProcARB callback, in T1 userParam)
                where T1 : unmanaged
            {
                fixed (void* userParam_ptr = &userParam)
                {
                    IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                    DebugMessageCallbackARB(callback_ptr, userParam_ptr);
                }
            }
            public static unsafe uint GetDebugMessageLogARB(uint count, int bufSize, Span<DebugSource> sources, Span<DebugType> types, Span<uint> ids, Span<DebugSeverity> severities, Span<int> lengths, out string messageLog)
            {
                uint returnValue;
                fixed (DebugSource* sources_ptr = sources)
                {
                    fixed (DebugType* types_ptr = types)
                    {
                        fixed (uint* ids_ptr = ids)
                        {
                            fixed (DebugSeverity* severities_ptr = severities)
                            {
                                fixed (int* lengths_ptr = lengths)
                                {
                                    var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                    returnValue = GetDebugMessageLogARB(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                    messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                    Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                                }
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe uint GetDebugMessageLogARB(uint count, int bufSize, DebugSource[] sources, DebugType[] types, uint[] ids, DebugSeverity[] severities, int[] lengths, out string messageLog)
            {
                uint returnValue;
                fixed (DebugSource* sources_ptr = sources)
                {
                    fixed (DebugType* types_ptr = types)
                    {
                        fixed (uint* ids_ptr = ids)
                        {
                            fixed (DebugSeverity* severities_ptr = severities)
                            {
                                fixed (int* lengths_ptr = lengths)
                                {
                                    var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                    returnValue = GetDebugMessageLogARB(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                    messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                    Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                                }
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe uint GetDebugMessageLogARB(uint count, int bufSize, ref DebugSource sources, ref DebugType types, ref uint ids, ref DebugSeverity severities, ref int lengths, out string messageLog)
            {
                uint returnValue;
                fixed (DebugSource* sources_ptr = &sources)
                fixed (DebugType* types_ptr = &types)
                fixed (uint* ids_ptr = &ids)
                fixed (DebugSeverity* severities_ptr = &severities)
                fixed (int* lengths_ptr = &lengths)
                {
                    var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    returnValue = GetDebugMessageLogARB(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                    messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                }
                return returnValue;
            }
            public static unsafe TransformFeedbackHandle CreateTransformFeedback()
            {
                TransformFeedbackHandle ids;
                int n = 1;
                Unsafe.SkipInit(out ids);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
                CreateTransformFeedbacks(n, ids_handle);
                return ids;
            }
            public static unsafe void CreateTransformFeedback(out TransformFeedbackHandle ids)
            {
                int n = 1;
                Unsafe.SkipInit(out ids);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
                CreateTransformFeedbacks(n, ids_handle);
            }
            public static unsafe void CreateTransformFeedbacks(Span<TransformFeedbackHandle> ids)
            {
                int n = (int)(ids.Length);
                fixed (TransformFeedbackHandle* ids_ptr = ids)
                {
                    CreateTransformFeedbacks(n, ids_ptr);
                }
            }
            public static unsafe void CreateTransformFeedbacks(TransformFeedbackHandle[] ids)
            {
                int n = (int)(ids.Length);
                fixed (TransformFeedbackHandle* ids_ptr = ids)
                {
                    CreateTransformFeedbacks(n, ids_ptr);
                }
            }
            public static unsafe void CreateTransformFeedbacks(int n, ref TransformFeedbackHandle ids)
            {
                fixed (TransformFeedbackHandle* ids_ptr = &ids)
                {
                    CreateTransformFeedbacks(n, ids_ptr);
                }
            }
            public static unsafe void GetTransformFeedbacki(TransformFeedbackHandle xfb, TransformFeedbackPName pname, ref int param)
            {
                fixed (int* param_ptr = &param)
                {
                    GetTransformFeedbackiv(xfb, pname, param_ptr);
                }
            }
            public static unsafe void GetTransformFeedback(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, ref int param)
            {
                fixed (int* param_ptr = &param)
                {
                    GetTransformFeedbacki_v(xfb, pname, index, param_ptr);
                }
            }
            public static unsafe void GetTransformFeedbacki64_(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, ref long param)
            {
                fixed (long* param_ptr = &param)
                {
                    GetTransformFeedbacki64_v(xfb, pname, index, param_ptr);
                }
            }
            public static unsafe BufferHandle CreateBuffer()
            {
                BufferHandle buffers;
                int n = 1;
                Unsafe.SkipInit(out buffers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
                CreateBuffers(n, buffers_handle);
                return buffers;
            }
            public static unsafe void CreateBuffer(out BufferHandle buffers)
            {
                int n = 1;
                Unsafe.SkipInit(out buffers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                BufferHandle* buffers_handle = (BufferHandle*)Unsafe.AsPointer(ref buffers);
                CreateBuffers(n, buffers_handle);
            }
            public static unsafe void CreateBuffers(Span<BufferHandle> buffers)
            {
                int n = (int)(buffers.Length);
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    CreateBuffers(n, buffers_ptr);
                }
            }
            public static unsafe void CreateBuffers(BufferHandle[] buffers)
            {
                int n = (int)(buffers.Length);
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    CreateBuffers(n, buffers_ptr);
                }
            }
            public static unsafe void CreateBuffers(int n, ref BufferHandle buffers)
            {
                fixed (BufferHandle* buffers_ptr = &buffers)
                {
                    CreateBuffers(n, buffers_ptr);
                }
            }
            public static unsafe void NamedBufferStorage(BufferHandle buffer, nint size, IntPtr data, BufferStorageMask flags)
            {
                void* data_vptr = (void*)data;
                NamedBufferStorage(buffer, size, data_vptr, flags);
            }
            public static unsafe void NamedBufferStorage<T1>(BufferHandle buffer, ReadOnlySpan<T1> data, BufferStorageMask flags)
                where T1 : unmanaged
            {
                nint size = (nint)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    NamedBufferStorage(buffer, size, data_ptr, flags);
                }
            }
            public static unsafe void NamedBufferStorage<T1>(BufferHandle buffer, T1[] data, BufferStorageMask flags)
                where T1 : unmanaged
            {
                nint size = (nint)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    NamedBufferStorage(buffer, size, data_ptr, flags);
                }
            }
            public static unsafe void NamedBufferStorage<T1>(BufferHandle buffer, nint size, in T1 data, BufferStorageMask flags)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    NamedBufferStorage(buffer, size, data_ptr, flags);
                }
            }
            public static unsafe void NamedBufferData(BufferHandle buffer, nint size, IntPtr data, VertexBufferObjectUsage usage)
            {
                void* data_vptr = (void*)data;
                NamedBufferData(buffer, size, data_vptr, usage);
            }
            public static unsafe void NamedBufferData<T1>(BufferHandle buffer, nint size, in T1 data, VertexBufferObjectUsage usage)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    NamedBufferData(buffer, size, data_ptr, usage);
                }
            }
            public static unsafe void NamedBufferSubData(BufferHandle buffer, IntPtr offset, nint size, IntPtr data)
            {
                void* data_vptr = (void*)data;
                NamedBufferSubData(buffer, offset, size, data_vptr);
            }
            public static unsafe void NamedBufferSubData<T1>(BufferHandle buffer, IntPtr offset, nint size, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    NamedBufferSubData(buffer, offset, size, data_ptr);
                }
            }
            public static unsafe void NamedBufferSubData<T1>(BufferHandle buffer, IntPtr offset, nint size, T1[] data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    NamedBufferSubData(buffer, offset, size, data_ptr);
                }
            }
            public static unsafe void NamedBufferSubData<T1>(BufferHandle buffer, IntPtr offset, nint size, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    NamedBufferSubData(buffer, offset, size, data_ptr);
                }
            }
            public static unsafe void ClearNamedBufferData(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, IntPtr data)
            {
                void* data_vptr = (void*)data;
                ClearNamedBufferData(buffer, internalformat, format, type, data_vptr);
            }
            public static unsafe void ClearNamedBufferData<T1>(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    ClearNamedBufferData(buffer, internalformat, format, type, data_ptr);
                }
            }
            public static unsafe void ClearNamedBufferSubData(BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, IntPtr data)
            {
                void* data_vptr = (void*)data;
                ClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data_vptr);
            }
            public static unsafe void ClearNamedBufferSubData<T1>(BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    ClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data_ptr);
                }
            }
            public static unsafe void GetNamedBufferParameteri(BufferHandle buffer, BufferPNameARB pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetNamedBufferParameteriv(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedBufferParameteri64(BufferHandle buffer, BufferPNameARB pname, ref long parameters)
            {
                fixed (long* parameters_ptr = &parameters)
                {
                    GetNamedBufferParameteri64v(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedBufferPointer(BufferHandle buffer, BufferPointerNameARB pname, void** parameters)
            {
                GetNamedBufferPointerv(buffer, pname, parameters);
            }
            public static unsafe void GetNamedBufferSubData(BufferHandle buffer, IntPtr offset, nint size, IntPtr data)
            {
                void* data_vptr = (void*)data;
                GetNamedBufferSubData(buffer, offset, size, data_vptr);
            }
            public static unsafe void GetNamedBufferSubData<T1>(BufferHandle buffer, IntPtr offset, nint size, ref T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    GetNamedBufferSubData(buffer, offset, size, data_ptr);
                }
            }
            public static unsafe FramebufferHandle CreateFramebuffer()
            {
                FramebufferHandle framebuffers;
                int n = 1;
                Unsafe.SkipInit(out framebuffers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
                CreateFramebuffers(n, framebuffers_handle);
                return framebuffers;
            }
            public static unsafe void CreateFramebuffer(out FramebufferHandle framebuffers)
            {
                int n = 1;
                Unsafe.SkipInit(out framebuffers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
                CreateFramebuffers(n, framebuffers_handle);
            }
            public static unsafe void CreateFramebuffers(Span<FramebufferHandle> framebuffers)
            {
                int n = (int)(framebuffers.Length);
                fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
                {
                    CreateFramebuffers(n, framebuffers_ptr);
                }
            }
            public static unsafe void CreateFramebuffers(FramebufferHandle[] framebuffers)
            {
                int n = (int)(framebuffers.Length);
                fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
                {
                    CreateFramebuffers(n, framebuffers_ptr);
                }
            }
            public static unsafe void CreateFramebuffers(int n, ref FramebufferHandle framebuffers)
            {
                fixed (FramebufferHandle* framebuffers_ptr = &framebuffers)
                {
                    CreateFramebuffers(n, framebuffers_ptr);
                }
            }
            public static unsafe void NamedFramebufferDrawBuffers(FramebufferHandle framebuffer, int n, in ColorBuffer bufs)
            {
                fixed (ColorBuffer* bufs_ptr = &bufs)
                {
                    NamedFramebufferDrawBuffers(framebuffer, n, bufs_ptr);
                }
            }
            public static unsafe void InvalidateNamedFramebufferData(FramebufferHandle framebuffer, int numAttachments, in FramebufferAttachment attachments)
            {
                fixed (FramebufferAttachment* attachments_ptr = &attachments)
                {
                    InvalidateNamedFramebufferData(framebuffer, numAttachments, attachments_ptr);
                }
            }
            public static unsafe void InvalidateNamedFramebufferSubData(FramebufferHandle framebuffer, int numAttachments, in FramebufferAttachment attachments, int x, int y, int width, int height)
            {
                fixed (FramebufferAttachment* attachments_ptr = &attachments)
                {
                    InvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments_ptr, x, y, width, height);
                }
            }
            public static unsafe void ClearNamedFramebufferi(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, in int value)
            {
                fixed (int* value_ptr = &value)
                {
                    ClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value_ptr);
                }
            }
            public static unsafe void ClearNamedFramebufferui(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    ClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value_ptr);
                }
            }
            public static unsafe void ClearNamedFramebufferf(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    ClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value_ptr);
                }
            }
            public static unsafe void ClearNamedFramebuffer(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil)
            {
                ClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil);
            }
            public static unsafe void GetNamedFramebufferParameteri(FramebufferHandle framebuffer, GetFramebufferParameter pname, ref int param)
            {
                fixed (int* param_ptr = &param)
                {
                    GetNamedFramebufferParameteriv(framebuffer, pname, param_ptr);
                }
            }
            public static unsafe void GetNamedFramebufferAttachmentParameteri(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, parameters_ptr);
                }
            }
            public static unsafe RenderbufferHandle CreateRenderbuffer()
            {
                RenderbufferHandle renderbuffers;
                int n = 1;
                Unsafe.SkipInit(out renderbuffers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
                CreateRenderbuffers(n, renderbuffers_handle);
                return renderbuffers;
            }
            public static unsafe void CreateRenderbuffer(out RenderbufferHandle renderbuffers)
            {
                int n = 1;
                Unsafe.SkipInit(out renderbuffers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
                CreateRenderbuffers(n, renderbuffers_handle);
            }
            public static unsafe void CreateRenderbuffers(Span<RenderbufferHandle> renderbuffers)
            {
                int n = (int)(renderbuffers.Length);
                fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
                {
                    CreateRenderbuffers(n, renderbuffers_ptr);
                }
            }
            public static unsafe void CreateRenderbuffers(RenderbufferHandle[] renderbuffers)
            {
                int n = (int)(renderbuffers.Length);
                fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
                {
                    CreateRenderbuffers(n, renderbuffers_ptr);
                }
            }
            public static unsafe void CreateRenderbuffers(int n, ref RenderbufferHandle renderbuffers)
            {
                fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers)
                {
                    CreateRenderbuffers(n, renderbuffers_ptr);
                }
            }
            public static unsafe void GetNamedRenderbufferParameteri(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetNamedRenderbufferParameteriv(renderbuffer, pname, parameters_ptr);
                }
            }
            public static unsafe TextureHandle CreateTexture(TextureTarget target)
            {
                TextureHandle textures;
                int n = 1;
                Unsafe.SkipInit(out textures);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
                CreateTextures(target, n, textures_handle);
                return textures;
            }
            public static unsafe void CreateTexture(TextureTarget target, out TextureHandle textures)
            {
                int n = 1;
                Unsafe.SkipInit(out textures);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                TextureHandle* textures_handle = (TextureHandle*)Unsafe.AsPointer(ref textures);
                CreateTextures(target, n, textures_handle);
            }
            public static unsafe void CreateTextures(TextureTarget target, Span<TextureHandle> textures)
            {
                int n = (int)(textures.Length);
                fixed (TextureHandle* textures_ptr = textures)
                {
                    CreateTextures(target, n, textures_ptr);
                }
            }
            public static unsafe void CreateTextures(TextureTarget target, TextureHandle[] textures)
            {
                int n = (int)(textures.Length);
                fixed (TextureHandle* textures_ptr = textures)
                {
                    CreateTextures(target, n, textures_ptr);
                }
            }
            public static unsafe void CreateTextures(TextureTarget target, int n, ref TextureHandle textures)
            {
                fixed (TextureHandle* textures_ptr = &textures)
                {
                    CreateTextures(target, n, textures_ptr);
                }
            }
            public static unsafe void TextureStorage2DMultisample(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
            {
                byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
                TextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations_byte);
            }
            public static unsafe void TextureStorage3DMultisample(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
            {
                byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
                TextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
            }
            public static unsafe void TextureSubImage1D(TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TextureSubImage1D(texture, level, xoffset, width, format, type, pixels_vptr);
            }
            public static unsafe void TextureSubImage1D<T1>(TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TextureSubImage1D(texture, level, xoffset, width, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels_vptr);
            }
            public static unsafe void TextureSubImage2D<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_vptr);
            }
            public static unsafe void TextureSubImage3D<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
                }
            }
            public static unsafe void CompressedTextureSubImage1D(TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, IntPtr data)
            {
                void* data_vptr = (void*)data;
                CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data_vptr);
            }
            public static unsafe void CompressedTextureSubImage1D<T1>(TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, IntPtr data)
            {
                void* data_vptr = (void*)data;
                CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data_vptr);
            }
            public static unsafe void CompressedTextureSubImage2D<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, IntPtr data)
            {
                void* data_vptr = (void*)data;
                CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_vptr);
            }
            public static unsafe void CompressedTextureSubImage3D<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
                }
            }
            public static unsafe void TextureParameterf(TextureHandle texture, TextureParameterName pname, in float param)
            {
                fixed (float* param_ptr = &param)
                {
                    TextureParameterfv(texture, pname, param_ptr);
                }
            }
            public static unsafe void TextureParameterIi(TextureHandle texture, TextureParameterName pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    TextureParameterIiv(texture, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureParameterIui(TextureHandle texture, TextureParameterName pname, in uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    TextureParameterIuiv(texture, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureParameteri(TextureHandle texture, TextureParameterName pname, in int param)
            {
                fixed (int* param_ptr = &param)
                {
                    TextureParameteriv(texture, pname, param_ptr);
                }
            }
            public static unsafe void GetTextureImage(TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                GetTextureImage(texture, level, format, type, bufSize, pixels_vptr);
            }
            public static unsafe void GetTextureImage<T1>(TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, ref T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    GetTextureImage(texture, level, format, type, bufSize, pixels_ptr);
                }
            }
            public static unsafe void GetCompressedTextureImage(TextureHandle texture, int level, int bufSize, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                GetCompressedTextureImage(texture, level, bufSize, pixels_vptr);
            }
            public static unsafe void GetCompressedTextureImage<T1>(TextureHandle texture, int level, int bufSize, ref T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    GetCompressedTextureImage(texture, level, bufSize, pixels_ptr);
                }
            }
            public static unsafe void GetTextureLevelParameterf(TextureHandle texture, int level, GetTextureParameter pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetTextureLevelParameterfv(texture, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureLevelParameteri(TextureHandle texture, int level, GetTextureParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetTextureLevelParameteriv(texture, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterf(TextureHandle texture, GetTextureParameter pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetTextureParameterfv(texture, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterIi(TextureHandle texture, GetTextureParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetTextureParameterIiv(texture, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterIui(TextureHandle texture, GetTextureParameter pname, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetTextureParameterIuiv(texture, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameteri(TextureHandle texture, GetTextureParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetTextureParameteriv(texture, pname, parameters_ptr);
                }
            }
            public static unsafe VertexArrayHandle CreateVertexArray()
            {
                VertexArrayHandle arrays;
                int n = 1;
                Unsafe.SkipInit(out arrays);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
                CreateVertexArrays(n, arrays_handle);
                return arrays;
            }
            public static unsafe void CreateVertexArray(out VertexArrayHandle arrays)
            {
                int n = 1;
                Unsafe.SkipInit(out arrays);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
                CreateVertexArrays(n, arrays_handle);
            }
            public static unsafe void CreateVertexArrays(Span<VertexArrayHandle> arrays)
            {
                int n = (int)(arrays.Length);
                fixed (VertexArrayHandle* arrays_ptr = arrays)
                {
                    CreateVertexArrays(n, arrays_ptr);
                }
            }
            public static unsafe void CreateVertexArrays(VertexArrayHandle[] arrays)
            {
                int n = (int)(arrays.Length);
                fixed (VertexArrayHandle* arrays_ptr = arrays)
                {
                    CreateVertexArrays(n, arrays_ptr);
                }
            }
            public static unsafe void CreateVertexArrays(int n, ref VertexArrayHandle arrays)
            {
                fixed (VertexArrayHandle* arrays_ptr = &arrays)
                {
                    CreateVertexArrays(n, arrays_ptr);
                }
            }
            public static unsafe void VertexArrayVertexBuffers(VertexArrayHandle vaobj, uint first, int count, in BufferHandle buffers, in IntPtr offsets, in int strides)
            {
                fixed (BufferHandle* buffers_ptr = &buffers)
                fixed (IntPtr* offsets_ptr = &offsets)
                fixed (int* strides_ptr = &strides)
                {
                    VertexArrayVertexBuffers(vaobj, first, count, buffers_ptr, offsets_ptr, strides_ptr);
                }
            }
            public static unsafe void VertexArrayAttribFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexArrayAttribFormat(vaobj, attribindex, size, type, normalized_byte, relativeoffset);
            }
            public static unsafe void GetVertexArrayi(VertexArrayHandle vaobj, VertexArrayPName pname, ref int param)
            {
                fixed (int* param_ptr = &param)
                {
                    GetVertexArrayiv(vaobj, pname, param_ptr);
                }
            }
            public static unsafe void GetVertexArrayIndexedi(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, ref int param)
            {
                fixed (int* param_ptr = &param)
                {
                    GetVertexArrayIndexediv(vaobj, index, pname, param_ptr);
                }
            }
            public static unsafe void GetVertexArrayIndexed64iv(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, ref long param)
            {
                fixed (long* param_ptr = &param)
                {
                    GetVertexArrayIndexed64iv(vaobj, index, pname, param_ptr);
                }
            }
            public static unsafe SamplerHandle CreateSampler()
            {
                SamplerHandle samplers;
                int n = 1;
                Unsafe.SkipInit(out samplers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
                CreateSamplers(n, samplers_handle);
                return samplers;
            }
            public static unsafe void CreateSampler(out SamplerHandle samplers)
            {
                int n = 1;
                Unsafe.SkipInit(out samplers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
                CreateSamplers(n, samplers_handle);
            }
            public static unsafe void CreateSamplers(Span<SamplerHandle> samplers)
            {
                int n = (int)(samplers.Length);
                fixed (SamplerHandle* samplers_ptr = samplers)
                {
                    CreateSamplers(n, samplers_ptr);
                }
            }
            public static unsafe void CreateSamplers(SamplerHandle[] samplers)
            {
                int n = (int)(samplers.Length);
                fixed (SamplerHandle* samplers_ptr = samplers)
                {
                    CreateSamplers(n, samplers_ptr);
                }
            }
            public static unsafe void CreateSamplers(int n, ref SamplerHandle samplers)
            {
                fixed (SamplerHandle* samplers_ptr = &samplers)
                {
                    CreateSamplers(n, samplers_ptr);
                }
            }
            public static unsafe ProgramPipelineHandle CreateProgramPipeline()
            {
                ProgramPipelineHandle pipelines;
                int n = 1;
                Unsafe.SkipInit(out pipelines);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
                CreateProgramPipelines(n, pipelines_handle);
                return pipelines;
            }
            public static unsafe void CreateProgramPipeline(out ProgramPipelineHandle pipelines)
            {
                int n = 1;
                Unsafe.SkipInit(out pipelines);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
                CreateProgramPipelines(n, pipelines_handle);
            }
            public static unsafe void CreateProgramPipelines(Span<ProgramPipelineHandle> pipelines)
            {
                int n = (int)(pipelines.Length);
                fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
                {
                    CreateProgramPipelines(n, pipelines_ptr);
                }
            }
            public static unsafe void CreateProgramPipelines(ProgramPipelineHandle[] pipelines)
            {
                int n = (int)(pipelines.Length);
                fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
                {
                    CreateProgramPipelines(n, pipelines_ptr);
                }
            }
            public static unsafe void CreateProgramPipelines(int n, ref ProgramPipelineHandle pipelines)
            {
                fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines)
                {
                    CreateProgramPipelines(n, pipelines_ptr);
                }
            }
            public static unsafe QueryHandle CreateQuerie(QueryTarget target)
            {
                QueryHandle ids;
                int n = 1;
                Unsafe.SkipInit(out ids);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
                CreateQueries(target, n, ids_handle);
                return ids;
            }
            public static unsafe void CreateQuerie(QueryTarget target, out QueryHandle ids)
            {
                int n = 1;
                Unsafe.SkipInit(out ids);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                QueryHandle* ids_handle = (QueryHandle*)Unsafe.AsPointer(ref ids);
                CreateQueries(target, n, ids_handle);
            }
            public static unsafe void CreateQueries(QueryTarget target, Span<QueryHandle> ids)
            {
                int n = (int)(ids.Length);
                fixed (QueryHandle* ids_ptr = ids)
                {
                    CreateQueries(target, n, ids_ptr);
                }
            }
            public static unsafe void CreateQueries(QueryTarget target, QueryHandle[] ids)
            {
                int n = (int)(ids.Length);
                fixed (QueryHandle* ids_ptr = ids)
                {
                    CreateQueries(target, n, ids_ptr);
                }
            }
            public static unsafe void CreateQueries(QueryTarget target, int n, ref QueryHandle ids)
            {
                fixed (QueryHandle* ids_ptr = &ids)
                {
                    CreateQueries(target, n, ids_ptr);
                }
            }
            public static unsafe void GetQueryBufferObjecti64(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
            {
                GetQueryBufferObjecti64v(id, buffer, pname, offset);
            }
            public static unsafe void GetQueryBufferObjecti(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
            {
                GetQueryBufferObjectiv(id, buffer, pname, offset);
            }
            public static unsafe void GetQueryBufferObjectui64(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
            {
                GetQueryBufferObjectui64v(id, buffer, pname, offset);
            }
            public static unsafe void GetQueryBufferObjectui(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset)
            {
                GetQueryBufferObjectuiv(id, buffer, pname, offset);
            }
            public static unsafe void DrawBuffersARB(ReadOnlySpan<DrawBufferMode> bufs)
            {
                int n = (int)(bufs.Length);
                fixed (DrawBufferMode* bufs_ptr = bufs)
                {
                    DrawBuffersARB(n, bufs_ptr);
                }
            }
            public static unsafe void DrawBuffersARB(DrawBufferMode[] bufs)
            {
                int n = (int)(bufs.Length);
                fixed (DrawBufferMode* bufs_ptr = bufs)
                {
                    DrawBuffersARB(n, bufs_ptr);
                }
            }
            public static unsafe void DrawBuffersARB(int n, in DrawBufferMode bufs)
            {
                fixed (DrawBufferMode* bufs_ptr = &bufs)
                {
                    DrawBuffersARB(n, bufs_ptr);
                }
            }
            public static unsafe void DrawElementsBaseVertex(PrimitiveType mode, int count, DrawElementsType type, nint offset, int basevertex)
            {
                void* indices = (void*)offset;
                DrawElementsBaseVertex(mode, count, type, indices, basevertex);
            }
            public static unsafe void DrawRangeElementsBaseVertex(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, nint offset, int basevertex)
            {
                void* indices = (void*)offset;
                DrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
            }
            public static unsafe void DrawElementsInstancedBaseVertex(PrimitiveType mode, int count, DrawElementsType type, nint offset, int instancecount, int basevertex)
            {
                void* indices = (void*)offset;
                DrawElementsInstancedBaseVertex(mode, count, type, indices, instancecount, basevertex);
            }
            public static unsafe void MultiDrawElementsBaseVertex(PrimitiveType mode, ReadOnlySpan<int> count, DrawElementsType type, void** indices, int drawcount, ReadOnlySpan<int> basevertex)
            {
                fixed (int* count_ptr = count)
                {
                    fixed (int* basevertex_ptr = basevertex)
                    {
                        MultiDrawElementsBaseVertex(mode, count_ptr, type, indices, drawcount, basevertex_ptr);
                    }
                }
            }
            public static unsafe void MultiDrawElementsBaseVertex(PrimitiveType mode, int[] count, DrawElementsType type, void** indices, int drawcount, int[] basevertex)
            {
                fixed (int* count_ptr = count)
                {
                    fixed (int* basevertex_ptr = basevertex)
                    {
                        MultiDrawElementsBaseVertex(mode, count_ptr, type, indices, drawcount, basevertex_ptr);
                    }
                }
            }
            public static unsafe void MultiDrawElementsBaseVertex(PrimitiveType mode, in int count, DrawElementsType type, void** indices, int drawcount, in int basevertex)
            {
                fixed (int* count_ptr = &count)
                fixed (int* basevertex_ptr = &basevertex)
                {
                    MultiDrawElementsBaseVertex(mode, count_ptr, type, indices, drawcount, basevertex_ptr);
                }
            }
            public static unsafe void DrawArraysIndirect(PrimitiveType mode, IntPtr indirect)
            {
                void* indirect_vptr = (void*)indirect;
                DrawArraysIndirect(mode, indirect_vptr);
            }
            public static unsafe void DrawArraysIndirect<T1>(PrimitiveType mode, in T1 indirect)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = &indirect)
                {
                    DrawArraysIndirect(mode, indirect_ptr);
                }
            }
            public static unsafe void DrawElementsIndirect(PrimitiveType mode, DrawElementsType type, IntPtr indirect)
            {
                void* indirect_vptr = (void*)indirect;
                DrawElementsIndirect(mode, type, indirect_vptr);
            }
            public static unsafe void DrawElementsIndirect<T1>(PrimitiveType mode, DrawElementsType type, in T1 indirect)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = &indirect)
                {
                    DrawElementsIndirect(mode, type, indirect_ptr);
                }
            }
            public static unsafe void DrawElementsInstancedARB(PrimitiveType mode, int count, DrawElementsType type, nint offset, int primcount)
            {
                void* indices = (void*)offset;
                DrawElementsInstancedARB(mode, count, type, indices, primcount);
            }
            public static unsafe void ProgramStringARB(ProgramTarget target, ProgramFormat format, int len, IntPtr str)
            {
                void* str_vptr = (void*)str;
                ProgramStringARB(target, format, len, str_vptr);
            }
            public static unsafe void ProgramStringARB<T1>(ProgramTarget target, ProgramFormat format, ReadOnlySpan<T1> str)
                where T1 : unmanaged
            {
                int len = (int)(str.Length * sizeof(T1));
                fixed (void* str_ptr = str)
                {
                    ProgramStringARB(target, format, len, str_ptr);
                }
            }
            public static unsafe void ProgramStringARB<T1>(ProgramTarget target, ProgramFormat format, T1[] str)
                where T1 : unmanaged
            {
                int len = (int)(str.Length * sizeof(T1));
                fixed (void* str_ptr = str)
                {
                    ProgramStringARB(target, format, len, str_ptr);
                }
            }
            public static unsafe void ProgramStringARB<T1>(ProgramTarget target, ProgramFormat format, int len, in T1 str)
                where T1 : unmanaged
            {
                fixed (void* str_ptr = &str)
                {
                    ProgramStringARB(target, format, len, str_ptr);
                }
            }
            public static unsafe void DeleteProgramsARB(ReadOnlySpan<ProgramHandle> programs)
            {
                int n = (int)(programs.Length);
                fixed (ProgramHandle* programs_ptr = programs)
                {
                    DeleteProgramsARB(n, programs_ptr);
                }
            }
            public static unsafe void DeleteProgramsARB(ProgramHandle[] programs)
            {
                int n = (int)(programs.Length);
                fixed (ProgramHandle* programs_ptr = programs)
                {
                    DeleteProgramsARB(n, programs_ptr);
                }
            }
            public static unsafe void DeleteProgramsARB(int n, in ProgramHandle programs)
            {
                fixed (ProgramHandle* programs_ptr = &programs)
                {
                    DeleteProgramsARB(n, programs_ptr);
                }
            }
            public static unsafe void GenProgramsARB(Span<ProgramHandle> programs)
            {
                int n = (int)(programs.Length);
                fixed (ProgramHandle* programs_ptr = programs)
                {
                    GenProgramsARB(n, programs_ptr);
                }
            }
            public static unsafe void GenProgramsARB(ProgramHandle[] programs)
            {
                int n = (int)(programs.Length);
                fixed (ProgramHandle* programs_ptr = programs)
                {
                    GenProgramsARB(n, programs_ptr);
                }
            }
            public static unsafe void GenProgramsARB(int n, ref ProgramHandle programs)
            {
                fixed (ProgramHandle* programs_ptr = &programs)
                {
                    GenProgramsARB(n, programs_ptr);
                }
            }
            public static unsafe void ProgramEnvParameter4dvARB(ProgramTarget target, uint index, ReadOnlySpan<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    ProgramEnvParameter4dvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameter4dvARB(ProgramTarget target, uint index, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    ProgramEnvParameter4dvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameter4dvARB(ProgramTarget target, uint index, in double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    ProgramEnvParameter4dvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameter4fvARB(ProgramTarget target, uint index, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ProgramEnvParameter4fvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameter4fvARB(ProgramTarget target, uint index, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ProgramEnvParameter4fvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameter4fvARB(ProgramTarget target, uint index, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    ProgramEnvParameter4fvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameter4dvARB(ProgramTarget target, uint index, ReadOnlySpan<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    ProgramLocalParameter4dvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameter4dvARB(ProgramTarget target, uint index, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    ProgramLocalParameter4dvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameter4dvARB(ProgramTarget target, uint index, in double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    ProgramLocalParameter4dvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameter4fvARB(ProgramTarget target, uint index, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ProgramLocalParameter4fvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameter4fvARB(ProgramTarget target, uint index, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ProgramLocalParameter4fvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameter4fvARB(ProgramTarget target, uint index, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    ProgramLocalParameter4fvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramEnvParameterdvARB(ProgramTarget target, uint index, Span<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetProgramEnvParameterdvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramEnvParameterdvARB(ProgramTarget target, uint index, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetProgramEnvParameterdvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramEnvParameterdvARB(ProgramTarget target, uint index, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    GetProgramEnvParameterdvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramEnvParameterfvARB(ProgramTarget target, uint index, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetProgramEnvParameterfvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramEnvParameterfvARB(ProgramTarget target, uint index, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetProgramEnvParameterfvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramEnvParameterfvARB(ProgramTarget target, uint index, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetProgramEnvParameterfvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramLocalParameterdvARB(ProgramTarget target, uint index, Span<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetProgramLocalParameterdvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramLocalParameterdvARB(ProgramTarget target, uint index, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetProgramLocalParameterdvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramLocalParameterdvARB(ProgramTarget target, uint index, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    GetProgramLocalParameterdvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramLocalParameterfvARB(ProgramTarget target, uint index, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetProgramLocalParameterfvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramLocalParameterfvARB(ProgramTarget target, uint index, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetProgramLocalParameterfvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramLocalParameterfvARB(ProgramTarget target, uint index, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetProgramLocalParameterfvARB(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramivARB(ProgramTarget target, ProgramPropertyARB pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetProgramivARB(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramivARB(ProgramTarget target, ProgramPropertyARB pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetProgramivARB(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramivARB(ProgramTarget target, ProgramPropertyARB pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetProgramivARB(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramStringARB(ProgramTarget target, ProgramStringProperty pname, IntPtr str)
            {
                void* str_vptr = (void*)str;
                GetProgramStringARB(target, pname, str_vptr);
            }
            public static unsafe void GetProgramStringARB<T1>(ProgramTarget target, ProgramStringProperty pname, Span<T1> str)
                where T1 : unmanaged
            {
                fixed (void* str_ptr = str)
                {
                    GetProgramStringARB(target, pname, str_ptr);
                }
            }
            public static unsafe void GetProgramStringARB<T1>(ProgramTarget target, ProgramStringProperty pname, T1[] str)
                where T1 : unmanaged
            {
                fixed (void* str_ptr = str)
                {
                    GetProgramStringARB(target, pname, str_ptr);
                }
            }
            public static unsafe void GetProgramStringARB<T1>(ProgramTarget target, ProgramStringProperty pname, ref T1 str)
                where T1 : unmanaged
            {
                fixed (void* str_ptr = &str)
                {
                    GetProgramStringARB(target, pname, str_ptr);
                }
            }
            public static unsafe void GetFramebufferParameteri(FramebufferTarget target, FramebufferAttachmentParameterName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFramebufferParameteriv(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFramebufferParameteri(FramebufferTarget target, FramebufferAttachmentParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFramebufferParameteriv(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFramebufferParameteri(FramebufferTarget target, FramebufferAttachmentParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetFramebufferParameteriv(target, pname, parameters_ptr);
                }
            }
            public static unsafe void DeleteRenderbuffer(in RenderbufferHandle renderbuffers)
            {
                int n = 1;
                fixed(RenderbufferHandle* renderbuffers_handle = &renderbuffers)
                {
                    DeleteRenderbuffers(n, renderbuffers_handle);
                }
            }
            public static unsafe void DeleteRenderbuffers(ReadOnlySpan<RenderbufferHandle> renderbuffers)
            {
                int n = (int)(renderbuffers.Length);
                fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
                {
                    DeleteRenderbuffers(n, renderbuffers_ptr);
                }
            }
            public static unsafe void DeleteRenderbuffers(RenderbufferHandle[] renderbuffers)
            {
                int n = (int)(renderbuffers.Length);
                fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
                {
                    DeleteRenderbuffers(n, renderbuffers_ptr);
                }
            }
            public static unsafe void DeleteRenderbuffers(int n, in RenderbufferHandle renderbuffers)
            {
                fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers)
                {
                    DeleteRenderbuffers(n, renderbuffers_ptr);
                }
            }
            public static unsafe RenderbufferHandle GenRenderbuffer()
            {
                RenderbufferHandle renderbuffers;
                int n = 1;
                Unsafe.SkipInit(out renderbuffers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
                GenRenderbuffers(n, renderbuffers_handle);
                return renderbuffers;
            }
            public static unsafe void GenRenderbuffer(out RenderbufferHandle renderbuffers)
            {
                int n = 1;
                Unsafe.SkipInit(out renderbuffers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                RenderbufferHandle* renderbuffers_handle = (RenderbufferHandle*)Unsafe.AsPointer(ref renderbuffers);
                GenRenderbuffers(n, renderbuffers_handle);
            }
            public static unsafe void GenRenderbuffers(Span<RenderbufferHandle> renderbuffers)
            {
                int n = (int)(renderbuffers.Length);
                fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
                {
                    GenRenderbuffers(n, renderbuffers_ptr);
                }
            }
            public static unsafe void GenRenderbuffers(RenderbufferHandle[] renderbuffers)
            {
                int n = (int)(renderbuffers.Length);
                fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
                {
                    GenRenderbuffers(n, renderbuffers_ptr);
                }
            }
            public static unsafe void GenRenderbuffers(int n, ref RenderbufferHandle renderbuffers)
            {
                fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers)
                {
                    GenRenderbuffers(n, renderbuffers_ptr);
                }
            }
            public static unsafe void GetRenderbufferParameteri(RenderbufferTarget target, RenderbufferParameterName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetRenderbufferParameteriv(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetRenderbufferParameteri(RenderbufferTarget target, RenderbufferParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetRenderbufferParameteriv(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetRenderbufferParameteri(RenderbufferTarget target, RenderbufferParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetRenderbufferParameteriv(target, pname, parameters_ptr);
                }
            }
            public static unsafe void DeleteFramebuffer(in FramebufferHandle framebuffers)
            {
                int n = 1;
                fixed(FramebufferHandle* framebuffers_handle = &framebuffers)
                {
                    DeleteFramebuffers(n, framebuffers_handle);
                }
            }
            public static unsafe void DeleteFramebuffers(ReadOnlySpan<FramebufferHandle> framebuffers)
            {
                int n = (int)(framebuffers.Length);
                fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
                {
                    DeleteFramebuffers(n, framebuffers_ptr);
                }
            }
            public static unsafe void DeleteFramebuffers(FramebufferHandle[] framebuffers)
            {
                int n = (int)(framebuffers.Length);
                fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
                {
                    DeleteFramebuffers(n, framebuffers_ptr);
                }
            }
            public static unsafe void DeleteFramebuffers(int n, in FramebufferHandle framebuffers)
            {
                fixed (FramebufferHandle* framebuffers_ptr = &framebuffers)
                {
                    DeleteFramebuffers(n, framebuffers_ptr);
                }
            }
            public static unsafe FramebufferHandle GenFramebuffer()
            {
                FramebufferHandle framebuffers;
                int n = 1;
                Unsafe.SkipInit(out framebuffers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
                GenFramebuffers(n, framebuffers_handle);
                return framebuffers;
            }
            public static unsafe void GenFramebuffer(out FramebufferHandle framebuffers)
            {
                int n = 1;
                Unsafe.SkipInit(out framebuffers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                FramebufferHandle* framebuffers_handle = (FramebufferHandle*)Unsafe.AsPointer(ref framebuffers);
                GenFramebuffers(n, framebuffers_handle);
            }
            public static unsafe void GenFramebuffers(Span<FramebufferHandle> framebuffers)
            {
                int n = (int)(framebuffers.Length);
                fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
                {
                    GenFramebuffers(n, framebuffers_ptr);
                }
            }
            public static unsafe void GenFramebuffers(FramebufferHandle[] framebuffers)
            {
                int n = (int)(framebuffers.Length);
                fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
                {
                    GenFramebuffers(n, framebuffers_ptr);
                }
            }
            public static unsafe void GenFramebuffers(int n, ref FramebufferHandle framebuffers)
            {
                fixed (FramebufferHandle* framebuffers_ptr = &framebuffers)
                {
                    GenFramebuffers(n, framebuffers_ptr);
                }
            }
            public static unsafe void GetFramebufferAttachmentParameteri(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFramebufferAttachmentParameteri(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFramebufferAttachmentParameteri(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetFramebufferAttachmentParameteriv(target, attachment, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramBinary(ProgramHandle program, int bufSize, Span<int> length, Span<All> binaryFormat, IntPtr binary)
            {
                fixed (int* length_ptr = length)
                {
                    fixed (All* binaryFormat_ptr = binaryFormat)
                    {
                        void* binary_vptr = (void*)binary;
                        GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
                    }
                }
            }
            public static unsafe void GetProgramBinary(ProgramHandle program, int bufSize, int[] length, All[] binaryFormat, IntPtr binary)
            {
                fixed (int* length_ptr = length)
                {
                    fixed (All* binaryFormat_ptr = binaryFormat)
                    {
                        void* binary_vptr = (void*)binary;
                        GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
                    }
                }
            }
            public static unsafe void GetProgramBinary(ProgramHandle program, int bufSize, ref int length, ref All binaryFormat, IntPtr binary)
            {
                fixed (int* length_ptr = &length)
                fixed (All* binaryFormat_ptr = &binaryFormat)
                {
                    void* binary_vptr = (void*)binary;
                    GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_vptr);
                }
            }
            public static unsafe void GetProgramBinary<T1>(ProgramHandle program, Span<int> length, Span<All> binaryFormat, Span<T1> binary)
                where T1 : unmanaged
            {
                fixed (int* length_ptr = length)
                {
                    fixed (All* binaryFormat_ptr = binaryFormat)
                    {
                        int bufSize = (int)(binary.Length * sizeof(T1));
                        fixed (void* binary_ptr = binary)
                        {
                            GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
                        }
                    }
                }
            }
            public static unsafe void GetProgramBinary<T1>(ProgramHandle program, int[] length, All[] binaryFormat, T1[] binary)
                where T1 : unmanaged
            {
                fixed (int* length_ptr = length)
                {
                    fixed (All* binaryFormat_ptr = binaryFormat)
                    {
                        int bufSize = (int)(binary.Length * sizeof(T1));
                        fixed (void* binary_ptr = binary)
                        {
                            GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
                        }
                    }
                }
            }
            public static unsafe void GetProgramBinary<T1>(ProgramHandle program, int bufSize, ref int length, ref All binaryFormat, ref T1 binary)
                where T1 : unmanaged
            {
                fixed (int* length_ptr = &length)
                fixed (All* binaryFormat_ptr = &binaryFormat)
                fixed (void* binary_ptr = &binary)
                {
                    GetProgramBinary(program, bufSize, length_ptr, binaryFormat_ptr, binary_ptr);
                }
            }
            public static unsafe void ProgramBinary(ProgramHandle program, All binaryFormat, IntPtr binary, int length)
            {
                void* binary_vptr = (void*)binary;
                ProgramBinary(program, binaryFormat, binary_vptr, length);
            }
            public static unsafe void ProgramBinary<T1>(ProgramHandle program, All binaryFormat, ReadOnlySpan<T1> binary)
                where T1 : unmanaged
            {
                int length = (int)(binary.Length * sizeof(T1));
                fixed (void* binary_ptr = binary)
                {
                    ProgramBinary(program, binaryFormat, binary_ptr, length);
                }
            }
            public static unsafe void ProgramBinary<T1>(ProgramHandle program, All binaryFormat, T1[] binary)
                where T1 : unmanaged
            {
                int length = (int)(binary.Length * sizeof(T1));
                fixed (void* binary_ptr = binary)
                {
                    ProgramBinary(program, binaryFormat, binary_ptr, length);
                }
            }
            public static unsafe void ProgramBinary<T1>(ProgramHandle program, All binaryFormat, in T1 binary, int length)
                where T1 : unmanaged
            {
                fixed (void* binary_ptr = &binary)
                {
                    ProgramBinary(program, binaryFormat, binary_ptr, length);
                }
            }
            public static unsafe void GetTextureSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels_vptr);
            }
            public static unsafe void GetTextureSubImage<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, ref T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels_ptr);
                }
            }
            public static unsafe void GetCompressedTextureSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels_vptr);
            }
            public static unsafe void GetCompressedTextureSubImage<T1>(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, ref T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels_ptr);
                }
            }
            public static unsafe void SpecializeShaderARB(ShaderHandle shader, string pEntryPoint, uint numSpecializationConstants, in uint pConstantIndex, in uint pConstantValue)
            {
                fixed (uint* pConstantIndex_ptr = &pConstantIndex)
                fixed (uint* pConstantValue_ptr = &pConstantValue)
                {
                    byte* pEntryPoint_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(pEntryPoint);
                    SpecializeShaderARB(shader, pEntryPoint_ptr, numSpecializationConstants, pConstantIndex_ptr, pConstantValue_ptr);
                    Marshal.FreeCoTaskMem((IntPtr)pEntryPoint_ptr);
                }
            }
            public static unsafe void Uniform1d(int location, in double value)
            {
                int count = 1;
                fixed (double* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    Uniform1dv(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1d(int location, int count, ReadOnlySpan<double> value)
            {
                fixed (double* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    Uniform1dv(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1d(int location, int count, double[] value)
            {
                fixed (double* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    Uniform1dv(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2d(int location, in Vector2d value)
            {
                int count = 1;
                fixed (Vector2d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    Uniform2dv(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2d(int location, int count, ReadOnlySpan<Vector2d> value)
            {
                fixed (Vector2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    Uniform2dv(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2d(int location, int count, Vector2d[] value)
            {
                fixed (Vector2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    Uniform2dv(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3d(int location, in Vector3d value)
            {
                int count = 1;
                fixed (Vector3d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    Uniform3dv(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3d(int location, int count, ReadOnlySpan<Vector3d> value)
            {
                fixed (Vector3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    Uniform3dv(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3d(int location, int count, Vector3d[] value)
            {
                fixed (Vector3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    Uniform3dv(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4d(int location, in Vector4d value)
            {
                int count = 1;
                fixed (Vector4d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    Uniform4dv(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4d(int location, int count, ReadOnlySpan<Vector4d> value)
            {
                fixed (Vector4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    Uniform4dv(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4d(int location, int count, Vector4d[] value)
            {
                fixed (Vector4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    Uniform4dv(location, count, value_ptr);
                }
            }
            public static unsafe void UniformMatrix2d(int location, bool transpose, in Matrix2d value)
            {
                int count = 1;
                fixed (Matrix2d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix2dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix2d(int location, int count, bool transpose, ReadOnlySpan<Matrix2d> value)
            {
                fixed (Matrix2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix2dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix2d(int location, int count, bool transpose, Matrix2d[] value)
            {
                fixed (Matrix2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix2dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix3d(int location, bool transpose, in Matrix3d value)
            {
                int count = 1;
                fixed (Matrix3d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix3dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix3d(int location, int count, bool transpose, ReadOnlySpan<Matrix3d> value)
            {
                fixed (Matrix3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix3dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix3d(int location, int count, bool transpose, Matrix3d[] value)
            {
                fixed (Matrix3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix3dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix4d(int location, bool transpose, in Matrix4d value)
            {
                int count = 1;
                fixed (Matrix4d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix4dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix4d(int location, int count, bool transpose, ReadOnlySpan<Matrix4d> value)
            {
                fixed (Matrix4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix4dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix4d(int location, int count, bool transpose, Matrix4d[] value)
            {
                fixed (Matrix4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix4dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix2x3d(int location, bool transpose, in Matrix2x3d value)
            {
                int count = 1;
                fixed (Matrix2x3d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix2x3dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix2x3d(int location, int count, bool transpose, ReadOnlySpan<Matrix2x3d> value)
            {
                fixed (Matrix2x3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix2x3dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix2x3d(int location, int count, bool transpose, Matrix2x3d[] value)
            {
                fixed (Matrix2x3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix2x3dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix2x4d(int location, bool transpose, in Matrix2x4d value)
            {
                int count = 1;
                fixed (Matrix2x4d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix2x4dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix2x4d(int location, int count, bool transpose, ReadOnlySpan<Matrix2x4d> value)
            {
                fixed (Matrix2x4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix2x4dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix2x4d(int location, int count, bool transpose, Matrix2x4d[] value)
            {
                fixed (Matrix2x4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix2x4dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix3x2d(int location, bool transpose, in Matrix3x2d value)
            {
                int count = 1;
                fixed (Matrix3x2d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix3x2dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix3x2d(int location, int count, bool transpose, ReadOnlySpan<Matrix3x2d> value)
            {
                fixed (Matrix3x2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix3x2dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix3x2d(int location, int count, bool transpose, Matrix3x2d[] value)
            {
                fixed (Matrix3x2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix3x2dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix3x4d(int location, bool transpose, in Matrix3x4d value)
            {
                int count = 1;
                fixed (Matrix3x4d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix3x4dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix3x4d(int location, int count, bool transpose, ReadOnlySpan<Matrix3x4d> value)
            {
                fixed (Matrix3x4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix3x4dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix3x4d(int location, int count, bool transpose, Matrix3x4d[] value)
            {
                fixed (Matrix3x4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix3x4dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix4x2d(int location, bool transpose, in Matrix4x2d value)
            {
                int count = 1;
                fixed (Matrix4x2d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix4x2dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix4x2d(int location, int count, bool transpose, ReadOnlySpan<Matrix4x2d> value)
            {
                fixed (Matrix4x2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix4x2dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix4x2d(int location, int count, bool transpose, Matrix4x2d[] value)
            {
                fixed (Matrix4x2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix4x2dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix4x3d(int location, bool transpose, in Matrix4x3d value)
            {
                int count = 1;
                fixed (Matrix4x3d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix4x3dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix4x3d(int location, int count, bool transpose, ReadOnlySpan<Matrix4x3d> value)
            {
                fixed (Matrix4x3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix4x3dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix4x3d(int location, int count, bool transpose, Matrix4x3d[] value)
            {
                fixed (Matrix4x3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix4x3dv(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void GetUniformd(ProgramHandle program, int location, Span<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetUniformdv(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformd(ProgramHandle program, int location, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetUniformdv(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformd(ProgramHandle program, int location, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    GetUniformdv(program, location, parameters_ptr);
                }
            }
            public static unsafe void Uniform1i64vARB(int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 1);
                fixed (long* value_ptr = value)
                {
                    Uniform1i64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1i64vARB(int location, long[] value)
            {
                int count = (int)(value.Length / 1);
                fixed (long* value_ptr = value)
                {
                    Uniform1i64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1i64vARB(int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    Uniform1i64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2i64vARB(int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 2);
                fixed (long* value_ptr = value)
                {
                    Uniform2i64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2i64vARB(int location, long[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (long* value_ptr = value)
                {
                    Uniform2i64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2i64vARB(int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    Uniform2i64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3i64vARB(int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 3);
                fixed (long* value_ptr = value)
                {
                    Uniform3i64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3i64vARB(int location, long[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (long* value_ptr = value)
                {
                    Uniform3i64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3i64vARB(int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    Uniform3i64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4i64vARB(int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 4);
                fixed (long* value_ptr = value)
                {
                    Uniform4i64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4i64vARB(int location, long[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (long* value_ptr = value)
                {
                    Uniform4i64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4i64vARB(int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    Uniform4i64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1ui64vARB(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 1);
                fixed (ulong* value_ptr = value)
                {
                    Uniform1ui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1ui64vARB(int location, ulong[] value)
            {
                int count = (int)(value.Length / 1);
                fixed (ulong* value_ptr = value)
                {
                    Uniform1ui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1ui64vARB(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    Uniform1ui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2ui64vARB(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 2);
                fixed (ulong* value_ptr = value)
                {
                    Uniform2ui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2ui64vARB(int location, ulong[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (ulong* value_ptr = value)
                {
                    Uniform2ui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2ui64vARB(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    Uniform2ui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3ui64vARB(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 3);
                fixed (ulong* value_ptr = value)
                {
                    Uniform3ui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3ui64vARB(int location, ulong[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (ulong* value_ptr = value)
                {
                    Uniform3ui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3ui64vARB(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    Uniform3ui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4ui64vARB(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 4);
                fixed (ulong* value_ptr = value)
                {
                    Uniform4ui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4ui64vARB(int location, ulong[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (ulong* value_ptr = value)
                {
                    Uniform4ui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4ui64vARB(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    Uniform4ui64vARB(location, count, value_ptr);
                }
            }
            public static unsafe void GetUniformi64vARB(ProgramHandle program, int location, Span<long> parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetUniformi64vARB(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformi64vARB(ProgramHandle program, int location, long[] parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetUniformi64vARB(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformi64vARB(ProgramHandle program, int location, ref long parameters)
            {
                fixed (long* parameters_ptr = &parameters)
                {
                    GetUniformi64vARB(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformui64vARB(ProgramHandle program, int location, Span<ulong> parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetUniformui64vARB(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformui64vARB(ProgramHandle program, int location, ulong[] parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetUniformui64vARB(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformui64vARB(ProgramHandle program, int location, ref ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    GetUniformui64vARB(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformi64vARB(ProgramHandle program, int location, Span<long> parameters)
            {
                int bufSize = (int)(parameters.Length * 8);
                fixed (long* parameters_ptr = parameters)
                {
                    GetnUniformi64vARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformi64vARB(ProgramHandle program, int location, long[] parameters)
            {
                int bufSize = (int)(parameters.Length * 8);
                fixed (long* parameters_ptr = parameters)
                {
                    GetnUniformi64vARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformi64vARB(ProgramHandle program, int location, int bufSize, ref long parameters)
            {
                fixed (long* parameters_ptr = &parameters)
                {
                    GetnUniformi64vARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformui64vARB(ProgramHandle program, int location, Span<ulong> parameters)
            {
                int bufSize = (int)(parameters.Length * 8);
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetnUniformui64vARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformui64vARB(ProgramHandle program, int location, ulong[] parameters)
            {
                int bufSize = (int)(parameters.Length * 8);
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetnUniformui64vARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformui64vARB(ProgramHandle program, int location, int bufSize, ref ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    GetnUniformui64vARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void ProgramUniform1i64vARB(ProgramHandle program, int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform1i64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1i64vARB(ProgramHandle program, int location, long[] value)
            {
                int count = (int)(value.Length);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform1i64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1i64vARB(ProgramHandle program, int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    ProgramUniform1i64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2i64vARB(ProgramHandle program, int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 2);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform2i64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2i64vARB(ProgramHandle program, int location, long[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform2i64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2i64vARB(ProgramHandle program, int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    ProgramUniform2i64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3i64vARB(ProgramHandle program, int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 3);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform3i64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3i64vARB(ProgramHandle program, int location, long[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform3i64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3i64vARB(ProgramHandle program, int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    ProgramUniform3i64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4i64vARB(ProgramHandle program, int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 4);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform4i64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4i64vARB(ProgramHandle program, int location, long[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform4i64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4i64vARB(ProgramHandle program, int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    ProgramUniform4i64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ui64vARB(ProgramHandle program, int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform1ui64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ui64vARB(ProgramHandle program, int location, ulong[] value)
            {
                int count = (int)(value.Length);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform1ui64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ui64vARB(ProgramHandle program, int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    ProgramUniform1ui64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ui64vARB(ProgramHandle program, int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 2);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform2ui64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ui64vARB(ProgramHandle program, int location, ulong[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform2ui64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ui64vARB(ProgramHandle program, int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    ProgramUniform2ui64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ui64vARB(ProgramHandle program, int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 3);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform3ui64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ui64vARB(ProgramHandle program, int location, ulong[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform3ui64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ui64vARB(ProgramHandle program, int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    ProgramUniform3ui64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ui64vARB(ProgramHandle program, int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 4);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform4ui64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ui64vARB(ProgramHandle program, int location, ulong[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform4ui64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ui64vARB(ProgramHandle program, int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    ProgramUniform4ui64vARB(program, location, count, value_ptr);
                }
            }
            public static unsafe void MultiDrawArraysIndirectCountARB(PrimitiveType mode, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride)
            {
                void* indirect_vptr = (void*)indirect;
                MultiDrawArraysIndirectCountARB(mode, indirect_vptr, drawcount, maxdrawcount, stride);
            }
            public static unsafe void MultiDrawArraysIndirectCountARB<T1>(PrimitiveType mode, in T1 indirect, IntPtr drawcount, int maxdrawcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = &indirect)
                {
                    MultiDrawArraysIndirectCountARB(mode, indirect_ptr, drawcount, maxdrawcount, stride);
                }
            }
            public static unsafe void MultiDrawElementsIndirectCountARB(PrimitiveType mode, DrawElementsType type, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride)
            {
                void* indirect_vptr = (void*)indirect;
                MultiDrawElementsIndirectCountARB(mode, type, indirect_vptr, drawcount, maxdrawcount, stride);
            }
            public static unsafe void MultiDrawElementsIndirectCountARB<T1>(PrimitiveType mode, DrawElementsType type, in T1 indirect, IntPtr drawcount, int maxdrawcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = &indirect)
                {
                    MultiDrawElementsIndirectCountARB(mode, type, indirect_ptr, drawcount, maxdrawcount, stride);
                }
            }
            public static unsafe void GetInternalformati(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, Span<int> parameters)
            {
                int count = (int)(parameters.Length);
                fixed (int* parameters_ptr = parameters)
                {
                    GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
                }
            }
            public static unsafe void GetInternalformati(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int[] parameters)
            {
                int count = (int)(parameters.Length);
                fixed (int* parameters_ptr = parameters)
                {
                    GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
                }
            }
            public static unsafe void GetInternalformati(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetInternalformativ(target, internalformat, pname, count, parameters_ptr);
                }
            }
            public static unsafe void GetInternalformati64(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, Span<long> parameters)
            {
                int count = (int)(parameters.Length);
                fixed (long* parameters_ptr = parameters)
                {
                    GetInternalformati64v(target, internalformat, pname, count, parameters_ptr);
                }
            }
            public static unsafe void GetInternalformati64(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, long[] parameters)
            {
                int count = (int)(parameters.Length);
                fixed (long* parameters_ptr = parameters)
                {
                    GetInternalformati64v(target, internalformat, pname, count, parameters_ptr);
                }
            }
            public static unsafe void GetInternalformati64(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, ref long parameters)
            {
                fixed (long* parameters_ptr = &parameters)
                {
                    GetInternalformati64v(target, internalformat, pname, count, parameters_ptr);
                }
            }
            public static unsafe void InvalidateFramebuffer(FramebufferTarget target, ReadOnlySpan<InvalidateFramebufferAttachment> attachments)
            {
                int numAttachments = (int)(attachments.Length);
                fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments)
                {
                    InvalidateFramebuffer(target, numAttachments, attachments_ptr);
                }
            }
            public static unsafe void InvalidateFramebuffer(FramebufferTarget target, InvalidateFramebufferAttachment[] attachments)
            {
                int numAttachments = (int)(attachments.Length);
                fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments)
                {
                    InvalidateFramebuffer(target, numAttachments, attachments_ptr);
                }
            }
            public static unsafe void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, in InvalidateFramebufferAttachment attachments)
            {
                fixed (InvalidateFramebufferAttachment* attachments_ptr = &attachments)
                {
                    InvalidateFramebuffer(target, numAttachments, attachments_ptr);
                }
            }
            public static unsafe void InvalidateSubFramebuffer(FramebufferTarget target, ReadOnlySpan<InvalidateFramebufferAttachment> attachments, int x, int y, int width, int height)
            {
                int numAttachments = (int)(attachments.Length);
                fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments)
                {
                    InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
                }
            }
            public static unsafe void InvalidateSubFramebuffer(FramebufferTarget target, InvalidateFramebufferAttachment[] attachments, int x, int y, int width, int height)
            {
                int numAttachments = (int)(attachments.Length);
                fixed (InvalidateFramebufferAttachment* attachments_ptr = attachments)
                {
                    InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
                }
            }
            public static unsafe void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, in InvalidateFramebufferAttachment attachments, int x, int y, int width, int height)
            {
                fixed (InvalidateFramebufferAttachment* attachments_ptr = &attachments)
                {
                    InvalidateSubFramebuffer(target, numAttachments, attachments_ptr, x, y, width, height);
                }
            }
            public static unsafe void MatrixIndexubvARB(ReadOnlySpan<byte> indices)
            {
                int size = (int)(indices.Length);
                fixed (byte* indices_ptr = indices)
                {
                    MatrixIndexubvARB(size, indices_ptr);
                }
            }
            public static unsafe void MatrixIndexubvARB(byte[] indices)
            {
                int size = (int)(indices.Length);
                fixed (byte* indices_ptr = indices)
                {
                    MatrixIndexubvARB(size, indices_ptr);
                }
            }
            public static unsafe void MatrixIndexubvARB(int size, in byte indices)
            {
                fixed (byte* indices_ptr = &indices)
                {
                    MatrixIndexubvARB(size, indices_ptr);
                }
            }
            public static unsafe void MatrixIndexusvARB(ReadOnlySpan<ushort> indices)
            {
                int size = (int)(indices.Length);
                fixed (ushort* indices_ptr = indices)
                {
                    MatrixIndexusvARB(size, indices_ptr);
                }
            }
            public static unsafe void MatrixIndexusvARB(ushort[] indices)
            {
                int size = (int)(indices.Length);
                fixed (ushort* indices_ptr = indices)
                {
                    MatrixIndexusvARB(size, indices_ptr);
                }
            }
            public static unsafe void MatrixIndexusvARB(int size, in ushort indices)
            {
                fixed (ushort* indices_ptr = &indices)
                {
                    MatrixIndexusvARB(size, indices_ptr);
                }
            }
            public static unsafe void MatrixIndexuivARB(ReadOnlySpan<uint> indices)
            {
                int size = (int)(indices.Length);
                fixed (uint* indices_ptr = indices)
                {
                    MatrixIndexuivARB(size, indices_ptr);
                }
            }
            public static unsafe void MatrixIndexuivARB(uint[] indices)
            {
                int size = (int)(indices.Length);
                fixed (uint* indices_ptr = indices)
                {
                    MatrixIndexuivARB(size, indices_ptr);
                }
            }
            public static unsafe void MatrixIndexuivARB(int size, in uint indices)
            {
                fixed (uint* indices_ptr = &indices)
                {
                    MatrixIndexuivARB(size, indices_ptr);
                }
            }
            public static unsafe void MatrixIndexPointerARB(int size, MatrixIndexPointerTypeARB type, int stride, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                MatrixIndexPointerARB(size, type, stride, pointer_vptr);
            }
            public static unsafe void MatrixIndexPointerARB<T1>(int size, MatrixIndexPointerTypeARB type, int stride, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    MatrixIndexPointerARB(size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void MatrixIndexPointerARB<T1>(int size, MatrixIndexPointerTypeARB type, int stride, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    MatrixIndexPointerARB(size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void MatrixIndexPointerARB<T1>(int size, MatrixIndexPointerTypeARB type, int stride, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    MatrixIndexPointerARB(size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void BindBuffersBase(BufferTargetARB target, uint first, ReadOnlySpan<BufferHandle> buffers)
            {
                int count = (int)(buffers.Length);
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    BindBuffersBase(target, first, count, buffers_ptr);
                }
            }
            public static unsafe void BindBuffersBase(BufferTargetARB target, uint first, BufferHandle[] buffers)
            {
                int count = (int)(buffers.Length);
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    BindBuffersBase(target, first, count, buffers_ptr);
                }
            }
            public static unsafe void BindBuffersBase(BufferTargetARB target, uint first, int count, in BufferHandle buffers)
            {
                fixed (BufferHandle* buffers_ptr = &buffers)
                {
                    BindBuffersBase(target, first, count, buffers_ptr);
                }
            }
            public static unsafe void BindBuffersRange(BufferTargetARB target, uint first, int count, ReadOnlySpan<BufferHandle> buffers, ReadOnlySpan<IntPtr> offsets, ReadOnlySpan<nint> sizes)
            {
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    fixed (IntPtr* offsets_ptr = offsets)
                    {
                        fixed (nint* sizes_ptr = sizes)
                        {
                            BindBuffersRange(target, first, count, buffers_ptr, offsets_ptr, sizes_ptr);
                        }
                    }
                }
            }
            public static unsafe void BindBuffersRange(BufferTargetARB target, uint first, int count, BufferHandle[] buffers, IntPtr[] offsets, nint[] sizes)
            {
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    fixed (IntPtr* offsets_ptr = offsets)
                    {
                        fixed (nint* sizes_ptr = sizes)
                        {
                            BindBuffersRange(target, first, count, buffers_ptr, offsets_ptr, sizes_ptr);
                        }
                    }
                }
            }
            public static unsafe void BindBuffersRange(BufferTargetARB target, uint first, int count, in BufferHandle buffers, in IntPtr offsets, in nint sizes)
            {
                fixed (BufferHandle* buffers_ptr = &buffers)
                fixed (IntPtr* offsets_ptr = &offsets)
                fixed (nint* sizes_ptr = &sizes)
                {
                    BindBuffersRange(target, first, count, buffers_ptr, offsets_ptr, sizes_ptr);
                }
            }
            public static unsafe void BindTextures(uint first, ReadOnlySpan<TextureHandle> textures)
            {
                int count = (int)(textures.Length);
                fixed (TextureHandle* textures_ptr = textures)
                {
                    BindTextures(first, count, textures_ptr);
                }
            }
            public static unsafe void BindTextures(uint first, TextureHandle[] textures)
            {
                int count = (int)(textures.Length);
                fixed (TextureHandle* textures_ptr = textures)
                {
                    BindTextures(first, count, textures_ptr);
                }
            }
            public static unsafe void BindTextures(uint first, int count, in TextureHandle textures)
            {
                fixed (TextureHandle* textures_ptr = &textures)
                {
                    BindTextures(first, count, textures_ptr);
                }
            }
            public static unsafe void BindSamplers(uint first, ReadOnlySpan<SamplerHandle> samplers)
            {
                int count = (int)(samplers.Length);
                fixed (SamplerHandle* samplers_ptr = samplers)
                {
                    BindSamplers(first, count, samplers_ptr);
                }
            }
            public static unsafe void BindSamplers(uint first, SamplerHandle[] samplers)
            {
                int count = (int)(samplers.Length);
                fixed (SamplerHandle* samplers_ptr = samplers)
                {
                    BindSamplers(first, count, samplers_ptr);
                }
            }
            public static unsafe void BindSamplers(uint first, int count, in SamplerHandle samplers)
            {
                fixed (SamplerHandle* samplers_ptr = &samplers)
                {
                    BindSamplers(first, count, samplers_ptr);
                }
            }
            public static unsafe void BindImageTextures(uint first, ReadOnlySpan<TextureHandle> textures)
            {
                int count = (int)(textures.Length);
                fixed (TextureHandle* textures_ptr = textures)
                {
                    BindImageTextures(first, count, textures_ptr);
                }
            }
            public static unsafe void BindImageTextures(uint first, TextureHandle[] textures)
            {
                int count = (int)(textures.Length);
                fixed (TextureHandle* textures_ptr = textures)
                {
                    BindImageTextures(first, count, textures_ptr);
                }
            }
            public static unsafe void BindImageTextures(uint first, int count, in TextureHandle textures)
            {
                fixed (TextureHandle* textures_ptr = &textures)
                {
                    BindImageTextures(first, count, textures_ptr);
                }
            }
            public static unsafe void BindVertexBuffers(uint first, int count, ReadOnlySpan<BufferHandle> buffers, ReadOnlySpan<IntPtr> offsets, ReadOnlySpan<int> strides)
            {
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    fixed (IntPtr* offsets_ptr = offsets)
                    {
                        fixed (int* strides_ptr = strides)
                        {
                            BindVertexBuffers(first, count, buffers_ptr, offsets_ptr, strides_ptr);
                        }
                    }
                }
            }
            public static unsafe void BindVertexBuffers(uint first, int count, BufferHandle[] buffers, IntPtr[] offsets, int[] strides)
            {
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    fixed (IntPtr* offsets_ptr = offsets)
                    {
                        fixed (int* strides_ptr = strides)
                        {
                            BindVertexBuffers(first, count, buffers_ptr, offsets_ptr, strides_ptr);
                        }
                    }
                }
            }
            public static unsafe void BindVertexBuffers(uint first, int count, in BufferHandle buffers, in IntPtr offsets, in int strides)
            {
                fixed (BufferHandle* buffers_ptr = &buffers)
                fixed (IntPtr* offsets_ptr = &offsets)
                fixed (int* strides_ptr = &strides)
                {
                    BindVertexBuffers(first, count, buffers_ptr, offsets_ptr, strides_ptr);
                }
            }
            public static unsafe void MultiDrawArraysIndirect(PrimitiveType mode, IntPtr indirect, int drawcount, int stride)
            {
                void* indirect_vptr = (void*)indirect;
                MultiDrawArraysIndirect(mode, indirect_vptr, drawcount, stride);
            }
            public static unsafe void MultiDrawArraysIndirect<T1>(PrimitiveType mode, ReadOnlySpan<T1> indirect, int drawcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = indirect)
                {
                    MultiDrawArraysIndirect(mode, indirect_ptr, drawcount, stride);
                }
            }
            public static unsafe void MultiDrawArraysIndirect<T1>(PrimitiveType mode, T1[] indirect, int drawcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = indirect)
                {
                    MultiDrawArraysIndirect(mode, indirect_ptr, drawcount, stride);
                }
            }
            public static unsafe void MultiDrawArraysIndirect<T1>(PrimitiveType mode, in T1 indirect, int drawcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = &indirect)
                {
                    MultiDrawArraysIndirect(mode, indirect_ptr, drawcount, stride);
                }
            }
            public static unsafe void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, IntPtr indirect, int drawcount, int stride)
            {
                void* indirect_vptr = (void*)indirect;
                MultiDrawElementsIndirect(mode, type, indirect_vptr, drawcount, stride);
            }
            public static unsafe void MultiDrawElementsIndirect<T1>(PrimitiveType mode, DrawElementsType type, ReadOnlySpan<T1> indirect, int drawcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = indirect)
                {
                    MultiDrawElementsIndirect(mode, type, indirect_ptr, drawcount, stride);
                }
            }
            public static unsafe void MultiDrawElementsIndirect<T1>(PrimitiveType mode, DrawElementsType type, T1[] indirect, int drawcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = indirect)
                {
                    MultiDrawElementsIndirect(mode, type, indirect_ptr, drawcount, stride);
                }
            }
            public static unsafe void MultiDrawElementsIndirect<T1>(PrimitiveType mode, DrawElementsType type, in T1 indirect, int drawcount, int stride)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = &indirect)
                {
                    MultiDrawElementsIndirect(mode, type, indirect_ptr, drawcount, stride);
                }
            }
            public static unsafe void SampleCoverageARB(float value, bool invert)
            {
                byte invert_byte = (byte)(invert ? 1 : 0);
                SampleCoverageARB(value, invert_byte);
            }
            public static unsafe void MultiTexCoord1dvARB(TextureUnit target, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    MultiTexCoord1dvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1dvARB(TextureUnit target, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    MultiTexCoord1dvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1dvARB(TextureUnit target, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    MultiTexCoord1dvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1fvARB(TextureUnit target, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    MultiTexCoord1fvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1fvARB(TextureUnit target, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    MultiTexCoord1fvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1fvARB(TextureUnit target, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    MultiTexCoord1fvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1ivARB(TextureUnit target, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    MultiTexCoord1ivARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1ivARB(TextureUnit target, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    MultiTexCoord1ivARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1ivARB(TextureUnit target, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    MultiTexCoord1ivARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1svARB(TextureUnit target, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    MultiTexCoord1svARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1svARB(TextureUnit target, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    MultiTexCoord1svARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1svARB(TextureUnit target, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    MultiTexCoord1svARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2dvARB(TextureUnit target, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    MultiTexCoord2dvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2dvARB(TextureUnit target, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    MultiTexCoord2dvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2dvARB(TextureUnit target, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    MultiTexCoord2dvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2fvARB(TextureUnit target, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    MultiTexCoord2fvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2fvARB(TextureUnit target, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    MultiTexCoord2fvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2fvARB(TextureUnit target, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    MultiTexCoord2fvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2ivARB(TextureUnit target, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    MultiTexCoord2ivARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2ivARB(TextureUnit target, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    MultiTexCoord2ivARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2ivARB(TextureUnit target, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    MultiTexCoord2ivARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2svARB(TextureUnit target, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    MultiTexCoord2svARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2svARB(TextureUnit target, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    MultiTexCoord2svARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2svARB(TextureUnit target, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    MultiTexCoord2svARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3dvARB(TextureUnit target, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    MultiTexCoord3dvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3dvARB(TextureUnit target, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    MultiTexCoord3dvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3dvARB(TextureUnit target, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    MultiTexCoord3dvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3fvARB(TextureUnit target, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    MultiTexCoord3fvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3fvARB(TextureUnit target, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    MultiTexCoord3fvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3fvARB(TextureUnit target, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    MultiTexCoord3fvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3ivARB(TextureUnit target, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    MultiTexCoord3ivARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3ivARB(TextureUnit target, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    MultiTexCoord3ivARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3ivARB(TextureUnit target, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    MultiTexCoord3ivARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3svARB(TextureUnit target, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    MultiTexCoord3svARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3svARB(TextureUnit target, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    MultiTexCoord3svARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3svARB(TextureUnit target, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    MultiTexCoord3svARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4dvARB(TextureUnit target, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    MultiTexCoord4dvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4dvARB(TextureUnit target, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    MultiTexCoord4dvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4dvARB(TextureUnit target, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    MultiTexCoord4dvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4fvARB(TextureUnit target, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    MultiTexCoord4fvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4fvARB(TextureUnit target, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    MultiTexCoord4fvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4fvARB(TextureUnit target, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    MultiTexCoord4fvARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4ivARB(TextureUnit target, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    MultiTexCoord4ivARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4ivARB(TextureUnit target, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    MultiTexCoord4ivARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4ivARB(TextureUnit target, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    MultiTexCoord4ivARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4svARB(TextureUnit target, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    MultiTexCoord4svARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4svARB(TextureUnit target, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    MultiTexCoord4svARB(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4svARB(TextureUnit target, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    MultiTexCoord4svARB(target, v_ptr);
                }
            }
            public static unsafe void GenQueriesARB(Span<QueryHandle> ids)
            {
                int n = (int)(ids.Length);
                fixed (QueryHandle* ids_ptr = ids)
                {
                    GenQueriesARB(n, ids_ptr);
                }
            }
            public static unsafe void GenQueriesARB(QueryHandle[] ids)
            {
                int n = (int)(ids.Length);
                fixed (QueryHandle* ids_ptr = ids)
                {
                    GenQueriesARB(n, ids_ptr);
                }
            }
            public static unsafe void GenQueriesARB(int n, ref QueryHandle ids)
            {
                fixed (QueryHandle* ids_ptr = &ids)
                {
                    GenQueriesARB(n, ids_ptr);
                }
            }
            public static unsafe void DeleteQueriesARB(ReadOnlySpan<QueryHandle> ids)
            {
                int n = (int)(ids.Length);
                fixed (QueryHandle* ids_ptr = ids)
                {
                    DeleteQueriesARB(n, ids_ptr);
                }
            }
            public static unsafe void DeleteQueriesARB(QueryHandle[] ids)
            {
                int n = (int)(ids.Length);
                fixed (QueryHandle* ids_ptr = ids)
                {
                    DeleteQueriesARB(n, ids_ptr);
                }
            }
            public static unsafe void DeleteQueriesARB(int n, in QueryHandle ids)
            {
                fixed (QueryHandle* ids_ptr = &ids)
                {
                    DeleteQueriesARB(n, ids_ptr);
                }
            }
            public static unsafe void GetQueryivARB(QueryTarget target, QueryParameterName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetQueryivARB(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryivARB(QueryTarget target, QueryParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetQueryivARB(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryivARB(QueryTarget target, QueryParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetQueryivARB(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjectivARB(QueryHandle id, QueryObjectParameterName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetQueryObjectivARB(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjectivARB(QueryHandle id, QueryObjectParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetQueryObjectivARB(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjectivARB(QueryHandle id, QueryObjectParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetQueryObjectivARB(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjectuivARB(QueryHandle id, QueryObjectParameterName pname, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetQueryObjectuivARB(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjectuivARB(QueryHandle id, QueryObjectParameterName pname, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetQueryObjectuivARB(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjectuivARB(QueryHandle id, QueryObjectParameterName pname, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetQueryObjectuivARB(id, pname, parameters_ptr);
                }
            }
            public static unsafe void PointParameterfvARB(PointParameterNameARB pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    PointParameterfvARB(pname, parameters_ptr);
                }
            }
            public static unsafe void PointParameterfvARB(PointParameterNameARB pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    PointParameterfvARB(pname, parameters_ptr);
                }
            }
            public static unsafe void PointParameterfvARB(PointParameterNameARB pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    PointParameterfvARB(pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramInterfacei(ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramInterfacei(ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramInterfacei(ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetProgramInterfaceiv(program, programInterface, pname, parameters_ptr);
                }
            }
            public static unsafe uint GetProgramResourceIndex(ProgramHandle program, ProgramInterface programInterface, string name)
            {
                uint returnValue;
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                returnValue = GetProgramResourceIndex(program, programInterface, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                return returnValue;
            }
            public static unsafe string GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, Span<int> length)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return name;
            }
            public static unsafe void GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, Span<int> length, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe string GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int[] length)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return name;
            }
            public static unsafe void GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int[] length, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe string GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, ref int length)
            {
                string name;
                fixed (int* length_ptr = &length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return name;
            }
            public static unsafe void GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, ref int length, out string name)
            {
                fixed (int* length_ptr = &length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramResourceName(program, programInterface, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe void GetProgramResourcei(ProgramHandle program, ProgramInterface programInterface, uint index, ReadOnlySpan<ProgramResourceProperty> props, Span<int> length, Span<int> parameters)
            {
                int propCount = (int)(props.Length);
                fixed (ProgramResourceProperty* props_ptr = props)
                {
                    fixed (int* length_ptr = length)
                    {
                        int count = (int)(parameters.Length);
                        fixed (int* parameters_ptr = parameters)
                        {
                            GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                        }
                    }
                }
            }
            public static unsafe void GetProgramResourcei(ProgramHandle program, ProgramInterface programInterface, uint index, ProgramResourceProperty[] props, int[] length, int[] parameters)
            {
                int propCount = (int)(props.Length);
                fixed (ProgramResourceProperty* props_ptr = props)
                {
                    fixed (int* length_ptr = length)
                    {
                        int count = (int)(parameters.Length);
                        fixed (int* parameters_ptr = parameters)
                        {
                            GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                        }
                    }
                }
            }
            public static unsafe void GetProgramResourcei(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, in ProgramResourceProperty props, int count, ref int length, ref int parameters)
            {
                fixed (ProgramResourceProperty* props_ptr = &props)
                fixed (int* length_ptr = &length)
                fixed (int* parameters_ptr = &parameters)
                {
                    GetProgramResourceiv(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                }
            }
            public static unsafe int GetProgramResourceLocation(ProgramHandle program, ProgramInterface programInterface, string name)
            {
                int returnValue;
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                returnValue = GetProgramResourceLocation(program, programInterface, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                return returnValue;
            }
            public static unsafe int GetProgramResourceLocationIndex(ProgramHandle program, ProgramInterface programInterface, string name)
            {
                int returnValue;
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                returnValue = GetProgramResourceLocationIndex(program, programInterface, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                return returnValue;
            }
            public static unsafe void GetnTexImageARB(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, IntPtr img)
            {
                void* img_vptr = (void*)img;
                GetnTexImageARB(target, level, format, type, bufSize, img_vptr);
            }
            public static unsafe void GetnTexImageARB<T1>(TextureTarget target, int level, PixelFormat format, PixelType type, Span<T1> img)
                where T1 : unmanaged
            {
                int bufSize = (int)(img.Length * sizeof(T1));
                fixed (void* img_ptr = img)
                {
                    GetnTexImageARB(target, level, format, type, bufSize, img_ptr);
                }
            }
            public static unsafe void GetnTexImageARB<T1>(TextureTarget target, int level, PixelFormat format, PixelType type, T1[] img)
                where T1 : unmanaged
            {
                int bufSize = (int)(img.Length * sizeof(T1));
                fixed (void* img_ptr = img)
                {
                    GetnTexImageARB(target, level, format, type, bufSize, img_ptr);
                }
            }
            public static unsafe void GetnTexImageARB<T1>(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, ref T1 img)
                where T1 : unmanaged
            {
                fixed (void* img_ptr = &img)
                {
                    GetnTexImageARB(target, level, format, type, bufSize, img_ptr);
                }
            }
            public static unsafe void ReadnPixelsARB(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, IntPtr data)
            {
                void* data_vptr = (void*)data;
                ReadnPixelsARB(x, y, width, height, format, type, bufSize, data_vptr);
            }
            public static unsafe void ReadnPixelsARB<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, Span<T1> data)
                where T1 : unmanaged
            {
                int bufSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    ReadnPixelsARB(x, y, width, height, format, type, bufSize, data_ptr);
                }
            }
            public static unsafe void ReadnPixelsARB<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, T1[] data)
                where T1 : unmanaged
            {
                int bufSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    ReadnPixelsARB(x, y, width, height, format, type, bufSize, data_ptr);
                }
            }
            public static unsafe void ReadnPixelsARB<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, ref T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    ReadnPixelsARB(x, y, width, height, format, type, bufSize, data_ptr);
                }
            }
            public static unsafe void GetnCompressedTexImageARB(TextureTarget target, int lod, int bufSize, IntPtr img)
            {
                void* img_vptr = (void*)img;
                GetnCompressedTexImageARB(target, lod, bufSize, img_vptr);
            }
            public static unsafe void GetnCompressedTexImageARB<T1>(TextureTarget target, int lod, Span<T1> img)
                where T1 : unmanaged
            {
                int bufSize = (int)(img.Length * sizeof(T1));
                fixed (void* img_ptr = img)
                {
                    GetnCompressedTexImageARB(target, lod, bufSize, img_ptr);
                }
            }
            public static unsafe void GetnCompressedTexImageARB<T1>(TextureTarget target, int lod, T1[] img)
                where T1 : unmanaged
            {
                int bufSize = (int)(img.Length * sizeof(T1));
                fixed (void* img_ptr = img)
                {
                    GetnCompressedTexImageARB(target, lod, bufSize, img_ptr);
                }
            }
            public static unsafe void GetnCompressedTexImageARB<T1>(TextureTarget target, int lod, int bufSize, ref T1 img)
                where T1 : unmanaged
            {
                fixed (void* img_ptr = &img)
                {
                    GetnCompressedTexImageARB(target, lod, bufSize, img_ptr);
                }
            }
            public static unsafe void GetnUniformfvARB(ProgramHandle program, int location, Span<float> parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (float* parameters_ptr = parameters)
                {
                    GetnUniformfvARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformfvARB(ProgramHandle program, int location, float[] parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (float* parameters_ptr = parameters)
                {
                    GetnUniformfvARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformfvARB(ProgramHandle program, int location, int bufSize, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetnUniformfvARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformivARB(ProgramHandle program, int location, Span<int> parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (int* parameters_ptr = parameters)
                {
                    GetnUniformivARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformivARB(ProgramHandle program, int location, int[] parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (int* parameters_ptr = parameters)
                {
                    GetnUniformivARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformivARB(ProgramHandle program, int location, int bufSize, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetnUniformivARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformuivARB(ProgramHandle program, int location, Span<uint> parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (uint* parameters_ptr = parameters)
                {
                    GetnUniformuivARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformuivARB(ProgramHandle program, int location, uint[] parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (uint* parameters_ptr = parameters)
                {
                    GetnUniformuivARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformuivARB(ProgramHandle program, int location, int bufSize, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetnUniformuivARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformdvARB(ProgramHandle program, int location, Span<double> parameters)
            {
                int bufSize = (int)(parameters.Length * 8);
                fixed (double* parameters_ptr = parameters)
                {
                    GetnUniformdvARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformdvARB(ProgramHandle program, int location, double[] parameters)
            {
                int bufSize = (int)(parameters.Length * 8);
                fixed (double* parameters_ptr = parameters)
                {
                    GetnUniformdvARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformdvARB(ProgramHandle program, int location, int bufSize, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    GetnUniformdvARB(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void FramebufferSampleLocationsfvARB(FramebufferTarget target, uint start, int count, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    FramebufferSampleLocationsfvARB(target, start, count, v_ptr);
                }
            }
            public static unsafe void NamedFramebufferSampleLocationsfvARB(FramebufferHandle framebuffer, uint start, int count, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    NamedFramebufferSampleLocationsfvARB(framebuffer, start, count, v_ptr);
                }
            }
            public static unsafe SamplerHandle GenSampler()
            {
                SamplerHandle samplers;
                int count = 1;
                Unsafe.SkipInit(out samplers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
                GenSamplers(count, samplers_handle);
                return samplers;
            }
            public static unsafe void GenSampler(out SamplerHandle samplers)
            {
                int count = 1;
                Unsafe.SkipInit(out samplers);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                SamplerHandle* samplers_handle = (SamplerHandle*)Unsafe.AsPointer(ref samplers);
                GenSamplers(count, samplers_handle);
            }
            public static unsafe void GenSamplers(Span<SamplerHandle> samplers)
            {
                int count = (int)(samplers.Length);
                fixed (SamplerHandle* samplers_ptr = samplers)
                {
                    GenSamplers(count, samplers_ptr);
                }
            }
            public static unsafe void GenSamplers(SamplerHandle[] samplers)
            {
                int count = (int)(samplers.Length);
                fixed (SamplerHandle* samplers_ptr = samplers)
                {
                    GenSamplers(count, samplers_ptr);
                }
            }
            public static unsafe void GenSamplers(int count, ref SamplerHandle samplers)
            {
                fixed (SamplerHandle* samplers_ptr = &samplers)
                {
                    GenSamplers(count, samplers_ptr);
                }
            }
            public static unsafe void DeleteSampler(in SamplerHandle samplers)
            {
                int count = 1;
                fixed(SamplerHandle* samplers_handle = &samplers)
                {
                    DeleteSamplers(count, samplers_handle);
                }
            }
            public static unsafe void DeleteSamplers(ReadOnlySpan<SamplerHandle> samplers)
            {
                int count = (int)(samplers.Length);
                fixed (SamplerHandle* samplers_ptr = samplers)
                {
                    DeleteSamplers(count, samplers_ptr);
                }
            }
            public static unsafe void DeleteSamplers(SamplerHandle[] samplers)
            {
                int count = (int)(samplers.Length);
                fixed (SamplerHandle* samplers_ptr = samplers)
                {
                    DeleteSamplers(count, samplers_ptr);
                }
            }
            public static unsafe void DeleteSamplers(int count, in SamplerHandle samplers)
            {
                fixed (SamplerHandle* samplers_ptr = &samplers)
                {
                    DeleteSamplers(count, samplers_ptr);
                }
            }
            public static unsafe void SamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<int> param)
            {
                fixed (int* param_ptr = param)
                {
                    SamplerParameteriv(sampler, pname, param_ptr);
                }
            }
            public static unsafe void SamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, int[] param)
            {
                fixed (int* param_ptr = param)
                {
                    SamplerParameteriv(sampler, pname, param_ptr);
                }
            }
            public static unsafe void SamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, in int param)
            {
                fixed (int* param_ptr = &param)
                {
                    SamplerParameteriv(sampler, pname, param_ptr);
                }
            }
            public static unsafe void SamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, ReadOnlySpan<float> param)
            {
                fixed (float* param_ptr = param)
                {
                    SamplerParameterfv(sampler, pname, param_ptr);
                }
            }
            public static unsafe void SamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, float[] param)
            {
                fixed (float* param_ptr = param)
                {
                    SamplerParameterfv(sampler, pname, param_ptr);
                }
            }
            public static unsafe void SamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, in float param)
            {
                fixed (float* param_ptr = &param)
                {
                    SamplerParameterfv(sampler, pname, param_ptr);
                }
            }
            public static unsafe void SamplerParameterIi(SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<int> param)
            {
                fixed (int* param_ptr = param)
                {
                    SamplerParameterIiv(sampler, pname, param_ptr);
                }
            }
            public static unsafe void SamplerParameterIi(SamplerHandle sampler, SamplerParameterI pname, int[] param)
            {
                fixed (int* param_ptr = param)
                {
                    SamplerParameterIiv(sampler, pname, param_ptr);
                }
            }
            public static unsafe void SamplerParameterIi(SamplerHandle sampler, SamplerParameterI pname, in int param)
            {
                fixed (int* param_ptr = &param)
                {
                    SamplerParameterIiv(sampler, pname, param_ptr);
                }
            }
            public static unsafe void SamplerParameterIui(SamplerHandle sampler, SamplerParameterI pname, ReadOnlySpan<uint> param)
            {
                fixed (uint* param_ptr = param)
                {
                    SamplerParameterIuiv(sampler, pname, param_ptr);
                }
            }
            public static unsafe void SamplerParameterIui(SamplerHandle sampler, SamplerParameterI pname, uint[] param)
            {
                fixed (uint* param_ptr = param)
                {
                    SamplerParameterIuiv(sampler, pname, param_ptr);
                }
            }
            public static unsafe void SamplerParameterIui(SamplerHandle sampler, SamplerParameterI pname, in uint param)
            {
                fixed (uint* param_ptr = &param)
                {
                    SamplerParameterIuiv(sampler, pname, param_ptr);
                }
            }
            public static unsafe void GetSamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetSamplerParameteriv(sampler, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetSamplerParameteriv(sampler, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetSamplerParameteriv(sampler, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSamplerParameterIi(SamplerHandle sampler, SamplerParameterI pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetSamplerParameterIiv(sampler, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSamplerParameterIi(SamplerHandle sampler, SamplerParameterI pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetSamplerParameterIiv(sampler, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSamplerParameterIi(SamplerHandle sampler, SamplerParameterI pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetSamplerParameterIiv(sampler, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetSamplerParameterfv(sampler, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetSamplerParameterfv(sampler, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetSamplerParameterfv(sampler, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSamplerParameterIui(SamplerHandle sampler, SamplerParameterI pname, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSamplerParameterIui(SamplerHandle sampler, SamplerParameterI pname, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSamplerParameterIui(SamplerHandle sampler, SamplerParameterI pname, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetSamplerParameterIuiv(sampler, pname, parameters_ptr);
                }
            }
            public static unsafe ProgramHandle CreateShaderProgram(ShaderType type, int count, byte** strings)
            {
                ProgramHandle returnValue;
                returnValue = CreateShaderProgramv(type, count, strings);
                return returnValue;
            }
            public static unsafe void DeleteProgramPipeline(in ProgramPipelineHandle pipelines)
            {
                int n = 1;
                fixed(ProgramPipelineHandle* pipelines_handle = &pipelines)
                {
                    DeleteProgramPipelines(n, pipelines_handle);
                }
            }
            public static unsafe void DeleteProgramPipelines(ReadOnlySpan<ProgramPipelineHandle> pipelines)
            {
                int n = (int)(pipelines.Length);
                fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
                {
                    DeleteProgramPipelines(n, pipelines_ptr);
                }
            }
            public static unsafe void DeleteProgramPipelines(ProgramPipelineHandle[] pipelines)
            {
                int n = (int)(pipelines.Length);
                fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
                {
                    DeleteProgramPipelines(n, pipelines_ptr);
                }
            }
            public static unsafe void DeleteProgramPipelines(int n, in ProgramPipelineHandle pipelines)
            {
                fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines)
                {
                    DeleteProgramPipelines(n, pipelines_ptr);
                }
            }
            public static unsafe ProgramPipelineHandle GenProgramPipeline()
            {
                ProgramPipelineHandle pipelines;
                int n = 1;
                Unsafe.SkipInit(out pipelines);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
                GenProgramPipelines(n, pipelines_handle);
                return pipelines;
            }
            public static unsafe void GenProgramPipeline(out ProgramPipelineHandle pipelines)
            {
                int n = 1;
                Unsafe.SkipInit(out pipelines);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                ProgramPipelineHandle* pipelines_handle = (ProgramPipelineHandle*)Unsafe.AsPointer(ref pipelines);
                GenProgramPipelines(n, pipelines_handle);
            }
            public static unsafe void GenProgramPipelines(Span<ProgramPipelineHandle> pipelines)
            {
                int n = (int)(pipelines.Length);
                fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
                {
                    GenProgramPipelines(n, pipelines_ptr);
                }
            }
            public static unsafe void GenProgramPipelines(ProgramPipelineHandle[] pipelines)
            {
                int n = (int)(pipelines.Length);
                fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
                {
                    GenProgramPipelines(n, pipelines_ptr);
                }
            }
            public static unsafe void GenProgramPipelines(int n, ref ProgramPipelineHandle pipelines)
            {
                fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines)
                {
                    GenProgramPipelines(n, pipelines_ptr);
                }
            }
            public static unsafe void GetProgramPipelinei(ProgramPipelineHandle pipeline, PipelineParameterName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetProgramPipelineiv(pipeline, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramPipelinei(ProgramPipelineHandle pipeline, PipelineParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetProgramPipelineiv(pipeline, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramPipelinei(ProgramPipelineHandle pipeline, PipelineParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetProgramPipelineiv(pipeline, pname, parameters_ptr);
                }
            }
            public static unsafe void ProgramUniform1iv(ProgramHandle program, int location, ReadOnlySpan<int> value)
            {
                int count = (int)(value.Length);
                fixed (int* value_ptr = value)
                {
                    ProgramUniform1iv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1iv(ProgramHandle program, int location, int[] value)
            {
                int count = (int)(value.Length);
                fixed (int* value_ptr = value)
                {
                    ProgramUniform1iv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1iv(ProgramHandle program, int location, int count, in int value)
            {
                fixed (int* value_ptr = &value)
                {
                    ProgramUniform1iv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1fv(ProgramHandle program, int location, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length);
                fixed (float* value_ptr = value)
                {
                    ProgramUniform1fv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1fv(ProgramHandle program, int location, float[] value)
            {
                int count = (int)(value.Length);
                fixed (float* value_ptr = value)
                {
                    ProgramUniform1fv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1fv(ProgramHandle program, int location, int count, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    ProgramUniform1fv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1dv(ProgramHandle program, int location, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length);
                fixed (double* value_ptr = value)
                {
                    ProgramUniform1dv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1dv(ProgramHandle program, int location, double[] value)
            {
                int count = (int)(value.Length);
                fixed (double* value_ptr = value)
                {
                    ProgramUniform1dv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1dv(ProgramHandle program, int location, int count, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    ProgramUniform1dv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ui(ProgramHandle program, int location, ReadOnlySpan<uint> value)
            {
                int count = (int)(value.Length);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform1uiv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ui(ProgramHandle program, int location, uint[] value)
            {
                int count = (int)(value.Length);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform1uiv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ui(ProgramHandle program, int location, int count, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    ProgramUniform1uiv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2i(ProgramHandle program, int location, in Vector2i value)
            {
                int count = 1;
                fixed (Vector2i* tmp_vecPtr = &value)
                {
                    int* value_ptr = (int*)tmp_vecPtr;
                    ProgramUniform2iv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2i(ProgramHandle program, int location, int count, ReadOnlySpan<Vector2i> value)
            {
                fixed (Vector2i* tmp_vecPtr = value)
                {
                    int* value_ptr = (int*)tmp_vecPtr;
                    ProgramUniform2iv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2i(ProgramHandle program, int location, int count, Vector2i[] value)
            {
                fixed (Vector2i* tmp_vecPtr = value)
                {
                    int* value_ptr = (int*)tmp_vecPtr;
                    ProgramUniform2iv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2f(ProgramHandle program, int location, in Vector2 value)
            {
                int count = 1;
                fixed (Vector2* tmp_vecPtr = &value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    ProgramUniform2fv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2f(ProgramHandle program, int location, int count, ReadOnlySpan<Vector2> value)
            {
                fixed (Vector2* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    ProgramUniform2fv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2f(ProgramHandle program, int location, int count, Vector2[] value)
            {
                fixed (Vector2* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    ProgramUniform2fv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2d(ProgramHandle program, int location, in Vector2d value)
            {
                int count = 1;
                fixed (Vector2d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    ProgramUniform2dv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2d(ProgramHandle program, int location, int count, ReadOnlySpan<Vector2d> value)
            {
                fixed (Vector2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    ProgramUniform2dv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2d(ProgramHandle program, int location, int count, Vector2d[] value)
            {
                fixed (Vector2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    ProgramUniform2dv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ui(ProgramHandle program, int location, ReadOnlySpan<uint> value)
            {
                int count = (int)(value.Length / 2);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform2uiv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ui(ProgramHandle program, int location, uint[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform2uiv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ui(ProgramHandle program, int location, int count, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    ProgramUniform2uiv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3i(ProgramHandle program, int location, in Vector3i value)
            {
                int count = 1;
                fixed (Vector3i* tmp_vecPtr = &value)
                {
                    int* value_ptr = (int*)tmp_vecPtr;
                    ProgramUniform3iv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3i(ProgramHandle program, int location, int count, ReadOnlySpan<Vector3i> value)
            {
                fixed (Vector3i* tmp_vecPtr = value)
                {
                    int* value_ptr = (int*)tmp_vecPtr;
                    ProgramUniform3iv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3i(ProgramHandle program, int location, int count, Vector3i[] value)
            {
                fixed (Vector3i* tmp_vecPtr = value)
                {
                    int* value_ptr = (int*)tmp_vecPtr;
                    ProgramUniform3iv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3f(ProgramHandle program, int location, in Vector3 value)
            {
                int count = 1;
                fixed (Vector3* tmp_vecPtr = &value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    ProgramUniform3fv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3f(ProgramHandle program, int location, int count, ReadOnlySpan<Vector3> value)
            {
                fixed (Vector3* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    ProgramUniform3fv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3f(ProgramHandle program, int location, int count, Vector3[] value)
            {
                fixed (Vector3* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    ProgramUniform3fv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3d(ProgramHandle program, int location, in Vector3d value)
            {
                int count = 1;
                fixed (Vector3d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    ProgramUniform3dv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3d(ProgramHandle program, int location, int count, ReadOnlySpan<Vector3d> value)
            {
                fixed (Vector3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    ProgramUniform3dv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3d(ProgramHandle program, int location, int count, Vector3d[] value)
            {
                fixed (Vector3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    ProgramUniform3dv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ui(ProgramHandle program, int location, ReadOnlySpan<uint> value)
            {
                int count = (int)(value.Length / 3);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform3uiv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ui(ProgramHandle program, int location, uint[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform3uiv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ui(ProgramHandle program, int location, int count, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    ProgramUniform3uiv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4i(ProgramHandle program, int location, in Vector4i value)
            {
                int count = 1;
                fixed (Vector4i* tmp_vecPtr = &value)
                {
                    int* value_ptr = (int*)tmp_vecPtr;
                    ProgramUniform4iv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4i(ProgramHandle program, int location, int count, ReadOnlySpan<Vector4i> value)
            {
                fixed (Vector4i* tmp_vecPtr = value)
                {
                    int* value_ptr = (int*)tmp_vecPtr;
                    ProgramUniform4iv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4i(ProgramHandle program, int location, int count, Vector4i[] value)
            {
                fixed (Vector4i* tmp_vecPtr = value)
                {
                    int* value_ptr = (int*)tmp_vecPtr;
                    ProgramUniform4iv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4f(ProgramHandle program, int location, in Vector4 value)
            {
                int count = 1;
                fixed (Vector4* tmp_vecPtr = &value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    ProgramUniform4fv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4f(ProgramHandle program, int location, int count, ReadOnlySpan<Vector4> value)
            {
                fixed (Vector4* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    ProgramUniform4fv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4f(ProgramHandle program, int location, int count, Vector4[] value)
            {
                fixed (Vector4* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    ProgramUniform4fv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4d(ProgramHandle program, int location, in Vector4d value)
            {
                int count = 1;
                fixed (Vector4d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    ProgramUniform4dv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4d(ProgramHandle program, int location, int count, ReadOnlySpan<Vector4d> value)
            {
                fixed (Vector4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    ProgramUniform4dv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4d(ProgramHandle program, int location, int count, Vector4d[] value)
            {
                fixed (Vector4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    ProgramUniform4dv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ui(ProgramHandle program, int location, ReadOnlySpan<uint> value)
            {
                int count = (int)(value.Length / 4);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform4uiv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ui(ProgramHandle program, int location, uint[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform4uiv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ui(ProgramHandle program, int location, int count, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    ProgramUniform4uiv(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2f(ProgramHandle program, int location, bool transpose, in Matrix2 value)
            {
                int count = 1;
                fixed (Matrix2* tmp_vecPtr = &value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix2> value)
            {
                fixed (Matrix2* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2f(ProgramHandle program, int location, int count, bool transpose, Matrix2[] value)
            {
                fixed (Matrix2* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3f(ProgramHandle program, int location, bool transpose, in Matrix3 value)
            {
                int count = 1;
                fixed (Matrix3* tmp_vecPtr = &value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix3> value)
            {
                fixed (Matrix3* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3f(ProgramHandle program, int location, int count, bool transpose, Matrix3[] value)
            {
                fixed (Matrix3* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4f(ProgramHandle program, int location, bool transpose, in Matrix4 value)
            {
                int count = 1;
                fixed (Matrix4* tmp_vecPtr = &value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix4> value)
            {
                fixed (Matrix4* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4f(ProgramHandle program, int location, int count, bool transpose, Matrix4[] value)
            {
                fixed (Matrix4* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2d(ProgramHandle program, int location, bool transpose, in Matrix2d value)
            {
                int count = 1;
                fixed (Matrix2d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix2d> value)
            {
                fixed (Matrix2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2d(ProgramHandle program, int location, int count, bool transpose, Matrix2d[] value)
            {
                fixed (Matrix2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3d(ProgramHandle program, int location, bool transpose, in Matrix3d value)
            {
                int count = 1;
                fixed (Matrix3d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix3d> value)
            {
                fixed (Matrix3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3d(ProgramHandle program, int location, int count, bool transpose, Matrix3d[] value)
            {
                fixed (Matrix3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4d(ProgramHandle program, int location, bool transpose, in Matrix4d value)
            {
                int count = 1;
                fixed (Matrix4d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix4d> value)
            {
                fixed (Matrix4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4d(ProgramHandle program, int location, int count, bool transpose, Matrix4d[] value)
            {
                fixed (Matrix4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x3f(ProgramHandle program, int location, bool transpose, in Matrix2x3 value)
            {
                int count = 1;
                fixed (Matrix2x3* tmp_vecPtr = &value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x3f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix2x3> value)
            {
                fixed (Matrix2x3* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x3f(ProgramHandle program, int location, int count, bool transpose, Matrix2x3[] value)
            {
                fixed (Matrix2x3* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x3fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x2f(ProgramHandle program, int location, bool transpose, in Matrix3x2 value)
            {
                int count = 1;
                fixed (Matrix3x2* tmp_vecPtr = &value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x2f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix3x2> value)
            {
                fixed (Matrix3x2* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x2f(ProgramHandle program, int location, int count, bool transpose, Matrix3x2[] value)
            {
                fixed (Matrix3x2* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x2fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x4f(ProgramHandle program, int location, bool transpose, in Matrix2x4 value)
            {
                int count = 1;
                fixed (Matrix2x4* tmp_vecPtr = &value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x4f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix2x4> value)
            {
                fixed (Matrix2x4* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x4f(ProgramHandle program, int location, int count, bool transpose, Matrix2x4[] value)
            {
                fixed (Matrix2x4* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x4fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x2f(ProgramHandle program, int location, bool transpose, in Matrix4x2 value)
            {
                int count = 1;
                fixed (Matrix4x2* tmp_vecPtr = &value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x2f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix4x2> value)
            {
                fixed (Matrix4x2* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x2f(ProgramHandle program, int location, int count, bool transpose, Matrix4x2[] value)
            {
                fixed (Matrix4x2* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x2fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x4f(ProgramHandle program, int location, bool transpose, in Matrix3x4 value)
            {
                int count = 1;
                fixed (Matrix3x4* tmp_vecPtr = &value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x4f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix3x4> value)
            {
                fixed (Matrix3x4* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x4f(ProgramHandle program, int location, int count, bool transpose, Matrix3x4[] value)
            {
                fixed (Matrix3x4* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x4fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x3f(ProgramHandle program, int location, bool transpose, in Matrix4x3 value)
            {
                int count = 1;
                fixed (Matrix4x3* tmp_vecPtr = &value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x3f(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix4x3> value)
            {
                fixed (Matrix4x3* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x3f(ProgramHandle program, int location, int count, bool transpose, Matrix4x3[] value)
            {
                fixed (Matrix4x3* tmp_vecPtr = value)
                {
                    float* value_ptr = (float*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x3fv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x3d(ProgramHandle program, int location, bool transpose, in Matrix2x3d value)
            {
                int count = 1;
                fixed (Matrix2x3d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x3dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x3d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix2x3d> value)
            {
                fixed (Matrix2x3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x3dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x3d(ProgramHandle program, int location, int count, bool transpose, Matrix2x3d[] value)
            {
                fixed (Matrix2x3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x3dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x2d(ProgramHandle program, int location, bool transpose, in Matrix3x2d value)
            {
                int count = 1;
                fixed (Matrix3x2d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x2dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x2d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix3x2d> value)
            {
                fixed (Matrix3x2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x2dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x2d(ProgramHandle program, int location, int count, bool transpose, Matrix3x2d[] value)
            {
                fixed (Matrix3x2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x2dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x4d(ProgramHandle program, int location, bool transpose, in Matrix2x4d value)
            {
                int count = 1;
                fixed (Matrix2x4d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x4dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x4d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix2x4d> value)
            {
                fixed (Matrix2x4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x4dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x4d(ProgramHandle program, int location, int count, bool transpose, Matrix2x4d[] value)
            {
                fixed (Matrix2x4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x4dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x2d(ProgramHandle program, int location, bool transpose, in Matrix4x2d value)
            {
                int count = 1;
                fixed (Matrix4x2d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x2dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x2d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix4x2d> value)
            {
                fixed (Matrix4x2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x2dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x2d(ProgramHandle program, int location, int count, bool transpose, Matrix4x2d[] value)
            {
                fixed (Matrix4x2d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x2dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x4d(ProgramHandle program, int location, bool transpose, in Matrix3x4d value)
            {
                int count = 1;
                fixed (Matrix3x4d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x4dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x4d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix3x4d> value)
            {
                fixed (Matrix3x4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x4dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x4d(ProgramHandle program, int location, int count, bool transpose, Matrix3x4d[] value)
            {
                fixed (Matrix3x4d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x4dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x3d(ProgramHandle program, int location, bool transpose, in Matrix4x3d value)
            {
                int count = 1;
                fixed (Matrix4x3d* tmp_vecPtr = &value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x3dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x3d(ProgramHandle program, int location, int count, bool transpose, ReadOnlySpan<Matrix4x3d> value)
            {
                fixed (Matrix4x3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x3dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x3d(ProgramHandle program, int location, int count, bool transpose, Matrix4x3d[] value)
            {
                fixed (Matrix4x3d* tmp_vecPtr = value)
                {
                    double* value_ptr = (double*)tmp_vecPtr;
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x3dv(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe string GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, Span<int> length)
            {
                string infoLog;
                fixed (int* length_ptr = length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
                return infoLog;
            }
            public static unsafe void GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, Span<int> length, out string infoLog)
            {
                fixed (int* length_ptr = length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
            }
            public static unsafe string GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, int[] length)
            {
                string infoLog;
                fixed (int* length_ptr = length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
                return infoLog;
            }
            public static unsafe void GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, int[] length, out string infoLog)
            {
                fixed (int* length_ptr = length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
            }
            public static unsafe string GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, ref int length)
            {
                string infoLog;
                fixed (int* length_ptr = &length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
                return infoLog;
            }
            public static unsafe void GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, ref int length, out string infoLog)
            {
                fixed (int* length_ptr = &length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramPipelineInfoLog(pipeline, bufSize, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
            }
            public static unsafe void GetActiveAtomicCounterBufferi(ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, parameters_ptr);
                }
            }
            public static unsafe void GetActiveAtomicCounterBufferi(ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, parameters_ptr);
                }
            }
            public static unsafe void GetActiveAtomicCounterBufferi(ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, parameters_ptr);
                }
            }
            public static unsafe void BindImageTexture(uint unit, TextureHandle texture, int level, bool layered, int layer, BufferAccessARB access, InternalFormat format)
            {
                byte layered_byte = (byte)(layered ? 1 : 0);
                BindImageTexture(unit, texture, level, layered_byte, layer, access, format);
            }
            public static unsafe void ShaderSourceARB(GLHandleARB shaderObj, int count, byte** str, ReadOnlySpan<int> length)
            {
                fixed (int* length_ptr = length)
                {
                    ShaderSourceARB(shaderObj, count, str, length_ptr);
                }
            }
            public static unsafe void ShaderSourceARB(GLHandleARB shaderObj, int count, byte** str, int[] length)
            {
                fixed (int* length_ptr = length)
                {
                    ShaderSourceARB(shaderObj, count, str, length_ptr);
                }
            }
            public static unsafe void ShaderSourceARB(GLHandleARB shaderObj, int count, byte** str, in int length)
            {
                fixed (int* length_ptr = &length)
                {
                    ShaderSourceARB(shaderObj, count, str, length_ptr);
                }
            }
            public static unsafe void Uniform1fvARB(int location, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 1);
                fixed (float* value_ptr = value)
                {
                    Uniform1fvARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1fvARB(int location, float[] value)
            {
                int count = (int)(value.Length / 1);
                fixed (float* value_ptr = value)
                {
                    Uniform1fvARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1fvARB(int location, int count, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    Uniform1fvARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2fvARB(int location, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 2);
                fixed (float* value_ptr = value)
                {
                    Uniform2fvARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2fvARB(int location, float[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (float* value_ptr = value)
                {
                    Uniform2fvARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2fvARB(int location, int count, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    Uniform2fvARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3fvARB(int location, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 3);
                fixed (float* value_ptr = value)
                {
                    Uniform3fvARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3fvARB(int location, float[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (float* value_ptr = value)
                {
                    Uniform3fvARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3fvARB(int location, int count, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    Uniform3fvARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4fvARB(int location, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 4);
                fixed (float* value_ptr = value)
                {
                    Uniform4fvARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4fvARB(int location, float[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (float* value_ptr = value)
                {
                    Uniform4fvARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4fvARB(int location, int count, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    Uniform4fvARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1ivARB(int location, ReadOnlySpan<int> value)
            {
                int count = (int)(value.Length / 1);
                fixed (int* value_ptr = value)
                {
                    Uniform1ivARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1ivARB(int location, int[] value)
            {
                int count = (int)(value.Length / 1);
                fixed (int* value_ptr = value)
                {
                    Uniform1ivARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1ivARB(int location, int count, in int value)
            {
                fixed (int* value_ptr = &value)
                {
                    Uniform1ivARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2ivARB(int location, ReadOnlySpan<int> value)
            {
                int count = (int)(value.Length / 2);
                fixed (int* value_ptr = value)
                {
                    Uniform2ivARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2ivARB(int location, int[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (int* value_ptr = value)
                {
                    Uniform2ivARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2ivARB(int location, int count, in int value)
            {
                fixed (int* value_ptr = &value)
                {
                    Uniform2ivARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3ivARB(int location, ReadOnlySpan<int> value)
            {
                int count = (int)(value.Length / 3);
                fixed (int* value_ptr = value)
                {
                    Uniform3ivARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3ivARB(int location, int[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (int* value_ptr = value)
                {
                    Uniform3ivARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3ivARB(int location, int count, in int value)
            {
                fixed (int* value_ptr = &value)
                {
                    Uniform3ivARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4ivARB(int location, ReadOnlySpan<int> value)
            {
                int count = (int)(value.Length / 4);
                fixed (int* value_ptr = value)
                {
                    Uniform4ivARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4ivARB(int location, int[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (int* value_ptr = value)
                {
                    Uniform4ivARB(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4ivARB(int location, int count, in int value)
            {
                fixed (int* value_ptr = &value)
                {
                    Uniform4ivARB(location, count, value_ptr);
                }
            }
            public static unsafe void UniformMatrix2fvARB(int location, bool transpose, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 4);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix2fvARB(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix2fvARB(int location, bool transpose, float[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix2fvARB(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix2fvARB(int location, int count, bool transpose, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix2fvARB(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix3fvARB(int location, bool transpose, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 9);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix3fvARB(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix3fvARB(int location, bool transpose, float[] value)
            {
                int count = (int)(value.Length / 9);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix3fvARB(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix3fvARB(int location, int count, bool transpose, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix3fvARB(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix4fvARB(int location, bool transpose, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 16);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix4fvARB(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix4fvARB(int location, bool transpose, float[] value)
            {
                int count = (int)(value.Length / 16);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix4fvARB(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void UniformMatrix4fvARB(int location, int count, bool transpose, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    UniformMatrix4fvARB(location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void GetObjectParameterfvARB(GLHandleARB obj, All pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetObjectParameterfvARB(obj, pname, parameters_ptr);
                }
            }
            public static unsafe void GetObjectParameterfvARB(GLHandleARB obj, All pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetObjectParameterfvARB(obj, pname, parameters_ptr);
                }
            }
            public static unsafe void GetObjectParameterfvARB(GLHandleARB obj, All pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetObjectParameterfvARB(obj, pname, parameters_ptr);
                }
            }
            public static unsafe void GetObjectParameterivARB(GLHandleARB obj, All pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetObjectParameterivARB(obj, pname, parameters_ptr);
                }
            }
            public static unsafe void GetObjectParameterivARB(GLHandleARB obj, All pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetObjectParameterivARB(obj, pname, parameters_ptr);
                }
            }
            public static unsafe void GetObjectParameterivARB(GLHandleARB obj, All pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetObjectParameterivARB(obj, pname, parameters_ptr);
                }
            }
            public static unsafe string GetInfoLogARB(GLHandleARB obj, int maxLength, Span<int> length)
            {
                string infoLog;
                fixed (int* length_ptr = length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetInfoLogARB(obj, maxLength, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
                return infoLog;
            }
            public static unsafe void GetInfoLogARB(GLHandleARB obj, int maxLength, Span<int> length, out string infoLog)
            {
                fixed (int* length_ptr = length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetInfoLogARB(obj, maxLength, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
            }
            public static unsafe string GetInfoLogARB(GLHandleARB obj, int maxLength, int[] length)
            {
                string infoLog;
                fixed (int* length_ptr = length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetInfoLogARB(obj, maxLength, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
                return infoLog;
            }
            public static unsafe void GetInfoLogARB(GLHandleARB obj, int maxLength, int[] length, out string infoLog)
            {
                fixed (int* length_ptr = length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetInfoLogARB(obj, maxLength, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
            }
            public static unsafe string GetInfoLogARB(GLHandleARB obj, int maxLength, ref int length)
            {
                string infoLog;
                fixed (int* length_ptr = &length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetInfoLogARB(obj, maxLength, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
                return infoLog;
            }
            public static unsafe void GetInfoLogARB(GLHandleARB obj, int maxLength, ref int length, out string infoLog)
            {
                fixed (int* length_ptr = &length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetInfoLogARB(obj, maxLength, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
            }
            public static unsafe void GetAttachedObjectsARB(GLHandleARB containerObj, Span<int> count, Span<GLHandleARB> obj)
            {
                fixed (int* count_ptr = count)
                {
                    int maxCount = (int)(obj.Length);
                    fixed (GLHandleARB* obj_ptr = obj)
                    {
                        GetAttachedObjectsARB(containerObj, maxCount, count_ptr, obj_ptr);
                    }
                }
            }
            public static unsafe void GetAttachedObjectsARB(GLHandleARB containerObj, int[] count, GLHandleARB[] obj)
            {
                fixed (int* count_ptr = count)
                {
                    int maxCount = (int)(obj.Length);
                    fixed (GLHandleARB* obj_ptr = obj)
                    {
                        GetAttachedObjectsARB(containerObj, maxCount, count_ptr, obj_ptr);
                    }
                }
            }
            public static unsafe void GetAttachedObjectsARB(GLHandleARB containerObj, int maxCount, ref int count, ref GLHandleARB obj)
            {
                fixed (int* count_ptr = &count)
                fixed (GLHandleARB* obj_ptr = &obj)
                {
                    GetAttachedObjectsARB(containerObj, maxCount, count_ptr, obj_ptr);
                }
            }
            public static unsafe int GetUniformLocationARB(GLHandleARB programObj, string name)
            {
                int returnValue;
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                returnValue = GetUniformLocationARB(programObj, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                return returnValue;
            }
            public static unsafe string GetActiveUniformARB(GLHandleARB programObj, uint index, int maxLength, Span<int> length, Span<int> size, Span<UniformType> type)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (UniformType* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                            GetActiveUniformARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
                return name;
            }
            public static unsafe void GetActiveUniformARB(GLHandleARB programObj, uint index, int maxLength, Span<int> length, Span<int> size, Span<UniformType> type, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (UniformType* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                            GetActiveUniformARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
            }
            public static unsafe string GetActiveUniformARB(GLHandleARB programObj, uint index, int maxLength, int[] length, int[] size, UniformType[] type)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (UniformType* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                            GetActiveUniformARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
                return name;
            }
            public static unsafe void GetActiveUniformARB(GLHandleARB programObj, uint index, int maxLength, int[] length, int[] size, UniformType[] type, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (UniformType* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                            GetActiveUniformARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
            }
            public static unsafe string GetActiveUniformARB(GLHandleARB programObj, uint index, int maxLength, ref int length, ref int size, ref UniformType type)
            {
                string name;
                fixed (int* length_ptr = &length)
                fixed (int* size_ptr = &size)
                fixed (UniformType* type_ptr = &type)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetActiveUniformARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return name;
            }
            public static unsafe void GetActiveUniformARB(GLHandleARB programObj, uint index, int maxLength, ref int length, ref int size, ref UniformType type, out string name)
            {
                fixed (int* length_ptr = &length)
                fixed (int* size_ptr = &size)
                fixed (UniformType* type_ptr = &type)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetActiveUniformARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe void GetUniformfvARB(GLHandleARB programObj, int location, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetUniformfvARB(programObj, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformfvARB(GLHandleARB programObj, int location, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetUniformfvARB(programObj, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformfvARB(GLHandleARB programObj, int location, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetUniformfvARB(programObj, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformivARB(GLHandleARB programObj, int location, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetUniformivARB(programObj, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformivARB(GLHandleARB programObj, int location, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetUniformivARB(programObj, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformivARB(GLHandleARB programObj, int location, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetUniformivARB(programObj, location, parameters_ptr);
                }
            }
            public static unsafe string GetShaderSourceARB(GLHandleARB obj, int maxLength, Span<int> length)
            {
                string source;
                fixed (int* length_ptr = length)
                {
                    var source_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetShaderSourceARB(obj, maxLength, length_ptr, source_ptr);
                    source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)source_ptr);
                }
                return source;
            }
            public static unsafe void GetShaderSourceARB(GLHandleARB obj, int maxLength, Span<int> length, out string source)
            {
                fixed (int* length_ptr = length)
                {
                    var source_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetShaderSourceARB(obj, maxLength, length_ptr, source_ptr);
                    source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)source_ptr);
                }
            }
            public static unsafe string GetShaderSourceARB(GLHandleARB obj, int maxLength, int[] length)
            {
                string source;
                fixed (int* length_ptr = length)
                {
                    var source_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetShaderSourceARB(obj, maxLength, length_ptr, source_ptr);
                    source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)source_ptr);
                }
                return source;
            }
            public static unsafe void GetShaderSourceARB(GLHandleARB obj, int maxLength, int[] length, out string source)
            {
                fixed (int* length_ptr = length)
                {
                    var source_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetShaderSourceARB(obj, maxLength, length_ptr, source_ptr);
                    source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)source_ptr);
                }
            }
            public static unsafe string GetShaderSourceARB(GLHandleARB obj, int maxLength, ref int length)
            {
                string source;
                fixed (int* length_ptr = &length)
                {
                    var source_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetShaderSourceARB(obj, maxLength, length_ptr, source_ptr);
                    source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)source_ptr);
                }
                return source;
            }
            public static unsafe void GetShaderSourceARB(GLHandleARB obj, int maxLength, ref int length, out string source)
            {
                fixed (int* length_ptr = &length)
                {
                    var source_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetShaderSourceARB(obj, maxLength, length_ptr, source_ptr);
                    source = Marshal.PtrToStringUTF8((IntPtr)source_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)source_ptr);
                }
            }
            public static unsafe int GetSubroutineUniformLocation(ProgramHandle program, ShaderType shadertype, string name)
            {
                int returnValue;
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                returnValue = GetSubroutineUniformLocation(program, shadertype, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                return returnValue;
            }
            public static unsafe uint GetSubroutineIndex(ProgramHandle program, ShaderType shadertype, string name)
            {
                uint returnValue;
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                returnValue = GetSubroutineIndex(program, shadertype, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                return returnValue;
            }
            public static unsafe void GetActiveSubroutineUniformi(ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, Span<int> values)
            {
                fixed (int* values_ptr = values)
                {
                    GetActiveSubroutineUniformiv(program, shadertype, index, pname, values_ptr);
                }
            }
            public static unsafe void GetActiveSubroutineUniformi(ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, int[] values)
            {
                fixed (int* values_ptr = values)
                {
                    GetActiveSubroutineUniformiv(program, shadertype, index, pname, values_ptr);
                }
            }
            public static unsafe void GetActiveSubroutineUniformi(ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, ref int values)
            {
                fixed (int* values_ptr = &values)
                {
                    GetActiveSubroutineUniformiv(program, shadertype, index, pname, values_ptr);
                }
            }
            public static unsafe string GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return name;
            }
            public static unsafe void GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe string GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return name;
            }
            public static unsafe void GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe string GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length)
            {
                string name;
                fixed (int* length_ptr = &length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return name;
            }
            public static unsafe void GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length, out string name)
            {
                fixed (int* length_ptr = &length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveSubroutineUniformName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe string GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return name;
            }
            public static unsafe void GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, Span<int> length, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe string GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return name;
            }
            public static unsafe void GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int[] length, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe string GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length)
            {
                string name;
                fixed (int* length_ptr = &length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return name;
            }
            public static unsafe void GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, ref int length, out string name)
            {
                fixed (int* length_ptr = &length)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveSubroutineName(program, shadertype, index, bufSize, length_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe void UniformSubroutinesui(ShaderType shadertype, ReadOnlySpan<uint> indices)
            {
                int count = (int)(indices.Length);
                fixed (uint* indices_ptr = indices)
                {
                    UniformSubroutinesuiv(shadertype, count, indices_ptr);
                }
            }
            public static unsafe void UniformSubroutinesui(ShaderType shadertype, uint[] indices)
            {
                int count = (int)(indices.Length);
                fixed (uint* indices_ptr = indices)
                {
                    UniformSubroutinesuiv(shadertype, count, indices_ptr);
                }
            }
            public static unsafe void UniformSubroutinesui(ShaderType shadertype, int count, in uint indices)
            {
                fixed (uint* indices_ptr = &indices)
                {
                    UniformSubroutinesuiv(shadertype, count, indices_ptr);
                }
            }
            public static unsafe void GetUniformSubroutineui(ShaderType shadertype, int location, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetUniformSubroutineuiv(shadertype, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformSubroutineui(ShaderType shadertype, int location, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetUniformSubroutineuiv(shadertype, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformSubroutineui(ShaderType shadertype, int location, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetUniformSubroutineuiv(shadertype, location, parameters_ptr);
                }
            }
            public static unsafe void GetProgramStagei(ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, Span<int> values)
            {
                fixed (int* values_ptr = values)
                {
                    GetProgramStageiv(program, shadertype, pname, values_ptr);
                }
            }
            public static unsafe void GetProgramStagei(ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, int[] values)
            {
                fixed (int* values_ptr = values)
                {
                    GetProgramStageiv(program, shadertype, pname, values_ptr);
                }
            }
            public static unsafe void GetProgramStagei(ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, ref int values)
            {
                fixed (int* values_ptr = &values)
                {
                    GetProgramStageiv(program, shadertype, pname, values_ptr);
                }
            }
            public static unsafe void NamedStringARB(All type, int namelen, string name, int stringlen, string str)
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                byte* str_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(str);
                NamedStringARB(type, namelen, name_ptr, stringlen, str_ptr);
                Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            public static unsafe void DeleteNamedStringARB(int namelen, string name)
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                DeleteNamedStringARB(namelen, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            public static unsafe void CompileShaderIncludeARB(ShaderHandle shader, int count, byte** path, ReadOnlySpan<int> length)
            {
                fixed (int* length_ptr = length)
                {
                    CompileShaderIncludeARB(shader, count, path, length_ptr);
                }
            }
            public static unsafe void CompileShaderIncludeARB(ShaderHandle shader, int count, byte** path, int[] length)
            {
                fixed (int* length_ptr = length)
                {
                    CompileShaderIncludeARB(shader, count, path, length_ptr);
                }
            }
            public static unsafe void CompileShaderIncludeARB(ShaderHandle shader, int count, byte** path, in int length)
            {
                fixed (int* length_ptr = &length)
                {
                    CompileShaderIncludeARB(shader, count, path, length_ptr);
                }
            }
            public static unsafe byte IsNamedStringARB(int namelen, string name)
            {
                byte returnValue;
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                returnValue = IsNamedStringARB(namelen, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                return returnValue;
            }
            public static unsafe string GetNamedStringARB(int namelen, string name, int bufSize, Span<int> stringlen)
            {
                string str;
                fixed (int* stringlen_ptr = stringlen)
                {
                    byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                    var str_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetNamedStringARB(namelen, name_ptr, bufSize, stringlen_ptr, str_ptr);
                    str = Marshal.PtrToStringUTF8((IntPtr)str_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return str;
            }
            public static unsafe void GetNamedStringARB(int namelen, string name, int bufSize, Span<int> stringlen, out string str)
            {
                fixed (int* stringlen_ptr = stringlen)
                {
                    byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                    var str_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetNamedStringARB(namelen, name_ptr, bufSize, stringlen_ptr, str_ptr);
                    str = Marshal.PtrToStringUTF8((IntPtr)str_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe string GetNamedStringARB(int namelen, string name, int bufSize, int[] stringlen)
            {
                string str;
                fixed (int* stringlen_ptr = stringlen)
                {
                    byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                    var str_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetNamedStringARB(namelen, name_ptr, bufSize, stringlen_ptr, str_ptr);
                    str = Marshal.PtrToStringUTF8((IntPtr)str_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return str;
            }
            public static unsafe void GetNamedStringARB(int namelen, string name, int bufSize, int[] stringlen, out string str)
            {
                fixed (int* stringlen_ptr = stringlen)
                {
                    byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                    var str_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetNamedStringARB(namelen, name_ptr, bufSize, stringlen_ptr, str_ptr);
                    str = Marshal.PtrToStringUTF8((IntPtr)str_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe string GetNamedStringARB(int namelen, string name, int bufSize, ref int stringlen)
            {
                string str;
                fixed (int* stringlen_ptr = &stringlen)
                {
                    byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                    var str_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetNamedStringARB(namelen, name_ptr, bufSize, stringlen_ptr, str_ptr);
                    str = Marshal.PtrToStringUTF8((IntPtr)str_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return str;
            }
            public static unsafe void GetNamedStringARB(int namelen, string name, int bufSize, ref int stringlen, out string str)
            {
                fixed (int* stringlen_ptr = &stringlen)
                {
                    byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                    var str_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetNamedStringARB(namelen, name_ptr, bufSize, stringlen_ptr, str_ptr);
                    str = Marshal.PtrToStringUTF8((IntPtr)str_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe void GetNamedStringivARB(int namelen, string name, All pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                    GetNamedStringivARB(namelen, name_ptr, pname, parameters_ptr);
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe void GetNamedStringivARB(int namelen, string name, All pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                    GetNamedStringivARB(namelen, name_ptr, pname, parameters_ptr);
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe void GetNamedStringivARB(int namelen, string name, All pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                    GetNamedStringivARB(namelen, name_ptr, pname, parameters_ptr);
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe void BufferPageCommitmentARB(All target, IntPtr offset, nint size, bool commit)
            {
                byte commit_byte = (byte)(commit ? 1 : 0);
                BufferPageCommitmentARB(target, offset, size, commit_byte);
            }
            public static unsafe void NamedBufferPageCommitmentEXT(BufferHandle buffer, IntPtr offset, nint size, bool commit)
            {
                byte commit_byte = (byte)(commit ? 1 : 0);
                NamedBufferPageCommitmentEXT(buffer, offset, size, commit_byte);
            }
            public static unsafe void NamedBufferPageCommitmentARB(BufferHandle buffer, IntPtr offset, nint size, bool commit)
            {
                byte commit_byte = (byte)(commit ? 1 : 0);
                NamedBufferPageCommitmentARB(buffer, offset, size, commit_byte);
            }
            public static unsafe void TexPageCommitmentARB(All target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit)
            {
                byte commit_byte = (byte)(commit ? 1 : 0);
                TexPageCommitmentARB(target, level, xoffset, yoffset, zoffset, width, height, depth, commit_byte);
            }
            public static unsafe void GetInteger64(GetPName pname, Span<long> data)
            {
                fixed (long* data_ptr = data)
                {
                    GetInteger64v(pname, data_ptr);
                }
            }
            public static unsafe void GetInteger64(GetPName pname, long[] data)
            {
                fixed (long* data_ptr = data)
                {
                    GetInteger64v(pname, data_ptr);
                }
            }
            public static unsafe void GetInteger64(GetPName pname, ref long data)
            {
                fixed (long* data_ptr = &data)
                {
                    GetInteger64v(pname, data_ptr);
                }
            }
            public static unsafe void GetSynci(GLSync sync, SyncParameterName pname, Span<int> length, Span<int> values)
            {
                fixed (int* length_ptr = length)
                {
                    int count = (int)(values.Length);
                    fixed (int* values_ptr = values)
                    {
                        GetSynciv(sync, pname, count, length_ptr, values_ptr);
                    }
                }
            }
            public static unsafe void GetSynci(GLSync sync, SyncParameterName pname, int[] length, int[] values)
            {
                fixed (int* length_ptr = length)
                {
                    int count = (int)(values.Length);
                    fixed (int* values_ptr = values)
                    {
                        GetSynciv(sync, pname, count, length_ptr, values_ptr);
                    }
                }
            }
            public static unsafe void GetSynci(GLSync sync, SyncParameterName pname, int count, ref int length, ref int values)
            {
                fixed (int* length_ptr = &length)
                fixed (int* values_ptr = &values)
                {
                    GetSynciv(sync, pname, count, length_ptr, values_ptr);
                }
            }
            public static unsafe void PatchParameterf(PatchParameterName pname, ReadOnlySpan<float> values)
            {
                fixed (float* values_ptr = values)
                {
                    PatchParameterfv(pname, values_ptr);
                }
            }
            public static unsafe void PatchParameterf(PatchParameterName pname, float[] values)
            {
                fixed (float* values_ptr = values)
                {
                    PatchParameterfv(pname, values_ptr);
                }
            }
            public static unsafe void PatchParameterf(PatchParameterName pname, in float values)
            {
                fixed (float* values_ptr = &values)
                {
                    PatchParameterfv(pname, values_ptr);
                }
            }
            public static unsafe void CompressedTexImage3DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data)
            {
                void* data_vptr = (void*)data;
                CompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data_vptr);
            }
            public static unsafe void CompressedTexImage3DARB<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                int imageSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    CompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexImage3DARB<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, T1[] data)
                where T1 : unmanaged
            {
                int imageSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    CompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexImage3DARB<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    CompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexImage2DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, IntPtr data)
            {
                void* data_vptr = (void*)data;
                CompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data_vptr);
            }
            public static unsafe void CompressedTexImage2DARB<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                int imageSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    CompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexImage2DARB<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, T1[] data)
                where T1 : unmanaged
            {
                int imageSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    CompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexImage2DARB<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    CompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexImage1DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, IntPtr data)
            {
                void* data_vptr = (void*)data;
                CompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data_vptr);
            }
            public static unsafe void CompressedTexImage1DARB<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int border, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                int imageSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    CompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexImage1DARB<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int border, T1[] data)
                where T1 : unmanaged
            {
                int imageSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    CompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexImage1DARB<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    CompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexSubImage3DARB(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, IntPtr data)
            {
                void* data_vptr = (void*)data;
                CompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_vptr);
            }
            public static unsafe void CompressedTexSubImage3DARB<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                int imageSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    CompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexSubImage3DARB<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, T1[] data)
                where T1 : unmanaged
            {
                int imageSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    CompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexSubImage3DARB<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    CompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexSubImage2DARB(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, IntPtr data)
            {
                void* data_vptr = (void*)data;
                CompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data_vptr);
            }
            public static unsafe void CompressedTexSubImage2DARB<T1>(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                int imageSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    CompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexSubImage2DARB<T1>(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, T1[] data)
                where T1 : unmanaged
            {
                int imageSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    CompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexSubImage2DARB<T1>(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    CompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexSubImage1DARB(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, IntPtr data)
            {
                void* data_vptr = (void*)data;
                CompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data_vptr);
            }
            public static unsafe void CompressedTexSubImage1DARB<T1>(TextureTarget target, int level, int xoffset, int width, InternalFormat format, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                int imageSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    CompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexSubImage1DARB<T1>(TextureTarget target, int level, int xoffset, int width, InternalFormat format, T1[] data)
                where T1 : unmanaged
            {
                int imageSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    CompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data_ptr);
                }
            }
            public static unsafe void CompressedTexSubImage1DARB<T1>(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    CompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data_ptr);
                }
            }
            public static unsafe void GetCompressedTexImageARB(TextureTarget target, int level, IntPtr img)
            {
                void* img_vptr = (void*)img;
                GetCompressedTexImageARB(target, level, img_vptr);
            }
            public static unsafe void GetCompressedTexImageARB<T1>(TextureTarget target, int level, Span<T1> img)
                where T1 : unmanaged
            {
                fixed (void* img_ptr = img)
                {
                    GetCompressedTexImageARB(target, level, img_ptr);
                }
            }
            public static unsafe void GetCompressedTexImageARB<T1>(TextureTarget target, int level, T1[] img)
                where T1 : unmanaged
            {
                fixed (void* img_ptr = img)
                {
                    GetCompressedTexImageARB(target, level, img_ptr);
                }
            }
            public static unsafe void GetCompressedTexImageARB<T1>(TextureTarget target, int level, ref T1 img)
                where T1 : unmanaged
            {
                fixed (void* img_ptr = &img)
                {
                    GetCompressedTexImageARB(target, level, img_ptr);
                }
            }
            public static unsafe void TexImage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations)
            {
                byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
                TexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations_byte);
            }
            public static unsafe void TexImage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
            {
                byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
                TexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
            }
            public static unsafe void GetMultisamplef(GetMultisamplePNameNV pname, uint index, Span<float> val)
            {
                fixed (float* val_ptr = val)
                {
                    GetMultisamplefv(pname, index, val_ptr);
                }
            }
            public static unsafe void GetMultisamplef(GetMultisamplePNameNV pname, uint index, float[] val)
            {
                fixed (float* val_ptr = val)
                {
                    GetMultisamplefv(pname, index, val_ptr);
                }
            }
            public static unsafe void GetMultisamplef(GetMultisamplePNameNV pname, uint index, ref float val)
            {
                fixed (float* val_ptr = &val)
                {
                    GetMultisamplefv(pname, index, val_ptr);
                }
            }
            public static unsafe void TexStorage2DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
            {
                byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
                TexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations_byte);
            }
            public static unsafe void TexStorage3DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
            {
                byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
                TexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
            }
            public static unsafe void GetQueryObjecti64(QueryHandle id, QueryObjectParameterName pname, Span<long> parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetQueryObjecti64v(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjecti64(QueryHandle id, QueryObjectParameterName pname, long[] parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetQueryObjecti64v(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjecti64(QueryHandle id, QueryObjectParameterName pname, ref long parameters)
            {
                fixed (long* parameters_ptr = &parameters)
                {
                    GetQueryObjecti64v(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjectui64(QueryHandle id, QueryObjectParameterName pname, Span<ulong> parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetQueryObjectui64v(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjectui64(QueryHandle id, QueryObjectParameterName pname, ulong[] parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetQueryObjectui64v(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjectui64(QueryHandle id, QueryObjectParameterName pname, ref ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    GetQueryObjectui64v(id, pname, parameters_ptr);
                }
            }
            public static unsafe void DeleteTransformFeedback(in TransformFeedbackHandle ids)
            {
                int n = 1;
                fixed(TransformFeedbackHandle* ids_handle = &ids)
                {
                    DeleteTransformFeedbacks(n, ids_handle);
                }
            }
            public static unsafe void DeleteTransformFeedbacks(ReadOnlySpan<TransformFeedbackHandle> ids)
            {
                int n = (int)(ids.Length);
                fixed (TransformFeedbackHandle* ids_ptr = ids)
                {
                    DeleteTransformFeedbacks(n, ids_ptr);
                }
            }
            public static unsafe void DeleteTransformFeedbacks(TransformFeedbackHandle[] ids)
            {
                int n = (int)(ids.Length);
                fixed (TransformFeedbackHandle* ids_ptr = ids)
                {
                    DeleteTransformFeedbacks(n, ids_ptr);
                }
            }
            public static unsafe void DeleteTransformFeedbacks(int n, in TransformFeedbackHandle ids)
            {
                fixed (TransformFeedbackHandle* ids_ptr = &ids)
                {
                    DeleteTransformFeedbacks(n, ids_ptr);
                }
            }
            public static unsafe TransformFeedbackHandle GenTransformFeedback()
            {
                TransformFeedbackHandle ids;
                int n = 1;
                Unsafe.SkipInit(out ids);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
                GenTransformFeedbacks(n, ids_handle);
                return ids;
            }
            public static unsafe void GenTransformFeedback(out TransformFeedbackHandle ids)
            {
                int n = 1;
                Unsafe.SkipInit(out ids);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                TransformFeedbackHandle* ids_handle = (TransformFeedbackHandle*)Unsafe.AsPointer(ref ids);
                GenTransformFeedbacks(n, ids_handle);
            }
            public static unsafe void GenTransformFeedbacks(Span<TransformFeedbackHandle> ids)
            {
                int n = (int)(ids.Length);
                fixed (TransformFeedbackHandle* ids_ptr = ids)
                {
                    GenTransformFeedbacks(n, ids_ptr);
                }
            }
            public static unsafe void GenTransformFeedbacks(TransformFeedbackHandle[] ids)
            {
                int n = (int)(ids.Length);
                fixed (TransformFeedbackHandle* ids_ptr = ids)
                {
                    GenTransformFeedbacks(n, ids_ptr);
                }
            }
            public static unsafe void GenTransformFeedbacks(int n, ref TransformFeedbackHandle ids)
            {
                fixed (TransformFeedbackHandle* ids_ptr = &ids)
                {
                    GenTransformFeedbacks(n, ids_ptr);
                }
            }
            public static unsafe void GetQueryIndexedi(QueryTarget target, uint index, QueryParameterName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetQueryIndexediv(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryIndexedi(QueryTarget target, uint index, QueryParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetQueryIndexediv(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryIndexedi(QueryTarget target, uint index, QueryParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetQueryIndexediv(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void LoadTransposeMatrixfARB(ReadOnlySpan<float> m)
            {
                fixed (float* m_ptr = m)
                {
                    LoadTransposeMatrixfARB(m_ptr);
                }
            }
            public static unsafe void LoadTransposeMatrixfARB(float[] m)
            {
                fixed (float* m_ptr = m)
                {
                    LoadTransposeMatrixfARB(m_ptr);
                }
            }
            public static unsafe void LoadTransposeMatrixfARB(in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    LoadTransposeMatrixfARB(m_ptr);
                }
            }
            public static unsafe void LoadTransposeMatrixdARB(ReadOnlySpan<double> m)
            {
                fixed (double* m_ptr = m)
                {
                    LoadTransposeMatrixdARB(m_ptr);
                }
            }
            public static unsafe void LoadTransposeMatrixdARB(double[] m)
            {
                fixed (double* m_ptr = m)
                {
                    LoadTransposeMatrixdARB(m_ptr);
                }
            }
            public static unsafe void LoadTransposeMatrixdARB(in double m)
            {
                fixed (double* m_ptr = &m)
                {
                    LoadTransposeMatrixdARB(m_ptr);
                }
            }
            public static unsafe void MultTransposeMatrixfARB(ReadOnlySpan<float> m)
            {
                fixed (float* m_ptr = m)
                {
                    MultTransposeMatrixfARB(m_ptr);
                }
            }
            public static unsafe void MultTransposeMatrixfARB(float[] m)
            {
                fixed (float* m_ptr = m)
                {
                    MultTransposeMatrixfARB(m_ptr);
                }
            }
            public static unsafe void MultTransposeMatrixfARB(in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MultTransposeMatrixfARB(m_ptr);
                }
            }
            public static unsafe void MultTransposeMatrixdARB(ReadOnlySpan<double> m)
            {
                fixed (double* m_ptr = m)
                {
                    MultTransposeMatrixdARB(m_ptr);
                }
            }
            public static unsafe void MultTransposeMatrixdARB(double[] m)
            {
                fixed (double* m_ptr = m)
                {
                    MultTransposeMatrixdARB(m_ptr);
                }
            }
            public static unsafe void MultTransposeMatrixdARB(in double m)
            {
                fixed (double* m_ptr = &m)
                {
                    MultTransposeMatrixdARB(m_ptr);
                }
            }
            public static unsafe void GetUniformIndices(ProgramHandle program, int uniformCount, byte** uniformNames, Span<uint> uniformIndices)
            {
                fixed (uint* uniformIndices_ptr = uniformIndices)
                {
                    GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
                }
            }
            public static unsafe void GetUniformIndices(ProgramHandle program, int uniformCount, byte** uniformNames, uint[] uniformIndices)
            {
                fixed (uint* uniformIndices_ptr = uniformIndices)
                {
                    GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
                }
            }
            public static unsafe void GetUniformIndices(ProgramHandle program, int uniformCount, byte** uniformNames, ref uint uniformIndices)
            {
                fixed (uint* uniformIndices_ptr = &uniformIndices)
                {
                    GetUniformIndices(program, uniformCount, uniformNames, uniformIndices_ptr);
                }
            }
            public static unsafe void GetActiveUniformsi(ProgramHandle program, ReadOnlySpan<uint> uniformIndices, UniformPName pname, Span<int> parameters)
            {
                int uniformCount = (int)(uniformIndices.Length);
                fixed (uint* uniformIndices_ptr = uniformIndices)
                {
                    fixed (int* parameters_ptr = parameters)
                    {
                        GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
                    }
                }
            }
            public static unsafe void GetActiveUniformsi(ProgramHandle program, uint[] uniformIndices, UniformPName pname, int[] parameters)
            {
                int uniformCount = (int)(uniformIndices.Length);
                fixed (uint* uniformIndices_ptr = uniformIndices)
                {
                    fixed (int* parameters_ptr = parameters)
                    {
                        GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
                    }
                }
            }
            public static unsafe void GetActiveUniformsi(ProgramHandle program, int uniformCount, in uint uniformIndices, UniformPName pname, ref int parameters)
            {
                fixed (uint* uniformIndices_ptr = &uniformIndices)
                fixed (int* parameters_ptr = &parameters)
                {
                    GetActiveUniformsiv(program, uniformCount, uniformIndices_ptr, pname, parameters_ptr);
                }
            }
            public static unsafe string GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, Span<int> length)
            {
                string uniformName;
                fixed (int* length_ptr = length)
                {
                    var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                    uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
                }
                return uniformName;
            }
            public static unsafe void GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, Span<int> length, out string uniformName)
            {
                fixed (int* length_ptr = length)
                {
                    var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                    uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
                }
            }
            public static unsafe string GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, int[] length)
            {
                string uniformName;
                fixed (int* length_ptr = length)
                {
                    var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                    uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
                }
                return uniformName;
            }
            public static unsafe void GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, int[] length, out string uniformName)
            {
                fixed (int* length_ptr = length)
                {
                    var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                    uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
                }
            }
            public static unsafe string GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, ref int length)
            {
                string uniformName;
                fixed (int* length_ptr = &length)
                {
                    var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                    uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
                }
                return uniformName;
            }
            public static unsafe void GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, ref int length, out string uniformName)
            {
                fixed (int* length_ptr = &length)
                {
                    var uniformName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveUniformName(program, uniformIndex, bufSize, length_ptr, uniformName_ptr);
                    uniformName = Marshal.PtrToStringUTF8((IntPtr)uniformName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)uniformName_ptr);
                }
            }
            public static unsafe uint GetUniformBlockIndex(ProgramHandle program, string uniformBlockName)
            {
                uint returnValue;
                byte* uniformBlockName_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(uniformBlockName);
                returnValue = GetUniformBlockIndex(program, uniformBlockName_ptr);
                Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
                return returnValue;
            }
            public static unsafe void GetActiveUniformBlocki(ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
                }
            }
            public static unsafe void GetActiveUniformBlocki(ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
                }
            }
            public static unsafe void GetActiveUniformBlocki(ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetActiveUniformBlockiv(program, uniformBlockIndex, pname, parameters_ptr);
                }
            }
            public static unsafe string GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, Span<int> length)
            {
                string uniformBlockName;
                fixed (int* length_ptr = length)
                {
                    var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                    uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
                }
                return uniformBlockName;
            }
            public static unsafe void GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, Span<int> length, out string uniformBlockName)
            {
                fixed (int* length_ptr = length)
                {
                    var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                    uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
                }
            }
            public static unsafe string GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, int[] length)
            {
                string uniformBlockName;
                fixed (int* length_ptr = length)
                {
                    var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                    uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
                }
                return uniformBlockName;
            }
            public static unsafe void GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, int[] length, out string uniformBlockName)
            {
                fixed (int* length_ptr = length)
                {
                    var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                    uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
                }
            }
            public static unsafe string GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, ref int length)
            {
                string uniformBlockName;
                fixed (int* length_ptr = &length)
                {
                    var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                    uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
                }
                return uniformBlockName;
            }
            public static unsafe void GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, ref int length, out string uniformBlockName)
            {
                fixed (int* length_ptr = &length)
                {
                    var uniformBlockName_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_ptr, uniformBlockName_ptr);
                    uniformBlockName = Marshal.PtrToStringUTF8((IntPtr)uniformBlockName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)uniformBlockName_ptr);
                }
            }
            public static unsafe void GetInteger(GetPName target, uint index, Span<int> data)
            {
                fixed (int* data_ptr = data)
                {
                    GetIntegeri_v(target, index, data_ptr);
                }
            }
            public static unsafe void GetInteger(GetPName target, uint index, int[] data)
            {
                fixed (int* data_ptr = data)
                {
                    GetIntegeri_v(target, index, data_ptr);
                }
            }
            public static unsafe void GetInteger(GetPName target, uint index, ref int data)
            {
                fixed (int* data_ptr = &data)
                {
                    GetIntegeri_v(target, index, data_ptr);
                }
            }
            public static unsafe void DeleteVertexArray(in VertexArrayHandle arrays)
            {
                int n = 1;
                fixed(VertexArrayHandle* arrays_handle = &arrays)
                {
                    DeleteVertexArrays(n, arrays_handle);
                }
            }
            public static unsafe void DeleteVertexArrays(ReadOnlySpan<VertexArrayHandle> arrays)
            {
                int n = (int)(arrays.Length);
                fixed (VertexArrayHandle* arrays_ptr = arrays)
                {
                    DeleteVertexArrays(n, arrays_ptr);
                }
            }
            public static unsafe void DeleteVertexArrays(VertexArrayHandle[] arrays)
            {
                int n = (int)(arrays.Length);
                fixed (VertexArrayHandle* arrays_ptr = arrays)
                {
                    DeleteVertexArrays(n, arrays_ptr);
                }
            }
            public static unsafe void DeleteVertexArrays(int n, in VertexArrayHandle arrays)
            {
                fixed (VertexArrayHandle* arrays_ptr = &arrays)
                {
                    DeleteVertexArrays(n, arrays_ptr);
                }
            }
            public static unsafe VertexArrayHandle GenVertexArray()
            {
                VertexArrayHandle arrays;
                int n = 1;
                Unsafe.SkipInit(out arrays);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
                GenVertexArrays(n, arrays_handle);
                return arrays;
            }
            public static unsafe void GenVertexArray(out VertexArrayHandle arrays)
            {
                int n = 1;
                Unsafe.SkipInit(out arrays);
                // FIXME: This could be a problem for the overloads that take an out parameter
                // as this parameter could *potentially* move while inside of this function
                // which would mean that the new value never gets written to the out parameter.
                // Making for a nasty bug.
                // The reason we don't use a fixed expression here is because of the "single out parameter to return value" overloading step
                // that will make it so this tries to fix a local variable which is not allowed in C# for some reason.
                // If you have problems with this we would really appreciate you opening an issue at https://github.com/opentk/opentk
                // - 2021-05-18
                VertexArrayHandle* arrays_handle = (VertexArrayHandle*)Unsafe.AsPointer(ref arrays);
                GenVertexArrays(n, arrays_handle);
            }
            public static unsafe void GenVertexArrays(Span<VertexArrayHandle> arrays)
            {
                int n = (int)(arrays.Length);
                fixed (VertexArrayHandle* arrays_ptr = arrays)
                {
                    GenVertexArrays(n, arrays_ptr);
                }
            }
            public static unsafe void GenVertexArrays(VertexArrayHandle[] arrays)
            {
                int n = (int)(arrays.Length);
                fixed (VertexArrayHandle* arrays_ptr = arrays)
                {
                    GenVertexArrays(n, arrays_ptr);
                }
            }
            public static unsafe void GenVertexArrays(int n, ref VertexArrayHandle arrays)
            {
                fixed (VertexArrayHandle* arrays_ptr = &arrays)
                {
                    GenVertexArrays(n, arrays_ptr);
                }
            }
            public static unsafe void VertexAttribL1dv(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL1dv(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL1dv(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL1dv(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL1dv(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttribL1dv(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL2dv(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL2dv(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL2dv(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL2dv(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL2dv(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttribL2dv(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL3dv(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL3dv(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL3dv(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL3dv(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL3dv(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttribL3dv(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL4dv(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL4dv(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL4dv(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL4dv(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL4dv(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttribL4dv(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, nint offset)
            {
                void* pointer = (void*)offset;
                VertexAttribLPointer(index, size, type, stride, pointer);
            }
            public static unsafe void GetVertexAttribLd(uint index, VertexAttribEnum pname, Span<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetVertexAttribLdv(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribLd(uint index, VertexAttribEnum pname, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetVertexAttribLdv(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribLd(uint index, VertexAttribEnum pname, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    GetVertexAttribLdv(index, pname, parameters_ptr);
                }
            }
            public static unsafe void VertexAttribFormat(uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribFormat(attribindex, size, type, normalized_byte, relativeoffset);
            }
            public static unsafe void WeightbvARB(ReadOnlySpan<sbyte> weights)
            {
                int size = (int)(weights.Length);
                fixed (sbyte* weights_ptr = weights)
                {
                    WeightbvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightbvARB(sbyte[] weights)
            {
                int size = (int)(weights.Length);
                fixed (sbyte* weights_ptr = weights)
                {
                    WeightbvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightbvARB(int size, in sbyte weights)
            {
                fixed (sbyte* weights_ptr = &weights)
                {
                    WeightbvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightsvARB(ReadOnlySpan<short> weights)
            {
                int size = (int)(weights.Length);
                fixed (short* weights_ptr = weights)
                {
                    WeightsvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightsvARB(short[] weights)
            {
                int size = (int)(weights.Length);
                fixed (short* weights_ptr = weights)
                {
                    WeightsvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightsvARB(int size, in short weights)
            {
                fixed (short* weights_ptr = &weights)
                {
                    WeightsvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightivARB(ReadOnlySpan<int> weights)
            {
                int size = (int)(weights.Length);
                fixed (int* weights_ptr = weights)
                {
                    WeightivARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightivARB(int[] weights)
            {
                int size = (int)(weights.Length);
                fixed (int* weights_ptr = weights)
                {
                    WeightivARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightivARB(int size, in int weights)
            {
                fixed (int* weights_ptr = &weights)
                {
                    WeightivARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightfvARB(ReadOnlySpan<float> weights)
            {
                int size = (int)(weights.Length);
                fixed (float* weights_ptr = weights)
                {
                    WeightfvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightfvARB(float[] weights)
            {
                int size = (int)(weights.Length);
                fixed (float* weights_ptr = weights)
                {
                    WeightfvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightfvARB(int size, in float weights)
            {
                fixed (float* weights_ptr = &weights)
                {
                    WeightfvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightdvARB(ReadOnlySpan<double> weights)
            {
                int size = (int)(weights.Length);
                fixed (double* weights_ptr = weights)
                {
                    WeightdvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightdvARB(double[] weights)
            {
                int size = (int)(weights.Length);
                fixed (double* weights_ptr = weights)
                {
                    WeightdvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightdvARB(int size, in double weights)
            {
                fixed (double* weights_ptr = &weights)
                {
                    WeightdvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightubvARB(ReadOnlySpan<byte> weights)
            {
                int size = (int)(weights.Length);
                fixed (byte* weights_ptr = weights)
                {
                    WeightubvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightubvARB(byte[] weights)
            {
                int size = (int)(weights.Length);
                fixed (byte* weights_ptr = weights)
                {
                    WeightubvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightubvARB(int size, in byte weights)
            {
                fixed (byte* weights_ptr = &weights)
                {
                    WeightubvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightusvARB(ReadOnlySpan<ushort> weights)
            {
                int size = (int)(weights.Length);
                fixed (ushort* weights_ptr = weights)
                {
                    WeightusvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightusvARB(ushort[] weights)
            {
                int size = (int)(weights.Length);
                fixed (ushort* weights_ptr = weights)
                {
                    WeightusvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightusvARB(int size, in ushort weights)
            {
                fixed (ushort* weights_ptr = &weights)
                {
                    WeightusvARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightuivARB(ReadOnlySpan<uint> weights)
            {
                int size = (int)(weights.Length);
                fixed (uint* weights_ptr = weights)
                {
                    WeightuivARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightuivARB(uint[] weights)
            {
                int size = (int)(weights.Length);
                fixed (uint* weights_ptr = weights)
                {
                    WeightuivARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightuivARB(int size, in uint weights)
            {
                fixed (uint* weights_ptr = &weights)
                {
                    WeightuivARB(size, weights_ptr);
                }
            }
            public static unsafe void WeightPointerARB(int size, WeightPointerTypeARB type, int stride, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                WeightPointerARB(size, type, stride, pointer_vptr);
            }
            public static unsafe void WeightPointerARB<T1>(int size, WeightPointerTypeARB type, int stride, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    WeightPointerARB(size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void WeightPointerARB<T1>(int size, WeightPointerTypeARB type, int stride, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    WeightPointerARB(size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void WeightPointerARB<T1>(int size, WeightPointerTypeARB type, int stride, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    WeightPointerARB(size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void DeleteBuffersARB(ReadOnlySpan<BufferHandle> buffers)
            {
                int n = (int)(buffers.Length);
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    DeleteBuffersARB(n, buffers_ptr);
                }
            }
            public static unsafe void DeleteBuffersARB(BufferHandle[] buffers)
            {
                int n = (int)(buffers.Length);
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    DeleteBuffersARB(n, buffers_ptr);
                }
            }
            public static unsafe void DeleteBuffersARB(int n, in BufferHandle buffers)
            {
                fixed (BufferHandle* buffers_ptr = &buffers)
                {
                    DeleteBuffersARB(n, buffers_ptr);
                }
            }
            public static unsafe void GenBuffersARB(Span<BufferHandle> buffers)
            {
                int n = (int)(buffers.Length);
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    GenBuffersARB(n, buffers_ptr);
                }
            }
            public static unsafe void GenBuffersARB(BufferHandle[] buffers)
            {
                int n = (int)(buffers.Length);
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    GenBuffersARB(n, buffers_ptr);
                }
            }
            public static unsafe void GenBuffersARB(int n, ref BufferHandle buffers)
            {
                fixed (BufferHandle* buffers_ptr = &buffers)
                {
                    GenBuffersARB(n, buffers_ptr);
                }
            }
            public static unsafe void BufferDataARB(BufferTargetARB target, nint size, IntPtr data, BufferUsageARB usage)
            {
                void* data_vptr = (void*)data;
                BufferDataARB(target, size, data_vptr, usage);
            }
            public static unsafe void BufferDataARB<T1>(BufferTargetARB target, ReadOnlySpan<T1> data, BufferUsageARB usage)
                where T1 : unmanaged
            {
                nint size = (nint)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    BufferDataARB(target, size, data_ptr, usage);
                }
            }
            public static unsafe void BufferDataARB<T1>(BufferTargetARB target, T1[] data, BufferUsageARB usage)
                where T1 : unmanaged
            {
                nint size = (nint)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    BufferDataARB(target, size, data_ptr, usage);
                }
            }
            public static unsafe void BufferDataARB<T1>(BufferTargetARB target, nint size, in T1 data, BufferUsageARB usage)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    BufferDataARB(target, size, data_ptr, usage);
                }
            }
            public static unsafe void BufferSubDataARB(BufferTargetARB target, IntPtr offset, nint size, IntPtr data)
            {
                void* data_vptr = (void*)data;
                BufferSubDataARB(target, offset, size, data_vptr);
            }
            public static unsafe void BufferSubDataARB<T1>(BufferTargetARB target, IntPtr offset, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                nint size = (nint)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    BufferSubDataARB(target, offset, size, data_ptr);
                }
            }
            public static unsafe void BufferSubDataARB<T1>(BufferTargetARB target, IntPtr offset, T1[] data)
                where T1 : unmanaged
            {
                nint size = (nint)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    BufferSubDataARB(target, offset, size, data_ptr);
                }
            }
            public static unsafe void BufferSubDataARB<T1>(BufferTargetARB target, IntPtr offset, nint size, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    BufferSubDataARB(target, offset, size, data_ptr);
                }
            }
            public static unsafe void GetBufferSubDataARB(BufferTargetARB target, IntPtr offset, nint size, IntPtr data)
            {
                void* data_vptr = (void*)data;
                GetBufferSubDataARB(target, offset, size, data_vptr);
            }
            public static unsafe void GetBufferSubDataARB<T1>(BufferTargetARB target, IntPtr offset, Span<T1> data)
                where T1 : unmanaged
            {
                nint size = (nint)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    GetBufferSubDataARB(target, offset, size, data_ptr);
                }
            }
            public static unsafe void GetBufferSubDataARB<T1>(BufferTargetARB target, IntPtr offset, T1[] data)
                where T1 : unmanaged
            {
                nint size = (nint)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    GetBufferSubDataARB(target, offset, size, data_ptr);
                }
            }
            public static unsafe void GetBufferSubDataARB<T1>(BufferTargetARB target, IntPtr offset, nint size, ref T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    GetBufferSubDataARB(target, offset, size, data_ptr);
                }
            }
            public static unsafe void GetBufferParameterivARB(BufferTargetARB target, BufferPNameARB pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetBufferParameterivARB(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetBufferParameterivARB(BufferTargetARB target, BufferPNameARB pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetBufferParameterivARB(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetBufferParameterivARB(BufferTargetARB target, BufferPNameARB pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetBufferParameterivARB(target, pname, parameters_ptr);
                }
            }
            public static unsafe void VertexAttrib1dvARB(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib1dvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1dvARB(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib1dvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1dvARB(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttrib1dvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1fvARB(uint index, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib1fvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1fvARB(uint index, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib1fvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1fvARB(uint index, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    VertexAttrib1fvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1svARB(uint index, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib1svARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1svARB(uint index, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib1svARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1svARB(uint index, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttrib1svARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2dvARB(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib2dvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2dvARB(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib2dvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2dvARB(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttrib2dvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2fvARB(uint index, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib2fvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2fvARB(uint index, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib2fvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2fvARB(uint index, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    VertexAttrib2fvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2svARB(uint index, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib2svARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2svARB(uint index, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib2svARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2svARB(uint index, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttrib2svARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3dvARB(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib3dvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3dvARB(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib3dvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3dvARB(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttrib3dvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3fvARB(uint index, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib3fvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3fvARB(uint index, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib3fvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3fvARB(uint index, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    VertexAttrib3fvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3svARB(uint index, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib3svARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3svARB(uint index, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib3svARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3svARB(uint index, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttrib3svARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NbvARB(uint index, ReadOnlySpan<sbyte> v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    VertexAttrib4NbvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NbvARB(uint index, sbyte[] v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    VertexAttrib4NbvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NbvARB(uint index, in sbyte v)
            {
                fixed (sbyte* v_ptr = &v)
                {
                    VertexAttrib4NbvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NivARB(uint index, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttrib4NivARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NivARB(uint index, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttrib4NivARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NivARB(uint index, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    VertexAttrib4NivARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NsvARB(uint index, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib4NsvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NsvARB(uint index, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib4NsvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NsvARB(uint index, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttrib4NsvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NubvARB(uint index, ReadOnlySpan<byte> v)
            {
                fixed (byte* v_ptr = v)
                {
                    VertexAttrib4NubvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NubvARB(uint index, byte[] v)
            {
                fixed (byte* v_ptr = v)
                {
                    VertexAttrib4NubvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NubvARB(uint index, in byte v)
            {
                fixed (byte* v_ptr = &v)
                {
                    VertexAttrib4NubvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NuivARB(uint index, ReadOnlySpan<uint> v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttrib4NuivARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NuivARB(uint index, uint[] v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttrib4NuivARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NuivARB(uint index, in uint v)
            {
                fixed (uint* v_ptr = &v)
                {
                    VertexAttrib4NuivARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NusvARB(uint index, ReadOnlySpan<ushort> v)
            {
                fixed (ushort* v_ptr = v)
                {
                    VertexAttrib4NusvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NusvARB(uint index, ushort[] v)
            {
                fixed (ushort* v_ptr = v)
                {
                    VertexAttrib4NusvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4NusvARB(uint index, in ushort v)
            {
                fixed (ushort* v_ptr = &v)
                {
                    VertexAttrib4NusvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4bvARB(uint index, ReadOnlySpan<sbyte> v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    VertexAttrib4bvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4bvARB(uint index, sbyte[] v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    VertexAttrib4bvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4bvARB(uint index, in sbyte v)
            {
                fixed (sbyte* v_ptr = &v)
                {
                    VertexAttrib4bvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4dvARB(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib4dvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4dvARB(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib4dvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4dvARB(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttrib4dvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4fvARB(uint index, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib4fvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4fvARB(uint index, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib4fvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4fvARB(uint index, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    VertexAttrib4fvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4ivARB(uint index, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttrib4ivARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4ivARB(uint index, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttrib4ivARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4ivARB(uint index, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    VertexAttrib4ivARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4svARB(uint index, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib4svARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4svARB(uint index, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib4svARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4svARB(uint index, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttrib4svARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4ubvARB(uint index, ReadOnlySpan<byte> v)
            {
                fixed (byte* v_ptr = v)
                {
                    VertexAttrib4ubvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4ubvARB(uint index, byte[] v)
            {
                fixed (byte* v_ptr = v)
                {
                    VertexAttrib4ubvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4ubvARB(uint index, in byte v)
            {
                fixed (byte* v_ptr = &v)
                {
                    VertexAttrib4ubvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4uivARB(uint index, ReadOnlySpan<uint> v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttrib4uivARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4uivARB(uint index, uint[] v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttrib4uivARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4uivARB(uint index, in uint v)
            {
                fixed (uint* v_ptr = &v)
                {
                    VertexAttrib4uivARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4usvARB(uint index, ReadOnlySpan<ushort> v)
            {
                fixed (ushort* v_ptr = v)
                {
                    VertexAttrib4usvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4usvARB(uint index, ushort[] v)
            {
                fixed (ushort* v_ptr = v)
                {
                    VertexAttrib4usvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4usvARB(uint index, in ushort v)
            {
                fixed (ushort* v_ptr = &v)
                {
                    VertexAttrib4usvARB(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribPointerARB(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribPointerARB(index, size, type, normalized_byte, stride, pointer_vptr);
            }
            public static unsafe void VertexAttribPointerARB<T1>(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribPointerARB(index, size, type, normalized_byte, stride, pointer_ptr);
                }
            }
            public static unsafe void VertexAttribPointerARB<T1>(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribPointerARB(index, size, type, normalized_byte, stride, pointer_ptr);
                }
            }
            public static unsafe void VertexAttribPointerARB<T1>(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribPointerARB(index, size, type, normalized_byte, stride, pointer_ptr);
                }
            }
            public static unsafe void GetVertexAttribdvARB(uint index, VertexAttribPropertyARB pname, Span<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetVertexAttribdvARB(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribdvARB(uint index, VertexAttribPropertyARB pname, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetVertexAttribdvARB(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribdvARB(uint index, VertexAttribPropertyARB pname, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    GetVertexAttribdvARB(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribfvARB(uint index, VertexAttribPropertyARB pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetVertexAttribfvARB(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribfvARB(uint index, VertexAttribPropertyARB pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetVertexAttribfvARB(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribfvARB(uint index, VertexAttribPropertyARB pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetVertexAttribfvARB(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribivARB(uint index, VertexAttribPropertyARB pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVertexAttribivARB(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribivARB(uint index, VertexAttribPropertyARB pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVertexAttribivARB(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribivARB(uint index, VertexAttribPropertyARB pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetVertexAttribivARB(index, pname, parameters_ptr);
                }
            }
            public static unsafe void BindAttribLocationARB(GLHandleARB programObj, uint index, string name)
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                BindAttribLocationARB(programObj, index, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            public static unsafe string GetActiveAttribARB(GLHandleARB programObj, uint index, int maxLength, Span<int> length, Span<int> size, Span<AttributeType> type)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (AttributeType* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                            GetActiveAttribARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
                return name;
            }
            public static unsafe void GetActiveAttribARB(GLHandleARB programObj, uint index, int maxLength, Span<int> length, Span<int> size, Span<AttributeType> type, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (AttributeType* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                            GetActiveAttribARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
            }
            public static unsafe string GetActiveAttribARB(GLHandleARB programObj, uint index, int maxLength, int[] length, int[] size, AttributeType[] type)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (AttributeType* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                            GetActiveAttribARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
                return name;
            }
            public static unsafe void GetActiveAttribARB(GLHandleARB programObj, uint index, int maxLength, int[] length, int[] size, AttributeType[] type, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (AttributeType* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                            GetActiveAttribARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
            }
            public static unsafe string GetActiveAttribARB(GLHandleARB programObj, uint index, int maxLength, ref int length, ref int size, ref AttributeType type)
            {
                string name;
                fixed (int* length_ptr = &length)
                fixed (int* size_ptr = &size)
                fixed (AttributeType* type_ptr = &type)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetActiveAttribARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return name;
            }
            public static unsafe void GetActiveAttribARB(GLHandleARB programObj, uint index, int maxLength, ref int length, ref int size, ref AttributeType type, out string name)
            {
                fixed (int* length_ptr = &length)
                fixed (int* size_ptr = &size)
                fixed (AttributeType* type_ptr = &type)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(maxLength);
                    GetActiveAttribARB(programObj, index, maxLength, length_ptr, size_ptr, type_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe int GetAttribLocationARB(GLHandleARB programObj, string name)
            {
                int returnValue;
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                returnValue = GetAttribLocationARB(programObj, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                return returnValue;
            }
            public static unsafe void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, uint value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP1ui(index, type, normalized_byte, value);
            }
            public static unsafe void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
            {
                fixed (uint* value_ptr = value)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribP1uiv(index, type, normalized_byte, value_ptr);
                }
            }
            public static unsafe void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, uint[] value)
            {
                fixed (uint* value_ptr = value)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribP1uiv(index, type, normalized_byte, value_ptr);
                }
            }
            public static unsafe void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribP1uiv(index, type, normalized_byte, value_ptr);
                }
            }
            public static unsafe void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, uint value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP2ui(index, type, normalized_byte, value);
            }
            public static unsafe void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
            {
                fixed (uint* value_ptr = value)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribP2uiv(index, type, normalized_byte, value_ptr);
                }
            }
            public static unsafe void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, uint[] value)
            {
                fixed (uint* value_ptr = value)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribP2uiv(index, type, normalized_byte, value_ptr);
                }
            }
            public static unsafe void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribP2uiv(index, type, normalized_byte, value_ptr);
                }
            }
            public static unsafe void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, uint value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP3ui(index, type, normalized_byte, value);
            }
            public static unsafe void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
            {
                fixed (uint* value_ptr = value)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribP3uiv(index, type, normalized_byte, value_ptr);
                }
            }
            public static unsafe void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, uint[] value)
            {
                fixed (uint* value_ptr = value)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribP3uiv(index, type, normalized_byte, value_ptr);
                }
            }
            public static unsafe void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribP3uiv(index, type, normalized_byte, value_ptr);
                }
            }
            public static unsafe void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, uint value)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribP4ui(index, type, normalized_byte, value);
            }
            public static unsafe void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, ReadOnlySpan<uint> value)
            {
                fixed (uint* value_ptr = value)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribP4uiv(index, type, normalized_byte, value_ptr);
                }
            }
            public static unsafe void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, uint[] value)
            {
                fixed (uint* value_ptr = value)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribP4uiv(index, type, normalized_byte, value_ptr);
                }
            }
            public static unsafe void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    byte normalized_byte = (byte)(normalized ? 1 : 0);
                    VertexAttribP4uiv(index, type, normalized_byte, value_ptr);
                }
            }
            public static unsafe void ViewportArray(uint first, int count, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    ViewportArrayv(first, count, v_ptr);
                }
            }
            public static unsafe void ViewportArray(uint first, int count, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    ViewportArrayv(first, count, v_ptr);
                }
            }
            public static unsafe void ViewportArray(uint first, int count, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    ViewportArrayv(first, count, v_ptr);
                }
            }
            public static unsafe void ViewportIndexedf(uint index, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    ViewportIndexedfv(index, v_ptr);
                }
            }
            public static unsafe void ViewportIndexedf(uint index, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    ViewportIndexedfv(index, v_ptr);
                }
            }
            public static unsafe void ViewportIndexedf(uint index, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    ViewportIndexedfv(index, v_ptr);
                }
            }
            public static unsafe void ScissorArray(uint first, int count, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    ScissorArrayv(first, count, v_ptr);
                }
            }
            public static unsafe void ScissorArray(uint first, int count, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    ScissorArrayv(first, count, v_ptr);
                }
            }
            public static unsafe void ScissorArray(uint first, int count, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    ScissorArrayv(first, count, v_ptr);
                }
            }
            public static unsafe void ScissorIndexedv(uint index, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    ScissorIndexedv(index, v_ptr);
                }
            }
            public static unsafe void ScissorIndexedv(uint index, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    ScissorIndexedv(index, v_ptr);
                }
            }
            public static unsafe void ScissorIndexedv(uint index, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    ScissorIndexedv(index, v_ptr);
                }
            }
            public static unsafe void DepthRangeArray(uint first, int count, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    DepthRangeArrayv(first, count, v_ptr);
                }
            }
            public static unsafe void DepthRangeArray(uint first, int count, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    DepthRangeArrayv(first, count, v_ptr);
                }
            }
            public static unsafe void DepthRangeArray(uint first, int count, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    DepthRangeArrayv(first, count, v_ptr);
                }
            }
            public static unsafe void GetFloat(GetPName target, uint index, Span<float> data)
            {
                fixed (float* data_ptr = data)
                {
                    GetFloati_v(target, index, data_ptr);
                }
            }
            public static unsafe void GetFloat(GetPName target, uint index, float[] data)
            {
                fixed (float* data_ptr = data)
                {
                    GetFloati_v(target, index, data_ptr);
                }
            }
            public static unsafe void GetFloat(GetPName target, uint index, ref float data)
            {
                fixed (float* data_ptr = &data)
                {
                    GetFloati_v(target, index, data_ptr);
                }
            }
            public static unsafe void GetDouble(GetPName target, uint index, Span<double> data)
            {
                fixed (double* data_ptr = data)
                {
                    GetDoublei_v(target, index, data_ptr);
                }
            }
            public static unsafe void GetDouble(GetPName target, uint index, double[] data)
            {
                fixed (double* data_ptr = data)
                {
                    GetDoublei_v(target, index, data_ptr);
                }
            }
            public static unsafe void GetDouble(GetPName target, uint index, ref double data)
            {
                fixed (double* data_ptr = &data)
                {
                    GetDoublei_v(target, index, data_ptr);
                }
            }
            public static unsafe void DepthRangeArraydvNV(uint first, int count, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    DepthRangeArraydvNV(first, count, v_ptr);
                }
            }
            public static unsafe void WindowPos2dvARB(ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    WindowPos2dvARB(v_ptr);
                }
            }
            public static unsafe void WindowPos2dvARB(double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    WindowPos2dvARB(v_ptr);
                }
            }
            public static unsafe void WindowPos2dvARB(in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    WindowPos2dvARB(v_ptr);
                }
            }
            public static unsafe void WindowPos2fvARB(ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    WindowPos2fvARB(v_ptr);
                }
            }
            public static unsafe void WindowPos2fvARB(float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    WindowPos2fvARB(v_ptr);
                }
            }
            public static unsafe void WindowPos2fvARB(in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    WindowPos2fvARB(v_ptr);
                }
            }
            public static unsafe void WindowPos2ivARB(ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    WindowPos2ivARB(v_ptr);
                }
            }
            public static unsafe void WindowPos2ivARB(int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    WindowPos2ivARB(v_ptr);
                }
            }
            public static unsafe void WindowPos2ivARB(in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    WindowPos2ivARB(v_ptr);
                }
            }
            public static unsafe void WindowPos2svARB(ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    WindowPos2svARB(v_ptr);
                }
            }
            public static unsafe void WindowPos2svARB(short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    WindowPos2svARB(v_ptr);
                }
            }
            public static unsafe void WindowPos2svARB(in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    WindowPos2svARB(v_ptr);
                }
            }
            public static unsafe void WindowPos3dvARB(ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    WindowPos3dvARB(v_ptr);
                }
            }
            public static unsafe void WindowPos3dvARB(double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    WindowPos3dvARB(v_ptr);
                }
            }
            public static unsafe void WindowPos3dvARB(in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    WindowPos3dvARB(v_ptr);
                }
            }
            public static unsafe void WindowPos3fvARB(ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    WindowPos3fvARB(v_ptr);
                }
            }
            public static unsafe void WindowPos3fvARB(float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    WindowPos3fvARB(v_ptr);
                }
            }
            public static unsafe void WindowPos3fvARB(in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    WindowPos3fvARB(v_ptr);
                }
            }
            public static unsafe void WindowPos3ivARB(ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    WindowPos3ivARB(v_ptr);
                }
            }
            public static unsafe void WindowPos3ivARB(int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    WindowPos3ivARB(v_ptr);
                }
            }
            public static unsafe void WindowPos3ivARB(in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    WindowPos3ivARB(v_ptr);
                }
            }
            public static unsafe void WindowPos3svARB(ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    WindowPos3svARB(v_ptr);
                }
            }
            public static unsafe void WindowPos3svARB(short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    WindowPos3svARB(v_ptr);
                }
            }
            public static unsafe void WindowPos3svARB(in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    WindowPos3svARB(v_ptr);
                }
            }
        }
        public static unsafe partial class ATI
        {
            public static unsafe void DrawBuffersATI(ReadOnlySpan<DrawBufferMode> bufs)
            {
                int n = (int)(bufs.Length);
                fixed (DrawBufferMode* bufs_ptr = bufs)
                {
                    DrawBuffersATI(n, bufs_ptr);
                }
            }
            public static unsafe void DrawBuffersATI(DrawBufferMode[] bufs)
            {
                int n = (int)(bufs.Length);
                fixed (DrawBufferMode* bufs_ptr = bufs)
                {
                    DrawBuffersATI(n, bufs_ptr);
                }
            }
            public static unsafe void DrawBuffersATI(int n, in DrawBufferMode bufs)
            {
                fixed (DrawBufferMode* bufs_ptr = &bufs)
                {
                    DrawBuffersATI(n, bufs_ptr);
                }
            }
            public static unsafe void ElementPointerATI(ElementPointerTypeATI type, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                ElementPointerATI(type, pointer_vptr);
            }
            public static unsafe void ElementPointerATI<T1>(ElementPointerTypeATI type, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    ElementPointerATI(type, pointer_ptr);
                }
            }
            public static unsafe void ElementPointerATI<T1>(ElementPointerTypeATI type, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    ElementPointerATI(type, pointer_ptr);
                }
            }
            public static unsafe void ElementPointerATI<T1>(ElementPointerTypeATI type, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    ElementPointerATI(type, pointer_ptr);
                }
            }
            public static unsafe void TexBumpParameterivATI(TexBumpParameterATI pname, ReadOnlySpan<int> param)
            {
                fixed (int* param_ptr = param)
                {
                    TexBumpParameterivATI(pname, param_ptr);
                }
            }
            public static unsafe void TexBumpParameterivATI(TexBumpParameterATI pname, int[] param)
            {
                fixed (int* param_ptr = param)
                {
                    TexBumpParameterivATI(pname, param_ptr);
                }
            }
            public static unsafe void TexBumpParameterivATI(TexBumpParameterATI pname, in int param)
            {
                fixed (int* param_ptr = &param)
                {
                    TexBumpParameterivATI(pname, param_ptr);
                }
            }
            public static unsafe void TexBumpParameterfvATI(TexBumpParameterATI pname, ReadOnlySpan<float> param)
            {
                fixed (float* param_ptr = param)
                {
                    TexBumpParameterfvATI(pname, param_ptr);
                }
            }
            public static unsafe void TexBumpParameterfvATI(TexBumpParameterATI pname, float[] param)
            {
                fixed (float* param_ptr = param)
                {
                    TexBumpParameterfvATI(pname, param_ptr);
                }
            }
            public static unsafe void TexBumpParameterfvATI(TexBumpParameterATI pname, in float param)
            {
                fixed (float* param_ptr = &param)
                {
                    TexBumpParameterfvATI(pname, param_ptr);
                }
            }
            public static unsafe void GetTexBumpParameterivATI(GetTexBumpParameterATI pname, Span<int> param)
            {
                fixed (int* param_ptr = param)
                {
                    GetTexBumpParameterivATI(pname, param_ptr);
                }
            }
            public static unsafe void GetTexBumpParameterivATI(GetTexBumpParameterATI pname, int[] param)
            {
                fixed (int* param_ptr = param)
                {
                    GetTexBumpParameterivATI(pname, param_ptr);
                }
            }
            public static unsafe void GetTexBumpParameterivATI(GetTexBumpParameterATI pname, ref int param)
            {
                fixed (int* param_ptr = &param)
                {
                    GetTexBumpParameterivATI(pname, param_ptr);
                }
            }
            public static unsafe void GetTexBumpParameterfvATI(GetTexBumpParameterATI pname, Span<float> param)
            {
                fixed (float* param_ptr = param)
                {
                    GetTexBumpParameterfvATI(pname, param_ptr);
                }
            }
            public static unsafe void GetTexBumpParameterfvATI(GetTexBumpParameterATI pname, float[] param)
            {
                fixed (float* param_ptr = param)
                {
                    GetTexBumpParameterfvATI(pname, param_ptr);
                }
            }
            public static unsafe void GetTexBumpParameterfvATI(GetTexBumpParameterATI pname, ref float param)
            {
                fixed (float* param_ptr = &param)
                {
                    GetTexBumpParameterfvATI(pname, param_ptr);
                }
            }
            public static unsafe void SetFragmentShaderConstantATI(uint dst, ReadOnlySpan<float> value)
            {
                fixed (float* value_ptr = value)
                {
                    SetFragmentShaderConstantATI(dst, value_ptr);
                }
            }
            public static unsafe void SetFragmentShaderConstantATI(uint dst, float[] value)
            {
                fixed (float* value_ptr = value)
                {
                    SetFragmentShaderConstantATI(dst, value_ptr);
                }
            }
            public static unsafe void SetFragmentShaderConstantATI(uint dst, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    SetFragmentShaderConstantATI(dst, value_ptr);
                }
            }
            public static unsafe uint NewObjectBufferATI(int size, IntPtr pointer, ArrayObjectUsageATI usage)
            {
                uint returnValue;
                void* pointer_vptr = (void*)pointer;
                returnValue = NewObjectBufferATI(size, pointer_vptr, usage);
                return returnValue;
            }
            public static unsafe uint NewObjectBufferATI<T1>(ReadOnlySpan<T1> pointer, ArrayObjectUsageATI usage)
                where T1 : unmanaged
            {
                uint returnValue;
                int size = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    returnValue = NewObjectBufferATI(size, pointer_ptr, usage);
                }
                return returnValue;
            }
            public static unsafe uint NewObjectBufferATI<T1>(T1[] pointer, ArrayObjectUsageATI usage)
                where T1 : unmanaged
            {
                uint returnValue;
                int size = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    returnValue = NewObjectBufferATI(size, pointer_ptr, usage);
                }
                return returnValue;
            }
            public static unsafe uint NewObjectBufferATI<T1>(int size, in T1 pointer, ArrayObjectUsageATI usage)
                where T1 : unmanaged
            {
                uint returnValue;
                fixed (void* pointer_ptr = &pointer)
                {
                    returnValue = NewObjectBufferATI(size, pointer_ptr, usage);
                }
                return returnValue;
            }
            public static unsafe void UpdateObjectBufferATI(BufferHandle buffer, uint offset, int size, IntPtr pointer, PreserveModeATI preserve)
            {
                void* pointer_vptr = (void*)pointer;
                UpdateObjectBufferATI(buffer, offset, size, pointer_vptr, preserve);
            }
            public static unsafe void UpdateObjectBufferATI<T1>(BufferHandle buffer, uint offset, ReadOnlySpan<T1> pointer, PreserveModeATI preserve)
                where T1 : unmanaged
            {
                int size = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    UpdateObjectBufferATI(buffer, offset, size, pointer_ptr, preserve);
                }
            }
            public static unsafe void UpdateObjectBufferATI<T1>(BufferHandle buffer, uint offset, T1[] pointer, PreserveModeATI preserve)
                where T1 : unmanaged
            {
                int size = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    UpdateObjectBufferATI(buffer, offset, size, pointer_ptr, preserve);
                }
            }
            public static unsafe void UpdateObjectBufferATI<T1>(BufferHandle buffer, uint offset, int size, in T1 pointer, PreserveModeATI preserve)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    UpdateObjectBufferATI(buffer, offset, size, pointer_ptr, preserve);
                }
            }
            public static unsafe void GetObjectBufferfvATI(BufferHandle buffer, ArrayObjectPNameATI pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetObjectBufferfvATI(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetObjectBufferfvATI(BufferHandle buffer, ArrayObjectPNameATI pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetObjectBufferfvATI(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetObjectBufferfvATI(BufferHandle buffer, ArrayObjectPNameATI pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetObjectBufferfvATI(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetObjectBufferivATI(BufferHandle buffer, ArrayObjectPNameATI pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetObjectBufferivATI(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetObjectBufferivATI(BufferHandle buffer, ArrayObjectPNameATI pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetObjectBufferivATI(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetObjectBufferivATI(BufferHandle buffer, ArrayObjectPNameATI pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetObjectBufferivATI(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetArrayObjectfvATI(EnableCap array, ArrayObjectPNameATI pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetArrayObjectfvATI(array, pname, parameters_ptr);
                }
            }
            public static unsafe void GetArrayObjectfvATI(EnableCap array, ArrayObjectPNameATI pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetArrayObjectfvATI(array, pname, parameters_ptr);
                }
            }
            public static unsafe void GetArrayObjectfvATI(EnableCap array, ArrayObjectPNameATI pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetArrayObjectfvATI(array, pname, parameters_ptr);
                }
            }
            public static unsafe void GetArrayObjectivATI(EnableCap array, ArrayObjectPNameATI pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetArrayObjectivATI(array, pname, parameters_ptr);
                }
            }
            public static unsafe void GetArrayObjectivATI(EnableCap array, ArrayObjectPNameATI pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetArrayObjectivATI(array, pname, parameters_ptr);
                }
            }
            public static unsafe void GetArrayObjectivATI(EnableCap array, ArrayObjectPNameATI pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetArrayObjectivATI(array, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVariantArrayObjectfvATI(uint id, ArrayObjectPNameATI pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetVariantArrayObjectfvATI(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVariantArrayObjectfvATI(uint id, ArrayObjectPNameATI pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetVariantArrayObjectfvATI(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVariantArrayObjectfvATI(uint id, ArrayObjectPNameATI pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetVariantArrayObjectfvATI(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVariantArrayObjectivATI(uint id, ArrayObjectPNameATI pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVariantArrayObjectivATI(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVariantArrayObjectivATI(uint id, ArrayObjectPNameATI pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVariantArrayObjectivATI(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVariantArrayObjectivATI(uint id, ArrayObjectPNameATI pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetVariantArrayObjectivATI(id, pname, parameters_ptr);
                }
            }
            public static unsafe void VertexAttribArrayObjectATI(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, BufferHandle buffer, uint offset)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribArrayObjectATI(index, size, type, normalized_byte, stride, buffer, offset);
            }
            public static unsafe void GetVertexAttribArrayObjectfvATI(uint index, ArrayObjectPNameATI pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetVertexAttribArrayObjectfvATI(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribArrayObjectfvATI(uint index, ArrayObjectPNameATI pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetVertexAttribArrayObjectfvATI(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribArrayObjectfvATI(uint index, ArrayObjectPNameATI pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetVertexAttribArrayObjectfvATI(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribArrayObjectivATI(uint index, ArrayObjectPNameATI pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVertexAttribArrayObjectivATI(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribArrayObjectivATI(uint index, ArrayObjectPNameATI pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVertexAttribArrayObjectivATI(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribArrayObjectivATI(uint index, ArrayObjectPNameATI pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetVertexAttribArrayObjectivATI(index, pname, parameters_ptr);
                }
            }
            public static unsafe void VertexStream1svATI(VertexStreamATI stream, ReadOnlySpan<short> coords)
            {
                fixed (short* coords_ptr = coords)
                {
                    VertexStream1svATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream1svATI(VertexStreamATI stream, short[] coords)
            {
                fixed (short* coords_ptr = coords)
                {
                    VertexStream1svATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream1svATI(VertexStreamATI stream, in short coords)
            {
                fixed (short* coords_ptr = &coords)
                {
                    VertexStream1svATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream1ivATI(VertexStreamATI stream, ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    VertexStream1ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream1ivATI(VertexStreamATI stream, int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    VertexStream1ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream1ivATI(VertexStreamATI stream, in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    VertexStream1ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream1fvATI(VertexStreamATI stream, ReadOnlySpan<float> coords)
            {
                fixed (float* coords_ptr = coords)
                {
                    VertexStream1fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream1fvATI(VertexStreamATI stream, float[] coords)
            {
                fixed (float* coords_ptr = coords)
                {
                    VertexStream1fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream1fvATI(VertexStreamATI stream, in float coords)
            {
                fixed (float* coords_ptr = &coords)
                {
                    VertexStream1fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream1dvATI(VertexStreamATI stream, ReadOnlySpan<double> coords)
            {
                fixed (double* coords_ptr = coords)
                {
                    VertexStream1dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream1dvATI(VertexStreamATI stream, double[] coords)
            {
                fixed (double* coords_ptr = coords)
                {
                    VertexStream1dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream1dvATI(VertexStreamATI stream, in double coords)
            {
                fixed (double* coords_ptr = &coords)
                {
                    VertexStream1dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream2svATI(VertexStreamATI stream, ReadOnlySpan<short> coords)
            {
                fixed (short* coords_ptr = coords)
                {
                    VertexStream2svATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream2svATI(VertexStreamATI stream, short[] coords)
            {
                fixed (short* coords_ptr = coords)
                {
                    VertexStream2svATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream2svATI(VertexStreamATI stream, in short coords)
            {
                fixed (short* coords_ptr = &coords)
                {
                    VertexStream2svATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream2ivATI(VertexStreamATI stream, ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    VertexStream2ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream2ivATI(VertexStreamATI stream, int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    VertexStream2ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream2ivATI(VertexStreamATI stream, in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    VertexStream2ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream2fvATI(VertexStreamATI stream, ReadOnlySpan<float> coords)
            {
                fixed (float* coords_ptr = coords)
                {
                    VertexStream2fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream2fvATI(VertexStreamATI stream, float[] coords)
            {
                fixed (float* coords_ptr = coords)
                {
                    VertexStream2fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream2fvATI(VertexStreamATI stream, in float coords)
            {
                fixed (float* coords_ptr = &coords)
                {
                    VertexStream2fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream2dvATI(VertexStreamATI stream, ReadOnlySpan<double> coords)
            {
                fixed (double* coords_ptr = coords)
                {
                    VertexStream2dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream2dvATI(VertexStreamATI stream, double[] coords)
            {
                fixed (double* coords_ptr = coords)
                {
                    VertexStream2dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream2dvATI(VertexStreamATI stream, in double coords)
            {
                fixed (double* coords_ptr = &coords)
                {
                    VertexStream2dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream3svATI(VertexStreamATI stream, ReadOnlySpan<short> coords)
            {
                fixed (short* coords_ptr = coords)
                {
                    VertexStream3svATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream3svATI(VertexStreamATI stream, short[] coords)
            {
                fixed (short* coords_ptr = coords)
                {
                    VertexStream3svATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream3svATI(VertexStreamATI stream, in short coords)
            {
                fixed (short* coords_ptr = &coords)
                {
                    VertexStream3svATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream3ivATI(VertexStreamATI stream, ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    VertexStream3ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream3ivATI(VertexStreamATI stream, int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    VertexStream3ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream3ivATI(VertexStreamATI stream, in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    VertexStream3ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream3fvATI(VertexStreamATI stream, ReadOnlySpan<float> coords)
            {
                fixed (float* coords_ptr = coords)
                {
                    VertexStream3fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream3fvATI(VertexStreamATI stream, float[] coords)
            {
                fixed (float* coords_ptr = coords)
                {
                    VertexStream3fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream3fvATI(VertexStreamATI stream, in float coords)
            {
                fixed (float* coords_ptr = &coords)
                {
                    VertexStream3fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream3dvATI(VertexStreamATI stream, ReadOnlySpan<double> coords)
            {
                fixed (double* coords_ptr = coords)
                {
                    VertexStream3dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream3dvATI(VertexStreamATI stream, double[] coords)
            {
                fixed (double* coords_ptr = coords)
                {
                    VertexStream3dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream3dvATI(VertexStreamATI stream, in double coords)
            {
                fixed (double* coords_ptr = &coords)
                {
                    VertexStream3dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream4svATI(VertexStreamATI stream, ReadOnlySpan<short> coords)
            {
                fixed (short* coords_ptr = coords)
                {
                    VertexStream4svATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream4svATI(VertexStreamATI stream, short[] coords)
            {
                fixed (short* coords_ptr = coords)
                {
                    VertexStream4svATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream4svATI(VertexStreamATI stream, in short coords)
            {
                fixed (short* coords_ptr = &coords)
                {
                    VertexStream4svATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream4ivATI(VertexStreamATI stream, ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    VertexStream4ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream4ivATI(VertexStreamATI stream, int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    VertexStream4ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream4ivATI(VertexStreamATI stream, in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    VertexStream4ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream4fvATI(VertexStreamATI stream, ReadOnlySpan<float> coords)
            {
                fixed (float* coords_ptr = coords)
                {
                    VertexStream4fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream4fvATI(VertexStreamATI stream, float[] coords)
            {
                fixed (float* coords_ptr = coords)
                {
                    VertexStream4fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream4fvATI(VertexStreamATI stream, in float coords)
            {
                fixed (float* coords_ptr = &coords)
                {
                    VertexStream4fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream4dvATI(VertexStreamATI stream, ReadOnlySpan<double> coords)
            {
                fixed (double* coords_ptr = coords)
                {
                    VertexStream4dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream4dvATI(VertexStreamATI stream, double[] coords)
            {
                fixed (double* coords_ptr = coords)
                {
                    VertexStream4dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void VertexStream4dvATI(VertexStreamATI stream, in double coords)
            {
                fixed (double* coords_ptr = &coords)
                {
                    VertexStream4dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3bvATI(VertexStreamATI stream, ReadOnlySpan<sbyte> coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    NormalStream3bvATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3bvATI(VertexStreamATI stream, sbyte[] coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    NormalStream3bvATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3bvATI(VertexStreamATI stream, in sbyte coords)
            {
                fixed (sbyte* coords_ptr = &coords)
                {
                    NormalStream3bvATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3svATI(VertexStreamATI stream, ReadOnlySpan<short> coords)
            {
                fixed (short* coords_ptr = coords)
                {
                    NormalStream3svATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3svATI(VertexStreamATI stream, short[] coords)
            {
                fixed (short* coords_ptr = coords)
                {
                    NormalStream3svATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3svATI(VertexStreamATI stream, in short coords)
            {
                fixed (short* coords_ptr = &coords)
                {
                    NormalStream3svATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3ivATI(VertexStreamATI stream, ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    NormalStream3ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3ivATI(VertexStreamATI stream, int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    NormalStream3ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3ivATI(VertexStreamATI stream, in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    NormalStream3ivATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3fvATI(VertexStreamATI stream, ReadOnlySpan<float> coords)
            {
                fixed (float* coords_ptr = coords)
                {
                    NormalStream3fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3fvATI(VertexStreamATI stream, float[] coords)
            {
                fixed (float* coords_ptr = coords)
                {
                    NormalStream3fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3fvATI(VertexStreamATI stream, in float coords)
            {
                fixed (float* coords_ptr = &coords)
                {
                    NormalStream3fvATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3dvATI(VertexStreamATI stream, ReadOnlySpan<double> coords)
            {
                fixed (double* coords_ptr = coords)
                {
                    NormalStream3dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3dvATI(VertexStreamATI stream, double[] coords)
            {
                fixed (double* coords_ptr = coords)
                {
                    NormalStream3dvATI(stream, coords_ptr);
                }
            }
            public static unsafe void NormalStream3dvATI(VertexStreamATI stream, in double coords)
            {
                fixed (double* coords_ptr = &coords)
                {
                    NormalStream3dvATI(stream, coords_ptr);
                }
            }
        }
        public static unsafe partial class EXT
        {
            public static unsafe void EGLImageTargetTexStorageEXT(All target, IntPtr image, in int attrib_list)
            {
                fixed (int* attrib_list_ptr = &attrib_list)
                {
                    void* image_vptr = (void*)image;
                    EGLImageTargetTexStorageEXT(target, image_vptr, attrib_list_ptr);
                }
            }
            public static unsafe void EGLImageTargetTexStorageEXT<T1>(All target, ref T1 image, in int attrib_list)
                where T1 : unmanaged
            {
                fixed (void* image_ptr = &image)
                fixed (int* attrib_list_ptr = &attrib_list)
                {
                    EGLImageTargetTexStorageEXT(target, image_ptr, attrib_list_ptr);
                }
            }
            public static unsafe void EGLImageTargetTextureStorageEXT(TextureHandle texture, IntPtr image, in int attrib_list)
            {
                fixed (int* attrib_list_ptr = &attrib_list)
                {
                    void* image_vptr = (void*)image;
                    EGLImageTargetTextureStorageEXT(texture, image_vptr, attrib_list_ptr);
                }
            }
            public static unsafe void EGLImageTargetTextureStorageEXT<T1>(TextureHandle texture, ref T1 image, in int attrib_list)
                where T1 : unmanaged
            {
                fixed (void* image_ptr = &image)
                fixed (int* attrib_list_ptr = &attrib_list)
                {
                    EGLImageTargetTextureStorageEXT(texture, image_ptr, attrib_list_ptr);
                }
            }
            public static unsafe void ColorSubTableEXT(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, IntPtr data)
            {
                void* data_vptr = (void*)data;
                ColorSubTableEXT(target, start, count, format, type, data_vptr);
            }
            public static unsafe void ColorSubTableEXT<T1>(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ColorSubTableEXT(target, start, count, format, type, data_ptr);
                }
            }
            public static unsafe void ColorSubTableEXT<T1>(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, T1[] data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ColorSubTableEXT(target, start, count, format, type, data_ptr);
                }
            }
            public static unsafe void ColorSubTableEXT<T1>(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    ColorSubTableEXT(target, start, count, format, type, data_ptr);
                }
            }
            public static unsafe void ConvolutionFilter1DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, IntPtr image)
            {
                void* image_vptr = (void*)image;
                ConvolutionFilter1DEXT(target, internalformat, width, format, type, image_vptr);
            }
            public static unsafe void ConvolutionFilter1DEXT<T1>(ConvolutionTargetEXT target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, ReadOnlySpan<T1> image)
                where T1 : unmanaged
            {
                fixed (void* image_ptr = image)
                {
                    ConvolutionFilter1DEXT(target, internalformat, width, format, type, image_ptr);
                }
            }
            public static unsafe void ConvolutionFilter1DEXT<T1>(ConvolutionTargetEXT target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, T1[] image)
                where T1 : unmanaged
            {
                fixed (void* image_ptr = image)
                {
                    ConvolutionFilter1DEXT(target, internalformat, width, format, type, image_ptr);
                }
            }
            public static unsafe void ConvolutionFilter1DEXT<T1>(ConvolutionTargetEXT target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, in T1 image)
                where T1 : unmanaged
            {
                fixed (void* image_ptr = &image)
                {
                    ConvolutionFilter1DEXT(target, internalformat, width, format, type, image_ptr);
                }
            }
            public static unsafe void ConvolutionFilter2DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, IntPtr image)
            {
                void* image_vptr = (void*)image;
                ConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image_vptr);
            }
            public static unsafe void ConvolutionFilter2DEXT<T1>(ConvolutionTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, ReadOnlySpan<T1> image)
                where T1 : unmanaged
            {
                fixed (void* image_ptr = image)
                {
                    ConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image_ptr);
                }
            }
            public static unsafe void ConvolutionFilter2DEXT<T1>(ConvolutionTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, T1[] image)
                where T1 : unmanaged
            {
                fixed (void* image_ptr = image)
                {
                    ConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image_ptr);
                }
            }
            public static unsafe void ConvolutionFilter2DEXT<T1>(ConvolutionTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, in T1 image)
                where T1 : unmanaged
            {
                fixed (void* image_ptr = &image)
                {
                    ConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image_ptr);
                }
            }
            public static unsafe void ConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ConvolutionParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ConvolutionParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    ConvolutionParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ConvolutionParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ConvolutionParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    ConvolutionParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetConvolutionFilterEXT(ConvolutionTargetEXT target, PixelFormat format, PixelType type, IntPtr image)
            {
                void* image_vptr = (void*)image;
                GetConvolutionFilterEXT(target, format, type, image_vptr);
            }
            public static unsafe void GetConvolutionFilterEXT<T1>(ConvolutionTargetEXT target, PixelFormat format, PixelType type, Span<T1> image)
                where T1 : unmanaged
            {
                fixed (void* image_ptr = image)
                {
                    GetConvolutionFilterEXT(target, format, type, image_ptr);
                }
            }
            public static unsafe void GetConvolutionFilterEXT<T1>(ConvolutionTargetEXT target, PixelFormat format, PixelType type, T1[] image)
                where T1 : unmanaged
            {
                fixed (void* image_ptr = image)
                {
                    GetConvolutionFilterEXT(target, format, type, image_ptr);
                }
            }
            public static unsafe void GetConvolutionFilterEXT<T1>(ConvolutionTargetEXT target, PixelFormat format, PixelType type, ref T1 image)
                where T1 : unmanaged
            {
                fixed (void* image_ptr = &image)
                {
                    GetConvolutionFilterEXT(target, format, type, image_ptr);
                }
            }
            public static unsafe void GetConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetConvolutionParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetConvolutionParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetConvolutionParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetConvolutionParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetConvolutionParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetConvolutionParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSeparableFilterEXT(SeparableTargetEXT target, PixelFormat format, PixelType type, IntPtr row, IntPtr column, IntPtr span)
            {
                void* row_vptr = (void*)row;
                void* column_vptr = (void*)column;
                void* span_vptr = (void*)span;
                GetSeparableFilterEXT(target, format, type, row_vptr, column_vptr, span_vptr);
            }
            public static unsafe void GetSeparableFilterEXT<T1, T2, T3>(SeparableTargetEXT target, PixelFormat format, PixelType type, Span<T3> row, Span<T2> column, Span<T1> span)
                where T1 : unmanaged
                where T2 : unmanaged
                where T3 : unmanaged
            {
                fixed (void* row_ptr = row)
                {
                    fixed (void* column_ptr = column)
                    {
                        fixed (void* span_ptr = span)
                        {
                            GetSeparableFilterEXT(target, format, type, row_ptr, column_ptr, span_ptr);
                        }
                    }
                }
            }
            public static unsafe void GetSeparableFilterEXT<T1, T2, T3>(SeparableTargetEXT target, PixelFormat format, PixelType type, T3[] row, T2[] column, T1[] span)
                where T1 : unmanaged
                where T2 : unmanaged
                where T3 : unmanaged
            {
                fixed (void* row_ptr = row)
                {
                    fixed (void* column_ptr = column)
                    {
                        fixed (void* span_ptr = span)
                        {
                            GetSeparableFilterEXT(target, format, type, row_ptr, column_ptr, span_ptr);
                        }
                    }
                }
            }
            public static unsafe void GetSeparableFilterEXT<T1, T2, T3>(SeparableTargetEXT target, PixelFormat format, PixelType type, ref T1 row, ref T2 column, ref T3 span)
                where T1 : unmanaged
                where T2 : unmanaged
                where T3 : unmanaged
            {
                fixed (void* row_ptr = &row)
                fixed (void* column_ptr = &column)
                fixed (void* span_ptr = &span)
                {
                    GetSeparableFilterEXT(target, format, type, row_ptr, column_ptr, span_ptr);
                }
            }
            public static unsafe void SeparableFilter2DEXT(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, IntPtr row, IntPtr column)
            {
                void* row_vptr = (void*)row;
                void* column_vptr = (void*)column;
                SeparableFilter2DEXT(target, internalformat, width, height, format, type, row_vptr, column_vptr);
            }
            public static unsafe void SeparableFilter2DEXT<T1, T2>(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, ReadOnlySpan<T2> row, ReadOnlySpan<T1> column)
                where T1 : unmanaged
                where T2 : unmanaged
            {
                fixed (void* row_ptr = row)
                {
                    fixed (void* column_ptr = column)
                    {
                        SeparableFilter2DEXT(target, internalformat, width, height, format, type, row_ptr, column_ptr);
                    }
                }
            }
            public static unsafe void SeparableFilter2DEXT<T1, T2>(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, T2[] row, T1[] column)
                where T1 : unmanaged
                where T2 : unmanaged
            {
                fixed (void* row_ptr = row)
                {
                    fixed (void* column_ptr = column)
                    {
                        SeparableFilter2DEXT(target, internalformat, width, height, format, type, row_ptr, column_ptr);
                    }
                }
            }
            public static unsafe void SeparableFilter2DEXT<T1, T2>(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, in T1 row, in T2 column)
                where T1 : unmanaged
                where T2 : unmanaged
            {
                fixed (void* row_ptr = &row)
                fixed (void* column_ptr = &column)
                {
                    SeparableFilter2DEXT(target, internalformat, width, height, format, type, row_ptr, column_ptr);
                }
            }
            public static unsafe void Tangent3bvEXT(ReadOnlySpan<sbyte> v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    Tangent3bvEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3bvEXT(sbyte[] v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    Tangent3bvEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3bvEXT(in sbyte v)
            {
                fixed (sbyte* v_ptr = &v)
                {
                    Tangent3bvEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3dvEXT(ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    Tangent3dvEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3dvEXT(double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    Tangent3dvEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3dvEXT(in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    Tangent3dvEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3fvEXT(ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    Tangent3fvEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3fvEXT(float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    Tangent3fvEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3fvEXT(in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    Tangent3fvEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3ivEXT(ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    Tangent3ivEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3ivEXT(int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    Tangent3ivEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3ivEXT(in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    Tangent3ivEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3svEXT(ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    Tangent3svEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3svEXT(short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    Tangent3svEXT(v_ptr);
                }
            }
            public static unsafe void Tangent3svEXT(in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    Tangent3svEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3bvEXT(ReadOnlySpan<sbyte> v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    Binormal3bvEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3bvEXT(sbyte[] v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    Binormal3bvEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3bvEXT(in sbyte v)
            {
                fixed (sbyte* v_ptr = &v)
                {
                    Binormal3bvEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3dvEXT(ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    Binormal3dvEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3dvEXT(double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    Binormal3dvEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3dvEXT(in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    Binormal3dvEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3fvEXT(ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    Binormal3fvEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3fvEXT(float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    Binormal3fvEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3fvEXT(in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    Binormal3fvEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3ivEXT(ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    Binormal3ivEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3ivEXT(int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    Binormal3ivEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3ivEXT(in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    Binormal3ivEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3svEXT(ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    Binormal3svEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3svEXT(short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    Binormal3svEXT(v_ptr);
                }
            }
            public static unsafe void Binormal3svEXT(in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    Binormal3svEXT(v_ptr);
                }
            }
            public static unsafe void TangentPointerEXT(TangentPointerTypeEXT type, int stride, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                TangentPointerEXT(type, stride, pointer_vptr);
            }
            public static unsafe void TangentPointerEXT<T1>(TangentPointerTypeEXT type, int stride, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    TangentPointerEXT(type, stride, pointer_ptr);
                }
            }
            public static unsafe void TangentPointerEXT<T1>(TangentPointerTypeEXT type, int stride, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    TangentPointerEXT(type, stride, pointer_ptr);
                }
            }
            public static unsafe void TangentPointerEXT<T1>(TangentPointerTypeEXT type, int stride, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    TangentPointerEXT(type, stride, pointer_ptr);
                }
            }
            public static unsafe void BinormalPointerEXT(BinormalPointerTypeEXT type, int stride, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                BinormalPointerEXT(type, stride, pointer_vptr);
            }
            public static unsafe void BinormalPointerEXT<T1>(BinormalPointerTypeEXT type, int stride, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    BinormalPointerEXT(type, stride, pointer_ptr);
                }
            }
            public static unsafe void BinormalPointerEXT<T1>(BinormalPointerTypeEXT type, int stride, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    BinormalPointerEXT(type, stride, pointer_ptr);
                }
            }
            public static unsafe void BinormalPointerEXT<T1>(BinormalPointerTypeEXT type, int stride, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    BinormalPointerEXT(type, stride, pointer_ptr);
                }
            }
            public static unsafe void CullParameterdvEXT(CullParameterEXT pname, Span<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    CullParameterdvEXT(pname, parameters_ptr);
                }
            }
            public static unsafe void CullParameterdvEXT(CullParameterEXT pname, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    CullParameterdvEXT(pname, parameters_ptr);
                }
            }
            public static unsafe void CullParameterdvEXT(CullParameterEXT pname, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    CullParameterdvEXT(pname, parameters_ptr);
                }
            }
            public static unsafe void CullParameterfvEXT(CullParameterEXT pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    CullParameterfvEXT(pname, parameters_ptr);
                }
            }
            public static unsafe void CullParameterfvEXT(CullParameterEXT pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    CullParameterfvEXT(pname, parameters_ptr);
                }
            }
            public static unsafe void CullParameterfvEXT(CullParameterEXT pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    CullParameterfvEXT(pname, parameters_ptr);
                }
            }
            public static unsafe void LabelObjectEXT(All type, uint obj, int length, string label)
            {
                byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
                LabelObjectEXT(type, obj, length, label_ptr);
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            public static unsafe string GetObjectLabelEXT(All type, uint obj, int bufSize, Span<int> length)
            {
                string label;
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabelEXT(type, obj, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectLabelEXT(All type, uint obj, int bufSize, Span<int> length, out string label)
            {
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabelEXT(type, obj, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe string GetObjectLabelEXT(All type, uint obj, int bufSize, int[] length)
            {
                string label;
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabelEXT(type, obj, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectLabelEXT(All type, uint obj, int bufSize, int[] length, out string label)
            {
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabelEXT(type, obj, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe string GetObjectLabelEXT(All type, uint obj, int bufSize, ref int length)
            {
                string label;
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabelEXT(type, obj, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectLabelEXT(All type, uint obj, int bufSize, ref int length, out string label)
            {
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabelEXT(type, obj, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe void InsertEventMarkerEXT(int length, string marker)
            {
                byte* marker_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(marker);
                InsertEventMarkerEXT(length, marker_ptr);
                Marshal.FreeCoTaskMem((IntPtr)marker_ptr);
            }
            public static unsafe void PushGroupMarkerEXT(int length, string marker)
            {
                byte* marker_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(marker);
                PushGroupMarkerEXT(length, marker_ptr);
                Marshal.FreeCoTaskMem((IntPtr)marker_ptr);
            }
            public static unsafe void MatrixLoadfEXT(MatrixMode mode, ReadOnlySpan<float> m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixLoadfEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadfEXT(MatrixMode mode, float[] m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixLoadfEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadfEXT(MatrixMode mode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixLoadfEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoaddEXT(MatrixMode mode, ReadOnlySpan<double> m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixLoaddEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoaddEXT(MatrixMode mode, double[] m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixLoaddEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoaddEXT(MatrixMode mode, in double m)
            {
                fixed (double* m_ptr = &m)
                {
                    MatrixLoaddEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultfEXT(MatrixMode mode, ReadOnlySpan<float> m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixMultfEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultfEXT(MatrixMode mode, float[] m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixMultfEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultfEXT(MatrixMode mode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixMultfEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultdEXT(MatrixMode mode, ReadOnlySpan<double> m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixMultdEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultdEXT(MatrixMode mode, double[] m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixMultdEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultdEXT(MatrixMode mode, in double m)
            {
                fixed (double* m_ptr = &m)
                {
                    MatrixMultdEXT(mode, m_ptr);
                }
            }
            public static unsafe void TextureParameterfvEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    TextureParameterfvEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureParameterfvEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    TextureParameterfvEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureParameterfvEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    TextureParameterfvEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureParameterivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    TextureParameterivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureParameterivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    TextureParameterivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureParameterivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    TextureParameterivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureImage1DEXT(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TextureImage1DEXT(texture, target, level, internalformat, width, border, format, type, pixels_vptr);
            }
            public static unsafe void TextureImage1DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TextureImage1DEXT(texture, target, level, internalformat, width, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureImage1DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TextureImage1DEXT(texture, target, level, internalformat, width, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureImage1DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TextureImage1DEXT(texture, target, level, internalformat, width, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureImage2DEXT(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, type, pixels_vptr);
            }
            public static unsafe void TextureImage2DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureImage2DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureImage2DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureSubImage1DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TextureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels_vptr);
            }
            public static unsafe void TextureSubImage1DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TextureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureSubImage1DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TextureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureSubImage1DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TextureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureSubImage2DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels_vptr);
            }
            public static unsafe void TextureSubImage2DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureSubImage2DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureSubImage2DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
                }
            }
            public static unsafe void GetTextureImageEXT(TextureHandle texture, TextureTarget target, int level, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                GetTextureImageEXT(texture, target, level, format, type, pixels_vptr);
            }
            public static unsafe void GetTextureImageEXT<T1>(TextureHandle texture, TextureTarget target, int level, PixelFormat format, PixelType type, Span<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    GetTextureImageEXT(texture, target, level, format, type, pixels_ptr);
                }
            }
            public static unsafe void GetTextureImageEXT<T1>(TextureHandle texture, TextureTarget target, int level, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    GetTextureImageEXT(texture, target, level, format, type, pixels_ptr);
                }
            }
            public static unsafe void GetTextureImageEXT<T1>(TextureHandle texture, TextureTarget target, int level, PixelFormat format, PixelType type, ref T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    GetTextureImageEXT(texture, target, level, format, type, pixels_ptr);
                }
            }
            public static unsafe void GetTextureParameterfvEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetTextureParameterfvEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterfvEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetTextureParameterfvEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterfvEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetTextureParameterfvEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTextureParameterivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTextureParameterivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetTextureParameterivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureLevelParameterfvEXT(TextureHandle texture, TextureTarget target, int level, GetTextureParameter pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetTextureLevelParameterfvEXT(texture, target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureLevelParameterfvEXT(TextureHandle texture, TextureTarget target, int level, GetTextureParameter pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetTextureLevelParameterfvEXT(texture, target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureLevelParameterfvEXT(TextureHandle texture, TextureTarget target, int level, GetTextureParameter pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetTextureLevelParameterfvEXT(texture, target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureLevelParameterivEXT(TextureHandle texture, TextureTarget target, int level, GetTextureParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTextureLevelParameterivEXT(texture, target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureLevelParameterivEXT(TextureHandle texture, TextureTarget target, int level, GetTextureParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTextureLevelParameterivEXT(texture, target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureLevelParameterivEXT(TextureHandle texture, TextureTarget target, int level, GetTextureParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetTextureLevelParameterivEXT(texture, target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureImage3DEXT(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, type, pixels_vptr);
            }
            public static unsafe void TextureImage3DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureImage3DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureImage3DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureSubImage3DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_vptr);
            }
            public static unsafe void TextureSubImage3DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureSubImage3DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureSubImage3DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexCoordPointerEXT(TextureUnit texunit, int size, TexCoordPointerType type, int stride, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                MultiTexCoordPointerEXT(texunit, size, type, stride, pointer_vptr);
            }
            public static unsafe void MultiTexCoordPointerEXT<T1>(TextureUnit texunit, int size, TexCoordPointerType type, int stride, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    MultiTexCoordPointerEXT(texunit, size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void MultiTexCoordPointerEXT<T1>(TextureUnit texunit, int size, TexCoordPointerType type, int stride, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    MultiTexCoordPointerEXT(texunit, size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void MultiTexCoordPointerEXT<T1>(TextureUnit texunit, int size, TexCoordPointerType type, int stride, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    MultiTexCoordPointerEXT(texunit, size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void MultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    MultiTexEnvfvEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    MultiTexEnvfvEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    MultiTexEnvfvEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    MultiTexEnvivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    MultiTexEnvivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    MultiTexEnvivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, ReadOnlySpan<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    MultiTexGendvEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    MultiTexGendvEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, in double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    MultiTexGendvEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    MultiTexGenfvEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    MultiTexGenfvEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    MultiTexGenfvEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    MultiTexGenivEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    MultiTexGenivEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    MultiTexGenivEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMultiTexEnvfvEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMultiTexEnvfvEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetMultiTexEnvfvEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMultiTexEnvivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMultiTexEnvivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetMultiTexEnvivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, Span<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetMultiTexGendvEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetMultiTexGendvEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    GetMultiTexGendvEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMultiTexGenfvEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMultiTexGenfvEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetMultiTexGenfvEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMultiTexGenivEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMultiTexGenivEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetMultiTexGenivEXT(texunit, coord, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    MultiTexParameterivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    MultiTexParameterivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    MultiTexParameterivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    MultiTexParameterfvEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    MultiTexParameterfvEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    MultiTexParameterfvEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                MultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, type, pixels_vptr);
            }
            public static unsafe void MultiTexImage1DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    MultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexImage1DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    MultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexImage1DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    MultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                MultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, type, pixels_vptr);
            }
            public static unsafe void MultiTexImage2DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    MultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexImage2DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    MultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexImage2DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    MultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                MultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels_vptr);
            }
            public static unsafe void MultiTexSubImage1DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    MultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexSubImage1DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    MultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexSubImage1DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    MultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                MultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels_vptr);
            }
            public static unsafe void MultiTexSubImage2DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    MultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexSubImage2DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    MultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexSubImage2DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    MultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
                }
            }
            public static unsafe void GetMultiTexImageEXT(TextureUnit texunit, TextureTarget target, int level, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                GetMultiTexImageEXT(texunit, target, level, format, type, pixels_vptr);
            }
            public static unsafe void GetMultiTexImageEXT<T1>(TextureUnit texunit, TextureTarget target, int level, PixelFormat format, PixelType type, Span<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    GetMultiTexImageEXT(texunit, target, level, format, type, pixels_ptr);
                }
            }
            public static unsafe void GetMultiTexImageEXT<T1>(TextureUnit texunit, TextureTarget target, int level, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    GetMultiTexImageEXT(texunit, target, level, format, type, pixels_ptr);
                }
            }
            public static unsafe void GetMultiTexImageEXT<T1>(TextureUnit texunit, TextureTarget target, int level, PixelFormat format, PixelType type, ref T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    GetMultiTexImageEXT(texunit, target, level, format, type, pixels_ptr);
                }
            }
            public static unsafe void GetMultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMultiTexParameterfvEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMultiTexParameterfvEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetMultiTexParameterfvEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMultiTexParameterivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMultiTexParameterivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetMultiTexParameterivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexLevelParameterfvEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMultiTexLevelParameterfvEXT(texunit, target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexLevelParameterfvEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMultiTexLevelParameterfvEXT(texunit, target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexLevelParameterfvEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetMultiTexLevelParameterfvEXT(texunit, target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexLevelParameterivEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMultiTexLevelParameterivEXT(texunit, target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexLevelParameterivEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMultiTexLevelParameterivEXT(texunit, target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexLevelParameterivEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetMultiTexLevelParameterivEXT(texunit, target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                MultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels_vptr);
            }
            public static unsafe void MultiTexImage3DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    MultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexImage3DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    MultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexImage3DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    MultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                MultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_vptr);
            }
            public static unsafe void MultiTexSubImage3DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    MultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexSubImage3DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    MultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
                }
            }
            public static unsafe void MultiTexSubImage3DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    MultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
                }
            }
            public static unsafe void GetFloatIndexedvEXT(GetPName target, uint index, Span<float> data)
            {
                fixed (float* data_ptr = data)
                {
                    GetFloatIndexedvEXT(target, index, data_ptr);
                }
            }
            public static unsafe void GetFloatIndexedvEXT(GetPName target, uint index, float[] data)
            {
                fixed (float* data_ptr = data)
                {
                    GetFloatIndexedvEXT(target, index, data_ptr);
                }
            }
            public static unsafe void GetFloatIndexedvEXT(GetPName target, uint index, ref float data)
            {
                fixed (float* data_ptr = &data)
                {
                    GetFloatIndexedvEXT(target, index, data_ptr);
                }
            }
            public static unsafe void GetDoubleIndexedvEXT(GetPName target, uint index, Span<double> data)
            {
                fixed (double* data_ptr = data)
                {
                    GetDoubleIndexedvEXT(target, index, data_ptr);
                }
            }
            public static unsafe void GetDoubleIndexedvEXT(GetPName target, uint index, double[] data)
            {
                fixed (double* data_ptr = data)
                {
                    GetDoubleIndexedvEXT(target, index, data_ptr);
                }
            }
            public static unsafe void GetDoubleIndexedvEXT(GetPName target, uint index, ref double data)
            {
                fixed (double* data_ptr = &data)
                {
                    GetDoubleIndexedvEXT(target, index, data_ptr);
                }
            }
            public static unsafe void GetIntegerIndexedvEXT(GetPName target, uint index, Span<int> data)
            {
                fixed (int* data_ptr = data)
                {
                    GetIntegerIndexedvEXT(target, index, data_ptr);
                }
            }
            public static unsafe void GetIntegerIndexedvEXT(GetPName target, uint index, int[] data)
            {
                fixed (int* data_ptr = data)
                {
                    GetIntegerIndexedvEXT(target, index, data_ptr);
                }
            }
            public static unsafe void GetIntegerIndexedvEXT(GetPName target, uint index, ref int data)
            {
                fixed (int* data_ptr = &data)
                {
                    GetIntegerIndexedvEXT(target, index, data_ptr);
                }
            }
            public static unsafe void GetBooleanIndexedvEXT(BufferTargetARB target, uint index, Span<byte> data)
            {
                fixed (byte* data_ptr = data)
                {
                    GetBooleanIndexedvEXT(target, index, data_ptr);
                }
            }
            public static unsafe void GetBooleanIndexedvEXT(BufferTargetARB target, uint index, byte[] data)
            {
                fixed (byte* data_ptr = data)
                {
                    GetBooleanIndexedvEXT(target, index, data_ptr);
                }
            }
            public static unsafe void GetBooleanIndexedvEXT(BufferTargetARB target, uint index, ref byte data)
            {
                fixed (byte* data_ptr = &data)
                {
                    GetBooleanIndexedvEXT(target, index, data_ptr);
                }
            }
            public static unsafe void CompressedTextureImage3DEXT(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, IntPtr bits)
            {
                void* bits_vptr = (void*)bits;
                CompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits_vptr);
            }
            public static unsafe void CompressedTextureImage3DEXT<T1>(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, ReadOnlySpan<T1> bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureImage3DEXT<T1>(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, T1[] bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureImage3DEXT<T1>(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, in T1 bits)
                where T1 : unmanaged
            {
                fixed (void* bits_ptr = &bits)
                {
                    CompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureImage2DEXT(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, IntPtr bits)
            {
                void* bits_vptr = (void*)bits;
                CompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits_vptr);
            }
            public static unsafe void CompressedTextureImage2DEXT<T1>(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, ReadOnlySpan<T1> bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureImage2DEXT<T1>(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, T1[] bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureImage2DEXT<T1>(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, in T1 bits)
                where T1 : unmanaged
            {
                fixed (void* bits_ptr = &bits)
                {
                    CompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureImage1DEXT(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, IntPtr bits)
            {
                void* bits_vptr = (void*)bits;
                CompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits_vptr);
            }
            public static unsafe void CompressedTextureImage1DEXT<T1>(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, ReadOnlySpan<T1> bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureImage1DEXT<T1>(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, T1[] bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureImage1DEXT<T1>(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, in T1 bits)
                where T1 : unmanaged
            {
                fixed (void* bits_ptr = &bits)
                {
                    CompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureSubImage3DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, IntPtr bits)
            {
                void* bits_vptr = (void*)bits;
                CompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits_vptr);
            }
            public static unsafe void CompressedTextureSubImage3DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, ReadOnlySpan<T1> bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureSubImage3DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, T1[] bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureSubImage3DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, in T1 bits)
                where T1 : unmanaged
            {
                fixed (void* bits_ptr = &bits)
                {
                    CompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureSubImage2DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, IntPtr bits)
            {
                void* bits_vptr = (void*)bits;
                CompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits_vptr);
            }
            public static unsafe void CompressedTextureSubImage2DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, ReadOnlySpan<T1> bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureSubImage2DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, T1[] bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureSubImage2DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, in T1 bits)
                where T1 : unmanaged
            {
                fixed (void* bits_ptr = &bits)
                {
                    CompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureSubImage1DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, IntPtr bits)
            {
                void* bits_vptr = (void*)bits;
                CompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits_vptr);
            }
            public static unsafe void CompressedTextureSubImage1DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, InternalFormat format, ReadOnlySpan<T1> bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureSubImage1DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, InternalFormat format, T1[] bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedTextureSubImage1DEXT<T1>(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, in T1 bits)
                where T1 : unmanaged
            {
                fixed (void* bits_ptr = &bits)
                {
                    CompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void GetCompressedTextureImageEXT(TextureHandle texture, TextureTarget target, int lod, IntPtr img)
            {
                void* img_vptr = (void*)img;
                GetCompressedTextureImageEXT(texture, target, lod, img_vptr);
            }
            public static unsafe void GetCompressedTextureImageEXT<T1>(TextureHandle texture, TextureTarget target, int lod, Span<T1> img)
                where T1 : unmanaged
            {
                fixed (void* img_ptr = img)
                {
                    GetCompressedTextureImageEXT(texture, target, lod, img_ptr);
                }
            }
            public static unsafe void GetCompressedTextureImageEXT<T1>(TextureHandle texture, TextureTarget target, int lod, T1[] img)
                where T1 : unmanaged
            {
                fixed (void* img_ptr = img)
                {
                    GetCompressedTextureImageEXT(texture, target, lod, img_ptr);
                }
            }
            public static unsafe void GetCompressedTextureImageEXT<T1>(TextureHandle texture, TextureTarget target, int lod, ref T1 img)
                where T1 : unmanaged
            {
                fixed (void* img_ptr = &img)
                {
                    GetCompressedTextureImageEXT(texture, target, lod, img_ptr);
                }
            }
            public static unsafe void CompressedMultiTexImage3DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, IntPtr bits)
            {
                void* bits_vptr = (void*)bits;
                CompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits_vptr);
            }
            public static unsafe void CompressedMultiTexImage3DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, ReadOnlySpan<T1> bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexImage3DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, T1[] bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexImage3DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, in T1 bits)
                where T1 : unmanaged
            {
                fixed (void* bits_ptr = &bits)
                {
                    CompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, IntPtr bits)
            {
                void* bits_vptr = (void*)bits;
                CompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits_vptr);
            }
            public static unsafe void CompressedMultiTexImage2DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, ReadOnlySpan<T1> bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexImage2DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, T1[] bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexImage2DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, in T1 bits)
                where T1 : unmanaged
            {
                fixed (void* bits_ptr = &bits)
                {
                    CompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, IntPtr bits)
            {
                void* bits_vptr = (void*)bits;
                CompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, bits_vptr);
            }
            public static unsafe void CompressedMultiTexImage1DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, ReadOnlySpan<T1> bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexImage1DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, T1[] bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexImage1DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, in T1 bits)
                where T1 : unmanaged
            {
                fixed (void* bits_ptr = &bits)
                {
                    CompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, IntPtr bits)
            {
                void* bits_vptr = (void*)bits;
                CompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits_vptr);
            }
            public static unsafe void CompressedMultiTexSubImage3DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, ReadOnlySpan<T1> bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexSubImage3DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, T1[] bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexSubImage3DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, in T1 bits)
                where T1 : unmanaged
            {
                fixed (void* bits_ptr = &bits)
                {
                    CompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, IntPtr bits)
            {
                void* bits_vptr = (void*)bits;
                CompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits_vptr);
            }
            public static unsafe void CompressedMultiTexSubImage2DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, ReadOnlySpan<T1> bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexSubImage2DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, T1[] bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexSubImage2DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, in T1 bits)
                where T1 : unmanaged
            {
                fixed (void* bits_ptr = &bits)
                {
                    CompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, IntPtr bits)
            {
                void* bits_vptr = (void*)bits;
                CompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, bits_vptr);
            }
            public static unsafe void CompressedMultiTexSubImage1DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, InternalFormat format, ReadOnlySpan<T1> bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexSubImage1DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, InternalFormat format, T1[] bits)
                where T1 : unmanaged
            {
                int imageSize = (int)(bits.Length * sizeof(T1));
                fixed (void* bits_ptr = bits)
                {
                    CompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void CompressedMultiTexSubImage1DEXT<T1>(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, in T1 bits)
                where T1 : unmanaged
            {
                fixed (void* bits_ptr = &bits)
                {
                    CompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, bits_ptr);
                }
            }
            public static unsafe void GetCompressedMultiTexImageEXT(TextureUnit texunit, TextureTarget target, int lod, IntPtr img)
            {
                void* img_vptr = (void*)img;
                GetCompressedMultiTexImageEXT(texunit, target, lod, img_vptr);
            }
            public static unsafe void GetCompressedMultiTexImageEXT<T1>(TextureUnit texunit, TextureTarget target, int lod, Span<T1> img)
                where T1 : unmanaged
            {
                fixed (void* img_ptr = img)
                {
                    GetCompressedMultiTexImageEXT(texunit, target, lod, img_ptr);
                }
            }
            public static unsafe void GetCompressedMultiTexImageEXT<T1>(TextureUnit texunit, TextureTarget target, int lod, T1[] img)
                where T1 : unmanaged
            {
                fixed (void* img_ptr = img)
                {
                    GetCompressedMultiTexImageEXT(texunit, target, lod, img_ptr);
                }
            }
            public static unsafe void GetCompressedMultiTexImageEXT<T1>(TextureUnit texunit, TextureTarget target, int lod, ref T1 img)
                where T1 : unmanaged
            {
                fixed (void* img_ptr = &img)
                {
                    GetCompressedMultiTexImageEXT(texunit, target, lod, img_ptr);
                }
            }
            public static unsafe void MatrixLoadTransposefEXT(MatrixMode mode, ReadOnlySpan<float> m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixLoadTransposefEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadTransposefEXT(MatrixMode mode, float[] m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixLoadTransposefEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadTransposefEXT(MatrixMode mode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixLoadTransposefEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadTransposedEXT(MatrixMode mode, ReadOnlySpan<double> m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixLoadTransposedEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadTransposedEXT(MatrixMode mode, double[] m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixLoadTransposedEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadTransposedEXT(MatrixMode mode, in double m)
            {
                fixed (double* m_ptr = &m)
                {
                    MatrixLoadTransposedEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultTransposefEXT(MatrixMode mode, ReadOnlySpan<float> m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixMultTransposefEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultTransposefEXT(MatrixMode mode, float[] m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixMultTransposefEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultTransposefEXT(MatrixMode mode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixMultTransposefEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultTransposedEXT(MatrixMode mode, ReadOnlySpan<double> m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixMultTransposedEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultTransposedEXT(MatrixMode mode, double[] m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixMultTransposedEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultTransposedEXT(MatrixMode mode, in double m)
            {
                fixed (double* m_ptr = &m)
                {
                    MatrixMultTransposedEXT(mode, m_ptr);
                }
            }
            public static unsafe void NamedBufferDataEXT(BufferHandle buffer, nint size, IntPtr data, VertexBufferObjectUsage usage)
            {
                void* data_vptr = (void*)data;
                NamedBufferDataEXT(buffer, size, data_vptr, usage);
            }
            public static unsafe void NamedBufferDataEXT<T1>(BufferHandle buffer, nint size, ReadOnlySpan<T1> data, VertexBufferObjectUsage usage)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    NamedBufferDataEXT(buffer, size, data_ptr, usage);
                }
            }
            public static unsafe void NamedBufferDataEXT<T1>(BufferHandle buffer, nint size, T1[] data, VertexBufferObjectUsage usage)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    NamedBufferDataEXT(buffer, size, data_ptr, usage);
                }
            }
            public static unsafe void NamedBufferDataEXT<T1>(BufferHandle buffer, nint size, in T1 data, VertexBufferObjectUsage usage)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    NamedBufferDataEXT(buffer, size, data_ptr, usage);
                }
            }
            public static unsafe void NamedBufferSubDataEXT(BufferHandle buffer, IntPtr offset, nint size, IntPtr data)
            {
                void* data_vptr = (void*)data;
                NamedBufferSubDataEXT(buffer, offset, size, data_vptr);
            }
            public static unsafe void NamedBufferSubDataEXT<T1>(BufferHandle buffer, IntPtr offset, nint size, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    NamedBufferSubDataEXT(buffer, offset, size, data_ptr);
                }
            }
            public static unsafe void NamedBufferSubDataEXT<T1>(BufferHandle buffer, IntPtr offset, nint size, T1[] data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    NamedBufferSubDataEXT(buffer, offset, size, data_ptr);
                }
            }
            public static unsafe void NamedBufferSubDataEXT<T1>(BufferHandle buffer, IntPtr offset, nint size, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    NamedBufferSubDataEXT(buffer, offset, size, data_ptr);
                }
            }
            public static unsafe void GetNamedBufferParameterivEXT(BufferHandle buffer, BufferPNameARB pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetNamedBufferParameterivEXT(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedBufferParameterivEXT(BufferHandle buffer, BufferPNameARB pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetNamedBufferParameterivEXT(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedBufferParameterivEXT(BufferHandle buffer, BufferPNameARB pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetNamedBufferParameterivEXT(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedBufferSubDataEXT(BufferHandle buffer, IntPtr offset, nint size, IntPtr data)
            {
                void* data_vptr = (void*)data;
                GetNamedBufferSubDataEXT(buffer, offset, size, data_vptr);
            }
            public static unsafe void GetNamedBufferSubDataEXT<T1>(BufferHandle buffer, IntPtr offset, nint size, Span<T1> data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    GetNamedBufferSubDataEXT(buffer, offset, size, data_ptr);
                }
            }
            public static unsafe void GetNamedBufferSubDataEXT<T1>(BufferHandle buffer, IntPtr offset, nint size, T1[] data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    GetNamedBufferSubDataEXT(buffer, offset, size, data_ptr);
                }
            }
            public static unsafe void GetNamedBufferSubDataEXT<T1>(BufferHandle buffer, IntPtr offset, nint size, ref T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    GetNamedBufferSubDataEXT(buffer, offset, size, data_ptr);
                }
            }
            public static unsafe void ProgramUniform1fvEXT(ProgramHandle program, int location, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length);
                fixed (float* value_ptr = value)
                {
                    ProgramUniform1fvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1fvEXT(ProgramHandle program, int location, float[] value)
            {
                int count = (int)(value.Length);
                fixed (float* value_ptr = value)
                {
                    ProgramUniform1fvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1fvEXT(ProgramHandle program, int location, int count, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    ProgramUniform1fvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2fvEXT(ProgramHandle program, int location, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 2);
                fixed (float* value_ptr = value)
                {
                    ProgramUniform2fvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2fvEXT(ProgramHandle program, int location, float[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (float* value_ptr = value)
                {
                    ProgramUniform2fvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2fvEXT(ProgramHandle program, int location, int count, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    ProgramUniform2fvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3fvEXT(ProgramHandle program, int location, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 3);
                fixed (float* value_ptr = value)
                {
                    ProgramUniform3fvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3fvEXT(ProgramHandle program, int location, float[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (float* value_ptr = value)
                {
                    ProgramUniform3fvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3fvEXT(ProgramHandle program, int location, int count, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    ProgramUniform3fvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4fvEXT(ProgramHandle program, int location, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 4);
                fixed (float* value_ptr = value)
                {
                    ProgramUniform4fvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4fvEXT(ProgramHandle program, int location, float[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (float* value_ptr = value)
                {
                    ProgramUniform4fvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4fvEXT(ProgramHandle program, int location, int count, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    ProgramUniform4fvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ivEXT(ProgramHandle program, int location, ReadOnlySpan<int> value)
            {
                int count = (int)(value.Length);
                fixed (int* value_ptr = value)
                {
                    ProgramUniform1ivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ivEXT(ProgramHandle program, int location, int[] value)
            {
                int count = (int)(value.Length);
                fixed (int* value_ptr = value)
                {
                    ProgramUniform1ivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ivEXT(ProgramHandle program, int location, int count, in int value)
            {
                fixed (int* value_ptr = &value)
                {
                    ProgramUniform1ivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ivEXT(ProgramHandle program, int location, ReadOnlySpan<int> value)
            {
                int count = (int)(value.Length / 2);
                fixed (int* value_ptr = value)
                {
                    ProgramUniform2ivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ivEXT(ProgramHandle program, int location, int[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (int* value_ptr = value)
                {
                    ProgramUniform2ivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ivEXT(ProgramHandle program, int location, int count, in int value)
            {
                fixed (int* value_ptr = &value)
                {
                    ProgramUniform2ivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ivEXT(ProgramHandle program, int location, ReadOnlySpan<int> value)
            {
                int count = (int)(value.Length / 3);
                fixed (int* value_ptr = value)
                {
                    ProgramUniform3ivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ivEXT(ProgramHandle program, int location, int[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (int* value_ptr = value)
                {
                    ProgramUniform3ivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ivEXT(ProgramHandle program, int location, int count, in int value)
            {
                fixed (int* value_ptr = &value)
                {
                    ProgramUniform3ivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ivEXT(ProgramHandle program, int location, ReadOnlySpan<int> value)
            {
                int count = (int)(value.Length / 4);
                fixed (int* value_ptr = value)
                {
                    ProgramUniform4ivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ivEXT(ProgramHandle program, int location, int[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (int* value_ptr = value)
                {
                    ProgramUniform4ivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ivEXT(ProgramHandle program, int location, int count, in int value)
            {
                fixed (int* value_ptr = &value)
                {
                    ProgramUniform4ivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2fvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 4);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2fvEXT(ProgramHandle program, int location, bool transpose, float[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2fvEXT(ProgramHandle program, int location, int count, bool transpose, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3fvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 9);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3fvEXT(ProgramHandle program, int location, bool transpose, float[] value)
            {
                int count = (int)(value.Length / 9);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3fvEXT(ProgramHandle program, int location, int count, bool transpose, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4fvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 16);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4fvEXT(ProgramHandle program, int location, bool transpose, float[] value)
            {
                int count = (int)(value.Length / 16);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4fvEXT(ProgramHandle program, int location, int count, bool transpose, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x3fvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 6);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x3fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x3fvEXT(ProgramHandle program, int location, bool transpose, float[] value)
            {
                int count = (int)(value.Length / 6);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x3fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x3fvEXT(ProgramHandle program, int location, int count, bool transpose, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x3fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x2fvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 6);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x2fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x2fvEXT(ProgramHandle program, int location, bool transpose, float[] value)
            {
                int count = (int)(value.Length / 6);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x2fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x2fvEXT(ProgramHandle program, int location, int count, bool transpose, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x2fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x4fvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 8);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x4fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x4fvEXT(ProgramHandle program, int location, bool transpose, float[] value)
            {
                int count = (int)(value.Length / 8);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x4fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x4fvEXT(ProgramHandle program, int location, int count, bool transpose, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x4fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x2fvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 8);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x2fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x2fvEXT(ProgramHandle program, int location, bool transpose, float[] value)
            {
                int count = (int)(value.Length / 8);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x2fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x2fvEXT(ProgramHandle program, int location, int count, bool transpose, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x2fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x4fvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 12);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x4fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x4fvEXT(ProgramHandle program, int location, bool transpose, float[] value)
            {
                int count = (int)(value.Length / 12);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x4fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x4fvEXT(ProgramHandle program, int location, int count, bool transpose, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x4fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x3fvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<float> value)
            {
                int count = (int)(value.Length / 12);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x3fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x3fvEXT(ProgramHandle program, int location, bool transpose, float[] value)
            {
                int count = (int)(value.Length / 12);
                fixed (float* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x3fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x3fvEXT(ProgramHandle program, int location, int count, bool transpose, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x3fvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void TextureParameterIivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    TextureParameterIivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureParameterIivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    TextureParameterIivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureParameterIivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    TextureParameterIivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureParameterIuivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, ReadOnlySpan<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    TextureParameterIuivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureParameterIuivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    TextureParameterIuivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void TextureParameterIuivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, in uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    TextureParameterIuivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterIivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTextureParameterIivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterIivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTextureParameterIivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterIivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetTextureParameterIivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterIuivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetTextureParameterIuivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterIuivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetTextureParameterIuivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTextureParameterIuivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetTextureParameterIuivEXT(texture, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    MultiTexParameterIivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    MultiTexParameterIivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    MultiTexParameterIivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, ReadOnlySpan<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    MultiTexParameterIuivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    MultiTexParameterIuivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, in uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    MultiTexParameterIuivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMultiTexParameterIivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMultiTexParameterIivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetMultiTexParameterIivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetMultiTexParameterIuivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetMultiTexParameterIuivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetMultiTexParameterIuivEXT(texunit, target, pname, parameters_ptr);
                }
            }
            public static unsafe void ProgramUniform1uivEXT(ProgramHandle program, int location, ReadOnlySpan<uint> value)
            {
                int count = (int)(value.Length);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform1uivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1uivEXT(ProgramHandle program, int location, uint[] value)
            {
                int count = (int)(value.Length);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform1uivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1uivEXT(ProgramHandle program, int location, int count, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    ProgramUniform1uivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2uivEXT(ProgramHandle program, int location, ReadOnlySpan<uint> value)
            {
                int count = (int)(value.Length / 2);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform2uivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2uivEXT(ProgramHandle program, int location, uint[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform2uivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2uivEXT(ProgramHandle program, int location, int count, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    ProgramUniform2uivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3uivEXT(ProgramHandle program, int location, ReadOnlySpan<uint> value)
            {
                int count = (int)(value.Length / 3);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform3uivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3uivEXT(ProgramHandle program, int location, uint[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform3uivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3uivEXT(ProgramHandle program, int location, int count, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    ProgramUniform3uivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4uivEXT(ProgramHandle program, int location, ReadOnlySpan<uint> value)
            {
                int count = (int)(value.Length / 4);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform4uivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4uivEXT(ProgramHandle program, int location, uint[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (uint* value_ptr = value)
                {
                    ProgramUniform4uivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4uivEXT(ProgramHandle program, int location, int count, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    ProgramUniform4uivEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameters4fvEXT(ProgramHandle program, ProgramTarget target, uint index, ReadOnlySpan<float> parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (float* parameters_ptr = parameters)
                {
                    NamedProgramLocalParameters4fvEXT(program, target, index, count, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameters4fvEXT(ProgramHandle program, ProgramTarget target, uint index, float[] parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (float* parameters_ptr = parameters)
                {
                    NamedProgramLocalParameters4fvEXT(program, target, index, count, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameters4fvEXT(ProgramHandle program, ProgramTarget target, uint index, int count, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    NamedProgramLocalParameters4fvEXT(program, target, index, count, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameterI4ivEXT(ProgramHandle program, ProgramTarget target, uint index, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    NamedProgramLocalParameterI4ivEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameterI4ivEXT(ProgramHandle program, ProgramTarget target, uint index, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    NamedProgramLocalParameterI4ivEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameterI4ivEXT(ProgramHandle program, ProgramTarget target, uint index, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    NamedProgramLocalParameterI4ivEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParametersI4ivEXT(ProgramHandle program, ProgramTarget target, uint index, ReadOnlySpan<int> parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (int* parameters_ptr = parameters)
                {
                    NamedProgramLocalParametersI4ivEXT(program, target, index, count, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParametersI4ivEXT(ProgramHandle program, ProgramTarget target, uint index, int[] parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (int* parameters_ptr = parameters)
                {
                    NamedProgramLocalParametersI4ivEXT(program, target, index, count, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParametersI4ivEXT(ProgramHandle program, ProgramTarget target, uint index, int count, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    NamedProgramLocalParametersI4ivEXT(program, target, index, count, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameterI4uivEXT(ProgramHandle program, ProgramTarget target, uint index, ReadOnlySpan<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    NamedProgramLocalParameterI4uivEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameterI4uivEXT(ProgramHandle program, ProgramTarget target, uint index, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    NamedProgramLocalParameterI4uivEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameterI4uivEXT(ProgramHandle program, ProgramTarget target, uint index, in uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    NamedProgramLocalParameterI4uivEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParametersI4uivEXT(ProgramHandle program, ProgramTarget target, uint index, ReadOnlySpan<uint> parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (uint* parameters_ptr = parameters)
                {
                    NamedProgramLocalParametersI4uivEXT(program, target, index, count, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParametersI4uivEXT(ProgramHandle program, ProgramTarget target, uint index, uint[] parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (uint* parameters_ptr = parameters)
                {
                    NamedProgramLocalParametersI4uivEXT(program, target, index, count, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParametersI4uivEXT(ProgramHandle program, ProgramTarget target, uint index, int count, in uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    NamedProgramLocalParametersI4uivEXT(program, target, index, count, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramLocalParameterIivEXT(ProgramHandle program, ProgramTarget target, uint index, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetNamedProgramLocalParameterIivEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramLocalParameterIivEXT(ProgramHandle program, ProgramTarget target, uint index, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetNamedProgramLocalParameterIivEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramLocalParameterIivEXT(ProgramHandle program, ProgramTarget target, uint index, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetNamedProgramLocalParameterIivEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramLocalParameterIuivEXT(ProgramHandle program, ProgramTarget target, uint index, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetNamedProgramLocalParameterIuivEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramLocalParameterIuivEXT(ProgramHandle program, ProgramTarget target, uint index, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetNamedProgramLocalParameterIuivEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramLocalParameterIuivEXT(ProgramHandle program, ProgramTarget target, uint index, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetNamedProgramLocalParameterIuivEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void GetFloati_vEXT(GetPName pname, uint index, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetFloati_vEXT(pname, index, parameters_ptr);
                }
            }
            public static unsafe void GetFloati_vEXT(GetPName pname, uint index, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetFloati_vEXT(pname, index, parameters_ptr);
                }
            }
            public static unsafe void GetFloati_vEXT(GetPName pname, uint index, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetFloati_vEXT(pname, index, parameters_ptr);
                }
            }
            public static unsafe void GetDoublei_vEXT(GetPName pname, uint index, Span<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetDoublei_vEXT(pname, index, parameters_ptr);
                }
            }
            public static unsafe void GetDoublei_vEXT(GetPName pname, uint index, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetDoublei_vEXT(pname, index, parameters_ptr);
                }
            }
            public static unsafe void GetDoublei_vEXT(GetPName pname, uint index, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    GetDoublei_vEXT(pname, index, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramStringEXT(ProgramHandle program, ProgramTarget target, ProgramFormat format, int len, IntPtr str)
            {
                void* str_vptr = (void*)str;
                NamedProgramStringEXT(program, target, format, len, str_vptr);
            }
            public static unsafe void NamedProgramStringEXT<T1>(ProgramHandle program, ProgramTarget target, ProgramFormat format, ReadOnlySpan<T1> str)
                where T1 : unmanaged
            {
                int len = (int)(str.Length * sizeof(T1));
                fixed (void* str_ptr = str)
                {
                    NamedProgramStringEXT(program, target, format, len, str_ptr);
                }
            }
            public static unsafe void NamedProgramStringEXT<T1>(ProgramHandle program, ProgramTarget target, ProgramFormat format, T1[] str)
                where T1 : unmanaged
            {
                int len = (int)(str.Length * sizeof(T1));
                fixed (void* str_ptr = str)
                {
                    NamedProgramStringEXT(program, target, format, len, str_ptr);
                }
            }
            public static unsafe void NamedProgramStringEXT<T1>(ProgramHandle program, ProgramTarget target, ProgramFormat format, int len, in T1 str)
                where T1 : unmanaged
            {
                fixed (void* str_ptr = &str)
                {
                    NamedProgramStringEXT(program, target, format, len, str_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameter4dvEXT(ProgramHandle program, ProgramTarget target, uint index, ReadOnlySpan<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    NamedProgramLocalParameter4dvEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameter4dvEXT(ProgramHandle program, ProgramTarget target, uint index, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    NamedProgramLocalParameter4dvEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameter4dvEXT(ProgramHandle program, ProgramTarget target, uint index, in double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    NamedProgramLocalParameter4dvEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameter4fvEXT(ProgramHandle program, ProgramTarget target, uint index, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    NamedProgramLocalParameter4fvEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameter4fvEXT(ProgramHandle program, ProgramTarget target, uint index, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    NamedProgramLocalParameter4fvEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void NamedProgramLocalParameter4fvEXT(ProgramHandle program, ProgramTarget target, uint index, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    NamedProgramLocalParameter4fvEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramLocalParameterdvEXT(ProgramHandle program, ProgramTarget target, uint index, Span<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetNamedProgramLocalParameterdvEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramLocalParameterdvEXT(ProgramHandle program, ProgramTarget target, uint index, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetNamedProgramLocalParameterdvEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramLocalParameterdvEXT(ProgramHandle program, ProgramTarget target, uint index, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    GetNamedProgramLocalParameterdvEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramLocalParameterfvEXT(ProgramHandle program, ProgramTarget target, uint index, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetNamedProgramLocalParameterfvEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramLocalParameterfvEXT(ProgramHandle program, ProgramTarget target, uint index, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetNamedProgramLocalParameterfvEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramLocalParameterfvEXT(ProgramHandle program, ProgramTarget target, uint index, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetNamedProgramLocalParameterfvEXT(program, target, index, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramivEXT(ProgramHandle program, ProgramTarget target, ProgramPropertyARB pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetNamedProgramivEXT(program, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramivEXT(ProgramHandle program, ProgramTarget target, ProgramPropertyARB pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetNamedProgramivEXT(program, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramivEXT(ProgramHandle program, ProgramTarget target, ProgramPropertyARB pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetNamedProgramivEXT(program, target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedProgramStringEXT(ProgramHandle program, ProgramTarget target, ProgramStringProperty pname, IntPtr str)
            {
                void* str_vptr = (void*)str;
                GetNamedProgramStringEXT(program, target, pname, str_vptr);
            }
            public static unsafe void GetNamedProgramStringEXT<T1>(ProgramHandle program, ProgramTarget target, ProgramStringProperty pname, Span<T1> str)
                where T1 : unmanaged
            {
                fixed (void* str_ptr = str)
                {
                    GetNamedProgramStringEXT(program, target, pname, str_ptr);
                }
            }
            public static unsafe void GetNamedProgramStringEXT<T1>(ProgramHandle program, ProgramTarget target, ProgramStringProperty pname, T1[] str)
                where T1 : unmanaged
            {
                fixed (void* str_ptr = str)
                {
                    GetNamedProgramStringEXT(program, target, pname, str_ptr);
                }
            }
            public static unsafe void GetNamedProgramStringEXT<T1>(ProgramHandle program, ProgramTarget target, ProgramStringProperty pname, ref T1 str)
                where T1 : unmanaged
            {
                fixed (void* str_ptr = &str)
                {
                    GetNamedProgramStringEXT(program, target, pname, str_ptr);
                }
            }
            public static unsafe void GetNamedRenderbufferParameterivEXT(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetNamedRenderbufferParameterivEXT(renderbuffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedRenderbufferParameterivEXT(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetNamedRenderbufferParameterivEXT(renderbuffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedRenderbufferParameterivEXT(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetNamedRenderbufferParameterivEXT(renderbuffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedFramebufferAttachmentParameterivEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedFramebufferAttachmentParameterivEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedFramebufferAttachmentParameterivEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, parameters_ptr);
                }
            }
            public static unsafe void FramebufferDrawBuffersEXT(FramebufferHandle framebuffer, ReadOnlySpan<DrawBufferMode> bufs)
            {
                int n = (int)(bufs.Length);
                fixed (DrawBufferMode* bufs_ptr = bufs)
                {
                    FramebufferDrawBuffersEXT(framebuffer, n, bufs_ptr);
                }
            }
            public static unsafe void FramebufferDrawBuffersEXT(FramebufferHandle framebuffer, DrawBufferMode[] bufs)
            {
                int n = (int)(bufs.Length);
                fixed (DrawBufferMode* bufs_ptr = bufs)
                {
                    FramebufferDrawBuffersEXT(framebuffer, n, bufs_ptr);
                }
            }
            public static unsafe void FramebufferDrawBuffersEXT(FramebufferHandle framebuffer, int n, in DrawBufferMode bufs)
            {
                fixed (DrawBufferMode* bufs_ptr = &bufs)
                {
                    FramebufferDrawBuffersEXT(framebuffer, n, bufs_ptr);
                }
            }
            public static unsafe void GetFramebufferParameterivEXT(FramebufferHandle framebuffer, GetFramebufferParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFramebufferParameterivEXT(framebuffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFramebufferParameterivEXT(FramebufferHandle framebuffer, GetFramebufferParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFramebufferParameterivEXT(framebuffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFramebufferParameterivEXT(FramebufferHandle framebuffer, GetFramebufferParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetFramebufferParameterivEXT(framebuffer, pname, parameters_ptr);
                }
            }
            public static unsafe void VertexArrayVertexAttribOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, uint index, int size, VertexAttribPointerType type, bool normalized, int stride, IntPtr offset)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, type, normalized_byte, stride, offset);
            }
            public static unsafe void GetVertexArrayIntegervEXT(VertexArrayHandle vaobj, VertexArrayPName pname, ref int param)
            {
                fixed (int* param_ptr = &param)
                {
                    GetVertexArrayIntegervEXT(vaobj, pname, param_ptr);
                }
            }
            public static unsafe void GetVertexArrayIntegeri_vEXT(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, ref int param)
            {
                fixed (int* param_ptr = &param)
                {
                    GetVertexArrayIntegeri_vEXT(vaobj, index, pname, param_ptr);
                }
            }
            public static unsafe void NamedBufferStorageEXT(BufferHandle buffer, nint size, IntPtr data, BufferStorageMask flags)
            {
                void* data_vptr = (void*)data;
                NamedBufferStorageEXT(buffer, size, data_vptr, flags);
            }
            public static unsafe void NamedBufferStorageEXT<T1>(BufferHandle buffer, ReadOnlySpan<T1> data, BufferStorageMask flags)
                where T1 : unmanaged
            {
                nint size = (nint)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    NamedBufferStorageEXT(buffer, size, data_ptr, flags);
                }
            }
            public static unsafe void NamedBufferStorageEXT<T1>(BufferHandle buffer, T1[] data, BufferStorageMask flags)
                where T1 : unmanaged
            {
                nint size = (nint)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    NamedBufferStorageEXT(buffer, size, data_ptr, flags);
                }
            }
            public static unsafe void NamedBufferStorageEXT<T1>(BufferHandle buffer, nint size, in T1 data, BufferStorageMask flags)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    NamedBufferStorageEXT(buffer, size, data_ptr, flags);
                }
            }
            public static unsafe void ClearNamedBufferDataEXT(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, IntPtr data)
            {
                void* data_vptr = (void*)data;
                ClearNamedBufferDataEXT(buffer, internalformat, format, type, data_vptr);
            }
            public static unsafe void ClearNamedBufferDataEXT<T1>(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ClearNamedBufferDataEXT(buffer, internalformat, format, type, data_ptr);
                }
            }
            public static unsafe void ClearNamedBufferDataEXT<T1>(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, T1[] data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ClearNamedBufferDataEXT(buffer, internalformat, format, type, data_ptr);
                }
            }
            public static unsafe void ClearNamedBufferDataEXT<T1>(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    ClearNamedBufferDataEXT(buffer, internalformat, format, type, data_ptr);
                }
            }
            public static unsafe void ClearNamedBufferSubDataEXT(BufferHandle buffer, SizedInternalFormat internalformat, nint offset, nint size, PixelFormat format, PixelType type, IntPtr data)
            {
                void* data_vptr = (void*)data;
                ClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, type, data_vptr);
            }
            public static unsafe void ClearNamedBufferSubDataEXT<T1>(BufferHandle buffer, SizedInternalFormat internalformat, nint offset, nint size, PixelFormat format, PixelType type, ReadOnlySpan<T1> data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, type, data_ptr);
                }
            }
            public static unsafe void ClearNamedBufferSubDataEXT<T1>(BufferHandle buffer, SizedInternalFormat internalformat, nint offset, nint size, PixelFormat format, PixelType type, T1[] data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    ClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, type, data_ptr);
                }
            }
            public static unsafe void ClearNamedBufferSubDataEXT<T1>(BufferHandle buffer, SizedInternalFormat internalformat, nint offset, nint size, PixelFormat format, PixelType type, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    ClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, type, data_ptr);
                }
            }
            public static unsafe void GetNamedFramebufferParameterivEXT(FramebufferHandle framebuffer, GetFramebufferParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetNamedFramebufferParameterivEXT(framebuffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedFramebufferParameterivEXT(FramebufferHandle framebuffer, GetFramebufferParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetNamedFramebufferParameterivEXT(framebuffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedFramebufferParameterivEXT(FramebufferHandle framebuffer, GetFramebufferParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetNamedFramebufferParameterivEXT(framebuffer, pname, parameters_ptr);
                }
            }
            public static unsafe void ProgramUniform1dvEXT(ProgramHandle program, int location, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length);
                fixed (double* value_ptr = value)
                {
                    ProgramUniform1dvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1dvEXT(ProgramHandle program, int location, double[] value)
            {
                int count = (int)(value.Length);
                fixed (double* value_ptr = value)
                {
                    ProgramUniform1dvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1dvEXT(ProgramHandle program, int location, int count, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    ProgramUniform1dvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2dvEXT(ProgramHandle program, int location, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length / 2);
                fixed (double* value_ptr = value)
                {
                    ProgramUniform2dvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2dvEXT(ProgramHandle program, int location, double[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (double* value_ptr = value)
                {
                    ProgramUniform2dvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2dvEXT(ProgramHandle program, int location, int count, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    ProgramUniform2dvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3dvEXT(ProgramHandle program, int location, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length / 3);
                fixed (double* value_ptr = value)
                {
                    ProgramUniform3dvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3dvEXT(ProgramHandle program, int location, double[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (double* value_ptr = value)
                {
                    ProgramUniform3dvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3dvEXT(ProgramHandle program, int location, int count, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    ProgramUniform3dvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4dvEXT(ProgramHandle program, int location, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length / 4);
                fixed (double* value_ptr = value)
                {
                    ProgramUniform4dvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4dvEXT(ProgramHandle program, int location, double[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (double* value_ptr = value)
                {
                    ProgramUniform4dvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4dvEXT(ProgramHandle program, int location, int count, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    ProgramUniform4dvEXT(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2dvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length / 4);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2dvEXT(ProgramHandle program, int location, bool transpose, double[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2dvEXT(ProgramHandle program, int location, int count, bool transpose, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3dvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length / 9);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3dvEXT(ProgramHandle program, int location, bool transpose, double[] value)
            {
                int count = (int)(value.Length / 9);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3dvEXT(ProgramHandle program, int location, int count, bool transpose, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4dvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length / 16);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4dvEXT(ProgramHandle program, int location, bool transpose, double[] value)
            {
                int count = (int)(value.Length / 16);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4dvEXT(ProgramHandle program, int location, int count, bool transpose, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x3dvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length / 6);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x3dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x3dvEXT(ProgramHandle program, int location, bool transpose, double[] value)
            {
                int count = (int)(value.Length / 6);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x3dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x3dvEXT(ProgramHandle program, int location, int count, bool transpose, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x3dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x4dvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length / 8);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x4dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x4dvEXT(ProgramHandle program, int location, bool transpose, double[] value)
            {
                int count = (int)(value.Length / 8);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x4dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix2x4dvEXT(ProgramHandle program, int location, int count, bool transpose, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix2x4dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x2dvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length / 6);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x2dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x2dvEXT(ProgramHandle program, int location, bool transpose, double[] value)
            {
                int count = (int)(value.Length / 6);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x2dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x2dvEXT(ProgramHandle program, int location, int count, bool transpose, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x2dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x4dvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length / 12);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x4dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x4dvEXT(ProgramHandle program, int location, bool transpose, double[] value)
            {
                int count = (int)(value.Length / 12);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x4dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix3x4dvEXT(ProgramHandle program, int location, int count, bool transpose, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix3x4dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x2dvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length / 8);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x2dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x2dvEXT(ProgramHandle program, int location, bool transpose, double[] value)
            {
                int count = (int)(value.Length / 8);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x2dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x2dvEXT(ProgramHandle program, int location, int count, bool transpose, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x2dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x3dvEXT(ProgramHandle program, int location, bool transpose, ReadOnlySpan<double> value)
            {
                int count = (int)(value.Length / 12);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x3dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x3dvEXT(ProgramHandle program, int location, bool transpose, double[] value)
            {
                int count = (int)(value.Length / 12);
                fixed (double* value_ptr = value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x3dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void ProgramUniformMatrix4x3dvEXT(ProgramHandle program, int location, int count, bool transpose, in double value)
            {
                fixed (double* value_ptr = &value)
                {
                    byte transpose_byte = (byte)(transpose ? 1 : 0);
                    ProgramUniformMatrix4x3dvEXT(program, location, count, transpose_byte, value_ptr);
                }
            }
            public static unsafe void TextureStorage2DMultisampleEXT(TextureHandle texture, TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
            {
                byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
                TextureStorage2DMultisampleEXT(texture, target, samples, internalformat, width, height, fixedsamplelocations_byte);
            }
            public static unsafe void TextureStorage3DMultisampleEXT(TextureHandle texture, All target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
            {
                byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
                TextureStorage3DMultisampleEXT(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations_byte);
            }
            public static unsafe void VertexArrayVertexAttribFormatEXT(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexArrayVertexAttribFormatEXT(vaobj, attribindex, size, type, normalized_byte, relativeoffset);
            }
            public static unsafe void TexturePageCommitmentEXT(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit)
            {
                byte commit_byte = (byte)(commit ? 1 : 0);
                TexturePageCommitmentEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit_byte);
            }
            public static unsafe void ColorMaskIndexedEXT(uint index, bool r, bool g, bool b, bool a)
            {
                byte r_byte = (byte)(r ? 1 : 0);
                byte g_byte = (byte)(g ? 1 : 0);
                byte b_byte = (byte)(b ? 1 : 0);
                byte a_byte = (byte)(a ? 1 : 0);
                ColorMaskIndexedEXT(index, r_byte, g_byte, b_byte, a_byte);
            }
            public static unsafe void DrawElementsInstancedEXT(PrimitiveType mode, int count, DrawElementsType type, nint offset, int primcount)
            {
                void* indices = (void*)offset;
                DrawElementsInstancedEXT(mode, count, type, indices, primcount);
            }
            public static unsafe void DrawRangeElementsEXT(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, nint offset)
            {
                void* indices = (void*)offset;
                DrawRangeElementsEXT(mode, start, end, count, type, indices);
            }
            public static unsafe void BufferStorageExternalEXT(All target, IntPtr offset, nint size, IntPtr clientBuffer, BufferStorageMask flags)
            {
                void* clientBuffer_vptr = (void*)clientBuffer;
                BufferStorageExternalEXT(target, offset, size, clientBuffer_vptr, flags);
            }
            public static unsafe void BufferStorageExternalEXT<T1>(All target, IntPtr offset, nint size, ref T1 clientBuffer, BufferStorageMask flags)
                where T1 : unmanaged
            {
                fixed (void* clientBuffer_ptr = &clientBuffer)
                {
                    BufferStorageExternalEXT(target, offset, size, clientBuffer_ptr, flags);
                }
            }
            public static unsafe void NamedBufferStorageExternalEXT(BufferHandle buffer, IntPtr offset, nint size, IntPtr clientBuffer, BufferStorageMask flags)
            {
                void* clientBuffer_vptr = (void*)clientBuffer;
                NamedBufferStorageExternalEXT(buffer, offset, size, clientBuffer_vptr, flags);
            }
            public static unsafe void NamedBufferStorageExternalEXT<T1>(BufferHandle buffer, IntPtr offset, nint size, ref T1 clientBuffer, BufferStorageMask flags)
                where T1 : unmanaged
            {
                fixed (void* clientBuffer_ptr = &clientBuffer)
                {
                    NamedBufferStorageExternalEXT(buffer, offset, size, clientBuffer_ptr, flags);
                }
            }
            public static unsafe void FogCoordfvEXT(ReadOnlySpan<float> coord)
            {
                fixed (float* coord_ptr = coord)
                {
                    FogCoordfvEXT(coord_ptr);
                }
            }
            public static unsafe void FogCoordfvEXT(float[] coord)
            {
                fixed (float* coord_ptr = coord)
                {
                    FogCoordfvEXT(coord_ptr);
                }
            }
            public static unsafe void FogCoordfvEXT(in float coord)
            {
                fixed (float* coord_ptr = &coord)
                {
                    FogCoordfvEXT(coord_ptr);
                }
            }
            public static unsafe void FogCoorddvEXT(ReadOnlySpan<double> coord)
            {
                fixed (double* coord_ptr = coord)
                {
                    FogCoorddvEXT(coord_ptr);
                }
            }
            public static unsafe void FogCoorddvEXT(double[] coord)
            {
                fixed (double* coord_ptr = coord)
                {
                    FogCoorddvEXT(coord_ptr);
                }
            }
            public static unsafe void FogCoorddvEXT(in double coord)
            {
                fixed (double* coord_ptr = &coord)
                {
                    FogCoorddvEXT(coord_ptr);
                }
            }
            public static unsafe void FogCoordPointerEXT(FogPointerTypeEXT type, int stride, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                FogCoordPointerEXT(type, stride, pointer_vptr);
            }
            public static unsafe void FogCoordPointerEXT<T1>(FogPointerTypeEXT type, int stride, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    FogCoordPointerEXT(type, stride, pointer_ptr);
                }
            }
            public static unsafe void FogCoordPointerEXT<T1>(FogPointerTypeEXT type, int stride, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    FogCoordPointerEXT(type, stride, pointer_ptr);
                }
            }
            public static unsafe void FogCoordPointerEXT<T1>(FogPointerTypeEXT type, int stride, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    FogCoordPointerEXT(type, stride, pointer_ptr);
                }
            }
            public static unsafe void DeleteRenderbuffersEXT(ReadOnlySpan<RenderbufferHandle> renderbuffers)
            {
                int n = (int)(renderbuffers.Length);
                fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
                {
                    DeleteRenderbuffersEXT(n, renderbuffers_ptr);
                }
            }
            public static unsafe void DeleteRenderbuffersEXT(RenderbufferHandle[] renderbuffers)
            {
                int n = (int)(renderbuffers.Length);
                fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
                {
                    DeleteRenderbuffersEXT(n, renderbuffers_ptr);
                }
            }
            public static unsafe void DeleteRenderbuffersEXT(int n, in RenderbufferHandle renderbuffers)
            {
                fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers)
                {
                    DeleteRenderbuffersEXT(n, renderbuffers_ptr);
                }
            }
            public static unsafe void GenRenderbuffersEXT(Span<RenderbufferHandle> renderbuffers)
            {
                int n = (int)(renderbuffers.Length);
                fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
                {
                    GenRenderbuffersEXT(n, renderbuffers_ptr);
                }
            }
            public static unsafe void GenRenderbuffersEXT(RenderbufferHandle[] renderbuffers)
            {
                int n = (int)(renderbuffers.Length);
                fixed (RenderbufferHandle* renderbuffers_ptr = renderbuffers)
                {
                    GenRenderbuffersEXT(n, renderbuffers_ptr);
                }
            }
            public static unsafe void GenRenderbuffersEXT(int n, ref RenderbufferHandle renderbuffers)
            {
                fixed (RenderbufferHandle* renderbuffers_ptr = &renderbuffers)
                {
                    GenRenderbuffersEXT(n, renderbuffers_ptr);
                }
            }
            public static unsafe void GetRenderbufferParameterivEXT(RenderbufferTarget target, RenderbufferParameterName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetRenderbufferParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetRenderbufferParameterivEXT(RenderbufferTarget target, RenderbufferParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetRenderbufferParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetRenderbufferParameterivEXT(RenderbufferTarget target, RenderbufferParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetRenderbufferParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void DeleteFramebuffersEXT(ReadOnlySpan<FramebufferHandle> framebuffers)
            {
                int n = (int)(framebuffers.Length);
                fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
                {
                    DeleteFramebuffersEXT(n, framebuffers_ptr);
                }
            }
            public static unsafe void DeleteFramebuffersEXT(FramebufferHandle[] framebuffers)
            {
                int n = (int)(framebuffers.Length);
                fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
                {
                    DeleteFramebuffersEXT(n, framebuffers_ptr);
                }
            }
            public static unsafe void DeleteFramebuffersEXT(int n, in FramebufferHandle framebuffers)
            {
                fixed (FramebufferHandle* framebuffers_ptr = &framebuffers)
                {
                    DeleteFramebuffersEXT(n, framebuffers_ptr);
                }
            }
            public static unsafe void GenFramebuffersEXT(Span<FramebufferHandle> framebuffers)
            {
                int n = (int)(framebuffers.Length);
                fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
                {
                    GenFramebuffersEXT(n, framebuffers_ptr);
                }
            }
            public static unsafe void GenFramebuffersEXT(FramebufferHandle[] framebuffers)
            {
                int n = (int)(framebuffers.Length);
                fixed (FramebufferHandle* framebuffers_ptr = framebuffers)
                {
                    GenFramebuffersEXT(n, framebuffers_ptr);
                }
            }
            public static unsafe void GenFramebuffersEXT(int n, ref FramebufferHandle framebuffers)
            {
                fixed (FramebufferHandle* framebuffers_ptr = &framebuffers)
                {
                    GenFramebuffersEXT(n, framebuffers_ptr);
                }
            }
            public static unsafe void GetFramebufferAttachmentParameterivEXT(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFramebufferAttachmentParameterivEXT(target, attachment, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFramebufferAttachmentParameterivEXT(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFramebufferAttachmentParameterivEXT(target, attachment, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFramebufferAttachmentParameterivEXT(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetFramebufferAttachmentParameterivEXT(target, attachment, pname, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameters4fvEXT(ProgramTarget target, uint index, ReadOnlySpan<float> parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (float* parameters_ptr = parameters)
                {
                    ProgramEnvParameters4fvEXT(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameters4fvEXT(ProgramTarget target, uint index, float[] parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (float* parameters_ptr = parameters)
                {
                    ProgramEnvParameters4fvEXT(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameters4fvEXT(ProgramTarget target, uint index, int count, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    ProgramEnvParameters4fvEXT(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameters4fvEXT(ProgramTarget target, uint index, ReadOnlySpan<float> parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (float* parameters_ptr = parameters)
                {
                    ProgramLocalParameters4fvEXT(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameters4fvEXT(ProgramTarget target, uint index, float[] parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (float* parameters_ptr = parameters)
                {
                    ProgramLocalParameters4fvEXT(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameters4fvEXT(ProgramTarget target, uint index, int count, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    ProgramLocalParameters4fvEXT(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void GetUniformuivEXT(ProgramHandle program, int location, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetUniformuivEXT(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformuivEXT(ProgramHandle program, int location, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetUniformuivEXT(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformuivEXT(ProgramHandle program, int location, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetUniformuivEXT(program, location, parameters_ptr);
                }
            }
            public static unsafe void BindFragDataLocationEXT(ProgramHandle program, uint color, string name)
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                BindFragDataLocationEXT(program, color, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            public static unsafe int GetFragDataLocationEXT(ProgramHandle program, string name)
            {
                int returnValue;
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                returnValue = GetFragDataLocationEXT(program, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                return returnValue;
            }
            public static unsafe void Uniform1uivEXT(int location, ReadOnlySpan<uint> value)
            {
                int count = (int)(value.Length / 1);
                fixed (uint* value_ptr = value)
                {
                    Uniform1uivEXT(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1uivEXT(int location, uint[] value)
            {
                int count = (int)(value.Length / 1);
                fixed (uint* value_ptr = value)
                {
                    Uniform1uivEXT(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1uivEXT(int location, int count, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    Uniform1uivEXT(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2uivEXT(int location, ReadOnlySpan<uint> value)
            {
                int count = (int)(value.Length / 2);
                fixed (uint* value_ptr = value)
                {
                    Uniform2uivEXT(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2uivEXT(int location, uint[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (uint* value_ptr = value)
                {
                    Uniform2uivEXT(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2uivEXT(int location, int count, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    Uniform2uivEXT(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3uivEXT(int location, ReadOnlySpan<uint> value)
            {
                int count = (int)(value.Length / 3);
                fixed (uint* value_ptr = value)
                {
                    Uniform3uivEXT(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3uivEXT(int location, uint[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (uint* value_ptr = value)
                {
                    Uniform3uivEXT(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3uivEXT(int location, int count, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    Uniform3uivEXT(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4uivEXT(int location, ReadOnlySpan<uint> value)
            {
                int count = (int)(value.Length / 4);
                fixed (uint* value_ptr = value)
                {
                    Uniform4uivEXT(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4uivEXT(int location, uint[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (uint* value_ptr = value)
                {
                    Uniform4uivEXT(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4uivEXT(int location, int count, in uint value)
            {
                fixed (uint* value_ptr = &value)
                {
                    Uniform4uivEXT(location, count, value_ptr);
                }
            }
            public static unsafe void VertexAttribI1ivEXT(uint index, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI1ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI1ivEXT(uint index, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI1ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI1ivEXT(uint index, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    VertexAttribI1ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI2ivEXT(uint index, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI2ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI2ivEXT(uint index, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI2ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI2ivEXT(uint index, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    VertexAttribI2ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI3ivEXT(uint index, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI3ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI3ivEXT(uint index, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI3ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI3ivEXT(uint index, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    VertexAttribI3ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4ivEXT(uint index, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI4ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4ivEXT(uint index, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI4ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4ivEXT(uint index, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    VertexAttribI4ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI1uivEXT(uint index, ReadOnlySpan<uint> v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI1uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI1uivEXT(uint index, uint[] v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI1uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI1uivEXT(uint index, in uint v)
            {
                fixed (uint* v_ptr = &v)
                {
                    VertexAttribI1uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI2uivEXT(uint index, ReadOnlySpan<uint> v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI2uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI2uivEXT(uint index, uint[] v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI2uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI2uivEXT(uint index, in uint v)
            {
                fixed (uint* v_ptr = &v)
                {
                    VertexAttribI2uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI3uivEXT(uint index, ReadOnlySpan<uint> v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI3uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI3uivEXT(uint index, uint[] v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI3uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI3uivEXT(uint index, in uint v)
            {
                fixed (uint* v_ptr = &v)
                {
                    VertexAttribI3uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4uivEXT(uint index, ReadOnlySpan<uint> v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI4uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4uivEXT(uint index, uint[] v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI4uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4uivEXT(uint index, in uint v)
            {
                fixed (uint* v_ptr = &v)
                {
                    VertexAttribI4uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4bvEXT(uint index, ReadOnlySpan<sbyte> v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    VertexAttribI4bvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4bvEXT(uint index, sbyte[] v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    VertexAttribI4bvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4bvEXT(uint index, in sbyte v)
            {
                fixed (sbyte* v_ptr = &v)
                {
                    VertexAttribI4bvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4svEXT(uint index, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttribI4svEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4svEXT(uint index, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttribI4svEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4svEXT(uint index, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttribI4svEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4ubvEXT(uint index, ReadOnlySpan<byte> v)
            {
                fixed (byte* v_ptr = v)
                {
                    VertexAttribI4ubvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4ubvEXT(uint index, byte[] v)
            {
                fixed (byte* v_ptr = v)
                {
                    VertexAttribI4ubvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4ubvEXT(uint index, in byte v)
            {
                fixed (byte* v_ptr = &v)
                {
                    VertexAttribI4ubvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4usvEXT(uint index, ReadOnlySpan<ushort> v)
            {
                fixed (ushort* v_ptr = v)
                {
                    VertexAttribI4usvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4usvEXT(uint index, ushort[] v)
            {
                fixed (ushort* v_ptr = v)
                {
                    VertexAttribI4usvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4usvEXT(uint index, in ushort v)
            {
                fixed (ushort* v_ptr = &v)
                {
                    VertexAttribI4usvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribIPointerEXT(uint index, int size, VertexAttribIType type, int stride, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                VertexAttribIPointerEXT(index, size, type, stride, pointer_vptr);
            }
            public static unsafe void VertexAttribIPointerEXT<T1>(uint index, int size, VertexAttribIType type, int stride, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    VertexAttribIPointerEXT(index, size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void VertexAttribIPointerEXT<T1>(uint index, int size, VertexAttribIType type, int stride, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    VertexAttribIPointerEXT(index, size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void VertexAttribIPointerEXT<T1>(uint index, int size, VertexAttribIType type, int stride, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    VertexAttribIPointerEXT(index, size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVertexAttribIivEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVertexAttribIivEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetVertexAttribIivEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetVertexAttribIuivEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetVertexAttribIuivEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetVertexAttribIuivEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetHistogramEXT(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, IntPtr values)
            {
                void* values_vptr = (void*)values;
                byte reset_byte = (byte)(reset ? 1 : 0);
                GetHistogramEXT(target, reset_byte, format, type, values_vptr);
            }
            public static unsafe void GetHistogramEXT<T1>(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, Span<T1> values)
                where T1 : unmanaged
            {
                fixed (void* values_ptr = values)
                {
                    byte reset_byte = (byte)(reset ? 1 : 0);
                    GetHistogramEXT(target, reset_byte, format, type, values_ptr);
                }
            }
            public static unsafe void GetHistogramEXT<T1>(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, T1[] values)
                where T1 : unmanaged
            {
                fixed (void* values_ptr = values)
                {
                    byte reset_byte = (byte)(reset ? 1 : 0);
                    GetHistogramEXT(target, reset_byte, format, type, values_ptr);
                }
            }
            public static unsafe void GetHistogramEXT<T1>(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, ref T1 values)
                where T1 : unmanaged
            {
                fixed (void* values_ptr = &values)
                {
                    byte reset_byte = (byte)(reset ? 1 : 0);
                    GetHistogramEXT(target, reset_byte, format, type, values_ptr);
                }
            }
            public static unsafe void GetHistogramParameterfvEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetHistogramParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetHistogramParameterfvEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetHistogramParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetHistogramParameterfvEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetHistogramParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetHistogramParameterivEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetHistogramParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetHistogramParameterivEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetHistogramParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetHistogramParameterivEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetHistogramParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMinmaxEXT(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, IntPtr values)
            {
                void* values_vptr = (void*)values;
                byte reset_byte = (byte)(reset ? 1 : 0);
                GetMinmaxEXT(target, reset_byte, format, type, values_vptr);
            }
            public static unsafe void GetMinmaxEXT<T1>(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, Span<T1> values)
                where T1 : unmanaged
            {
                fixed (void* values_ptr = values)
                {
                    byte reset_byte = (byte)(reset ? 1 : 0);
                    GetMinmaxEXT(target, reset_byte, format, type, values_ptr);
                }
            }
            public static unsafe void GetMinmaxEXT<T1>(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, T1[] values)
                where T1 : unmanaged
            {
                fixed (void* values_ptr = values)
                {
                    byte reset_byte = (byte)(reset ? 1 : 0);
                    GetMinmaxEXT(target, reset_byte, format, type, values_ptr);
                }
            }
            public static unsafe void GetMinmaxEXT<T1>(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, ref T1 values)
                where T1 : unmanaged
            {
                fixed (void* values_ptr = &values)
                {
                    byte reset_byte = (byte)(reset ? 1 : 0);
                    GetMinmaxEXT(target, reset_byte, format, type, values_ptr);
                }
            }
            public static unsafe void GetMinmaxParameterfvEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMinmaxParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMinmaxParameterfvEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMinmaxParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMinmaxParameterfvEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetMinmaxParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMinmaxParameterivEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMinmaxParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMinmaxParameterivEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMinmaxParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMinmaxParameterivEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetMinmaxParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void HistogramEXT(HistogramTargetEXT target, int width, InternalFormat internalformat, bool sink)
            {
                byte sink_byte = (byte)(sink ? 1 : 0);
                HistogramEXT(target, width, internalformat, sink_byte);
            }
            public static unsafe void MinmaxEXT(MinmaxTargetEXT target, InternalFormat internalformat, bool sink)
            {
                byte sink_byte = (byte)(sink ? 1 : 0);
                MinmaxEXT(target, internalformat, sink_byte);
            }
            public static unsafe void GetUnsignedBytevEXT(GetPName pname, Span<byte> data)
            {
                fixed (byte* data_ptr = data)
                {
                    GetUnsignedBytevEXT(pname, data_ptr);
                }
            }
            public static unsafe void GetUnsignedBytevEXT(GetPName pname, byte[] data)
            {
                fixed (byte* data_ptr = data)
                {
                    GetUnsignedBytevEXT(pname, data_ptr);
                }
            }
            public static unsafe void GetUnsignedBytevEXT(GetPName pname, ref byte data)
            {
                fixed (byte* data_ptr = &data)
                {
                    GetUnsignedBytevEXT(pname, data_ptr);
                }
            }
            public static unsafe void GetUnsignedBytei_vEXT(All target, uint index, Span<byte> data)
            {
                fixed (byte* data_ptr = data)
                {
                    GetUnsignedBytei_vEXT(target, index, data_ptr);
                }
            }
            public static unsafe void GetUnsignedBytei_vEXT(All target, uint index, byte[] data)
            {
                fixed (byte* data_ptr = data)
                {
                    GetUnsignedBytei_vEXT(target, index, data_ptr);
                }
            }
            public static unsafe void GetUnsignedBytei_vEXT(All target, uint index, ref byte data)
            {
                fixed (byte* data_ptr = &data)
                {
                    GetUnsignedBytei_vEXT(target, index, data_ptr);
                }
            }
            public static unsafe void DeleteMemoryObjectsEXT(ReadOnlySpan<uint> memoryObjects)
            {
                int n = (int)(memoryObjects.Length);
                fixed (uint* memoryObjects_ptr = memoryObjects)
                {
                    DeleteMemoryObjectsEXT(n, memoryObjects_ptr);
                }
            }
            public static unsafe void DeleteMemoryObjectsEXT(uint[] memoryObjects)
            {
                int n = (int)(memoryObjects.Length);
                fixed (uint* memoryObjects_ptr = memoryObjects)
                {
                    DeleteMemoryObjectsEXT(n, memoryObjects_ptr);
                }
            }
            public static unsafe void DeleteMemoryObjectsEXT(int n, in uint memoryObjects)
            {
                fixed (uint* memoryObjects_ptr = &memoryObjects)
                {
                    DeleteMemoryObjectsEXT(n, memoryObjects_ptr);
                }
            }
            public static unsafe void CreateMemoryObjectsEXT(int n, ref uint memoryObjects)
            {
                fixed (uint* memoryObjects_ptr = &memoryObjects)
                {
                    CreateMemoryObjectsEXT(n, memoryObjects_ptr);
                }
            }
            public static unsafe void MemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    MemoryObjectParameterivEXT(memoryObject, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetMemoryObjectParameterivEXT(memoryObject, pname, parameters_ptr);
                }
            }
            public static unsafe void TexStorageMem2DMultisampleEXT(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset)
            {
                byte fixedSampleLocations_byte = (byte)(fixedSampleLocations ? 1 : 0);
                TexStorageMem2DMultisampleEXT(target, samples, internalFormat, width, height, fixedSampleLocations_byte, memory, offset);
            }
            public static unsafe void TexStorageMem3DMultisampleEXT(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset)
            {
                byte fixedSampleLocations_byte = (byte)(fixedSampleLocations ? 1 : 0);
                TexStorageMem3DMultisampleEXT(target, samples, internalFormat, width, height, depth, fixedSampleLocations_byte, memory, offset);
            }
            public static unsafe void TextureStorageMem2DMultisampleEXT(TextureHandle texture, int samples, SizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset)
            {
                byte fixedSampleLocations_byte = (byte)(fixedSampleLocations ? 1 : 0);
                TextureStorageMem2DMultisampleEXT(texture, samples, internalFormat, width, height, fixedSampleLocations_byte, memory, offset);
            }
            public static unsafe void TextureStorageMem3DMultisampleEXT(TextureHandle texture, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset)
            {
                byte fixedSampleLocations_byte = (byte)(fixedSampleLocations ? 1 : 0);
                TextureStorageMem3DMultisampleEXT(texture, samples, internalFormat, width, height, depth, fixedSampleLocations_byte, memory, offset);
            }
            public static unsafe void ImportMemoryWin32HandleEXT(uint memory, ulong size, ExternalHandleType handleType, IntPtr handle)
            {
                void* handle_vptr = (void*)handle;
                ImportMemoryWin32HandleEXT(memory, size, handleType, handle_vptr);
            }
            public static unsafe void ImportMemoryWin32HandleEXT<T1>(uint memory, ulong size, ExternalHandleType handleType, ref T1 handle)
                where T1 : unmanaged
            {
                fixed (void* handle_ptr = &handle)
                {
                    ImportMemoryWin32HandleEXT(memory, size, handleType, handle_ptr);
                }
            }
            public static unsafe void ImportMemoryWin32NameEXT(uint memory, ulong size, ExternalHandleType handleType, IntPtr name)
            {
                void* name_vptr = (void*)name;
                ImportMemoryWin32NameEXT(memory, size, handleType, name_vptr);
            }
            public static unsafe void ImportMemoryWin32NameEXT<T1>(uint memory, ulong size, ExternalHandleType handleType, in T1 name)
                where T1 : unmanaged
            {
                fixed (void* name_ptr = &name)
                {
                    ImportMemoryWin32NameEXT(memory, size, handleType, name_ptr);
                }
            }
            public static unsafe void MultiDrawArraysEXT(PrimitiveType mode, ReadOnlySpan<int> first, ReadOnlySpan<int> count, int primcount)
            {
                fixed (int* first_ptr = first)
                {
                    fixed (int* count_ptr = count)
                    {
                        MultiDrawArraysEXT(mode, first_ptr, count_ptr, primcount);
                    }
                }
            }
            public static unsafe void MultiDrawArraysEXT(PrimitiveType mode, int[] first, int[] count, int primcount)
            {
                fixed (int* first_ptr = first)
                {
                    fixed (int* count_ptr = count)
                    {
                        MultiDrawArraysEXT(mode, first_ptr, count_ptr, primcount);
                    }
                }
            }
            public static unsafe void MultiDrawArraysEXT(PrimitiveType mode, in int first, in int count, int primcount)
            {
                fixed (int* first_ptr = &first)
                fixed (int* count_ptr = &count)
                {
                    MultiDrawArraysEXT(mode, first_ptr, count_ptr, primcount);
                }
            }
            public static unsafe void MultiDrawElementsEXT(PrimitiveType mode, ReadOnlySpan<int> count, DrawElementsType type, void** indices, int primcount)
            {
                fixed (int* count_ptr = count)
                {
                    MultiDrawElementsEXT(mode, count_ptr, type, indices, primcount);
                }
            }
            public static unsafe void MultiDrawElementsEXT(PrimitiveType mode, int[] count, DrawElementsType type, void** indices, int primcount)
            {
                fixed (int* count_ptr = count)
                {
                    MultiDrawElementsEXT(mode, count_ptr, type, indices, primcount);
                }
            }
            public static unsafe void MultiDrawElementsEXT(PrimitiveType mode, in int count, DrawElementsType type, void** indices, int primcount)
            {
                fixed (int* count_ptr = &count)
                {
                    MultiDrawElementsEXT(mode, count_ptr, type, indices, primcount);
                }
            }
            public static unsafe void SampleMaskEXT(float value, bool invert)
            {
                byte invert_byte = (byte)(invert ? 1 : 0);
                SampleMaskEXT(value, invert_byte);
            }
            public static unsafe void ColorTableEXT(ColorTableTarget target, InternalFormat internalFormat, int width, PixelFormat format, PixelType type, IntPtr table)
            {
                void* table_vptr = (void*)table;
                ColorTableEXT(target, internalFormat, width, format, type, table_vptr);
            }
            public static unsafe void ColorTableEXT<T1>(ColorTableTarget target, InternalFormat internalFormat, int width, PixelFormat format, PixelType type, ReadOnlySpan<T1> table)
                where T1 : unmanaged
            {
                fixed (void* table_ptr = table)
                {
                    ColorTableEXT(target, internalFormat, width, format, type, table_ptr);
                }
            }
            public static unsafe void ColorTableEXT<T1>(ColorTableTarget target, InternalFormat internalFormat, int width, PixelFormat format, PixelType type, T1[] table)
                where T1 : unmanaged
            {
                fixed (void* table_ptr = table)
                {
                    ColorTableEXT(target, internalFormat, width, format, type, table_ptr);
                }
            }
            public static unsafe void ColorTableEXT<T1>(ColorTableTarget target, InternalFormat internalFormat, int width, PixelFormat format, PixelType type, in T1 table)
                where T1 : unmanaged
            {
                fixed (void* table_ptr = &table)
                {
                    ColorTableEXT(target, internalFormat, width, format, type, table_ptr);
                }
            }
            public static unsafe void GetColorTableEXT(ColorTableTarget target, PixelFormat format, PixelType type, IntPtr data)
            {
                void* data_vptr = (void*)data;
                GetColorTableEXT(target, format, type, data_vptr);
            }
            public static unsafe void GetColorTableEXT<T1>(ColorTableTarget target, PixelFormat format, PixelType type, Span<T1> data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    GetColorTableEXT(target, format, type, data_ptr);
                }
            }
            public static unsafe void GetColorTableEXT<T1>(ColorTableTarget target, PixelFormat format, PixelType type, T1[] data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = data)
                {
                    GetColorTableEXT(target, format, type, data_ptr);
                }
            }
            public static unsafe void GetColorTableEXT<T1>(ColorTableTarget target, PixelFormat format, PixelType type, ref T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    GetColorTableEXT(target, format, type, data_ptr);
                }
            }
            public static unsafe void GetColorTableParameterivEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetColorTableParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetColorTableParameterivEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetColorTableParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetColorTableParameterivEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetColorTableParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetColorTableParameterfvEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetColorTableParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetColorTableParameterfvEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetColorTableParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetColorTableParameterfvEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetColorTableParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void PixelTransformParameterivEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    PixelTransformParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void PixelTransformParameterivEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    PixelTransformParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void PixelTransformParameterivEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    PixelTransformParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void PixelTransformParameterfvEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    PixelTransformParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void PixelTransformParameterfvEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    PixelTransformParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void PixelTransformParameterfvEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    PixelTransformParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetPixelTransformParameterivEXT(All target, All pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetPixelTransformParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetPixelTransformParameterivEXT(All target, All pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetPixelTransformParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetPixelTransformParameterivEXT(All target, All pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetPixelTransformParameterivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetPixelTransformParameterfvEXT(All target, All pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetPixelTransformParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetPixelTransformParameterfvEXT(All target, All pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetPixelTransformParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetPixelTransformParameterfvEXT(All target, All pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetPixelTransformParameterfvEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void PointParameterfvEXT(PointParameterNameARB pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    PointParameterfvEXT(pname, parameters_ptr);
                }
            }
            public static unsafe void PointParameterfvEXT(PointParameterNameARB pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    PointParameterfvEXT(pname, parameters_ptr);
                }
            }
            public static unsafe void PointParameterfvEXT(PointParameterNameARB pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    PointParameterfvEXT(pname, parameters_ptr);
                }
            }
            public static unsafe void RasterSamplesEXT(uint samples, bool fixedsamplelocations)
            {
                byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
                RasterSamplesEXT(samples, fixedsamplelocations_byte);
            }
            public static unsafe void GenSemaphoresEXT(Span<uint> semaphores)
            {
                int n = (int)(semaphores.Length);
                fixed (uint* semaphores_ptr = semaphores)
                {
                    GenSemaphoresEXT(n, semaphores_ptr);
                }
            }
            public static unsafe void GenSemaphoresEXT(uint[] semaphores)
            {
                int n = (int)(semaphores.Length);
                fixed (uint* semaphores_ptr = semaphores)
                {
                    GenSemaphoresEXT(n, semaphores_ptr);
                }
            }
            public static unsafe void GenSemaphoresEXT(int n, ref uint semaphores)
            {
                fixed (uint* semaphores_ptr = &semaphores)
                {
                    GenSemaphoresEXT(n, semaphores_ptr);
                }
            }
            public static unsafe void DeleteSemaphoresEXT(ReadOnlySpan<uint> semaphores)
            {
                int n = (int)(semaphores.Length);
                fixed (uint* semaphores_ptr = semaphores)
                {
                    DeleteSemaphoresEXT(n, semaphores_ptr);
                }
            }
            public static unsafe void DeleteSemaphoresEXT(uint[] semaphores)
            {
                int n = (int)(semaphores.Length);
                fixed (uint* semaphores_ptr = semaphores)
                {
                    DeleteSemaphoresEXT(n, semaphores_ptr);
                }
            }
            public static unsafe void DeleteSemaphoresEXT(int n, in uint semaphores)
            {
                fixed (uint* semaphores_ptr = &semaphores)
                {
                    DeleteSemaphoresEXT(n, semaphores_ptr);
                }
            }
            public static unsafe void SemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, in ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    SemaphoreParameterui64vEXT(semaphore, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, ref ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    GetSemaphoreParameterui64vEXT(semaphore, pname, parameters_ptr);
                }
            }
            public static unsafe void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, ReadOnlySpan<BufferHandle> buffers, uint numTextureBarriers, ReadOnlySpan<TextureHandle> textures, ReadOnlySpan<TextureLayout> srcLayouts)
            {
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    fixed (TextureHandle* textures_ptr = textures)
                    {
                        fixed (TextureLayout* srcLayouts_ptr = srcLayouts)
                        {
                            WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers_ptr, numTextureBarriers, textures_ptr, srcLayouts_ptr);
                        }
                    }
                }
            }
            public static unsafe void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, BufferHandle[] buffers, uint numTextureBarriers, TextureHandle[] textures, TextureLayout[] srcLayouts)
            {
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    fixed (TextureHandle* textures_ptr = textures)
                    {
                        fixed (TextureLayout* srcLayouts_ptr = srcLayouts)
                        {
                            WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers_ptr, numTextureBarriers, textures_ptr, srcLayouts_ptr);
                        }
                    }
                }
            }
            public static unsafe void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, in BufferHandle buffers, uint numTextureBarriers, in TextureHandle textures, in TextureLayout srcLayouts)
            {
                fixed (BufferHandle* buffers_ptr = &buffers)
                fixed (TextureHandle* textures_ptr = &textures)
                fixed (TextureLayout* srcLayouts_ptr = &srcLayouts)
                {
                    WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers_ptr, numTextureBarriers, textures_ptr, srcLayouts_ptr);
                }
            }
            public static unsafe void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, ReadOnlySpan<BufferHandle> buffers, uint numTextureBarriers, ReadOnlySpan<TextureHandle> textures, ReadOnlySpan<TextureLayout> dstLayouts)
            {
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    fixed (TextureHandle* textures_ptr = textures)
                    {
                        fixed (TextureLayout* dstLayouts_ptr = dstLayouts)
                        {
                            SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers_ptr, numTextureBarriers, textures_ptr, dstLayouts_ptr);
                        }
                    }
                }
            }
            public static unsafe void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, BufferHandle[] buffers, uint numTextureBarriers, TextureHandle[] textures, TextureLayout[] dstLayouts)
            {
                fixed (BufferHandle* buffers_ptr = buffers)
                {
                    fixed (TextureHandle* textures_ptr = textures)
                    {
                        fixed (TextureLayout* dstLayouts_ptr = dstLayouts)
                        {
                            SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers_ptr, numTextureBarriers, textures_ptr, dstLayouts_ptr);
                        }
                    }
                }
            }
            public static unsafe void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, in BufferHandle buffers, uint numTextureBarriers, in TextureHandle textures, in TextureLayout dstLayouts)
            {
                fixed (BufferHandle* buffers_ptr = &buffers)
                fixed (TextureHandle* textures_ptr = &textures)
                fixed (TextureLayout* dstLayouts_ptr = &dstLayouts)
                {
                    SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers_ptr, numTextureBarriers, textures_ptr, dstLayouts_ptr);
                }
            }
            public static unsafe void ImportSemaphoreWin32HandleEXT(uint semaphore, ExternalHandleType handleType, IntPtr handle)
            {
                void* handle_vptr = (void*)handle;
                ImportSemaphoreWin32HandleEXT(semaphore, handleType, handle_vptr);
            }
            public static unsafe void ImportSemaphoreWin32HandleEXT<T1>(uint semaphore, ExternalHandleType handleType, ref T1 handle)
                where T1 : unmanaged
            {
                fixed (void* handle_ptr = &handle)
                {
                    ImportSemaphoreWin32HandleEXT(semaphore, handleType, handle_ptr);
                }
            }
            public static unsafe void ImportSemaphoreWin32NameEXT(uint semaphore, ExternalHandleType handleType, IntPtr name)
            {
                void* name_vptr = (void*)name;
                ImportSemaphoreWin32NameEXT(semaphore, handleType, name_vptr);
            }
            public static unsafe void ImportSemaphoreWin32NameEXT<T1>(uint semaphore, ExternalHandleType handleType, in T1 name)
                where T1 : unmanaged
            {
                fixed (void* name_ptr = &name)
                {
                    ImportSemaphoreWin32NameEXT(semaphore, handleType, name_ptr);
                }
            }
            public static unsafe void SecondaryColor3bvEXT(ReadOnlySpan<sbyte> v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    SecondaryColor3bvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3bvEXT(sbyte[] v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    SecondaryColor3bvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3bvEXT(in sbyte v)
            {
                fixed (sbyte* v_ptr = &v)
                {
                    SecondaryColor3bvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3dvEXT(ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    SecondaryColor3dvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3dvEXT(double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    SecondaryColor3dvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3dvEXT(in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    SecondaryColor3dvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3fvEXT(ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    SecondaryColor3fvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3fvEXT(float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    SecondaryColor3fvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3fvEXT(in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    SecondaryColor3fvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3ivEXT(ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    SecondaryColor3ivEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3ivEXT(int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    SecondaryColor3ivEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3ivEXT(in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    SecondaryColor3ivEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3svEXT(ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    SecondaryColor3svEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3svEXT(short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    SecondaryColor3svEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3svEXT(in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    SecondaryColor3svEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3ubvEXT(ReadOnlySpan<byte> v)
            {
                fixed (byte* v_ptr = v)
                {
                    SecondaryColor3ubvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3ubvEXT(byte[] v)
            {
                fixed (byte* v_ptr = v)
                {
                    SecondaryColor3ubvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3ubvEXT(in byte v)
            {
                fixed (byte* v_ptr = &v)
                {
                    SecondaryColor3ubvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3uivEXT(ReadOnlySpan<uint> v)
            {
                fixed (uint* v_ptr = v)
                {
                    SecondaryColor3uivEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3uivEXT(uint[] v)
            {
                fixed (uint* v_ptr = v)
                {
                    SecondaryColor3uivEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3uivEXT(in uint v)
            {
                fixed (uint* v_ptr = &v)
                {
                    SecondaryColor3uivEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3usvEXT(ReadOnlySpan<ushort> v)
            {
                fixed (ushort* v_ptr = v)
                {
                    SecondaryColor3usvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3usvEXT(ushort[] v)
            {
                fixed (ushort* v_ptr = v)
                {
                    SecondaryColor3usvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3usvEXT(in ushort v)
            {
                fixed (ushort* v_ptr = &v)
                {
                    SecondaryColor3usvEXT(v_ptr);
                }
            }
            public static unsafe void SecondaryColorPointerEXT(int size, ColorPointerType type, int stride, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                SecondaryColorPointerEXT(size, type, stride, pointer_vptr);
            }
            public static unsafe void SecondaryColorPointerEXT<T1>(int size, ColorPointerType type, int stride, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    SecondaryColorPointerEXT(size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void SecondaryColorPointerEXT<T1>(int size, ColorPointerType type, int stride, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    SecondaryColorPointerEXT(size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void SecondaryColorPointerEXT<T1>(int size, ColorPointerType type, int stride, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    SecondaryColorPointerEXT(size, type, stride, pointer_ptr);
                }
            }
            public static unsafe ProgramHandle CreateShaderProgramEXT(ShaderType type, string str)
            {
                ProgramHandle returnValue;
                byte* str_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(str);
                returnValue = CreateShaderProgramEXT(type, str_ptr);
                Marshal.FreeCoTaskMem((IntPtr)str_ptr);
                return returnValue;
            }
            public static unsafe void DeleteProgramPipelinesEXT(ReadOnlySpan<ProgramPipelineHandle> pipelines)
            {
                int n = (int)(pipelines.Length);
                fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
                {
                    DeleteProgramPipelinesEXT(n, pipelines_ptr);
                }
            }
            public static unsafe void DeleteProgramPipelinesEXT(ProgramPipelineHandle[] pipelines)
            {
                int n = (int)(pipelines.Length);
                fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
                {
                    DeleteProgramPipelinesEXT(n, pipelines_ptr);
                }
            }
            public static unsafe void DeleteProgramPipelinesEXT(int n, in ProgramPipelineHandle pipelines)
            {
                fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines)
                {
                    DeleteProgramPipelinesEXT(n, pipelines_ptr);
                }
            }
            public static unsafe void GenProgramPipelinesEXT(Span<ProgramPipelineHandle> pipelines)
            {
                int n = (int)(pipelines.Length);
                fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
                {
                    GenProgramPipelinesEXT(n, pipelines_ptr);
                }
            }
            public static unsafe void GenProgramPipelinesEXT(ProgramPipelineHandle[] pipelines)
            {
                int n = (int)(pipelines.Length);
                fixed (ProgramPipelineHandle* pipelines_ptr = pipelines)
                {
                    GenProgramPipelinesEXT(n, pipelines_ptr);
                }
            }
            public static unsafe void GenProgramPipelinesEXT(int n, ref ProgramPipelineHandle pipelines)
            {
                fixed (ProgramPipelineHandle* pipelines_ptr = &pipelines)
                {
                    GenProgramPipelinesEXT(n, pipelines_ptr);
                }
            }
            public static unsafe string GetProgramPipelineInfoLogEXT(ProgramPipelineHandle pipeline, int bufSize, Span<int> length)
            {
                string infoLog;
                fixed (int* length_ptr = length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramPipelineInfoLogEXT(pipeline, bufSize, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
                return infoLog;
            }
            public static unsafe void GetProgramPipelineInfoLogEXT(ProgramPipelineHandle pipeline, int bufSize, Span<int> length, out string infoLog)
            {
                fixed (int* length_ptr = length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramPipelineInfoLogEXT(pipeline, bufSize, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
            }
            public static unsafe string GetProgramPipelineInfoLogEXT(ProgramPipelineHandle pipeline, int bufSize, int[] length)
            {
                string infoLog;
                fixed (int* length_ptr = length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramPipelineInfoLogEXT(pipeline, bufSize, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
                return infoLog;
            }
            public static unsafe void GetProgramPipelineInfoLogEXT(ProgramPipelineHandle pipeline, int bufSize, int[] length, out string infoLog)
            {
                fixed (int* length_ptr = length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramPipelineInfoLogEXT(pipeline, bufSize, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
            }
            public static unsafe string GetProgramPipelineInfoLogEXT(ProgramPipelineHandle pipeline, int bufSize, ref int length)
            {
                string infoLog;
                fixed (int* length_ptr = &length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramPipelineInfoLogEXT(pipeline, bufSize, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
                return infoLog;
            }
            public static unsafe void GetProgramPipelineInfoLogEXT(ProgramPipelineHandle pipeline, int bufSize, ref int length, out string infoLog)
            {
                fixed (int* length_ptr = &length)
                {
                    var infoLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetProgramPipelineInfoLogEXT(pipeline, bufSize, length_ptr, infoLog_ptr);
                    infoLog = Marshal.PtrToStringUTF8((IntPtr)infoLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)infoLog_ptr);
                }
            }
            public static unsafe void GetProgramPipelineivEXT(ProgramPipelineHandle pipeline, PipelineParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetProgramPipelineivEXT(pipeline, pname, parameters_ptr);
                }
            }
            public static unsafe void BindImageTextureEXT(uint index, TextureHandle texture, int level, bool layered, int layer, BufferAccessARB access, int format)
            {
                byte layered_byte = (byte)(layered ? 1 : 0);
                BindImageTextureEXT(index, texture, level, layered_byte, layer, access, format);
            }
            public static unsafe void TexSubImage1DEXT(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TexSubImage1DEXT(target, level, xoffset, width, format, type, pixels_vptr);
            }
            public static unsafe void TexSubImage1DEXT<T1>(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TexSubImage1DEXT(target, level, xoffset, width, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexSubImage1DEXT<T1>(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TexSubImage1DEXT(target, level, xoffset, width, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexSubImage1DEXT<T1>(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TexSubImage1DEXT(target, level, xoffset, width, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexSubImage2DEXT(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels_vptr);
            }
            public static unsafe void TexSubImage2DEXT<T1>(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexSubImage2DEXT<T1>(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexSubImage2DEXT<T1>(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexImage3DEXT(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels_vptr);
            }
            public static unsafe void TexImage3DEXT<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexImage3DEXT<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexImage3DEXT<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexSubImage3DEXT(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_vptr);
            }
            public static unsafe void TexSubImage3DEXT<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexSubImage3DEXT<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexSubImage3DEXT<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexParameterIivEXT(TextureTarget target, TextureParameterName pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    TexParameterIivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void TexParameterIivEXT(TextureTarget target, TextureParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    TexParameterIivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void TexParameterIivEXT(TextureTarget target, TextureParameterName pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    TexParameterIivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void TexParameterIuivEXT(TextureTarget target, TextureParameterName pname, ReadOnlySpan<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    TexParameterIuivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void TexParameterIuivEXT(TextureTarget target, TextureParameterName pname, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    TexParameterIuivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void TexParameterIuivEXT(TextureTarget target, TextureParameterName pname, in uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    TexParameterIuivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexParameterIivEXT(TextureTarget target, GetTextureParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTexParameterIivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexParameterIivEXT(TextureTarget target, GetTextureParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTexParameterIivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexParameterIivEXT(TextureTarget target, GetTextureParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetTexParameterIivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexParameterIuivEXT(TextureTarget target, GetTextureParameter pname, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetTexParameterIuivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexParameterIuivEXT(TextureTarget target, GetTextureParameter pname, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetTexParameterIuivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexParameterIuivEXT(TextureTarget target, GetTextureParameter pname, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetTexParameterIuivEXT(target, pname, parameters_ptr);
                }
            }
            public static unsafe byte AreTexturesResidentEXT(int n, ReadOnlySpan<TextureHandle> textures, Span<byte> residences)
            {
                byte returnValue;
                fixed (TextureHandle* textures_ptr = textures)
                {
                    fixed (byte* residences_ptr = residences)
                    {
                        returnValue = AreTexturesResidentEXT(n, textures_ptr, residences_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe byte AreTexturesResidentEXT(int n, TextureHandle[] textures, byte[] residences)
            {
                byte returnValue;
                fixed (TextureHandle* textures_ptr = textures)
                {
                    fixed (byte* residences_ptr = residences)
                    {
                        returnValue = AreTexturesResidentEXT(n, textures_ptr, residences_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe byte AreTexturesResidentEXT(int n, in TextureHandle textures, ref byte residences)
            {
                byte returnValue;
                fixed (TextureHandle* textures_ptr = &textures)
                fixed (byte* residences_ptr = &residences)
                {
                    returnValue = AreTexturesResidentEXT(n, textures_ptr, residences_ptr);
                }
                return returnValue;
            }
            public static unsafe void DeleteTexturesEXT(ReadOnlySpan<TextureHandle> textures)
            {
                int n = (int)(textures.Length);
                fixed (TextureHandle* textures_ptr = textures)
                {
                    DeleteTexturesEXT(n, textures_ptr);
                }
            }
            public static unsafe void DeleteTexturesEXT(TextureHandle[] textures)
            {
                int n = (int)(textures.Length);
                fixed (TextureHandle* textures_ptr = textures)
                {
                    DeleteTexturesEXT(n, textures_ptr);
                }
            }
            public static unsafe void DeleteTexturesEXT(int n, in TextureHandle textures)
            {
                fixed (TextureHandle* textures_ptr = &textures)
                {
                    DeleteTexturesEXT(n, textures_ptr);
                }
            }
            public static unsafe void GenTexturesEXT(Span<TextureHandle> textures)
            {
                int n = (int)(textures.Length);
                fixed (TextureHandle* textures_ptr = textures)
                {
                    GenTexturesEXT(n, textures_ptr);
                }
            }
            public static unsafe void GenTexturesEXT(TextureHandle[] textures)
            {
                int n = (int)(textures.Length);
                fixed (TextureHandle* textures_ptr = textures)
                {
                    GenTexturesEXT(n, textures_ptr);
                }
            }
            public static unsafe void GenTexturesEXT(int n, ref TextureHandle textures)
            {
                fixed (TextureHandle* textures_ptr = &textures)
                {
                    GenTexturesEXT(n, textures_ptr);
                }
            }
            public static unsafe void PrioritizeTexturesEXT(int n, ReadOnlySpan<TextureHandle> textures, ReadOnlySpan<float> priorities)
            {
                fixed (TextureHandle* textures_ptr = textures)
                {
                    fixed (float* priorities_ptr = priorities)
                    {
                        PrioritizeTexturesEXT(n, textures_ptr, priorities_ptr);
                    }
                }
            }
            public static unsafe void PrioritizeTexturesEXT(int n, TextureHandle[] textures, float[] priorities)
            {
                fixed (TextureHandle* textures_ptr = textures)
                {
                    fixed (float* priorities_ptr = priorities)
                    {
                        PrioritizeTexturesEXT(n, textures_ptr, priorities_ptr);
                    }
                }
            }
            public static unsafe void PrioritizeTexturesEXT(int n, in TextureHandle textures, in float priorities)
            {
                fixed (TextureHandle* textures_ptr = &textures)
                fixed (float* priorities_ptr = &priorities)
                {
                    PrioritizeTexturesEXT(n, textures_ptr, priorities_ptr);
                }
            }
            public static unsafe void GetQueryObjecti64vEXT(QueryHandle id, QueryObjectParameterName pname, Span<long> parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetQueryObjecti64vEXT(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjecti64vEXT(QueryHandle id, QueryObjectParameterName pname, long[] parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetQueryObjecti64vEXT(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjecti64vEXT(QueryHandle id, QueryObjectParameterName pname, ref long parameters)
            {
                fixed (long* parameters_ptr = &parameters)
                {
                    GetQueryObjecti64vEXT(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjectui64vEXT(QueryHandle id, QueryObjectParameterName pname, Span<ulong> parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetQueryObjectui64vEXT(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjectui64vEXT(QueryHandle id, QueryObjectParameterName pname, ulong[] parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetQueryObjectui64vEXT(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetQueryObjectui64vEXT(QueryHandle id, QueryObjectParameterName pname, ref ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    GetQueryObjectui64vEXT(id, pname, parameters_ptr);
                }
            }
            public static unsafe string GetTransformFeedbackVaryingEXT(ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (AttributeType* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                            GetTransformFeedbackVaryingEXT(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
                return name;
            }
            public static unsafe void GetTransformFeedbackVaryingEXT(ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<AttributeType> type, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (AttributeType* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                            GetTransformFeedbackVaryingEXT(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
            }
            public static unsafe string GetTransformFeedbackVaryingEXT(ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (AttributeType* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                            GetTransformFeedbackVaryingEXT(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
                return name;
            }
            public static unsafe void GetTransformFeedbackVaryingEXT(ProgramHandle program, uint index, int bufSize, int[] length, int[] size, AttributeType[] type, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (AttributeType* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                            GetTransformFeedbackVaryingEXT(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
            }
            public static unsafe string GetTransformFeedbackVaryingEXT(ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type)
            {
                string name;
                fixed (int* length_ptr = &length)
                fixed (int* size_ptr = &size)
                fixed (AttributeType* type_ptr = &type)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetTransformFeedbackVaryingEXT(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return name;
            }
            public static unsafe void GetTransformFeedbackVaryingEXT(ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref AttributeType type, out string name)
            {
                fixed (int* length_ptr = &length)
                fixed (int* size_ptr = &size)
                fixed (AttributeType* type_ptr = &type)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetTransformFeedbackVaryingEXT(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe void ColorPointerEXT(int size, ColorPointerType type, int stride, int count, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                ColorPointerEXT(size, type, stride, count, pointer_vptr);
            }
            public static unsafe void ColorPointerEXT<T1>(int size, ColorPointerType type, int stride, int count, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    ColorPointerEXT(size, type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void ColorPointerEXT<T1>(int size, ColorPointerType type, int stride, int count, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    ColorPointerEXT(size, type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void ColorPointerEXT<T1>(int size, ColorPointerType type, int stride, int count, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    ColorPointerEXT(size, type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void EdgeFlagPointerEXT(int stride, int count, ReadOnlySpan<byte> pointer)
            {
                fixed (byte* pointer_ptr = pointer)
                {
                    EdgeFlagPointerEXT(stride, count, pointer_ptr);
                }
            }
            public static unsafe void EdgeFlagPointerEXT(int stride, int count, byte[] pointer)
            {
                fixed (byte* pointer_ptr = pointer)
                {
                    EdgeFlagPointerEXT(stride, count, pointer_ptr);
                }
            }
            public static unsafe void EdgeFlagPointerEXT(int stride, int count, in byte pointer)
            {
                fixed (byte* pointer_ptr = &pointer)
                {
                    EdgeFlagPointerEXT(stride, count, pointer_ptr);
                }
            }
            public static unsafe void IndexPointerEXT(IndexPointerType type, int stride, int count, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                IndexPointerEXT(type, stride, count, pointer_vptr);
            }
            public static unsafe void IndexPointerEXT<T1>(IndexPointerType type, int stride, int count, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    IndexPointerEXT(type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void IndexPointerEXT<T1>(IndexPointerType type, int stride, int count, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    IndexPointerEXT(type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void IndexPointerEXT<T1>(IndexPointerType type, int stride, int count, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    IndexPointerEXT(type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void NormalPointerEXT(NormalPointerType type, int stride, int count, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                NormalPointerEXT(type, stride, count, pointer_vptr);
            }
            public static unsafe void NormalPointerEXT<T1>(NormalPointerType type, int stride, int count, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    NormalPointerEXT(type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void NormalPointerEXT<T1>(NormalPointerType type, int stride, int count, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    NormalPointerEXT(type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void NormalPointerEXT<T1>(NormalPointerType type, int stride, int count, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    NormalPointerEXT(type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void TexCoordPointerEXT(int size, TexCoordPointerType type, int stride, int count, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                TexCoordPointerEXT(size, type, stride, count, pointer_vptr);
            }
            public static unsafe void TexCoordPointerEXT<T1>(int size, TexCoordPointerType type, int stride, int count, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    TexCoordPointerEXT(size, type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void TexCoordPointerEXT<T1>(int size, TexCoordPointerType type, int stride, int count, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    TexCoordPointerEXT(size, type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void TexCoordPointerEXT<T1>(int size, TexCoordPointerType type, int stride, int count, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    TexCoordPointerEXT(size, type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void VertexPointerEXT(int size, VertexPointerType type, int stride, int count, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                VertexPointerEXT(size, type, stride, count, pointer_vptr);
            }
            public static unsafe void VertexPointerEXT<T1>(int size, VertexPointerType type, int stride, int count, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    VertexPointerEXT(size, type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void VertexPointerEXT<T1>(int size, VertexPointerType type, int stride, int count, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    VertexPointerEXT(size, type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void VertexPointerEXT<T1>(int size, VertexPointerType type, int stride, int count, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    VertexPointerEXT(size, type, stride, count, pointer_ptr);
                }
            }
            public static unsafe void VertexAttribL1dvEXT(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL1dvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL1dvEXT(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL1dvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL1dvEXT(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttribL1dvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL2dvEXT(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL2dvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL2dvEXT(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL2dvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL2dvEXT(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttribL2dvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL3dvEXT(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL3dvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL3dvEXT(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL3dvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL3dvEXT(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttribL3dvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL4dvEXT(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL4dvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL4dvEXT(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttribL4dvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL4dvEXT(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttribL4dvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribLPointerEXT(uint index, int size, VertexAttribLType type, int stride, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                VertexAttribLPointerEXT(index, size, type, stride, pointer_vptr);
            }
            public static unsafe void VertexAttribLPointerEXT<T1>(uint index, VertexAttribLType type, int stride, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                int size = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    VertexAttribLPointerEXT(index, size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void VertexAttribLPointerEXT<T1>(uint index, VertexAttribLType type, int stride, T1[] pointer)
                where T1 : unmanaged
            {
                int size = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    VertexAttribLPointerEXT(index, size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void VertexAttribLPointerEXT<T1>(uint index, int size, VertexAttribLType type, int stride, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    VertexAttribLPointerEXT(index, size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void GetVertexAttribLdvEXT(uint index, VertexAttribEnum pname, Span<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetVertexAttribLdvEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribLdvEXT(uint index, VertexAttribEnum pname, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetVertexAttribLdvEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribLdvEXT(uint index, VertexAttribEnum pname, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    GetVertexAttribLdvEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void SetInvariantEXT(uint id, ScalarType type, IntPtr addr)
            {
                void* addr_vptr = (void*)addr;
                SetInvariantEXT(id, type, addr_vptr);
            }
            public static unsafe void SetInvariantEXT<T1>(uint id, ScalarType type, ReadOnlySpan<T1> addr)
                where T1 : unmanaged
            {
                fixed (void* addr_ptr = addr)
                {
                    SetInvariantEXT(id, type, addr_ptr);
                }
            }
            public static unsafe void SetInvariantEXT<T1>(uint id, ScalarType type, T1[] addr)
                where T1 : unmanaged
            {
                fixed (void* addr_ptr = addr)
                {
                    SetInvariantEXT(id, type, addr_ptr);
                }
            }
            public static unsafe void SetInvariantEXT<T1>(uint id, ScalarType type, in T1 addr)
                where T1 : unmanaged
            {
                fixed (void* addr_ptr = &addr)
                {
                    SetInvariantEXT(id, type, addr_ptr);
                }
            }
            public static unsafe void SetLocalConstantEXT(uint id, ScalarType type, IntPtr addr)
            {
                void* addr_vptr = (void*)addr;
                SetLocalConstantEXT(id, type, addr_vptr);
            }
            public static unsafe void SetLocalConstantEXT<T1>(uint id, ScalarType type, ReadOnlySpan<T1> addr)
                where T1 : unmanaged
            {
                fixed (void* addr_ptr = addr)
                {
                    SetLocalConstantEXT(id, type, addr_ptr);
                }
            }
            public static unsafe void SetLocalConstantEXT<T1>(uint id, ScalarType type, T1[] addr)
                where T1 : unmanaged
            {
                fixed (void* addr_ptr = addr)
                {
                    SetLocalConstantEXT(id, type, addr_ptr);
                }
            }
            public static unsafe void SetLocalConstantEXT<T1>(uint id, ScalarType type, in T1 addr)
                where T1 : unmanaged
            {
                fixed (void* addr_ptr = &addr)
                {
                    SetLocalConstantEXT(id, type, addr_ptr);
                }
            }
            public static unsafe void VariantbvEXT(uint id, ReadOnlySpan<sbyte> addr)
            {
                fixed (sbyte* addr_ptr = addr)
                {
                    VariantbvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantbvEXT(uint id, sbyte[] addr)
            {
                fixed (sbyte* addr_ptr = addr)
                {
                    VariantbvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantbvEXT(uint id, in sbyte addr)
            {
                fixed (sbyte* addr_ptr = &addr)
                {
                    VariantbvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantsvEXT(uint id, ReadOnlySpan<short> addr)
            {
                fixed (short* addr_ptr = addr)
                {
                    VariantsvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantsvEXT(uint id, short[] addr)
            {
                fixed (short* addr_ptr = addr)
                {
                    VariantsvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantsvEXT(uint id, in short addr)
            {
                fixed (short* addr_ptr = &addr)
                {
                    VariantsvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantivEXT(uint id, ReadOnlySpan<int> addr)
            {
                fixed (int* addr_ptr = addr)
                {
                    VariantivEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantivEXT(uint id, int[] addr)
            {
                fixed (int* addr_ptr = addr)
                {
                    VariantivEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantivEXT(uint id, in int addr)
            {
                fixed (int* addr_ptr = &addr)
                {
                    VariantivEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantfvEXT(uint id, ReadOnlySpan<float> addr)
            {
                fixed (float* addr_ptr = addr)
                {
                    VariantfvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantfvEXT(uint id, float[] addr)
            {
                fixed (float* addr_ptr = addr)
                {
                    VariantfvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantfvEXT(uint id, in float addr)
            {
                fixed (float* addr_ptr = &addr)
                {
                    VariantfvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantdvEXT(uint id, ReadOnlySpan<double> addr)
            {
                fixed (double* addr_ptr = addr)
                {
                    VariantdvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantdvEXT(uint id, double[] addr)
            {
                fixed (double* addr_ptr = addr)
                {
                    VariantdvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantdvEXT(uint id, in double addr)
            {
                fixed (double* addr_ptr = &addr)
                {
                    VariantdvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantubvEXT(uint id, ReadOnlySpan<byte> addr)
            {
                fixed (byte* addr_ptr = addr)
                {
                    VariantubvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantubvEXT(uint id, byte[] addr)
            {
                fixed (byte* addr_ptr = addr)
                {
                    VariantubvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantubvEXT(uint id, in byte addr)
            {
                fixed (byte* addr_ptr = &addr)
                {
                    VariantubvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantusvEXT(uint id, ReadOnlySpan<ushort> addr)
            {
                fixed (ushort* addr_ptr = addr)
                {
                    VariantusvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantusvEXT(uint id, ushort[] addr)
            {
                fixed (ushort* addr_ptr = addr)
                {
                    VariantusvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantusvEXT(uint id, in ushort addr)
            {
                fixed (ushort* addr_ptr = &addr)
                {
                    VariantusvEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantuivEXT(uint id, ReadOnlySpan<uint> addr)
            {
                fixed (uint* addr_ptr = addr)
                {
                    VariantuivEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantuivEXT(uint id, uint[] addr)
            {
                fixed (uint* addr_ptr = addr)
                {
                    VariantuivEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantuivEXT(uint id, in uint addr)
            {
                fixed (uint* addr_ptr = &addr)
                {
                    VariantuivEXT(id, addr_ptr);
                }
            }
            public static unsafe void VariantPointerEXT(uint id, ScalarType type, uint stride, IntPtr addr)
            {
                void* addr_vptr = (void*)addr;
                VariantPointerEXT(id, type, stride, addr_vptr);
            }
            public static unsafe void VariantPointerEXT<T1>(uint id, ScalarType type, uint stride, ReadOnlySpan<T1> addr)
                where T1 : unmanaged
            {
                fixed (void* addr_ptr = addr)
                {
                    VariantPointerEXT(id, type, stride, addr_ptr);
                }
            }
            public static unsafe void VariantPointerEXT<T1>(uint id, ScalarType type, uint stride, T1[] addr)
                where T1 : unmanaged
            {
                fixed (void* addr_ptr = addr)
                {
                    VariantPointerEXT(id, type, stride, addr_ptr);
                }
            }
            public static unsafe void VariantPointerEXT<T1>(uint id, ScalarType type, uint stride, in T1 addr)
                where T1 : unmanaged
            {
                fixed (void* addr_ptr = &addr)
                {
                    VariantPointerEXT(id, type, stride, addr_ptr);
                }
            }
            public static unsafe void GetVariantBooleanvEXT(uint id, GetVariantValueEXT value, Span<byte> data)
            {
                fixed (byte* data_ptr = data)
                {
                    GetVariantBooleanvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetVariantBooleanvEXT(uint id, GetVariantValueEXT value, byte[] data)
            {
                fixed (byte* data_ptr = data)
                {
                    GetVariantBooleanvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetVariantBooleanvEXT(uint id, GetVariantValueEXT value, ref byte data)
            {
                fixed (byte* data_ptr = &data)
                {
                    GetVariantBooleanvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetVariantIntegervEXT(uint id, GetVariantValueEXT value, Span<int> data)
            {
                fixed (int* data_ptr = data)
                {
                    GetVariantIntegervEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetVariantIntegervEXT(uint id, GetVariantValueEXT value, int[] data)
            {
                fixed (int* data_ptr = data)
                {
                    GetVariantIntegervEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetVariantIntegervEXT(uint id, GetVariantValueEXT value, ref int data)
            {
                fixed (int* data_ptr = &data)
                {
                    GetVariantIntegervEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetVariantFloatvEXT(uint id, GetVariantValueEXT value, Span<float> data)
            {
                fixed (float* data_ptr = data)
                {
                    GetVariantFloatvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetVariantFloatvEXT(uint id, GetVariantValueEXT value, float[] data)
            {
                fixed (float* data_ptr = data)
                {
                    GetVariantFloatvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetVariantFloatvEXT(uint id, GetVariantValueEXT value, ref float data)
            {
                fixed (float* data_ptr = &data)
                {
                    GetVariantFloatvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetInvariantBooleanvEXT(uint id, GetVariantValueEXT value, Span<byte> data)
            {
                fixed (byte* data_ptr = data)
                {
                    GetInvariantBooleanvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetInvariantBooleanvEXT(uint id, GetVariantValueEXT value, byte[] data)
            {
                fixed (byte* data_ptr = data)
                {
                    GetInvariantBooleanvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetInvariantBooleanvEXT(uint id, GetVariantValueEXT value, ref byte data)
            {
                fixed (byte* data_ptr = &data)
                {
                    GetInvariantBooleanvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetInvariantIntegervEXT(uint id, GetVariantValueEXT value, Span<int> data)
            {
                fixed (int* data_ptr = data)
                {
                    GetInvariantIntegervEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetInvariantIntegervEXT(uint id, GetVariantValueEXT value, int[] data)
            {
                fixed (int* data_ptr = data)
                {
                    GetInvariantIntegervEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetInvariantIntegervEXT(uint id, GetVariantValueEXT value, ref int data)
            {
                fixed (int* data_ptr = &data)
                {
                    GetInvariantIntegervEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetInvariantFloatvEXT(uint id, GetVariantValueEXT value, Span<float> data)
            {
                fixed (float* data_ptr = data)
                {
                    GetInvariantFloatvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetInvariantFloatvEXT(uint id, GetVariantValueEXT value, float[] data)
            {
                fixed (float* data_ptr = data)
                {
                    GetInvariantFloatvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetInvariantFloatvEXT(uint id, GetVariantValueEXT value, ref float data)
            {
                fixed (float* data_ptr = &data)
                {
                    GetInvariantFloatvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetLocalConstantBooleanvEXT(uint id, GetVariantValueEXT value, Span<byte> data)
            {
                fixed (byte* data_ptr = data)
                {
                    GetLocalConstantBooleanvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetLocalConstantBooleanvEXT(uint id, GetVariantValueEXT value, byte[] data)
            {
                fixed (byte* data_ptr = data)
                {
                    GetLocalConstantBooleanvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetLocalConstantBooleanvEXT(uint id, GetVariantValueEXT value, ref byte data)
            {
                fixed (byte* data_ptr = &data)
                {
                    GetLocalConstantBooleanvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetLocalConstantIntegervEXT(uint id, GetVariantValueEXT value, Span<int> data)
            {
                fixed (int* data_ptr = data)
                {
                    GetLocalConstantIntegervEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetLocalConstantIntegervEXT(uint id, GetVariantValueEXT value, int[] data)
            {
                fixed (int* data_ptr = data)
                {
                    GetLocalConstantIntegervEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetLocalConstantIntegervEXT(uint id, GetVariantValueEXT value, ref int data)
            {
                fixed (int* data_ptr = &data)
                {
                    GetLocalConstantIntegervEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetLocalConstantFloatvEXT(uint id, GetVariantValueEXT value, Span<float> data)
            {
                fixed (float* data_ptr = data)
                {
                    GetLocalConstantFloatvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetLocalConstantFloatvEXT(uint id, GetVariantValueEXT value, float[] data)
            {
                fixed (float* data_ptr = data)
                {
                    GetLocalConstantFloatvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void GetLocalConstantFloatvEXT(uint id, GetVariantValueEXT value, ref float data)
            {
                fixed (float* data_ptr = &data)
                {
                    GetLocalConstantFloatvEXT(id, value, data_ptr);
                }
            }
            public static unsafe void VertexWeightfvEXT(ReadOnlySpan<float> weight)
            {
                fixed (float* weight_ptr = weight)
                {
                    VertexWeightfvEXT(weight_ptr);
                }
            }
            public static unsafe void VertexWeightfvEXT(float[] weight)
            {
                fixed (float* weight_ptr = weight)
                {
                    VertexWeightfvEXT(weight_ptr);
                }
            }
            public static unsafe void VertexWeightfvEXT(in float weight)
            {
                fixed (float* weight_ptr = &weight)
                {
                    VertexWeightfvEXT(weight_ptr);
                }
            }
            public static unsafe void VertexWeightPointerEXT(int size, VertexWeightPointerTypeEXT type, int stride, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                VertexWeightPointerEXT(size, type, stride, pointer_vptr);
            }
            public static unsafe void VertexWeightPointerEXT<T1>(int size, VertexWeightPointerTypeEXT type, int stride, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    VertexWeightPointerEXT(size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void VertexWeightPointerEXT<T1>(int size, VertexWeightPointerTypeEXT type, int stride, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    VertexWeightPointerEXT(size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void VertexWeightPointerEXT<T1>(int size, VertexWeightPointerTypeEXT type, int stride, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    VertexWeightPointerEXT(size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void WindowRectanglesEXT(All mode, int count, ReadOnlySpan<int> box)
            {
                fixed (int* box_ptr = box)
                {
                    WindowRectanglesEXT(mode, count, box_ptr);
                }
            }
            public static unsafe void WindowRectanglesEXT(All mode, int count, int[] box)
            {
                fixed (int* box_ptr = box)
                {
                    WindowRectanglesEXT(mode, count, box_ptr);
                }
            }
            public static unsafe void WindowRectanglesEXT(All mode, int count, in int box)
            {
                fixed (int* box_ptr = &box)
                {
                    WindowRectanglesEXT(mode, count, box_ptr);
                }
            }
        }
        public static unsafe partial class NV
        {
            public static unsafe void CreateSemaphoresNV(Span<uint> semaphores)
            {
                int n = (int)(semaphores.Length);
                fixed (uint* semaphores_ptr = semaphores)
                {
                    CreateSemaphoresNV(n, semaphores_ptr);
                }
            }
            public static unsafe void CreateSemaphoresNV(uint[] semaphores)
            {
                int n = (int)(semaphores.Length);
                fixed (uint* semaphores_ptr = semaphores)
                {
                    CreateSemaphoresNV(n, semaphores_ptr);
                }
            }
            public static unsafe void CreateSemaphoresNV(int n, ref uint semaphores)
            {
                fixed (uint* semaphores_ptr = &semaphores)
                {
                    CreateSemaphoresNV(n, semaphores_ptr);
                }
            }
            public static unsafe void SemaphoreParameterivNV(uint semaphore, SemaphoreParameterName pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    SemaphoreParameterivNV(semaphore, pname, parameters_ptr);
                }
            }
            public static unsafe void GetSemaphoreParameterivNV(uint semaphore, SemaphoreParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetSemaphoreParameterivNV(semaphore, pname, parameters_ptr);
                }
            }
            public static unsafe void MultiDrawArraysIndirectBindlessNV(PrimitiveType mode, IntPtr indirect, int drawCount, int stride, int vertexBufferCount)
            {
                void* indirect_vptr = (void*)indirect;
                MultiDrawArraysIndirectBindlessNV(mode, indirect_vptr, drawCount, stride, vertexBufferCount);
            }
            public static unsafe void MultiDrawArraysIndirectBindlessNV<T1>(PrimitiveType mode, in T1 indirect, int drawCount, int stride, int vertexBufferCount)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = &indirect)
                {
                    MultiDrawArraysIndirectBindlessNV(mode, indirect_ptr, drawCount, stride, vertexBufferCount);
                }
            }
            public static unsafe void MultiDrawElementsIndirectBindlessNV(PrimitiveType mode, DrawElementsType type, IntPtr indirect, int drawCount, int stride, int vertexBufferCount)
            {
                void* indirect_vptr = (void*)indirect;
                MultiDrawElementsIndirectBindlessNV(mode, type, indirect_vptr, drawCount, stride, vertexBufferCount);
            }
            public static unsafe void MultiDrawElementsIndirectBindlessNV<T1>(PrimitiveType mode, DrawElementsType type, in T1 indirect, int drawCount, int stride, int vertexBufferCount)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = &indirect)
                {
                    MultiDrawElementsIndirectBindlessNV(mode, type, indirect_ptr, drawCount, stride, vertexBufferCount);
                }
            }
            public static unsafe void MultiDrawArraysIndirectBindlessCountNV(PrimitiveType mode, IntPtr indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount)
            {
                void* indirect_vptr = (void*)indirect;
                MultiDrawArraysIndirectBindlessCountNV(mode, indirect_vptr, drawCount, maxDrawCount, stride, vertexBufferCount);
            }
            public static unsafe void MultiDrawArraysIndirectBindlessCountNV<T1>(PrimitiveType mode, in T1 indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = &indirect)
                {
                    MultiDrawArraysIndirectBindlessCountNV(mode, indirect_ptr, drawCount, maxDrawCount, stride, vertexBufferCount);
                }
            }
            public static unsafe void MultiDrawElementsIndirectBindlessCountNV(PrimitiveType mode, DrawElementsType type, IntPtr indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount)
            {
                void* indirect_vptr = (void*)indirect;
                MultiDrawElementsIndirectBindlessCountNV(mode, type, indirect_vptr, drawCount, maxDrawCount, stride, vertexBufferCount);
            }
            public static unsafe void MultiDrawElementsIndirectBindlessCountNV<T1>(PrimitiveType mode, DrawElementsType type, in T1 indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount)
                where T1 : unmanaged
            {
                fixed (void* indirect_ptr = &indirect)
                {
                    MultiDrawElementsIndirectBindlessCountNV(mode, type, indirect_ptr, drawCount, maxDrawCount, stride, vertexBufferCount);
                }
            }
            public static unsafe ulong GetImageHandleNV(TextureHandle texture, int level, bool layered, int layer, PixelFormat format)
            {
                ulong returnValue;
                byte layered_byte = (byte)(layered ? 1 : 0);
                returnValue = GetImageHandleNV(texture, level, layered_byte, layer, format);
                return returnValue;
            }
            public static unsafe void UniformHandleui64vNV(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length);
                fixed (ulong* value_ptr = value)
                {
                    UniformHandleui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void UniformHandleui64vNV(int location, ulong[] value)
            {
                int count = (int)(value.Length);
                fixed (ulong* value_ptr = value)
                {
                    UniformHandleui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void UniformHandleui64vNV(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    UniformHandleui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniformHandleui64vNV(ProgramHandle program, int location, ReadOnlySpan<ulong> values)
            {
                int count = (int)(values.Length);
                fixed (ulong* values_ptr = values)
                {
                    ProgramUniformHandleui64vNV(program, location, count, values_ptr);
                }
            }
            public static unsafe void ProgramUniformHandleui64vNV(ProgramHandle program, int location, ulong[] values)
            {
                int count = (int)(values.Length);
                fixed (ulong* values_ptr = values)
                {
                    ProgramUniformHandleui64vNV(program, location, count, values_ptr);
                }
            }
            public static unsafe void ProgramUniformHandleui64vNV(ProgramHandle program, int location, int count, in ulong values)
            {
                fixed (ulong* values_ptr = &values)
                {
                    ProgramUniformHandleui64vNV(program, location, count, values_ptr);
                }
            }
            public static unsafe void CreateStatesNV(Span<uint> states)
            {
                int n = (int)(states.Length);
                fixed (uint* states_ptr = states)
                {
                    CreateStatesNV(n, states_ptr);
                }
            }
            public static unsafe void CreateStatesNV(uint[] states)
            {
                int n = (int)(states.Length);
                fixed (uint* states_ptr = states)
                {
                    CreateStatesNV(n, states_ptr);
                }
            }
            public static unsafe void CreateStatesNV(int n, ref uint states)
            {
                fixed (uint* states_ptr = &states)
                {
                    CreateStatesNV(n, states_ptr);
                }
            }
            public static unsafe void DeleteStatesNV(ReadOnlySpan<uint> states)
            {
                int n = (int)(states.Length);
                fixed (uint* states_ptr = states)
                {
                    DeleteStatesNV(n, states_ptr);
                }
            }
            public static unsafe void DeleteStatesNV(uint[] states)
            {
                int n = (int)(states.Length);
                fixed (uint* states_ptr = states)
                {
                    DeleteStatesNV(n, states_ptr);
                }
            }
            public static unsafe void DeleteStatesNV(int n, in uint states)
            {
                fixed (uint* states_ptr = &states)
                {
                    DeleteStatesNV(n, states_ptr);
                }
            }
            public static unsafe void DrawCommandsNV(All primitiveMode, uint buffer, in IntPtr indirects, in int sizes, uint count)
            {
                fixed (IntPtr* indirects_ptr = &indirects)
                fixed (int* sizes_ptr = &sizes)
                {
                    DrawCommandsNV(primitiveMode, buffer, indirects_ptr, sizes_ptr, count);
                }
            }
            public static unsafe void DrawCommandsAddressNV(All primitiveMode, in ulong indirects, in int sizes, uint count)
            {
                fixed (ulong* indirects_ptr = &indirects)
                fixed (int* sizes_ptr = &sizes)
                {
                    DrawCommandsAddressNV(primitiveMode, indirects_ptr, sizes_ptr, count);
                }
            }
            public static unsafe void DrawCommandsStatesNV(BufferHandle buffer, in IntPtr indirects, in int sizes, in uint states, in uint fbos, uint count)
            {
                fixed (IntPtr* indirects_ptr = &indirects)
                fixed (int* sizes_ptr = &sizes)
                fixed (uint* states_ptr = &states)
                fixed (uint* fbos_ptr = &fbos)
                {
                    DrawCommandsStatesNV(buffer, indirects_ptr, sizes_ptr, states_ptr, fbos_ptr, count);
                }
            }
            public static unsafe void DrawCommandsStatesAddressNV(in ulong indirects, in int sizes, in uint states, in uint fbos, uint count)
            {
                fixed (ulong* indirects_ptr = &indirects)
                fixed (int* sizes_ptr = &sizes)
                fixed (uint* states_ptr = &states)
                fixed (uint* fbos_ptr = &fbos)
                {
                    DrawCommandsStatesAddressNV(indirects_ptr, sizes_ptr, states_ptr, fbos_ptr, count);
                }
            }
            public static unsafe void CreateCommandListsNV(Span<uint> lists)
            {
                int n = (int)(lists.Length);
                fixed (uint* lists_ptr = lists)
                {
                    CreateCommandListsNV(n, lists_ptr);
                }
            }
            public static unsafe void CreateCommandListsNV(uint[] lists)
            {
                int n = (int)(lists.Length);
                fixed (uint* lists_ptr = lists)
                {
                    CreateCommandListsNV(n, lists_ptr);
                }
            }
            public static unsafe void CreateCommandListsNV(int n, ref uint lists)
            {
                fixed (uint* lists_ptr = &lists)
                {
                    CreateCommandListsNV(n, lists_ptr);
                }
            }
            public static unsafe void DeleteCommandListsNV(ReadOnlySpan<uint> lists)
            {
                int n = (int)(lists.Length);
                fixed (uint* lists_ptr = lists)
                {
                    DeleteCommandListsNV(n, lists_ptr);
                }
            }
            public static unsafe void DeleteCommandListsNV(uint[] lists)
            {
                int n = (int)(lists.Length);
                fixed (uint* lists_ptr = lists)
                {
                    DeleteCommandListsNV(n, lists_ptr);
                }
            }
            public static unsafe void DeleteCommandListsNV(int n, in uint lists)
            {
                fixed (uint* lists_ptr = &lists)
                {
                    DeleteCommandListsNV(n, lists_ptr);
                }
            }
            public static unsafe void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, ReadOnlySpan<int> sizes, ReadOnlySpan<uint> states, ReadOnlySpan<uint> fbos, uint count)
            {
                fixed (int* sizes_ptr = sizes)
                {
                    fixed (uint* states_ptr = states)
                    {
                        fixed (uint* fbos_ptr = fbos)
                        {
                            ListDrawCommandsStatesClientNV(list, segment, indirects, sizes_ptr, states_ptr, fbos_ptr, count);
                        }
                    }
                }
            }
            public static unsafe void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int[] sizes, uint[] states, uint[] fbos, uint count)
            {
                fixed (int* sizes_ptr = sizes)
                {
                    fixed (uint* states_ptr = states)
                    {
                        fixed (uint* fbos_ptr = fbos)
                        {
                            ListDrawCommandsStatesClientNV(list, segment, indirects, sizes_ptr, states_ptr, fbos_ptr, count);
                        }
                    }
                }
            }
            public static unsafe void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, in int sizes, in uint states, in uint fbos, uint count)
            {
                fixed (int* sizes_ptr = &sizes)
                fixed (uint* states_ptr = &states)
                fixed (uint* fbos_ptr = &fbos)
                {
                    ListDrawCommandsStatesClientNV(list, segment, indirects, sizes_ptr, states_ptr, fbos_ptr, count);
                }
            }
            public static unsafe IntPtr GetVkProcAddrNV(string name)
            {
                IntPtr returnValue;
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                returnValue = GetVkProcAddrNV(name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                return returnValue;
            }
            public static unsafe void MapControlPointsNV(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, int uorder, int vorder, bool packed, IntPtr points)
            {
                void* points_vptr = (void*)points;
                byte packed_byte = (byte)(packed ? 1 : 0);
                MapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed_byte, points_vptr);
            }
            public static unsafe void MapControlPointsNV<T1>(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, int uorder, int vorder, bool packed, ReadOnlySpan<T1> points)
                where T1 : unmanaged
            {
                fixed (void* points_ptr = points)
                {
                    byte packed_byte = (byte)(packed ? 1 : 0);
                    MapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed_byte, points_ptr);
                }
            }
            public static unsafe void MapControlPointsNV<T1>(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, int uorder, int vorder, bool packed, T1[] points)
                where T1 : unmanaged
            {
                fixed (void* points_ptr = points)
                {
                    byte packed_byte = (byte)(packed ? 1 : 0);
                    MapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed_byte, points_ptr);
                }
            }
            public static unsafe void MapControlPointsNV<T1>(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, int uorder, int vorder, bool packed, in T1 points)
                where T1 : unmanaged
            {
                fixed (void* points_ptr = &points)
                {
                    byte packed_byte = (byte)(packed ? 1 : 0);
                    MapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed_byte, points_ptr);
                }
            }
            public static unsafe void MapParameterivNV(EvalTargetNV target, MapParameterNV pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    MapParameterivNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void MapParameterivNV(EvalTargetNV target, MapParameterNV pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    MapParameterivNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void MapParameterivNV(EvalTargetNV target, MapParameterNV pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    MapParameterivNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void MapParameterfvNV(EvalTargetNV target, MapParameterNV pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    MapParameterfvNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void MapParameterfvNV(EvalTargetNV target, MapParameterNV pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    MapParameterfvNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void MapParameterfvNV(EvalTargetNV target, MapParameterNV pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    MapParameterfvNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMapControlPointsNV(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, bool packed, IntPtr points)
            {
                void* points_vptr = (void*)points;
                byte packed_byte = (byte)(packed ? 1 : 0);
                GetMapControlPointsNV(target, index, type, ustride, vstride, packed_byte, points_vptr);
            }
            public static unsafe void GetMapControlPointsNV<T1>(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, bool packed, Span<T1> points)
                where T1 : unmanaged
            {
                fixed (void* points_ptr = points)
                {
                    byte packed_byte = (byte)(packed ? 1 : 0);
                    GetMapControlPointsNV(target, index, type, ustride, vstride, packed_byte, points_ptr);
                }
            }
            public static unsafe void GetMapControlPointsNV<T1>(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, bool packed, T1[] points)
                where T1 : unmanaged
            {
                fixed (void* points_ptr = points)
                {
                    byte packed_byte = (byte)(packed ? 1 : 0);
                    GetMapControlPointsNV(target, index, type, ustride, vstride, packed_byte, points_ptr);
                }
            }
            public static unsafe void GetMapControlPointsNV<T1>(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, bool packed, ref T1 points)
                where T1 : unmanaged
            {
                fixed (void* points_ptr = &points)
                {
                    byte packed_byte = (byte)(packed ? 1 : 0);
                    GetMapControlPointsNV(target, index, type, ustride, vstride, packed_byte, points_ptr);
                }
            }
            public static unsafe void GetMapParameterivNV(EvalTargetNV target, MapParameterNV pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMapParameterivNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMapParameterivNV(EvalTargetNV target, MapParameterNV pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMapParameterivNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMapParameterivNV(EvalTargetNV target, MapParameterNV pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetMapParameterivNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMapParameterfvNV(EvalTargetNV target, MapParameterNV pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMapParameterfvNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMapParameterfvNV(EvalTargetNV target, MapParameterNV pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMapParameterfvNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMapParameterfvNV(EvalTargetNV target, MapParameterNV pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetMapParameterfvNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMapAttribParameterivNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMapAttribParameterivNV(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMapAttribParameterivNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMapAttribParameterivNV(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMapAttribParameterivNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetMapAttribParameterivNV(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMapAttribParameterfvNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMapAttribParameterfvNV(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMapAttribParameterfvNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetMapAttribParameterfvNV(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMapAttribParameterfvNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetMapAttribParameterfvNV(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMultisamplefvNV(GetMultisamplePNameNV pname, uint index, Span<float> val)
            {
                fixed (float* val_ptr = val)
                {
                    GetMultisamplefvNV(pname, index, val_ptr);
                }
            }
            public static unsafe void GetMultisamplefvNV(GetMultisamplePNameNV pname, uint index, float[] val)
            {
                fixed (float* val_ptr = val)
                {
                    GetMultisamplefvNV(pname, index, val_ptr);
                }
            }
            public static unsafe void GetMultisamplefvNV(GetMultisamplePNameNV pname, uint index, ref float val)
            {
                fixed (float* val_ptr = &val)
                {
                    GetMultisamplefvNV(pname, index, val_ptr);
                }
            }
            public static unsafe void DeleteFencesNV(ReadOnlySpan<uint> fences)
            {
                int n = (int)(fences.Length);
                fixed (uint* fences_ptr = fences)
                {
                    DeleteFencesNV(n, fences_ptr);
                }
            }
            public static unsafe void DeleteFencesNV(uint[] fences)
            {
                int n = (int)(fences.Length);
                fixed (uint* fences_ptr = fences)
                {
                    DeleteFencesNV(n, fences_ptr);
                }
            }
            public static unsafe void DeleteFencesNV(int n, in uint fences)
            {
                fixed (uint* fences_ptr = &fences)
                {
                    DeleteFencesNV(n, fences_ptr);
                }
            }
            public static unsafe void GenFencesNV(Span<uint> fences)
            {
                int n = (int)(fences.Length);
                fixed (uint* fences_ptr = fences)
                {
                    GenFencesNV(n, fences_ptr);
                }
            }
            public static unsafe void GenFencesNV(uint[] fences)
            {
                int n = (int)(fences.Length);
                fixed (uint* fences_ptr = fences)
                {
                    GenFencesNV(n, fences_ptr);
                }
            }
            public static unsafe void GenFencesNV(int n, ref uint fences)
            {
                fixed (uint* fences_ptr = &fences)
                {
                    GenFencesNV(n, fences_ptr);
                }
            }
            public static unsafe void GetFenceivNV(uint fence, FenceParameterNameNV pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFenceivNV(fence, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFenceivNV(uint fence, FenceParameterNameNV pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFenceivNV(fence, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFenceivNV(uint fence, FenceParameterNameNV pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetFenceivNV(fence, pname, parameters_ptr);
                }
            }
            public static unsafe void ProgramNamedParameter4fNV(ProgramHandle id, int len, ReadOnlySpan<byte> name, float x, float y, float z, float w)
            {
                fixed (byte* name_ptr = name)
                {
                    ProgramNamedParameter4fNV(id, len, name_ptr, x, y, z, w);
                }
            }
            public static unsafe void ProgramNamedParameter4fNV(ProgramHandle id, int len, byte[] name, float x, float y, float z, float w)
            {
                fixed (byte* name_ptr = name)
                {
                    ProgramNamedParameter4fNV(id, len, name_ptr, x, y, z, w);
                }
            }
            public static unsafe void ProgramNamedParameter4fNV(ProgramHandle id, int len, in byte name, float x, float y, float z, float w)
            {
                fixed (byte* name_ptr = &name)
                {
                    ProgramNamedParameter4fNV(id, len, name_ptr, x, y, z, w);
                }
            }
            public static unsafe void ProgramNamedParameter4fvNV(ProgramHandle id, int len, ReadOnlySpan<byte> name, ReadOnlySpan<float> v)
            {
                fixed (byte* name_ptr = name)
                {
                    fixed (float* v_ptr = v)
                    {
                        ProgramNamedParameter4fvNV(id, len, name_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void ProgramNamedParameter4fvNV(ProgramHandle id, int len, byte[] name, float[] v)
            {
                fixed (byte* name_ptr = name)
                {
                    fixed (float* v_ptr = v)
                    {
                        ProgramNamedParameter4fvNV(id, len, name_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void ProgramNamedParameter4fvNV(ProgramHandle id, int len, in byte name, in float v)
            {
                fixed (byte* name_ptr = &name)
                fixed (float* v_ptr = &v)
                {
                    ProgramNamedParameter4fvNV(id, len, name_ptr, v_ptr);
                }
            }
            public static unsafe void ProgramNamedParameter4dNV(ProgramHandle id, int len, ReadOnlySpan<byte> name, double x, double y, double z, double w)
            {
                fixed (byte* name_ptr = name)
                {
                    ProgramNamedParameter4dNV(id, len, name_ptr, x, y, z, w);
                }
            }
            public static unsafe void ProgramNamedParameter4dNV(ProgramHandle id, int len, byte[] name, double x, double y, double z, double w)
            {
                fixed (byte* name_ptr = name)
                {
                    ProgramNamedParameter4dNV(id, len, name_ptr, x, y, z, w);
                }
            }
            public static unsafe void ProgramNamedParameter4dNV(ProgramHandle id, int len, in byte name, double x, double y, double z, double w)
            {
                fixed (byte* name_ptr = &name)
                {
                    ProgramNamedParameter4dNV(id, len, name_ptr, x, y, z, w);
                }
            }
            public static unsafe void ProgramNamedParameter4dvNV(ProgramHandle id, int len, ReadOnlySpan<byte> name, ReadOnlySpan<double> v)
            {
                fixed (byte* name_ptr = name)
                {
                    fixed (double* v_ptr = v)
                    {
                        ProgramNamedParameter4dvNV(id, len, name_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void ProgramNamedParameter4dvNV(ProgramHandle id, int len, byte[] name, double[] v)
            {
                fixed (byte* name_ptr = name)
                {
                    fixed (double* v_ptr = v)
                    {
                        ProgramNamedParameter4dvNV(id, len, name_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void ProgramNamedParameter4dvNV(ProgramHandle id, int len, in byte name, in double v)
            {
                fixed (byte* name_ptr = &name)
                fixed (double* v_ptr = &v)
                {
                    ProgramNamedParameter4dvNV(id, len, name_ptr, v_ptr);
                }
            }
            public static unsafe void GetProgramNamedParameterfvNV(ProgramHandle id, int len, ReadOnlySpan<byte> name, Span<float> parameters)
            {
                fixed (byte* name_ptr = name)
                {
                    fixed (float* parameters_ptr = parameters)
                    {
                        GetProgramNamedParameterfvNV(id, len, name_ptr, parameters_ptr);
                    }
                }
            }
            public static unsafe void GetProgramNamedParameterfvNV(ProgramHandle id, int len, byte[] name, float[] parameters)
            {
                fixed (byte* name_ptr = name)
                {
                    fixed (float* parameters_ptr = parameters)
                    {
                        GetProgramNamedParameterfvNV(id, len, name_ptr, parameters_ptr);
                    }
                }
            }
            public static unsafe void GetProgramNamedParameterfvNV(ProgramHandle id, int len, in byte name, ref float parameters)
            {
                fixed (byte* name_ptr = &name)
                fixed (float* parameters_ptr = &parameters)
                {
                    GetProgramNamedParameterfvNV(id, len, name_ptr, parameters_ptr);
                }
            }
            public static unsafe void GetProgramNamedParameterdvNV(ProgramHandle id, int len, ReadOnlySpan<byte> name, Span<double> parameters)
            {
                fixed (byte* name_ptr = name)
                {
                    fixed (double* parameters_ptr = parameters)
                    {
                        GetProgramNamedParameterdvNV(id, len, name_ptr, parameters_ptr);
                    }
                }
            }
            public static unsafe void GetProgramNamedParameterdvNV(ProgramHandle id, int len, byte[] name, double[] parameters)
            {
                fixed (byte* name_ptr = name)
                {
                    fixed (double* parameters_ptr = parameters)
                    {
                        GetProgramNamedParameterdvNV(id, len, name_ptr, parameters_ptr);
                    }
                }
            }
            public static unsafe void GetProgramNamedParameterdvNV(ProgramHandle id, int len, in byte name, ref double parameters)
            {
                fixed (byte* name_ptr = &name)
                fixed (double* parameters_ptr = &parameters)
                {
                    GetProgramNamedParameterdvNV(id, len, name_ptr, parameters_ptr);
                }
            }
            public static unsafe void RasterSamplesEXT(uint samples, bool fixedsamplelocations)
            {
                byte fixedsamplelocations_byte = (byte)(fixedsamplelocations ? 1 : 0);
                RasterSamplesEXT(samples, fixedsamplelocations_byte);
            }
            public static unsafe void CoverageModulationTableNV(ReadOnlySpan<float> v)
            {
                int n = (int)(v.Length);
                fixed (float* v_ptr = v)
                {
                    CoverageModulationTableNV(n, v_ptr);
                }
            }
            public static unsafe void CoverageModulationTableNV(float[] v)
            {
                int n = (int)(v.Length);
                fixed (float* v_ptr = v)
                {
                    CoverageModulationTableNV(n, v_ptr);
                }
            }
            public static unsafe void CoverageModulationTableNV(int n, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    CoverageModulationTableNV(n, v_ptr);
                }
            }
            public static unsafe void GetCoverageModulationTableNV(int bufSize, ref float v)
            {
                fixed (float* v_ptr = &v)
                {
                    GetCoverageModulationTableNV(bufSize, v_ptr);
                }
            }
            public static unsafe void ProgramLocalParameterI4ivNV(ProgramTarget target, uint index, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ProgramLocalParameterI4ivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameterI4ivNV(ProgramTarget target, uint index, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ProgramLocalParameterI4ivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameterI4ivNV(ProgramTarget target, uint index, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    ProgramLocalParameterI4ivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParametersI4ivNV(ProgramTarget target, uint index, ReadOnlySpan<int> parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (int* parameters_ptr = parameters)
                {
                    ProgramLocalParametersI4ivNV(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParametersI4ivNV(ProgramTarget target, uint index, int[] parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (int* parameters_ptr = parameters)
                {
                    ProgramLocalParametersI4ivNV(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParametersI4ivNV(ProgramTarget target, uint index, int count, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    ProgramLocalParametersI4ivNV(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameterI4uivNV(ProgramTarget target, uint index, ReadOnlySpan<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    ProgramLocalParameterI4uivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameterI4uivNV(ProgramTarget target, uint index, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    ProgramLocalParameterI4uivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParameterI4uivNV(ProgramTarget target, uint index, in uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    ProgramLocalParameterI4uivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParametersI4uivNV(ProgramTarget target, uint index, ReadOnlySpan<uint> parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (uint* parameters_ptr = parameters)
                {
                    ProgramLocalParametersI4uivNV(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParametersI4uivNV(ProgramTarget target, uint index, uint[] parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (uint* parameters_ptr = parameters)
                {
                    ProgramLocalParametersI4uivNV(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramLocalParametersI4uivNV(ProgramTarget target, uint index, int count, in uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    ProgramLocalParametersI4uivNV(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameterI4ivNV(ProgramTarget target, uint index, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ProgramEnvParameterI4ivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameterI4ivNV(ProgramTarget target, uint index, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ProgramEnvParameterI4ivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameterI4ivNV(ProgramTarget target, uint index, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    ProgramEnvParameterI4ivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParametersI4ivNV(ProgramTarget target, uint index, ReadOnlySpan<int> parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (int* parameters_ptr = parameters)
                {
                    ProgramEnvParametersI4ivNV(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParametersI4ivNV(ProgramTarget target, uint index, int[] parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (int* parameters_ptr = parameters)
                {
                    ProgramEnvParametersI4ivNV(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParametersI4ivNV(ProgramTarget target, uint index, int count, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    ProgramEnvParametersI4ivNV(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameterI4uivNV(ProgramTarget target, uint index, ReadOnlySpan<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    ProgramEnvParameterI4uivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameterI4uivNV(ProgramTarget target, uint index, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    ProgramEnvParameterI4uivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParameterI4uivNV(ProgramTarget target, uint index, in uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    ProgramEnvParameterI4uivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParametersI4uivNV(ProgramTarget target, uint index, ReadOnlySpan<uint> parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (uint* parameters_ptr = parameters)
                {
                    ProgramEnvParametersI4uivNV(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParametersI4uivNV(ProgramTarget target, uint index, uint[] parameters)
            {
                int count = (int)(parameters.Length / 4);
                fixed (uint* parameters_ptr = parameters)
                {
                    ProgramEnvParametersI4uivNV(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramEnvParametersI4uivNV(ProgramTarget target, uint index, int count, in uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    ProgramEnvParametersI4uivNV(target, index, count, parameters_ptr);
                }
            }
            public static unsafe void GetProgramLocalParameterIivNV(ProgramTarget target, uint index, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetProgramLocalParameterIivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramLocalParameterIivNV(ProgramTarget target, uint index, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetProgramLocalParameterIivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramLocalParameterIivNV(ProgramTarget target, uint index, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetProgramLocalParameterIivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramLocalParameterIuivNV(ProgramTarget target, uint index, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetProgramLocalParameterIuivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramLocalParameterIuivNV(ProgramTarget target, uint index, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetProgramLocalParameterIuivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramLocalParameterIuivNV(ProgramTarget target, uint index, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetProgramLocalParameterIuivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramEnvParameterIivNV(ProgramTarget target, uint index, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetProgramEnvParameterIivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramEnvParameterIivNV(ProgramTarget target, uint index, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetProgramEnvParameterIivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramEnvParameterIivNV(ProgramTarget target, uint index, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetProgramEnvParameterIivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramEnvParameterIuivNV(ProgramTarget target, uint index, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetProgramEnvParameterIuivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramEnvParameterIuivNV(ProgramTarget target, uint index, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetProgramEnvParameterIuivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void GetProgramEnvParameterIuivNV(ProgramTarget target, uint index, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetProgramEnvParameterIuivNV(target, index, parameters_ptr);
                }
            }
            public static unsafe void ProgramSubroutineParametersuivNV(All target, ReadOnlySpan<uint> parameters)
            {
                int count = (int)(parameters.Length);
                fixed (uint* parameters_ptr = parameters)
                {
                    ProgramSubroutineParametersuivNV(target, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramSubroutineParametersuivNV(All target, uint[] parameters)
            {
                int count = (int)(parameters.Length);
                fixed (uint* parameters_ptr = parameters)
                {
                    ProgramSubroutineParametersuivNV(target, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramSubroutineParametersuivNV(All target, int count, in uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    ProgramSubroutineParametersuivNV(target, count, parameters_ptr);
                }
            }
            public static unsafe void GetProgramSubroutineParameteruivNV(All target, uint index, Span<uint> param)
            {
                fixed (uint* param_ptr = param)
                {
                    GetProgramSubroutineParameteruivNV(target, index, param_ptr);
                }
            }
            public static unsafe void GetProgramSubroutineParameteruivNV(All target, uint index, uint[] param)
            {
                fixed (uint* param_ptr = param)
                {
                    GetProgramSubroutineParameteruivNV(target, index, param_ptr);
                }
            }
            public static unsafe void GetProgramSubroutineParameteruivNV(All target, uint index, ref uint param)
            {
                fixed (uint* param_ptr = &param)
                {
                    GetProgramSubroutineParameteruivNV(target, index, param_ptr);
                }
            }
            public static unsafe void Uniform1i64vNV(int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 1);
                fixed (long* value_ptr = value)
                {
                    Uniform1i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1i64vNV(int location, long[] value)
            {
                int count = (int)(value.Length / 1);
                fixed (long* value_ptr = value)
                {
                    Uniform1i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1i64vNV(int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    Uniform1i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2i64vNV(int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 2);
                fixed (long* value_ptr = value)
                {
                    Uniform2i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2i64vNV(int location, long[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (long* value_ptr = value)
                {
                    Uniform2i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2i64vNV(int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    Uniform2i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3i64vNV(int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 3);
                fixed (long* value_ptr = value)
                {
                    Uniform3i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3i64vNV(int location, long[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (long* value_ptr = value)
                {
                    Uniform3i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3i64vNV(int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    Uniform3i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4i64vNV(int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 4);
                fixed (long* value_ptr = value)
                {
                    Uniform4i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4i64vNV(int location, long[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (long* value_ptr = value)
                {
                    Uniform4i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4i64vNV(int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    Uniform4i64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1ui64vNV(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 1);
                fixed (ulong* value_ptr = value)
                {
                    Uniform1ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1ui64vNV(int location, ulong[] value)
            {
                int count = (int)(value.Length / 1);
                fixed (ulong* value_ptr = value)
                {
                    Uniform1ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform1ui64vNV(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    Uniform1ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2ui64vNV(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 2);
                fixed (ulong* value_ptr = value)
                {
                    Uniform2ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2ui64vNV(int location, ulong[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (ulong* value_ptr = value)
                {
                    Uniform2ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform2ui64vNV(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    Uniform2ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3ui64vNV(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 3);
                fixed (ulong* value_ptr = value)
                {
                    Uniform3ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3ui64vNV(int location, ulong[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (ulong* value_ptr = value)
                {
                    Uniform3ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform3ui64vNV(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    Uniform3ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4ui64vNV(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 4);
                fixed (ulong* value_ptr = value)
                {
                    Uniform4ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4ui64vNV(int location, ulong[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (ulong* value_ptr = value)
                {
                    Uniform4ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniform4ui64vNV(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    Uniform4ui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void GetUniformi64vNV(ProgramHandle program, int location, Span<long> parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetUniformi64vNV(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformi64vNV(ProgramHandle program, int location, long[] parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetUniformi64vNV(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformi64vNV(ProgramHandle program, int location, ref long parameters)
            {
                fixed (long* parameters_ptr = &parameters)
                {
                    GetUniformi64vNV(program, location, parameters_ptr);
                }
            }
            public static unsafe void ProgramUniform1i64vNV(ProgramHandle program, int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform1i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1i64vNV(ProgramHandle program, int location, long[] value)
            {
                int count = (int)(value.Length);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform1i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1i64vNV(ProgramHandle program, int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    ProgramUniform1i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2i64vNV(ProgramHandle program, int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 2);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform2i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2i64vNV(ProgramHandle program, int location, long[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform2i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2i64vNV(ProgramHandle program, int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    ProgramUniform2i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3i64vNV(ProgramHandle program, int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 3);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform3i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3i64vNV(ProgramHandle program, int location, long[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform3i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3i64vNV(ProgramHandle program, int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    ProgramUniform3i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4i64vNV(ProgramHandle program, int location, ReadOnlySpan<long> value)
            {
                int count = (int)(value.Length / 4);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform4i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4i64vNV(ProgramHandle program, int location, long[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (long* value_ptr = value)
                {
                    ProgramUniform4i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4i64vNV(ProgramHandle program, int location, int count, in long value)
            {
                fixed (long* value_ptr = &value)
                {
                    ProgramUniform4i64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ui64vNV(ProgramHandle program, int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform1ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ui64vNV(ProgramHandle program, int location, ulong[] value)
            {
                int count = (int)(value.Length);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform1ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform1ui64vNV(ProgramHandle program, int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    ProgramUniform1ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ui64vNV(ProgramHandle program, int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 2);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform2ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ui64vNV(ProgramHandle program, int location, ulong[] value)
            {
                int count = (int)(value.Length / 2);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform2ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform2ui64vNV(ProgramHandle program, int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    ProgramUniform2ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ui64vNV(ProgramHandle program, int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 3);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform3ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ui64vNV(ProgramHandle program, int location, ulong[] value)
            {
                int count = (int)(value.Length / 3);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform3ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform3ui64vNV(ProgramHandle program, int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    ProgramUniform3ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ui64vNV(ProgramHandle program, int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 4);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform4ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ui64vNV(ProgramHandle program, int location, ulong[] value)
            {
                int count = (int)(value.Length / 4);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniform4ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniform4ui64vNV(ProgramHandle program, int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    ProgramUniform4ui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void Vertex2hvNV(ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    Vertex2hvNV(v_ptr);
                }
            }
            public static unsafe void Vertex2hvNV(Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    Vertex2hvNV(v_ptr);
                }
            }
            public static unsafe void Vertex2hvNV(in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    Vertex2hvNV(v_ptr);
                }
            }
            public static unsafe void Vertex3hvNV(ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    Vertex3hvNV(v_ptr);
                }
            }
            public static unsafe void Vertex3hvNV(Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    Vertex3hvNV(v_ptr);
                }
            }
            public static unsafe void Vertex3hvNV(in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    Vertex3hvNV(v_ptr);
                }
            }
            public static unsafe void Vertex4hvNV(ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    Vertex4hvNV(v_ptr);
                }
            }
            public static unsafe void Vertex4hvNV(Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    Vertex4hvNV(v_ptr);
                }
            }
            public static unsafe void Vertex4hvNV(in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    Vertex4hvNV(v_ptr);
                }
            }
            public static unsafe void Normal3hvNV(ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    Normal3hvNV(v_ptr);
                }
            }
            public static unsafe void Normal3hvNV(Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    Normal3hvNV(v_ptr);
                }
            }
            public static unsafe void Normal3hvNV(in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    Normal3hvNV(v_ptr);
                }
            }
            public static unsafe void Color3hvNV(ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    Color3hvNV(v_ptr);
                }
            }
            public static unsafe void Color3hvNV(Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    Color3hvNV(v_ptr);
                }
            }
            public static unsafe void Color3hvNV(in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    Color3hvNV(v_ptr);
                }
            }
            public static unsafe void Color4hvNV(ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    Color4hvNV(v_ptr);
                }
            }
            public static unsafe void Color4hvNV(Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    Color4hvNV(v_ptr);
                }
            }
            public static unsafe void Color4hvNV(in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    Color4hvNV(v_ptr);
                }
            }
            public static unsafe void TexCoord1hvNV(ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    TexCoord1hvNV(v_ptr);
                }
            }
            public static unsafe void TexCoord1hvNV(Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    TexCoord1hvNV(v_ptr);
                }
            }
            public static unsafe void TexCoord1hvNV(in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    TexCoord1hvNV(v_ptr);
                }
            }
            public static unsafe void TexCoord2hvNV(ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    TexCoord2hvNV(v_ptr);
                }
            }
            public static unsafe void TexCoord2hvNV(Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    TexCoord2hvNV(v_ptr);
                }
            }
            public static unsafe void TexCoord2hvNV(in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    TexCoord2hvNV(v_ptr);
                }
            }
            public static unsafe void TexCoord3hvNV(ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    TexCoord3hvNV(v_ptr);
                }
            }
            public static unsafe void TexCoord3hvNV(Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    TexCoord3hvNV(v_ptr);
                }
            }
            public static unsafe void TexCoord3hvNV(in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    TexCoord3hvNV(v_ptr);
                }
            }
            public static unsafe void TexCoord4hvNV(ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    TexCoord4hvNV(v_ptr);
                }
            }
            public static unsafe void TexCoord4hvNV(Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    TexCoord4hvNV(v_ptr);
                }
            }
            public static unsafe void TexCoord4hvNV(in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    TexCoord4hvNV(v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1hvNV(TextureUnit target, ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    MultiTexCoord1hvNV(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1hvNV(TextureUnit target, Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    MultiTexCoord1hvNV(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord1hvNV(TextureUnit target, in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    MultiTexCoord1hvNV(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2hvNV(TextureUnit target, ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    MultiTexCoord2hvNV(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2hvNV(TextureUnit target, Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    MultiTexCoord2hvNV(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord2hvNV(TextureUnit target, in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    MultiTexCoord2hvNV(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3hvNV(TextureUnit target, ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    MultiTexCoord3hvNV(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3hvNV(TextureUnit target, Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    MultiTexCoord3hvNV(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord3hvNV(TextureUnit target, in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    MultiTexCoord3hvNV(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4hvNV(TextureUnit target, ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    MultiTexCoord4hvNV(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4hvNV(TextureUnit target, Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    MultiTexCoord4hvNV(target, v_ptr);
                }
            }
            public static unsafe void MultiTexCoord4hvNV(TextureUnit target, in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    MultiTexCoord4hvNV(target, v_ptr);
                }
            }
            public static unsafe void FogCoordhvNV(ReadOnlySpan<Half> fog)
            {
                fixed (Half* fog_ptr = fog)
                {
                    FogCoordhvNV(fog_ptr);
                }
            }
            public static unsafe void FogCoordhvNV(Half[] fog)
            {
                fixed (Half* fog_ptr = fog)
                {
                    FogCoordhvNV(fog_ptr);
                }
            }
            public static unsafe void FogCoordhvNV(in Half fog)
            {
                fixed (Half* fog_ptr = &fog)
                {
                    FogCoordhvNV(fog_ptr);
                }
            }
            public static unsafe void SecondaryColor3hvNV(ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    SecondaryColor3hvNV(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3hvNV(Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    SecondaryColor3hvNV(v_ptr);
                }
            }
            public static unsafe void SecondaryColor3hvNV(in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    SecondaryColor3hvNV(v_ptr);
                }
            }
            public static unsafe void VertexWeighthvNV(ReadOnlySpan<Half> weight)
            {
                fixed (Half* weight_ptr = weight)
                {
                    VertexWeighthvNV(weight_ptr);
                }
            }
            public static unsafe void VertexWeighthvNV(Half[] weight)
            {
                fixed (Half* weight_ptr = weight)
                {
                    VertexWeighthvNV(weight_ptr);
                }
            }
            public static unsafe void VertexWeighthvNV(in Half weight)
            {
                fixed (Half* weight_ptr = &weight)
                {
                    VertexWeighthvNV(weight_ptr);
                }
            }
            public static unsafe void VertexAttrib1hvNV(uint index, ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    VertexAttrib1hvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1hvNV(uint index, Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    VertexAttrib1hvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1hvNV(uint index, in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    VertexAttrib1hvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2hvNV(uint index, ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    VertexAttrib2hvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2hvNV(uint index, Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    VertexAttrib2hvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2hvNV(uint index, in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    VertexAttrib2hvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3hvNV(uint index, ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    VertexAttrib3hvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3hvNV(uint index, Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    VertexAttrib3hvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3hvNV(uint index, in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    VertexAttrib3hvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4hvNV(uint index, ReadOnlySpan<Half> v)
            {
                fixed (Half* v_ptr = v)
                {
                    VertexAttrib4hvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4hvNV(uint index, Half[] v)
            {
                fixed (Half* v_ptr = v)
                {
                    VertexAttrib4hvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4hvNV(uint index, in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    VertexAttrib4hvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribs1hvNV(uint index, ReadOnlySpan<Half> v)
            {
                int n = (int)(v.Length);
                fixed (Half* v_ptr = v)
                {
                    VertexAttribs1hvNV(index, n, v_ptr);
                }
            }
            public static unsafe void VertexAttribs1hvNV(uint index, Half[] v)
            {
                int n = (int)(v.Length);
                fixed (Half* v_ptr = v)
                {
                    VertexAttribs1hvNV(index, n, v_ptr);
                }
            }
            public static unsafe void VertexAttribs1hvNV(uint index, int n, in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    VertexAttribs1hvNV(index, n, v_ptr);
                }
            }
            public static unsafe void VertexAttribs2hvNV(uint index, ReadOnlySpan<Half> v)
            {
                int n = (int)(v.Length);
                fixed (Half* v_ptr = v)
                {
                    VertexAttribs2hvNV(index, n, v_ptr);
                }
            }
            public static unsafe void VertexAttribs2hvNV(uint index, Half[] v)
            {
                int n = (int)(v.Length);
                fixed (Half* v_ptr = v)
                {
                    VertexAttribs2hvNV(index, n, v_ptr);
                }
            }
            public static unsafe void VertexAttribs2hvNV(uint index, int n, in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    VertexAttribs2hvNV(index, n, v_ptr);
                }
            }
            public static unsafe void VertexAttribs3hvNV(uint index, ReadOnlySpan<Half> v)
            {
                int n = (int)(v.Length);
                fixed (Half* v_ptr = v)
                {
                    VertexAttribs3hvNV(index, n, v_ptr);
                }
            }
            public static unsafe void VertexAttribs3hvNV(uint index, Half[] v)
            {
                int n = (int)(v.Length);
                fixed (Half* v_ptr = v)
                {
                    VertexAttribs3hvNV(index, n, v_ptr);
                }
            }
            public static unsafe void VertexAttribs3hvNV(uint index, int n, in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    VertexAttribs3hvNV(index, n, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4hvNV(uint index, ReadOnlySpan<Half> v)
            {
                int n = (int)(v.Length);
                fixed (Half* v_ptr = v)
                {
                    VertexAttribs4hvNV(index, n, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4hvNV(uint index, Half[] v)
            {
                int n = (int)(v.Length);
                fixed (Half* v_ptr = v)
                {
                    VertexAttribs4hvNV(index, n, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4hvNV(uint index, int n, in Half v)
            {
                fixed (Half* v_ptr = &v)
                {
                    VertexAttribs4hvNV(index, n, v_ptr);
                }
            }
            public static unsafe void GetInternalformatSampleivNV(TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, Span<int> parameters)
            {
                int count = (int)(parameters.Length);
                fixed (int* parameters_ptr = parameters)
                {
                    GetInternalformatSampleivNV(target, internalformat, samples, pname, count, parameters_ptr);
                }
            }
            public static unsafe void GetInternalformatSampleivNV(TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, int[] parameters)
            {
                int count = (int)(parameters.Length);
                fixed (int* parameters_ptr = parameters)
                {
                    GetInternalformatSampleivNV(target, internalformat, samples, pname, count, parameters_ptr);
                }
            }
            public static unsafe void GetInternalformatSampleivNV(TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, int count, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetInternalformatSampleivNV(target, internalformat, samples, pname, count, parameters_ptr);
                }
            }
            public static unsafe void MulticastBufferSubDataNV(All gpuMask, BufferHandle buffer, IntPtr offset, nint size, IntPtr data)
            {
                void* data_vptr = (void*)data;
                MulticastBufferSubDataNV(gpuMask, buffer, offset, size, data_vptr);
            }
            public static unsafe void MulticastBufferSubDataNV<T1>(All gpuMask, BufferHandle buffer, IntPtr offset, nint size, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    MulticastBufferSubDataNV(gpuMask, buffer, offset, size, data_ptr);
                }
            }
            public static unsafe void MulticastFramebufferSampleLocationsfvNV(uint gpu, FramebufferHandle framebuffer, uint start, int count, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    MulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, v_ptr);
                }
            }
            public static unsafe void MulticastGetQueryObjectivNV(uint gpu, uint id, All pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    MulticastGetQueryObjectivNV(gpu, id, pname, parameters_ptr);
                }
            }
            public static unsafe void MulticastGetQueryObjectuivNV(uint gpu, uint id, All pname, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    MulticastGetQueryObjectuivNV(gpu, id, pname, parameters_ptr);
                }
            }
            public static unsafe void MulticastGetQueryObjecti64vNV(uint gpu, uint id, All pname, ref long parameters)
            {
                fixed (long* parameters_ptr = &parameters)
                {
                    MulticastGetQueryObjecti64vNV(gpu, id, pname, parameters_ptr);
                }
            }
            public static unsafe void MulticastGetQueryObjectui64vNV(uint gpu, uint id, All pname, ref ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    MulticastGetQueryObjectui64vNV(gpu, id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMemoryObjectDetachedResourcesuivNV(uint memory, All pname, int first, int count, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, parameters_ptr);
                }
            }
            public static unsafe void BufferPageCommitmentMemNV(BufferStorageTarget target, IntPtr offset, nint size, uint memory, ulong memOffset, bool commit)
            {
                byte commit_byte = (byte)(commit ? 1 : 0);
                BufferPageCommitmentMemNV(target, offset, size, memory, memOffset, commit_byte);
            }
            public static unsafe void TexPageCommitmentMemNV(TextureTarget target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, bool commit)
            {
                byte commit_byte = (byte)(commit ? 1 : 0);
                TexPageCommitmentMemNV(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit_byte);
            }
            public static unsafe void NamedBufferPageCommitmentMemNV(BufferHandle buffer, IntPtr offset, nint size, uint memory, ulong memOffset, bool commit)
            {
                byte commit_byte = (byte)(commit ? 1 : 0);
                NamedBufferPageCommitmentMemNV(buffer, offset, size, memory, memOffset, commit_byte);
            }
            public static unsafe void TexturePageCommitmentMemNV(TextureHandle texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, bool commit)
            {
                byte commit_byte = (byte)(commit ? 1 : 0);
                TexturePageCommitmentMemNV(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit_byte);
            }
            public static unsafe void GenOcclusionQueriesNV(Span<uint> ids)
            {
                int n = (int)(ids.Length);
                fixed (uint* ids_ptr = ids)
                {
                    GenOcclusionQueriesNV(n, ids_ptr);
                }
            }
            public static unsafe void GenOcclusionQueriesNV(uint[] ids)
            {
                int n = (int)(ids.Length);
                fixed (uint* ids_ptr = ids)
                {
                    GenOcclusionQueriesNV(n, ids_ptr);
                }
            }
            public static unsafe void GenOcclusionQueriesNV(int n, ref uint ids)
            {
                fixed (uint* ids_ptr = &ids)
                {
                    GenOcclusionQueriesNV(n, ids_ptr);
                }
            }
            public static unsafe void DeleteOcclusionQueriesNV(ReadOnlySpan<uint> ids)
            {
                int n = (int)(ids.Length);
                fixed (uint* ids_ptr = ids)
                {
                    DeleteOcclusionQueriesNV(n, ids_ptr);
                }
            }
            public static unsafe void DeleteOcclusionQueriesNV(uint[] ids)
            {
                int n = (int)(ids.Length);
                fixed (uint* ids_ptr = ids)
                {
                    DeleteOcclusionQueriesNV(n, ids_ptr);
                }
            }
            public static unsafe void DeleteOcclusionQueriesNV(int n, in uint ids)
            {
                fixed (uint* ids_ptr = &ids)
                {
                    DeleteOcclusionQueriesNV(n, ids_ptr);
                }
            }
            public static unsafe void GetOcclusionQueryivNV(uint id, OcclusionQueryParameterNameNV pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetOcclusionQueryivNV(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetOcclusionQueryivNV(uint id, OcclusionQueryParameterNameNV pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetOcclusionQueryivNV(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetOcclusionQueryivNV(uint id, OcclusionQueryParameterNameNV pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetOcclusionQueryivNV(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetOcclusionQueryuivNV(uint id, OcclusionQueryParameterNameNV pname, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetOcclusionQueryuivNV(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetOcclusionQueryuivNV(uint id, OcclusionQueryParameterNameNV pname, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetOcclusionQueryuivNV(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetOcclusionQueryuivNV(uint id, OcclusionQueryParameterNameNV pname, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetOcclusionQueryuivNV(id, pname, parameters_ptr);
                }
            }
            public static unsafe void ProgramBufferParametersfvNV(ProgramTarget target, uint bindingIndex, uint wordIndex, ReadOnlySpan<float> parameters)
            {
                int count = (int)(parameters.Length);
                fixed (float* parameters_ptr = parameters)
                {
                    ProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramBufferParametersfvNV(ProgramTarget target, uint bindingIndex, uint wordIndex, float[] parameters)
            {
                int count = (int)(parameters.Length);
                fixed (float* parameters_ptr = parameters)
                {
                    ProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramBufferParametersfvNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    ProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramBufferParametersIivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, ReadOnlySpan<int> parameters)
            {
                int count = (int)(parameters.Length);
                fixed (int* parameters_ptr = parameters)
                {
                    ProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramBufferParametersIivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int[] parameters)
            {
                int count = (int)(parameters.Length);
                fixed (int* parameters_ptr = parameters)
                {
                    ProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramBufferParametersIivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    ProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramBufferParametersIuivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, ReadOnlySpan<uint> parameters)
            {
                int count = (int)(parameters.Length);
                fixed (uint* parameters_ptr = parameters)
                {
                    ProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramBufferParametersIuivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, uint[] parameters)
            {
                int count = (int)(parameters.Length);
                fixed (uint* parameters_ptr = parameters)
                {
                    ProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, parameters_ptr);
                }
            }
            public static unsafe void ProgramBufferParametersIuivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, in uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    ProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, parameters_ptr);
                }
            }
            public static unsafe void PathCommandsNV(uint path, ReadOnlySpan<byte> commands, int numCoords, PathCoordType coordType, IntPtr coords)
            {
                int numCommands = (int)(commands.Length);
                fixed (byte* commands_ptr = commands)
                {
                    void* coords_vptr = (void*)coords;
                    PathCommandsNV(path, numCommands, commands_ptr, numCoords, coordType, coords_vptr);
                }
            }
            public static unsafe void PathCommandsNV(uint path, byte[] commands, int numCoords, PathCoordType coordType, IntPtr coords)
            {
                int numCommands = (int)(commands.Length);
                fixed (byte* commands_ptr = commands)
                {
                    void* coords_vptr = (void*)coords;
                    PathCommandsNV(path, numCommands, commands_ptr, numCoords, coordType, coords_vptr);
                }
            }
            public static unsafe void PathCommandsNV(uint path, int numCommands, in byte commands, int numCoords, PathCoordType coordType, IntPtr coords)
            {
                fixed (byte* commands_ptr = &commands)
                {
                    void* coords_vptr = (void*)coords;
                    PathCommandsNV(path, numCommands, commands_ptr, numCoords, coordType, coords_vptr);
                }
            }
            public static unsafe void PathCommandsNV<T1>(uint path, ReadOnlySpan<byte> commands, int numCoords, PathCoordType coordType, ReadOnlySpan<T1> coords)
                where T1 : unmanaged
            {
                int numCommands = (int)(commands.Length);
                fixed (byte* commands_ptr = commands)
                {
                    fixed (void* coords_ptr = coords)
                    {
                        PathCommandsNV(path, numCommands, commands_ptr, numCoords, coordType, coords_ptr);
                    }
                }
            }
            public static unsafe void PathCommandsNV<T1>(uint path, byte[] commands, int numCoords, PathCoordType coordType, T1[] coords)
                where T1 : unmanaged
            {
                int numCommands = (int)(commands.Length);
                fixed (byte* commands_ptr = commands)
                {
                    fixed (void* coords_ptr = coords)
                    {
                        PathCommandsNV(path, numCommands, commands_ptr, numCoords, coordType, coords_ptr);
                    }
                }
            }
            public static unsafe void PathCommandsNV<T1>(uint path, int numCommands, in byte commands, int numCoords, PathCoordType coordType, in T1 coords)
                where T1 : unmanaged
            {
                fixed (byte* commands_ptr = &commands)
                fixed (void* coords_ptr = &coords)
                {
                    PathCommandsNV(path, numCommands, commands_ptr, numCoords, coordType, coords_ptr);
                }
            }
            public static unsafe void PathCoordsNV(uint path, int numCoords, PathCoordType coordType, IntPtr coords)
            {
                void* coords_vptr = (void*)coords;
                PathCoordsNV(path, numCoords, coordType, coords_vptr);
            }
            public static unsafe void PathCoordsNV<T1>(uint path, int numCoords, PathCoordType coordType, ReadOnlySpan<T1> coords)
                where T1 : unmanaged
            {
                fixed (void* coords_ptr = coords)
                {
                    PathCoordsNV(path, numCoords, coordType, coords_ptr);
                }
            }
            public static unsafe void PathCoordsNV<T1>(uint path, int numCoords, PathCoordType coordType, T1[] coords)
                where T1 : unmanaged
            {
                fixed (void* coords_ptr = coords)
                {
                    PathCoordsNV(path, numCoords, coordType, coords_ptr);
                }
            }
            public static unsafe void PathCoordsNV<T1>(uint path, int numCoords, PathCoordType coordType, in T1 coords)
                where T1 : unmanaged
            {
                fixed (void* coords_ptr = &coords)
                {
                    PathCoordsNV(path, numCoords, coordType, coords_ptr);
                }
            }
            public static unsafe void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, ReadOnlySpan<byte> commands, int numCoords, PathCoordType coordType, IntPtr coords)
            {
                int numCommands = (int)(commands.Length);
                fixed (byte* commands_ptr = commands)
                {
                    void* coords_vptr = (void*)coords;
                    PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands_ptr, numCoords, coordType, coords_vptr);
                }
            }
            public static unsafe void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, byte[] commands, int numCoords, PathCoordType coordType, IntPtr coords)
            {
                int numCommands = (int)(commands.Length);
                fixed (byte* commands_ptr = commands)
                {
                    void* coords_vptr = (void*)coords;
                    PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands_ptr, numCoords, coordType, coords_vptr);
                }
            }
            public static unsafe void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, in byte commands, int numCoords, PathCoordType coordType, IntPtr coords)
            {
                fixed (byte* commands_ptr = &commands)
                {
                    void* coords_vptr = (void*)coords;
                    PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands_ptr, numCoords, coordType, coords_vptr);
                }
            }
            public static unsafe void PathSubCommandsNV<T1>(uint path, int commandStart, int commandsToDelete, ReadOnlySpan<byte> commands, int numCoords, PathCoordType coordType, ReadOnlySpan<T1> coords)
                where T1 : unmanaged
            {
                int numCommands = (int)(commands.Length);
                fixed (byte* commands_ptr = commands)
                {
                    fixed (void* coords_ptr = coords)
                    {
                        PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands_ptr, numCoords, coordType, coords_ptr);
                    }
                }
            }
            public static unsafe void PathSubCommandsNV<T1>(uint path, int commandStart, int commandsToDelete, byte[] commands, int numCoords, PathCoordType coordType, T1[] coords)
                where T1 : unmanaged
            {
                int numCommands = (int)(commands.Length);
                fixed (byte* commands_ptr = commands)
                {
                    fixed (void* coords_ptr = coords)
                    {
                        PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands_ptr, numCoords, coordType, coords_ptr);
                    }
                }
            }
            public static unsafe void PathSubCommandsNV<T1>(uint path, int commandStart, int commandsToDelete, int numCommands, in byte commands, int numCoords, PathCoordType coordType, in T1 coords)
                where T1 : unmanaged
            {
                fixed (byte* commands_ptr = &commands)
                fixed (void* coords_ptr = &coords)
                {
                    PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands_ptr, numCoords, coordType, coords_ptr);
                }
            }
            public static unsafe void PathSubCoordsNV(uint path, int coordStart, int numCoords, PathCoordType coordType, IntPtr coords)
            {
                void* coords_vptr = (void*)coords;
                PathSubCoordsNV(path, coordStart, numCoords, coordType, coords_vptr);
            }
            public static unsafe void PathSubCoordsNV<T1>(uint path, int coordStart, int numCoords, PathCoordType coordType, ReadOnlySpan<T1> coords)
                where T1 : unmanaged
            {
                fixed (void* coords_ptr = coords)
                {
                    PathSubCoordsNV(path, coordStart, numCoords, coordType, coords_ptr);
                }
            }
            public static unsafe void PathSubCoordsNV<T1>(uint path, int coordStart, int numCoords, PathCoordType coordType, T1[] coords)
                where T1 : unmanaged
            {
                fixed (void* coords_ptr = coords)
                {
                    PathSubCoordsNV(path, coordStart, numCoords, coordType, coords_ptr);
                }
            }
            public static unsafe void PathSubCoordsNV<T1>(uint path, int coordStart, int numCoords, PathCoordType coordType, in T1 coords)
                where T1 : unmanaged
            {
                fixed (void* coords_ptr = &coords)
                {
                    PathSubCoordsNV(path, coordStart, numCoords, coordType, coords_ptr);
                }
            }
            public static unsafe void PathStringNV(uint path, PathStringFormat format, int length, IntPtr pathString)
            {
                void* pathString_vptr = (void*)pathString;
                PathStringNV(path, format, length, pathString_vptr);
            }
            public static unsafe void PathStringNV<T1>(uint path, PathStringFormat format, ReadOnlySpan<T1> pathString)
                where T1 : unmanaged
            {
                int length = (int)(pathString.Length * sizeof(T1));
                fixed (void* pathString_ptr = pathString)
                {
                    PathStringNV(path, format, length, pathString_ptr);
                }
            }
            public static unsafe void PathStringNV<T1>(uint path, PathStringFormat format, T1[] pathString)
                where T1 : unmanaged
            {
                int length = (int)(pathString.Length * sizeof(T1));
                fixed (void* pathString_ptr = pathString)
                {
                    PathStringNV(path, format, length, pathString_ptr);
                }
            }
            public static unsafe void PathStringNV<T1>(uint path, PathStringFormat format, int length, in T1 pathString)
                where T1 : unmanaged
            {
                fixed (void* pathString_ptr = &pathString)
                {
                    PathStringNV(path, format, length, pathString_ptr);
                }
            }
            public static unsafe void PathGlyphsNV(uint firstPathName, PathFontTarget fontTarget, IntPtr fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, IntPtr charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
            {
                void* fontName_vptr = (void*)fontName;
                void* charcodes_vptr = (void*)charcodes;
                PathGlyphsNV(firstPathName, fontTarget, fontName_vptr, fontStyle, numGlyphs, type, charcodes_vptr, handleMissingGlyphs, pathParameterTemplate, emScale);
            }
            public static unsafe void PathGlyphsNV<T1, T2>(uint firstPathName, PathFontTarget fontTarget, ReadOnlySpan<T2> fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, ReadOnlySpan<T1> charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
                where T1 : unmanaged
                where T2 : unmanaged
            {
                fixed (void* fontName_ptr = fontName)
                {
                    fixed (void* charcodes_ptr = charcodes)
                    {
                        PathGlyphsNV(firstPathName, fontTarget, fontName_ptr, fontStyle, numGlyphs, type, charcodes_ptr, handleMissingGlyphs, pathParameterTemplate, emScale);
                    }
                }
            }
            public static unsafe void PathGlyphsNV<T1, T2>(uint firstPathName, PathFontTarget fontTarget, T2[] fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, T1[] charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
                where T1 : unmanaged
                where T2 : unmanaged
            {
                fixed (void* fontName_ptr = fontName)
                {
                    fixed (void* charcodes_ptr = charcodes)
                    {
                        PathGlyphsNV(firstPathName, fontTarget, fontName_ptr, fontStyle, numGlyphs, type, charcodes_ptr, handleMissingGlyphs, pathParameterTemplate, emScale);
                    }
                }
            }
            public static unsafe void PathGlyphsNV<T1, T2>(uint firstPathName, PathFontTarget fontTarget, in T1 fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, in T2 charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
                where T1 : unmanaged
                where T2 : unmanaged
            {
                fixed (void* fontName_ptr = &fontName)
                fixed (void* charcodes_ptr = &charcodes)
                {
                    PathGlyphsNV(firstPathName, fontTarget, fontName_ptr, fontStyle, numGlyphs, type, charcodes_ptr, handleMissingGlyphs, pathParameterTemplate, emScale);
                }
            }
            public static unsafe void PathGlyphRangeNV(uint firstPathName, PathFontTarget fontTarget, IntPtr fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
            {
                void* fontName_vptr = (void*)fontName;
                PathGlyphRangeNV(firstPathName, fontTarget, fontName_vptr, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
            }
            public static unsafe void PathGlyphRangeNV<T1>(uint firstPathName, PathFontTarget fontTarget, ReadOnlySpan<T1> fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
                where T1 : unmanaged
            {
                fixed (void* fontName_ptr = fontName)
                {
                    PathGlyphRangeNV(firstPathName, fontTarget, fontName_ptr, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
                }
            }
            public static unsafe void PathGlyphRangeNV<T1>(uint firstPathName, PathFontTarget fontTarget, T1[] fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
                where T1 : unmanaged
            {
                fixed (void* fontName_ptr = fontName)
                {
                    PathGlyphRangeNV(firstPathName, fontTarget, fontName_ptr, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
                }
            }
            public static unsafe void PathGlyphRangeNV<T1>(uint firstPathName, PathFontTarget fontTarget, in T1 fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
                where T1 : unmanaged
            {
                fixed (void* fontName_ptr = &fontName)
                {
                    PathGlyphRangeNV(firstPathName, fontTarget, fontName_ptr, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
                }
            }
            public static unsafe void WeightPathsNV(uint resultPath, int numPaths, ReadOnlySpan<uint> paths, ReadOnlySpan<float> weights)
            {
                fixed (uint* paths_ptr = paths)
                {
                    fixed (float* weights_ptr = weights)
                    {
                        WeightPathsNV(resultPath, numPaths, paths_ptr, weights_ptr);
                    }
                }
            }
            public static unsafe void WeightPathsNV(uint resultPath, int numPaths, uint[] paths, float[] weights)
            {
                fixed (uint* paths_ptr = paths)
                {
                    fixed (float* weights_ptr = weights)
                    {
                        WeightPathsNV(resultPath, numPaths, paths_ptr, weights_ptr);
                    }
                }
            }
            public static unsafe void WeightPathsNV(uint resultPath, int numPaths, in uint paths, in float weights)
            {
                fixed (uint* paths_ptr = &paths)
                fixed (float* weights_ptr = &weights)
                {
                    WeightPathsNV(resultPath, numPaths, paths_ptr, weights_ptr);
                }
            }
            public static unsafe void TransformPathNV(uint resultPath, uint srcPath, PathTransformType transformType, ReadOnlySpan<float> transformValues)
            {
                fixed (float* transformValues_ptr = transformValues)
                {
                    TransformPathNV(resultPath, srcPath, transformType, transformValues_ptr);
                }
            }
            public static unsafe void TransformPathNV(uint resultPath, uint srcPath, PathTransformType transformType, float[] transformValues)
            {
                fixed (float* transformValues_ptr = transformValues)
                {
                    TransformPathNV(resultPath, srcPath, transformType, transformValues_ptr);
                }
            }
            public static unsafe void TransformPathNV(uint resultPath, uint srcPath, PathTransformType transformType, in float transformValues)
            {
                fixed (float* transformValues_ptr = &transformValues)
                {
                    TransformPathNV(resultPath, srcPath, transformType, transformValues_ptr);
                }
            }
            public static unsafe void PathParameterivNV(uint path, PathParameter pname, ReadOnlySpan<int> value)
            {
                fixed (int* value_ptr = value)
                {
                    PathParameterivNV(path, pname, value_ptr);
                }
            }
            public static unsafe void PathParameterivNV(uint path, PathParameter pname, int[] value)
            {
                fixed (int* value_ptr = value)
                {
                    PathParameterivNV(path, pname, value_ptr);
                }
            }
            public static unsafe void PathParameterivNV(uint path, PathParameter pname, in int value)
            {
                fixed (int* value_ptr = &value)
                {
                    PathParameterivNV(path, pname, value_ptr);
                }
            }
            public static unsafe void PathParameterfvNV(uint path, PathParameter pname, ReadOnlySpan<float> value)
            {
                fixed (float* value_ptr = value)
                {
                    PathParameterfvNV(path, pname, value_ptr);
                }
            }
            public static unsafe void PathParameterfvNV(uint path, PathParameter pname, float[] value)
            {
                fixed (float* value_ptr = value)
                {
                    PathParameterfvNV(path, pname, value_ptr);
                }
            }
            public static unsafe void PathParameterfvNV(uint path, PathParameter pname, in float value)
            {
                fixed (float* value_ptr = &value)
                {
                    PathParameterfvNV(path, pname, value_ptr);
                }
            }
            public static unsafe void PathDashArrayNV(uint path, ReadOnlySpan<float> dashArray)
            {
                int dashCount = (int)(dashArray.Length);
                fixed (float* dashArray_ptr = dashArray)
                {
                    PathDashArrayNV(path, dashCount, dashArray_ptr);
                }
            }
            public static unsafe void PathDashArrayNV(uint path, float[] dashArray)
            {
                int dashCount = (int)(dashArray.Length);
                fixed (float* dashArray_ptr = dashArray)
                {
                    PathDashArrayNV(path, dashCount, dashArray_ptr);
                }
            }
            public static unsafe void PathDashArrayNV(uint path, int dashCount, in float dashArray)
            {
                fixed (float* dashArray_ptr = &dashArray)
                {
                    PathDashArrayNV(path, dashCount, dashArray_ptr);
                }
            }
            public static unsafe void StencilFillPathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, ReadOnlySpan<float> transformValues)
            {
                fixed (float* transformValues_ptr = transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    StencilFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, fillMode, mask, transformType, transformValues_ptr);
                }
            }
            public static unsafe void StencilFillPathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, float[] transformValues)
            {
                fixed (float* transformValues_ptr = transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    StencilFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, fillMode, mask, transformType, transformValues_ptr);
                }
            }
            public static unsafe void StencilFillPathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, in float transformValues)
            {
                fixed (float* transformValues_ptr = &transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    StencilFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, fillMode, mask, transformType, transformValues_ptr);
                }
            }
            public static unsafe void StencilFillPathInstancedNV<T1>(int numPaths, PathElementType pathNameType, ReadOnlySpan<T1> paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, ReadOnlySpan<float> transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = paths)
                {
                    fixed (float* transformValues_ptr = transformValues)
                    {
                        StencilFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, fillMode, mask, transformType, transformValues_ptr);
                    }
                }
            }
            public static unsafe void StencilFillPathInstancedNV<T1>(int numPaths, PathElementType pathNameType, T1[] paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, float[] transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = paths)
                {
                    fixed (float* transformValues_ptr = transformValues)
                    {
                        StencilFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, fillMode, mask, transformType, transformValues_ptr);
                    }
                }
            }
            public static unsafe void StencilFillPathInstancedNV<T1>(int numPaths, PathElementType pathNameType, in T1 paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, in float transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = &paths)
                fixed (float* transformValues_ptr = &transformValues)
                {
                    StencilFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, fillMode, mask, transformType, transformValues_ptr);
                }
            }
            public static unsafe void StencilStrokePathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, PathTransformType transformType, ReadOnlySpan<float> transformValues)
            {
                fixed (float* transformValues_ptr = transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    StencilStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, reference, mask, transformType, transformValues_ptr);
                }
            }
            public static unsafe void StencilStrokePathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, PathTransformType transformType, float[] transformValues)
            {
                fixed (float* transformValues_ptr = transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    StencilStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, reference, mask, transformType, transformValues_ptr);
                }
            }
            public static unsafe void StencilStrokePathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, PathTransformType transformType, in float transformValues)
            {
                fixed (float* transformValues_ptr = &transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    StencilStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, reference, mask, transformType, transformValues_ptr);
                }
            }
            public static unsafe void StencilStrokePathInstancedNV<T1>(int numPaths, PathElementType pathNameType, ReadOnlySpan<T1> paths, uint pathBase, int reference, uint mask, PathTransformType transformType, ReadOnlySpan<float> transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = paths)
                {
                    fixed (float* transformValues_ptr = transformValues)
                    {
                        StencilStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, reference, mask, transformType, transformValues_ptr);
                    }
                }
            }
            public static unsafe void StencilStrokePathInstancedNV<T1>(int numPaths, PathElementType pathNameType, T1[] paths, uint pathBase, int reference, uint mask, PathTransformType transformType, float[] transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = paths)
                {
                    fixed (float* transformValues_ptr = transformValues)
                    {
                        StencilStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, reference, mask, transformType, transformValues_ptr);
                    }
                }
            }
            public static unsafe void StencilStrokePathInstancedNV<T1>(int numPaths, PathElementType pathNameType, in T1 paths, uint pathBase, int reference, uint mask, PathTransformType transformType, in float transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = &paths)
                fixed (float* transformValues_ptr = &transformValues)
                {
                    StencilStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, reference, mask, transformType, transformValues_ptr);
                }
            }
            public static unsafe void CoverFillPathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, ReadOnlySpan<float> transformValues)
            {
                fixed (float* transformValues_ptr = transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    CoverFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, coverMode, transformType, transformValues_ptr);
                }
            }
            public static unsafe void CoverFillPathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float[] transformValues)
            {
                fixed (float* transformValues_ptr = transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    CoverFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, coverMode, transformType, transformValues_ptr);
                }
            }
            public static unsafe void CoverFillPathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, in float transformValues)
            {
                fixed (float* transformValues_ptr = &transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    CoverFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, coverMode, transformType, transformValues_ptr);
                }
            }
            public static unsafe void CoverFillPathInstancedNV<T1>(int numPaths, PathElementType pathNameType, ReadOnlySpan<T1> paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, ReadOnlySpan<float> transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = paths)
                {
                    fixed (float* transformValues_ptr = transformValues)
                    {
                        CoverFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, coverMode, transformType, transformValues_ptr);
                    }
                }
            }
            public static unsafe void CoverFillPathInstancedNV<T1>(int numPaths, PathElementType pathNameType, T1[] paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float[] transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = paths)
                {
                    fixed (float* transformValues_ptr = transformValues)
                    {
                        CoverFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, coverMode, transformType, transformValues_ptr);
                    }
                }
            }
            public static unsafe void CoverFillPathInstancedNV<T1>(int numPaths, PathElementType pathNameType, in T1 paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, in float transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = &paths)
                fixed (float* transformValues_ptr = &transformValues)
                {
                    CoverFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, coverMode, transformType, transformValues_ptr);
                }
            }
            public static unsafe void CoverStrokePathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, ReadOnlySpan<float> transformValues)
            {
                fixed (float* transformValues_ptr = transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    CoverStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, coverMode, transformType, transformValues_ptr);
                }
            }
            public static unsafe void CoverStrokePathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float[] transformValues)
            {
                fixed (float* transformValues_ptr = transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    CoverStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, coverMode, transformType, transformValues_ptr);
                }
            }
            public static unsafe void CoverStrokePathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, in float transformValues)
            {
                fixed (float* transformValues_ptr = &transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    CoverStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, coverMode, transformType, transformValues_ptr);
                }
            }
            public static unsafe void CoverStrokePathInstancedNV<T1>(int numPaths, PathElementType pathNameType, ReadOnlySpan<T1> paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, ReadOnlySpan<float> transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = paths)
                {
                    fixed (float* transformValues_ptr = transformValues)
                    {
                        CoverStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, coverMode, transformType, transformValues_ptr);
                    }
                }
            }
            public static unsafe void CoverStrokePathInstancedNV<T1>(int numPaths, PathElementType pathNameType, T1[] paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float[] transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = paths)
                {
                    fixed (float* transformValues_ptr = transformValues)
                    {
                        CoverStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, coverMode, transformType, transformValues_ptr);
                    }
                }
            }
            public static unsafe void CoverStrokePathInstancedNV<T1>(int numPaths, PathElementType pathNameType, in T1 paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, in float transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = &paths)
                fixed (float* transformValues_ptr = &transformValues)
                {
                    CoverStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, coverMode, transformType, transformValues_ptr);
                }
            }
            public static unsafe void GetPathParameterivNV(uint path, PathParameter pname, Span<int> value)
            {
                fixed (int* value_ptr = value)
                {
                    GetPathParameterivNV(path, pname, value_ptr);
                }
            }
            public static unsafe void GetPathParameterivNV(uint path, PathParameter pname, int[] value)
            {
                fixed (int* value_ptr = value)
                {
                    GetPathParameterivNV(path, pname, value_ptr);
                }
            }
            public static unsafe void GetPathParameterivNV(uint path, PathParameter pname, ref int value)
            {
                fixed (int* value_ptr = &value)
                {
                    GetPathParameterivNV(path, pname, value_ptr);
                }
            }
            public static unsafe void GetPathParameterfvNV(uint path, PathParameter pname, Span<float> value)
            {
                fixed (float* value_ptr = value)
                {
                    GetPathParameterfvNV(path, pname, value_ptr);
                }
            }
            public static unsafe void GetPathParameterfvNV(uint path, PathParameter pname, float[] value)
            {
                fixed (float* value_ptr = value)
                {
                    GetPathParameterfvNV(path, pname, value_ptr);
                }
            }
            public static unsafe void GetPathParameterfvNV(uint path, PathParameter pname, ref float value)
            {
                fixed (float* value_ptr = &value)
                {
                    GetPathParameterfvNV(path, pname, value_ptr);
                }
            }
            public static unsafe void GetPathCommandsNV(uint path, Span<byte> commands)
            {
                fixed (byte* commands_ptr = commands)
                {
                    GetPathCommandsNV(path, commands_ptr);
                }
            }
            public static unsafe void GetPathCommandsNV(uint path, byte[] commands)
            {
                fixed (byte* commands_ptr = commands)
                {
                    GetPathCommandsNV(path, commands_ptr);
                }
            }
            public static unsafe void GetPathCommandsNV(uint path, ref byte commands)
            {
                fixed (byte* commands_ptr = &commands)
                {
                    GetPathCommandsNV(path, commands_ptr);
                }
            }
            public static unsafe void GetPathCoordsNV(uint path, Span<float> coords)
            {
                fixed (float* coords_ptr = coords)
                {
                    GetPathCoordsNV(path, coords_ptr);
                }
            }
            public static unsafe void GetPathCoordsNV(uint path, float[] coords)
            {
                fixed (float* coords_ptr = coords)
                {
                    GetPathCoordsNV(path, coords_ptr);
                }
            }
            public static unsafe void GetPathCoordsNV(uint path, ref float coords)
            {
                fixed (float* coords_ptr = &coords)
                {
                    GetPathCoordsNV(path, coords_ptr);
                }
            }
            public static unsafe void GetPathDashArrayNV(uint path, Span<float> dashArray)
            {
                fixed (float* dashArray_ptr = dashArray)
                {
                    GetPathDashArrayNV(path, dashArray_ptr);
                }
            }
            public static unsafe void GetPathDashArrayNV(uint path, float[] dashArray)
            {
                fixed (float* dashArray_ptr = dashArray)
                {
                    GetPathDashArrayNV(path, dashArray_ptr);
                }
            }
            public static unsafe void GetPathDashArrayNV(uint path, ref float dashArray)
            {
                fixed (float* dashArray_ptr = &dashArray)
                {
                    GetPathDashArrayNV(path, dashArray_ptr);
                }
            }
            public static unsafe void GetPathMetricsNV(PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int stride, Span<float> metrics)
            {
                fixed (float* metrics_ptr = metrics)
                {
                    void* paths_vptr = (void*)paths;
                    GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths_vptr, pathBase, stride, metrics_ptr);
                }
            }
            public static unsafe void GetPathMetricsNV(PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int stride, float[] metrics)
            {
                fixed (float* metrics_ptr = metrics)
                {
                    void* paths_vptr = (void*)paths;
                    GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths_vptr, pathBase, stride, metrics_ptr);
                }
            }
            public static unsafe void GetPathMetricsNV(PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int stride, ref float metrics)
            {
                fixed (float* metrics_ptr = &metrics)
                {
                    void* paths_vptr = (void*)paths;
                    GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths_vptr, pathBase, stride, metrics_ptr);
                }
            }
            public static unsafe void GetPathMetricsNV<T1>(PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, ReadOnlySpan<T1> paths, uint pathBase, int stride, Span<float> metrics)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = paths)
                {
                    fixed (float* metrics_ptr = metrics)
                    {
                        GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths_ptr, pathBase, stride, metrics_ptr);
                    }
                }
            }
            public static unsafe void GetPathMetricsNV<T1>(PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, T1[] paths, uint pathBase, int stride, float[] metrics)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = paths)
                {
                    fixed (float* metrics_ptr = metrics)
                    {
                        GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths_ptr, pathBase, stride, metrics_ptr);
                    }
                }
            }
            public static unsafe void GetPathMetricsNV<T1>(PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, in T1 paths, uint pathBase, int stride, ref float metrics)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = &paths)
                fixed (float* metrics_ptr = &metrics)
                {
                    GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths_ptr, pathBase, stride, metrics_ptr);
                }
            }
            public static unsafe void GetPathMetricRangeNV(PathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, Span<float> metrics)
            {
                fixed (float* metrics_ptr = metrics)
                {
                    GetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics_ptr);
                }
            }
            public static unsafe void GetPathMetricRangeNV(PathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float[] metrics)
            {
                fixed (float* metrics_ptr = metrics)
                {
                    GetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics_ptr);
                }
            }
            public static unsafe void GetPathMetricRangeNV(PathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, ref float metrics)
            {
                fixed (float* metrics_ptr = &metrics)
                {
                    GetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics_ptr);
                }
            }
            public static unsafe void GetPathSpacingNV(PathListMode pathListMode, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, Span<float> returnedSpacing)
            {
                fixed (float* returnedSpacing_ptr = returnedSpacing)
                {
                    void* paths_vptr = (void*)paths;
                    GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths_vptr, pathBase, advanceScale, kerningScale, transformType, returnedSpacing_ptr);
                }
            }
            public static unsafe void GetPathSpacingNV(PathListMode pathListMode, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, float[] returnedSpacing)
            {
                fixed (float* returnedSpacing_ptr = returnedSpacing)
                {
                    void* paths_vptr = (void*)paths;
                    GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths_vptr, pathBase, advanceScale, kerningScale, transformType, returnedSpacing_ptr);
                }
            }
            public static unsafe void GetPathSpacingNV(PathListMode pathListMode, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, ref float returnedSpacing)
            {
                fixed (float* returnedSpacing_ptr = &returnedSpacing)
                {
                    void* paths_vptr = (void*)paths;
                    GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths_vptr, pathBase, advanceScale, kerningScale, transformType, returnedSpacing_ptr);
                }
            }
            public static unsafe void GetPathSpacingNV<T1>(PathListMode pathListMode, int numPaths, PathElementType pathNameType, ReadOnlySpan<T1> paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, Span<float> returnedSpacing)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = paths)
                {
                    fixed (float* returnedSpacing_ptr = returnedSpacing)
                    {
                        GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths_ptr, pathBase, advanceScale, kerningScale, transformType, returnedSpacing_ptr);
                    }
                }
            }
            public static unsafe void GetPathSpacingNV<T1>(PathListMode pathListMode, int numPaths, PathElementType pathNameType, T1[] paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, float[] returnedSpacing)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = paths)
                {
                    fixed (float* returnedSpacing_ptr = returnedSpacing)
                    {
                        GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths_ptr, pathBase, advanceScale, kerningScale, transformType, returnedSpacing_ptr);
                    }
                }
            }
            public static unsafe void GetPathSpacingNV<T1>(PathListMode pathListMode, int numPaths, PathElementType pathNameType, in T1 paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, ref float returnedSpacing)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = &paths)
                fixed (float* returnedSpacing_ptr = &returnedSpacing)
                {
                    GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths_ptr, pathBase, advanceScale, kerningScale, transformType, returnedSpacing_ptr);
                }
            }
            public static unsafe byte PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, Span<float> x, Span<float> y, Span<float> tangentX, Span<float> tangentY)
            {
                byte returnValue;
                fixed (float* x_ptr = x)
                {
                    fixed (float* y_ptr = y)
                    {
                        fixed (float* tangentX_ptr = tangentX)
                        {
                            fixed (float* tangentY_ptr = tangentY)
                            {
                                returnValue = PointAlongPathNV(path, startSegment, numSegments, distance, x_ptr, y_ptr, tangentX_ptr, tangentY_ptr);
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe byte PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float[] x, float[] y, float[] tangentX, float[] tangentY)
            {
                byte returnValue;
                fixed (float* x_ptr = x)
                {
                    fixed (float* y_ptr = y)
                    {
                        fixed (float* tangentX_ptr = tangentX)
                        {
                            fixed (float* tangentY_ptr = tangentY)
                            {
                                returnValue = PointAlongPathNV(path, startSegment, numSegments, distance, x_ptr, y_ptr, tangentX_ptr, tangentY_ptr);
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe byte PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, ref float tangentX, ref float tangentY)
            {
                byte returnValue;
                fixed (float* x_ptr = &x)
                fixed (float* y_ptr = &y)
                fixed (float* tangentX_ptr = &tangentX)
                fixed (float* tangentY_ptr = &tangentY)
                {
                    returnValue = PointAlongPathNV(path, startSegment, numSegments, distance, x_ptr, y_ptr, tangentX_ptr, tangentY_ptr);
                }
                return returnValue;
            }
            public static unsafe void MatrixLoad3x2fNV(All matrixMode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixLoad3x2fNV(matrixMode, m_ptr);
                }
            }
            public static unsafe void MatrixLoad3x3fNV(All matrixMode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixLoad3x3fNV(matrixMode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadTranspose3x3fNV(All matrixMode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixLoadTranspose3x3fNV(matrixMode, m_ptr);
                }
            }
            public static unsafe void MatrixMult3x2fNV(All matrixMode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixMult3x2fNV(matrixMode, m_ptr);
                }
            }
            public static unsafe void MatrixMult3x3fNV(All matrixMode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixMult3x3fNV(matrixMode, m_ptr);
                }
            }
            public static unsafe void MatrixMultTranspose3x3fNV(All matrixMode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixMultTranspose3x3fNV(matrixMode, m_ptr);
                }
            }
            public static unsafe void StencilThenCoverFillPathInstancedNV(int numPaths, All pathNameType, IntPtr paths, uint pathBase, All fillMode, uint mask, All coverMode, All transformType, in float transformValues)
            {
                fixed (float* transformValues_ptr = &transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    StencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, fillMode, mask, coverMode, transformType, transformValues_ptr);
                }
            }
            public static unsafe void StencilThenCoverFillPathInstancedNV<T1>(int numPaths, All pathNameType, in T1 paths, uint pathBase, All fillMode, uint mask, All coverMode, All transformType, in float transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = &paths)
                fixed (float* transformValues_ptr = &transformValues)
                {
                    StencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, fillMode, mask, coverMode, transformType, transformValues_ptr);
                }
            }
            public static unsafe void StencilThenCoverStrokePathInstancedNV(int numPaths, All pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, All coverMode, All transformType, in float transformValues)
            {
                fixed (float* transformValues_ptr = &transformValues)
                {
                    void* paths_vptr = (void*)paths;
                    StencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths_vptr, pathBase, reference, mask, coverMode, transformType, transformValues_ptr);
                }
            }
            public static unsafe void StencilThenCoverStrokePathInstancedNV<T1>(int numPaths, All pathNameType, in T1 paths, uint pathBase, int reference, uint mask, All coverMode, All transformType, in float transformValues)
                where T1 : unmanaged
            {
                fixed (void* paths_ptr = &paths)
                fixed (float* transformValues_ptr = &transformValues)
                {
                    StencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths_ptr, pathBase, reference, mask, coverMode, transformType, transformValues_ptr);
                }
            }
            public static unsafe All PathGlyphIndexRangeNV(All fontTarget, IntPtr fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, Span<uint> baseAndCount)
            {
                All returnValue;
                fixed (uint* baseAndCount_ptr = baseAndCount)
                {
                    void* fontName_vptr = (void*)fontName;
                    returnValue = PathGlyphIndexRangeNV(fontTarget, fontName_vptr, fontStyle, pathParameterTemplate, emScale, baseAndCount_ptr);
                }
                return returnValue;
            }
            public static unsafe All PathGlyphIndexRangeNV(All fontTarget, IntPtr fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint[] baseAndCount)
            {
                All returnValue;
                fixed (uint* baseAndCount_ptr = baseAndCount)
                {
                    void* fontName_vptr = (void*)fontName;
                    returnValue = PathGlyphIndexRangeNV(fontTarget, fontName_vptr, fontStyle, pathParameterTemplate, emScale, baseAndCount_ptr);
                }
                return returnValue;
            }
            public static unsafe All PathGlyphIndexRangeNV(All fontTarget, IntPtr fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, ref uint baseAndCount)
            {
                All returnValue;
                fixed (uint* baseAndCount_ptr = &baseAndCount)
                {
                    void* fontName_vptr = (void*)fontName;
                    returnValue = PathGlyphIndexRangeNV(fontTarget, fontName_vptr, fontStyle, pathParameterTemplate, emScale, baseAndCount_ptr);
                }
                return returnValue;
            }
            public static unsafe All PathGlyphIndexRangeNV<T1>(All fontTarget, in T1 fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, Span<uint> baseAndCount)
                where T1 : unmanaged
            {
                All returnValue;
                fixed (void* fontName_ptr = &fontName)
                {
                    fixed (uint* baseAndCount_ptr = baseAndCount)
                    {
                        returnValue = PathGlyphIndexRangeNV(fontTarget, fontName_ptr, fontStyle, pathParameterTemplate, emScale, baseAndCount_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe All PathGlyphIndexRangeNV<T1>(All fontTarget, in T1 fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint[] baseAndCount)
                where T1 : unmanaged
            {
                All returnValue;
                fixed (void* fontName_ptr = &fontName)
                {
                    fixed (uint* baseAndCount_ptr = baseAndCount)
                    {
                        returnValue = PathGlyphIndexRangeNV(fontTarget, fontName_ptr, fontStyle, pathParameterTemplate, emScale, baseAndCount_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe All PathGlyphIndexRangeNV<T1>(All fontTarget, in T1 fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, ref uint baseAndCount)
                where T1 : unmanaged
            {
                All returnValue;
                fixed (void* fontName_ptr = &fontName)
                fixed (uint* baseAndCount_ptr = &baseAndCount)
                {
                    returnValue = PathGlyphIndexRangeNV(fontTarget, fontName_ptr, fontStyle, pathParameterTemplate, emScale, baseAndCount_ptr);
                }
                return returnValue;
            }
            public static unsafe All PathGlyphIndexArrayNV(uint firstPathName, All fontTarget, IntPtr fontName, PathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
            {
                All returnValue;
                void* fontName_vptr = (void*)fontName;
                returnValue = PathGlyphIndexArrayNV(firstPathName, fontTarget, fontName_vptr, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
                return returnValue;
            }
            public static unsafe All PathGlyphIndexArrayNV<T1>(uint firstPathName, All fontTarget, in T1 fontName, PathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
                where T1 : unmanaged
            {
                All returnValue;
                fixed (void* fontName_ptr = &fontName)
                {
                    returnValue = PathGlyphIndexArrayNV(firstPathName, fontTarget, fontName_ptr, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
                }
                return returnValue;
            }
            public static unsafe All PathMemoryGlyphIndexArrayNV(uint firstPathName, All fontTarget, nint fontSize, IntPtr fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
            {
                All returnValue;
                void* fontData_vptr = (void*)fontData;
                returnValue = PathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData_vptr, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
                return returnValue;
            }
            public static unsafe All PathMemoryGlyphIndexArrayNV<T1>(uint firstPathName, All fontTarget, nint fontSize, in T1 fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
                where T1 : unmanaged
            {
                All returnValue;
                fixed (void* fontData_ptr = &fontData)
                {
                    returnValue = PathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData_ptr, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
                }
                return returnValue;
            }
            public static unsafe void ProgramPathFragmentInputGenNV(ProgramHandle program, int location, All genMode, int components, in float coeffs)
            {
                fixed (float* coeffs_ptr = &coeffs)
                {
                    ProgramPathFragmentInputGenNV(program, location, genMode, components, coeffs_ptr);
                }
            }
            public static unsafe void GetProgramResourcefvNV(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, in All props, Span<int> length, Span<float> parameters)
            {
                fixed (All* props_ptr = &props)
                {
                    fixed (int* length_ptr = length)
                    {
                        int count = (int)(parameters.Length);
                        fixed (float* parameters_ptr = parameters)
                        {
                            GetProgramResourcefvNV(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                        }
                    }
                }
            }
            public static unsafe void GetProgramResourcefvNV(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, in All props, int[] length, float[] parameters)
            {
                fixed (All* props_ptr = &props)
                {
                    fixed (int* length_ptr = length)
                    {
                        int count = (int)(parameters.Length);
                        fixed (float* parameters_ptr = parameters)
                        {
                            GetProgramResourcefvNV(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                        }
                    }
                }
            }
            public static unsafe void GetProgramResourcefvNV(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, in All props, int count, ref int length, ref float parameters)
            {
                fixed (All* props_ptr = &props)
                fixed (int* length_ptr = &length)
                fixed (float* parameters_ptr = &parameters)
                {
                    GetProgramResourcefvNV(program, programInterface, index, propCount, props_ptr, count, length_ptr, parameters_ptr);
                }
            }
            public static unsafe void MatrixLoadTransposefEXT(MatrixMode mode, ReadOnlySpan<float> m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixLoadTransposefEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadTransposefEXT(MatrixMode mode, float[] m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixLoadTransposefEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadTransposefEXT(MatrixMode mode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixLoadTransposefEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadTransposedEXT(MatrixMode mode, ReadOnlySpan<double> m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixLoadTransposedEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadTransposedEXT(MatrixMode mode, double[] m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixLoadTransposedEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadTransposedEXT(MatrixMode mode, in double m)
            {
                fixed (double* m_ptr = &m)
                {
                    MatrixLoadTransposedEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadfEXT(MatrixMode mode, ReadOnlySpan<float> m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixLoadfEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadfEXT(MatrixMode mode, float[] m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixLoadfEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoadfEXT(MatrixMode mode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixLoadfEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoaddEXT(MatrixMode mode, ReadOnlySpan<double> m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixLoaddEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoaddEXT(MatrixMode mode, double[] m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixLoaddEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixLoaddEXT(MatrixMode mode, in double m)
            {
                fixed (double* m_ptr = &m)
                {
                    MatrixLoaddEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultTransposefEXT(MatrixMode mode, ReadOnlySpan<float> m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixMultTransposefEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultTransposefEXT(MatrixMode mode, float[] m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixMultTransposefEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultTransposefEXT(MatrixMode mode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixMultTransposefEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultTransposedEXT(MatrixMode mode, ReadOnlySpan<double> m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixMultTransposedEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultTransposedEXT(MatrixMode mode, double[] m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixMultTransposedEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultTransposedEXT(MatrixMode mode, in double m)
            {
                fixed (double* m_ptr = &m)
                {
                    MatrixMultTransposedEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultfEXT(MatrixMode mode, ReadOnlySpan<float> m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixMultfEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultfEXT(MatrixMode mode, float[] m)
            {
                fixed (float* m_ptr = m)
                {
                    MatrixMultfEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultfEXT(MatrixMode mode, in float m)
            {
                fixed (float* m_ptr = &m)
                {
                    MatrixMultfEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultdEXT(MatrixMode mode, ReadOnlySpan<double> m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixMultdEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultdEXT(MatrixMode mode, double[] m)
            {
                fixed (double* m_ptr = m)
                {
                    MatrixMultdEXT(mode, m_ptr);
                }
            }
            public static unsafe void MatrixMultdEXT(MatrixMode mode, in double m)
            {
                fixed (double* m_ptr = &m)
                {
                    MatrixMultdEXT(mode, m_ptr);
                }
            }
            public static unsafe void PixelDataRangeNV(PixelDataRangeTargetNV target, int length, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                PixelDataRangeNV(target, length, pointer_vptr);
            }
            public static unsafe void PixelDataRangeNV<T1>(PixelDataRangeTargetNV target, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                int length = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    PixelDataRangeNV(target, length, pointer_ptr);
                }
            }
            public static unsafe void PixelDataRangeNV<T1>(PixelDataRangeTargetNV target, T1[] pointer)
                where T1 : unmanaged
            {
                int length = (int)(pointer.Length * sizeof(T1));
                fixed (void* pointer_ptr = pointer)
                {
                    PixelDataRangeNV(target, length, pointer_ptr);
                }
            }
            public static unsafe void PixelDataRangeNV<T1>(PixelDataRangeTargetNV target, int length, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    PixelDataRangeNV(target, length, pointer_ptr);
                }
            }
            public static unsafe void PointParameterivNV(PointParameterNameARB pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    PointParameterivNV(pname, parameters_ptr);
                }
            }
            public static unsafe void PointParameterivNV(PointParameterNameARB pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    PointParameterivNV(pname, parameters_ptr);
                }
            }
            public static unsafe void PointParameterivNV(PointParameterNameARB pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    PointParameterivNV(pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoivNV(uint video_slot, All pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVideoivNV(video_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoivNV(uint video_slot, All pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVideoivNV(video_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoivNV(uint video_slot, All pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetVideoivNV(video_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideouivNV(uint video_slot, All pname, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetVideouivNV(video_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideouivNV(uint video_slot, All pname, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetVideouivNV(video_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideouivNV(uint video_slot, All pname, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetVideouivNV(video_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoi64vNV(uint video_slot, All pname, Span<long> parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetVideoi64vNV(video_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoi64vNV(uint video_slot, All pname, long[] parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetVideoi64vNV(video_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoi64vNV(uint video_slot, All pname, ref long parameters)
            {
                fixed (long* parameters_ptr = &parameters)
                {
                    GetVideoi64vNV(video_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoui64vNV(uint video_slot, All pname, Span<ulong> parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetVideoui64vNV(video_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoui64vNV(uint video_slot, All pname, ulong[] parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetVideoui64vNV(video_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoui64vNV(uint video_slot, All pname, ref ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    GetVideoui64vNV(video_slot, pname, parameters_ptr);
                }
            }
            public static unsafe int QueryResourceNV(All queryType, int tagId, Span<int> buffer)
            {
                int returnValue;
                uint count = (uint)(buffer.Length);
                fixed (int* buffer_ptr = buffer)
                {
                    returnValue = QueryResourceNV(queryType, tagId, count, buffer_ptr);
                }
                return returnValue;
            }
            public static unsafe int QueryResourceNV(All queryType, int tagId, int[] buffer)
            {
                int returnValue;
                uint count = (uint)(buffer.Length);
                fixed (int* buffer_ptr = buffer)
                {
                    returnValue = QueryResourceNV(queryType, tagId, count, buffer_ptr);
                }
                return returnValue;
            }
            public static unsafe int QueryResourceNV(All queryType, int tagId, uint count, ref int buffer)
            {
                int returnValue;
                fixed (int* buffer_ptr = &buffer)
                {
                    returnValue = QueryResourceNV(queryType, tagId, count, buffer_ptr);
                }
                return returnValue;
            }
            public static unsafe void GenQueryResourceTagNV(Span<int> tagIds)
            {
                int n = (int)(tagIds.Length);
                fixed (int* tagIds_ptr = tagIds)
                {
                    GenQueryResourceTagNV(n, tagIds_ptr);
                }
            }
            public static unsafe void GenQueryResourceTagNV(int[] tagIds)
            {
                int n = (int)(tagIds.Length);
                fixed (int* tagIds_ptr = tagIds)
                {
                    GenQueryResourceTagNV(n, tagIds_ptr);
                }
            }
            public static unsafe void GenQueryResourceTagNV(int n, ref int tagIds)
            {
                fixed (int* tagIds_ptr = &tagIds)
                {
                    GenQueryResourceTagNV(n, tagIds_ptr);
                }
            }
            public static unsafe void DeleteQueryResourceTagNV(ReadOnlySpan<int> tagIds)
            {
                int n = (int)(tagIds.Length);
                fixed (int* tagIds_ptr = tagIds)
                {
                    DeleteQueryResourceTagNV(n, tagIds_ptr);
                }
            }
            public static unsafe void DeleteQueryResourceTagNV(int[] tagIds)
            {
                int n = (int)(tagIds.Length);
                fixed (int* tagIds_ptr = tagIds)
                {
                    DeleteQueryResourceTagNV(n, tagIds_ptr);
                }
            }
            public static unsafe void DeleteQueryResourceTagNV(int n, in int tagIds)
            {
                fixed (int* tagIds_ptr = &tagIds)
                {
                    DeleteQueryResourceTagNV(n, tagIds_ptr);
                }
            }
            public static unsafe void QueryResourceTagNV(int tagId, string tagString)
            {
                byte* tagString_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(tagString);
                QueryResourceTagNV(tagId, tagString_ptr);
                Marshal.FreeCoTaskMem((IntPtr)tagString_ptr);
            }
            public static unsafe void CombinerParameterfvNV(CombinerParameterNV pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    CombinerParameterfvNV(pname, parameters_ptr);
                }
            }
            public static unsafe void CombinerParameterfvNV(CombinerParameterNV pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    CombinerParameterfvNV(pname, parameters_ptr);
                }
            }
            public static unsafe void CombinerParameterfvNV(CombinerParameterNV pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    CombinerParameterfvNV(pname, parameters_ptr);
                }
            }
            public static unsafe void CombinerParameterivNV(CombinerParameterNV pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    CombinerParameterivNV(pname, parameters_ptr);
                }
            }
            public static unsafe void CombinerParameterivNV(CombinerParameterNV pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    CombinerParameterivNV(pname, parameters_ptr);
                }
            }
            public static unsafe void CombinerParameterivNV(CombinerParameterNV pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    CombinerParameterivNV(pname, parameters_ptr);
                }
            }
            public static unsafe void CombinerOutputNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerRegisterNV abOutput, CombinerRegisterNV cdOutput, CombinerRegisterNV sumOutput, CombinerScaleNV scale, CombinerBiasNV bias, bool abDotProduct, bool cdDotProduct, bool muxSum)
            {
                byte abDotProduct_byte = (byte)(abDotProduct ? 1 : 0);
                byte cdDotProduct_byte = (byte)(cdDotProduct ? 1 : 0);
                byte muxSum_byte = (byte)(muxSum ? 1 : 0);
                CombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct_byte, cdDotProduct_byte, muxSum_byte);
            }
            public static unsafe void GetCombinerInputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetCombinerInputParameterfvNV(stage, portion, variable, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerInputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetCombinerInputParameterfvNV(stage, portion, variable, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerInputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetCombinerInputParameterfvNV(stage, portion, variable, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerInputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetCombinerInputParameterivNV(stage, portion, variable, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerInputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetCombinerInputParameterivNV(stage, portion, variable, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerInputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetCombinerInputParameterivNV(stage, portion, variable, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerOutputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetCombinerOutputParameterfvNV(stage, portion, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerOutputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetCombinerOutputParameterfvNV(stage, portion, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerOutputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetCombinerOutputParameterfvNV(stage, portion, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerOutputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetCombinerOutputParameterivNV(stage, portion, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerOutputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetCombinerOutputParameterivNV(stage, portion, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerOutputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetCombinerOutputParameterivNV(stage, portion, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFinalCombinerInputParameterfvNV(CombinerVariableNV variable, CombinerParameterNV pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetFinalCombinerInputParameterfvNV(variable, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFinalCombinerInputParameterfvNV(CombinerVariableNV variable, CombinerParameterNV pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetFinalCombinerInputParameterfvNV(variable, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFinalCombinerInputParameterfvNV(CombinerVariableNV variable, CombinerParameterNV pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetFinalCombinerInputParameterfvNV(variable, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFinalCombinerInputParameterivNV(CombinerVariableNV variable, CombinerParameterNV pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFinalCombinerInputParameterivNV(variable, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFinalCombinerInputParameterivNV(CombinerVariableNV variable, CombinerParameterNV pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFinalCombinerInputParameterivNV(variable, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFinalCombinerInputParameterivNV(CombinerVariableNV variable, CombinerParameterNV pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetFinalCombinerInputParameterivNV(variable, pname, parameters_ptr);
                }
            }
            public static unsafe void CombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    CombinerStageParameterfvNV(stage, pname, parameters_ptr);
                }
            }
            public static unsafe void CombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    CombinerStageParameterfvNV(stage, pname, parameters_ptr);
                }
            }
            public static unsafe void CombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    CombinerStageParameterfvNV(stage, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetCombinerStageParameterfvNV(stage, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetCombinerStageParameterfvNV(stage, pname, parameters_ptr);
                }
            }
            public static unsafe void GetCombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetCombinerStageParameterfvNV(stage, pname, parameters_ptr);
                }
            }
            public static unsafe void FramebufferSampleLocationsfvNV(FramebufferTarget target, uint start, int count, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    FramebufferSampleLocationsfvNV(target, start, count, v_ptr);
                }
            }
            public static unsafe void NamedFramebufferSampleLocationsfvNV(FramebufferHandle framebuffer, uint start, int count, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    NamedFramebufferSampleLocationsfvNV(framebuffer, start, count, v_ptr);
                }
            }
            public static unsafe void ScissorExclusiveArrayvNV(uint first, int count, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    ScissorExclusiveArrayvNV(first, count, v_ptr);
                }
            }
            public static unsafe void ScissorExclusiveArrayvNV(uint first, int count, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    ScissorExclusiveArrayvNV(first, count, v_ptr);
                }
            }
            public static unsafe void ScissorExclusiveArrayvNV(uint first, int count, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    ScissorExclusiveArrayvNV(first, count, v_ptr);
                }
            }
            public static unsafe void GetBufferParameterui64vNV(BufferTargetARB target, All pname, Span<ulong> parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetBufferParameterui64vNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetBufferParameterui64vNV(BufferTargetARB target, All pname, ulong[] parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetBufferParameterui64vNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetBufferParameterui64vNV(BufferTargetARB target, All pname, ref ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    GetBufferParameterui64vNV(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedBufferParameterui64vNV(BufferHandle buffer, BufferPNameARB pname, Span<ulong> parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetNamedBufferParameterui64vNV(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedBufferParameterui64vNV(BufferHandle buffer, BufferPNameARB pname, ulong[] parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetNamedBufferParameterui64vNV(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetNamedBufferParameterui64vNV(BufferHandle buffer, BufferPNameARB pname, ref ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    GetNamedBufferParameterui64vNV(buffer, pname, parameters_ptr);
                }
            }
            public static unsafe void GetIntegerui64vNV(All value, Span<ulong> result)
            {
                fixed (ulong* result_ptr = result)
                {
                    GetIntegerui64vNV(value, result_ptr);
                }
            }
            public static unsafe void GetIntegerui64vNV(All value, ulong[] result)
            {
                fixed (ulong* result_ptr = result)
                {
                    GetIntegerui64vNV(value, result_ptr);
                }
            }
            public static unsafe void GetIntegerui64vNV(All value, ref ulong result)
            {
                fixed (ulong* result_ptr = &result)
                {
                    GetIntegerui64vNV(value, result_ptr);
                }
            }
            public static unsafe void Uniformui64vNV(int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length / 1);
                fixed (ulong* value_ptr = value)
                {
                    Uniformui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniformui64vNV(int location, ulong[] value)
            {
                int count = (int)(value.Length / 1);
                fixed (ulong* value_ptr = value)
                {
                    Uniformui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void Uniformui64vNV(int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    Uniformui64vNV(location, count, value_ptr);
                }
            }
            public static unsafe void GetUniformui64vNV(ProgramHandle program, int location, Span<ulong> parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetUniformui64vNV(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformui64vNV(ProgramHandle program, int location, ulong[] parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetUniformui64vNV(program, location, parameters_ptr);
                }
            }
            public static unsafe void GetUniformui64vNV(ProgramHandle program, int location, ref ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    GetUniformui64vNV(program, location, parameters_ptr);
                }
            }
            public static unsafe void ProgramUniformui64vNV(ProgramHandle program, int location, ReadOnlySpan<ulong> value)
            {
                int count = (int)(value.Length);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniformui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniformui64vNV(ProgramHandle program, int location, ulong[] value)
            {
                int count = (int)(value.Length);
                fixed (ulong* value_ptr = value)
                {
                    ProgramUniformui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void ProgramUniformui64vNV(ProgramHandle program, int location, int count, in ulong value)
            {
                fixed (ulong* value_ptr = &value)
                {
                    ProgramUniformui64vNV(program, location, count, value_ptr);
                }
            }
            public static unsafe void GetShadingRateImagePaletteNV(uint viewport, uint entry, Span<All> rate)
            {
                fixed (All* rate_ptr = rate)
                {
                    GetShadingRateImagePaletteNV(viewport, entry, rate_ptr);
                }
            }
            public static unsafe void GetShadingRateImagePaletteNV(uint viewport, uint entry, All[] rate)
            {
                fixed (All* rate_ptr = rate)
                {
                    GetShadingRateImagePaletteNV(viewport, entry, rate_ptr);
                }
            }
            public static unsafe void GetShadingRateImagePaletteNV(uint viewport, uint entry, ref All rate)
            {
                fixed (All* rate_ptr = &rate)
                {
                    GetShadingRateImagePaletteNV(viewport, entry, rate_ptr);
                }
            }
            public static unsafe void GetShadingRateSampleLocationivNV(All rate, uint samples, uint index, Span<int> location)
            {
                fixed (int* location_ptr = location)
                {
                    GetShadingRateSampleLocationivNV(rate, samples, index, location_ptr);
                }
            }
            public static unsafe void GetShadingRateSampleLocationivNV(All rate, uint samples, uint index, int[] location)
            {
                fixed (int* location_ptr = location)
                {
                    GetShadingRateSampleLocationivNV(rate, samples, index, location_ptr);
                }
            }
            public static unsafe void GetShadingRateSampleLocationivNV(All rate, uint samples, uint index, ref int location)
            {
                fixed (int* location_ptr = &location)
                {
                    GetShadingRateSampleLocationivNV(rate, samples, index, location_ptr);
                }
            }
            public static unsafe void ShadingRateImageBarrierNV(bool synchronize)
            {
                byte synchronize_byte = (byte)(synchronize ? 1 : 0);
                ShadingRateImageBarrierNV(synchronize_byte);
            }
            public static unsafe void ShadingRateImagePaletteNV(uint viewport, uint first, ReadOnlySpan<All> rates)
            {
                int count = (int)(rates.Length);
                fixed (All* rates_ptr = rates)
                {
                    ShadingRateImagePaletteNV(viewport, first, count, rates_ptr);
                }
            }
            public static unsafe void ShadingRateImagePaletteNV(uint viewport, uint first, All[] rates)
            {
                int count = (int)(rates.Length);
                fixed (All* rates_ptr = rates)
                {
                    ShadingRateImagePaletteNV(viewport, first, count, rates_ptr);
                }
            }
            public static unsafe void ShadingRateImagePaletteNV(uint viewport, uint first, int count, in All rates)
            {
                fixed (All* rates_ptr = &rates)
                {
                    ShadingRateImagePaletteNV(viewport, first, count, rates_ptr);
                }
            }
            public static unsafe void ShadingRateSampleOrderCustomNV(All rate, uint samples, ReadOnlySpan<int> locations)
            {
                fixed (int* locations_ptr = locations)
                {
                    ShadingRateSampleOrderCustomNV(rate, samples, locations_ptr);
                }
            }
            public static unsafe void ShadingRateSampleOrderCustomNV(All rate, uint samples, int[] locations)
            {
                fixed (int* locations_ptr = locations)
                {
                    ShadingRateSampleOrderCustomNV(rate, samples, locations_ptr);
                }
            }
            public static unsafe void ShadingRateSampleOrderCustomNV(All rate, uint samples, in int locations)
            {
                fixed (int* locations_ptr = &locations)
                {
                    ShadingRateSampleOrderCustomNV(rate, samples, locations_ptr);
                }
            }
            public static unsafe void TexImage2DMultisampleCoverageNV(TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations)
            {
                byte fixedSampleLocations_byte = (byte)(fixedSampleLocations ? 1 : 0);
                TexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations_byte);
            }
            public static unsafe void TexImage3DMultisampleCoverageNV(TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations)
            {
                byte fixedSampleLocations_byte = (byte)(fixedSampleLocations ? 1 : 0);
                TexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations_byte);
            }
            public static unsafe void TextureImage2DMultisampleNV(TextureHandle texture, TextureTarget target, int samples, int internalFormat, int width, int height, bool fixedSampleLocations)
            {
                byte fixedSampleLocations_byte = (byte)(fixedSampleLocations ? 1 : 0);
                TextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations_byte);
            }
            public static unsafe void TextureImage3DMultisampleNV(TextureHandle texture, TextureTarget target, int samples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations)
            {
                byte fixedSampleLocations_byte = (byte)(fixedSampleLocations ? 1 : 0);
                TextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations_byte);
            }
            public static unsafe void TextureImage2DMultisampleCoverageNV(TextureHandle texture, TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations)
            {
                byte fixedSampleLocations_byte = (byte)(fixedSampleLocations ? 1 : 0);
                TextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations_byte);
            }
            public static unsafe void TextureImage3DMultisampleCoverageNV(TextureHandle texture, TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations)
            {
                byte fixedSampleLocations_byte = (byte)(fixedSampleLocations ? 1 : 0);
                TextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations_byte);
            }
            public static unsafe void TransformFeedbackAttribsNV(int count, ReadOnlySpan<int> attribs, All bufferMode)
            {
                fixed (int* attribs_ptr = attribs)
                {
                    TransformFeedbackAttribsNV(count, attribs_ptr, bufferMode);
                }
            }
            public static unsafe void TransformFeedbackAttribsNV(int count, int[] attribs, All bufferMode)
            {
                fixed (int* attribs_ptr = attribs)
                {
                    TransformFeedbackAttribsNV(count, attribs_ptr, bufferMode);
                }
            }
            public static unsafe void TransformFeedbackAttribsNV(int count, in int attribs, All bufferMode)
            {
                fixed (int* attribs_ptr = &attribs)
                {
                    TransformFeedbackAttribsNV(count, attribs_ptr, bufferMode);
                }
            }
            public static unsafe void TransformFeedbackVaryingsNV(ProgramHandle program, ReadOnlySpan<int> locations, All bufferMode)
            {
                int count = (int)(locations.Length);
                fixed (int* locations_ptr = locations)
                {
                    TransformFeedbackVaryingsNV(program, count, locations_ptr, bufferMode);
                }
            }
            public static unsafe void TransformFeedbackVaryingsNV(ProgramHandle program, int[] locations, All bufferMode)
            {
                int count = (int)(locations.Length);
                fixed (int* locations_ptr = locations)
                {
                    TransformFeedbackVaryingsNV(program, count, locations_ptr, bufferMode);
                }
            }
            public static unsafe void TransformFeedbackVaryingsNV(ProgramHandle program, int count, in int locations, All bufferMode)
            {
                fixed (int* locations_ptr = &locations)
                {
                    TransformFeedbackVaryingsNV(program, count, locations_ptr, bufferMode);
                }
            }
            public static unsafe void ActiveVaryingNV(ProgramHandle program, string name)
            {
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                ActiveVaryingNV(program, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
            }
            public static unsafe int GetVaryingLocationNV(ProgramHandle program, string name)
            {
                int returnValue;
                byte* name_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(name);
                returnValue = GetVaryingLocationNV(program, name_ptr);
                Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                return returnValue;
            }
            public static unsafe string GetActiveVaryingNV(ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<All> type)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (All* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                            GetActiveVaryingNV(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
                return name;
            }
            public static unsafe void GetActiveVaryingNV(ProgramHandle program, uint index, int bufSize, Span<int> length, Span<int> size, Span<All> type, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (All* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                            GetActiveVaryingNV(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
            }
            public static unsafe string GetActiveVaryingNV(ProgramHandle program, uint index, int bufSize, int[] length, int[] size, All[] type)
            {
                string name;
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (All* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                            GetActiveVaryingNV(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
                return name;
            }
            public static unsafe void GetActiveVaryingNV(ProgramHandle program, uint index, int bufSize, int[] length, int[] size, All[] type, out string name)
            {
                fixed (int* length_ptr = length)
                {
                    fixed (int* size_ptr = size)
                    {
                        fixed (All* type_ptr = type)
                        {
                            var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                            GetActiveVaryingNV(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                            name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                            Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                        }
                    }
                }
            }
            public static unsafe string GetActiveVaryingNV(ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref All type)
            {
                string name;
                fixed (int* length_ptr = &length)
                fixed (int* size_ptr = &size)
                fixed (All* type_ptr = &type)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveVaryingNV(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
                return name;
            }
            public static unsafe void GetActiveVaryingNV(ProgramHandle program, uint index, int bufSize, ref int length, ref int size, ref All type, out string name)
            {
                fixed (int* length_ptr = &length)
                fixed (int* size_ptr = &size)
                fixed (All* type_ptr = &type)
                {
                    var name_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetActiveVaryingNV(program, index, bufSize, length_ptr, size_ptr, type_ptr, name_ptr);
                    name = Marshal.PtrToStringUTF8((IntPtr)name_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)name_ptr);
                }
            }
            public static unsafe void GetTransformFeedbackVaryingNV(ProgramHandle program, uint index, Span<int> location)
            {
                fixed (int* location_ptr = location)
                {
                    GetTransformFeedbackVaryingNV(program, index, location_ptr);
                }
            }
            public static unsafe void GetTransformFeedbackVaryingNV(ProgramHandle program, uint index, int[] location)
            {
                fixed (int* location_ptr = location)
                {
                    GetTransformFeedbackVaryingNV(program, index, location_ptr);
                }
            }
            public static unsafe void GetTransformFeedbackVaryingNV(ProgramHandle program, uint index, ref int location)
            {
                fixed (int* location_ptr = &location)
                {
                    GetTransformFeedbackVaryingNV(program, index, location_ptr);
                }
            }
            public static unsafe void TransformFeedbackStreamAttribsNV(ReadOnlySpan<int> attribs, ReadOnlySpan<int> bufstreams, All bufferMode)
            {
                int count = (int)(attribs.Length);
                fixed (int* attribs_ptr = attribs)
                {
                    int nbuffers = (int)(bufstreams.Length);
                    fixed (int* bufstreams_ptr = bufstreams)
                    {
                        TransformFeedbackStreamAttribsNV(count, attribs_ptr, nbuffers, bufstreams_ptr, bufferMode);
                    }
                }
            }
            public static unsafe void TransformFeedbackStreamAttribsNV(int[] attribs, int[] bufstreams, All bufferMode)
            {
                int count = (int)(attribs.Length);
                fixed (int* attribs_ptr = attribs)
                {
                    int nbuffers = (int)(bufstreams.Length);
                    fixed (int* bufstreams_ptr = bufstreams)
                    {
                        TransformFeedbackStreamAttribsNV(count, attribs_ptr, nbuffers, bufstreams_ptr, bufferMode);
                    }
                }
            }
            public static unsafe void TransformFeedbackStreamAttribsNV(int count, in int attribs, int nbuffers, in int bufstreams, All bufferMode)
            {
                fixed (int* attribs_ptr = &attribs)
                fixed (int* bufstreams_ptr = &bufstreams)
                {
                    TransformFeedbackStreamAttribsNV(count, attribs_ptr, nbuffers, bufstreams_ptr, bufferMode);
                }
            }
            public static unsafe void DeleteTransformFeedbacksNV(ReadOnlySpan<TransformFeedbackHandle> ids)
            {
                int n = (int)(ids.Length);
                fixed (TransformFeedbackHandle* ids_ptr = ids)
                {
                    DeleteTransformFeedbacksNV(n, ids_ptr);
                }
            }
            public static unsafe void DeleteTransformFeedbacksNV(TransformFeedbackHandle[] ids)
            {
                int n = (int)(ids.Length);
                fixed (TransformFeedbackHandle* ids_ptr = ids)
                {
                    DeleteTransformFeedbacksNV(n, ids_ptr);
                }
            }
            public static unsafe void DeleteTransformFeedbacksNV(int n, in TransformFeedbackHandle ids)
            {
                fixed (TransformFeedbackHandle* ids_ptr = &ids)
                {
                    DeleteTransformFeedbacksNV(n, ids_ptr);
                }
            }
            public static unsafe void GenTransformFeedbacksNV(Span<TransformFeedbackHandle> ids)
            {
                int n = (int)(ids.Length);
                fixed (TransformFeedbackHandle* ids_ptr = ids)
                {
                    GenTransformFeedbacksNV(n, ids_ptr);
                }
            }
            public static unsafe void GenTransformFeedbacksNV(TransformFeedbackHandle[] ids)
            {
                int n = (int)(ids.Length);
                fixed (TransformFeedbackHandle* ids_ptr = ids)
                {
                    GenTransformFeedbacksNV(n, ids_ptr);
                }
            }
            public static unsafe void GenTransformFeedbacksNV(int n, ref TransformFeedbackHandle ids)
            {
                fixed (TransformFeedbackHandle* ids_ptr = &ids)
                {
                    GenTransformFeedbacksNV(n, ids_ptr);
                }
            }
            public static unsafe void VDPAUInitNV(IntPtr vdpDevice, IntPtr getProcAddress)
            {
                void* vdpDevice_vptr = (void*)vdpDevice;
                void* getProcAddress_vptr = (void*)getProcAddress;
                VDPAUInitNV(vdpDevice_vptr, getProcAddress_vptr);
            }
            public static unsafe void VDPAUInitNV<T1, T2>(in T1 vdpDevice, in T2 getProcAddress)
                where T1 : unmanaged
                where T2 : unmanaged
            {
                fixed (void* vdpDevice_ptr = &vdpDevice)
                fixed (void* getProcAddress_ptr = &getProcAddress)
                {
                    VDPAUInitNV(vdpDevice_ptr, getProcAddress_ptr);
                }
            }
            public static unsafe IntPtr VDPAURegisterVideoSurfaceNV(IntPtr vdpSurface, All target, ReadOnlySpan<uint> textureNames)
            {
                IntPtr returnValue;
                int numTextureNames = (int)(textureNames.Length);
                fixed (uint* textureNames_ptr = textureNames)
                {
                    void* vdpSurface_vptr = (void*)vdpSurface;
                    returnValue = VDPAURegisterVideoSurfaceNV(vdpSurface_vptr, target, numTextureNames, textureNames_ptr);
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterVideoSurfaceNV(IntPtr vdpSurface, All target, uint[] textureNames)
            {
                IntPtr returnValue;
                int numTextureNames = (int)(textureNames.Length);
                fixed (uint* textureNames_ptr = textureNames)
                {
                    void* vdpSurface_vptr = (void*)vdpSurface;
                    returnValue = VDPAURegisterVideoSurfaceNV(vdpSurface_vptr, target, numTextureNames, textureNames_ptr);
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterVideoSurfaceNV(IntPtr vdpSurface, All target, int numTextureNames, in uint textureNames)
            {
                IntPtr returnValue;
                fixed (uint* textureNames_ptr = &textureNames)
                {
                    void* vdpSurface_vptr = (void*)vdpSurface;
                    returnValue = VDPAURegisterVideoSurfaceNV(vdpSurface_vptr, target, numTextureNames, textureNames_ptr);
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterVideoSurfaceNV<T1>(in T1 vdpSurface, All target, ReadOnlySpan<uint> textureNames)
                where T1 : unmanaged
            {
                IntPtr returnValue;
                fixed (void* vdpSurface_ptr = &vdpSurface)
                {
                    int numTextureNames = (int)(textureNames.Length);
                    fixed (uint* textureNames_ptr = textureNames)
                    {
                        returnValue = VDPAURegisterVideoSurfaceNV(vdpSurface_ptr, target, numTextureNames, textureNames_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterVideoSurfaceNV<T1>(in T1 vdpSurface, All target, uint[] textureNames)
                where T1 : unmanaged
            {
                IntPtr returnValue;
                fixed (void* vdpSurface_ptr = &vdpSurface)
                {
                    int numTextureNames = (int)(textureNames.Length);
                    fixed (uint* textureNames_ptr = textureNames)
                    {
                        returnValue = VDPAURegisterVideoSurfaceNV(vdpSurface_ptr, target, numTextureNames, textureNames_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterVideoSurfaceNV<T1>(in T1 vdpSurface, All target, int numTextureNames, in uint textureNames)
                where T1 : unmanaged
            {
                IntPtr returnValue;
                fixed (void* vdpSurface_ptr = &vdpSurface)
                fixed (uint* textureNames_ptr = &textureNames)
                {
                    returnValue = VDPAURegisterVideoSurfaceNV(vdpSurface_ptr, target, numTextureNames, textureNames_ptr);
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterOutputSurfaceNV(IntPtr vdpSurface, All target, ReadOnlySpan<uint> textureNames)
            {
                IntPtr returnValue;
                int numTextureNames = (int)(textureNames.Length);
                fixed (uint* textureNames_ptr = textureNames)
                {
                    void* vdpSurface_vptr = (void*)vdpSurface;
                    returnValue = VDPAURegisterOutputSurfaceNV(vdpSurface_vptr, target, numTextureNames, textureNames_ptr);
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterOutputSurfaceNV(IntPtr vdpSurface, All target, uint[] textureNames)
            {
                IntPtr returnValue;
                int numTextureNames = (int)(textureNames.Length);
                fixed (uint* textureNames_ptr = textureNames)
                {
                    void* vdpSurface_vptr = (void*)vdpSurface;
                    returnValue = VDPAURegisterOutputSurfaceNV(vdpSurface_vptr, target, numTextureNames, textureNames_ptr);
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterOutputSurfaceNV(IntPtr vdpSurface, All target, int numTextureNames, in uint textureNames)
            {
                IntPtr returnValue;
                fixed (uint* textureNames_ptr = &textureNames)
                {
                    void* vdpSurface_vptr = (void*)vdpSurface;
                    returnValue = VDPAURegisterOutputSurfaceNV(vdpSurface_vptr, target, numTextureNames, textureNames_ptr);
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterOutputSurfaceNV<T1>(in T1 vdpSurface, All target, ReadOnlySpan<uint> textureNames)
                where T1 : unmanaged
            {
                IntPtr returnValue;
                fixed (void* vdpSurface_ptr = &vdpSurface)
                {
                    int numTextureNames = (int)(textureNames.Length);
                    fixed (uint* textureNames_ptr = textureNames)
                    {
                        returnValue = VDPAURegisterOutputSurfaceNV(vdpSurface_ptr, target, numTextureNames, textureNames_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterOutputSurfaceNV<T1>(in T1 vdpSurface, All target, uint[] textureNames)
                where T1 : unmanaged
            {
                IntPtr returnValue;
                fixed (void* vdpSurface_ptr = &vdpSurface)
                {
                    int numTextureNames = (int)(textureNames.Length);
                    fixed (uint* textureNames_ptr = textureNames)
                    {
                        returnValue = VDPAURegisterOutputSurfaceNV(vdpSurface_ptr, target, numTextureNames, textureNames_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterOutputSurfaceNV<T1>(in T1 vdpSurface, All target, int numTextureNames, in uint textureNames)
                where T1 : unmanaged
            {
                IntPtr returnValue;
                fixed (void* vdpSurface_ptr = &vdpSurface)
                fixed (uint* textureNames_ptr = &textureNames)
                {
                    returnValue = VDPAURegisterOutputSurfaceNV(vdpSurface_ptr, target, numTextureNames, textureNames_ptr);
                }
                return returnValue;
            }
            public static unsafe void VDPAUGetSurfaceivNV(IntPtr surface, All pname, ref int length, Span<int> values)
            {
                fixed (int* length_ptr = &length)
                {
                    int count = (int)(values.Length);
                    fixed (int* values_ptr = values)
                    {
                        VDPAUGetSurfaceivNV(surface, pname, count, length_ptr, values_ptr);
                    }
                }
            }
            public static unsafe void VDPAUGetSurfaceivNV(IntPtr surface, All pname, ref int length, int[] values)
            {
                fixed (int* length_ptr = &length)
                {
                    int count = (int)(values.Length);
                    fixed (int* values_ptr = values)
                    {
                        VDPAUGetSurfaceivNV(surface, pname, count, length_ptr, values_ptr);
                    }
                }
            }
            public static unsafe void VDPAUGetSurfaceivNV(IntPtr surface, All pname, int count, ref int length, ref int values)
            {
                fixed (int* length_ptr = &length)
                fixed (int* values_ptr = &values)
                {
                    VDPAUGetSurfaceivNV(surface, pname, count, length_ptr, values_ptr);
                }
            }
            public static unsafe void VDPAUMapSurfacesNV(ReadOnlySpan<IntPtr> surfaces)
            {
                int numSurfaces = (int)(surfaces.Length);
                fixed (IntPtr* surfaces_ptr = surfaces)
                {
                    VDPAUMapSurfacesNV(numSurfaces, surfaces_ptr);
                }
            }
            public static unsafe void VDPAUMapSurfacesNV(IntPtr[] surfaces)
            {
                int numSurfaces = (int)(surfaces.Length);
                fixed (IntPtr* surfaces_ptr = surfaces)
                {
                    VDPAUMapSurfacesNV(numSurfaces, surfaces_ptr);
                }
            }
            public static unsafe void VDPAUMapSurfacesNV(int numSurfaces, in IntPtr surfaces)
            {
                fixed (IntPtr* surfaces_ptr = &surfaces)
                {
                    VDPAUMapSurfacesNV(numSurfaces, surfaces_ptr);
                }
            }
            public static unsafe void VDPAUUnmapSurfacesNV(ReadOnlySpan<IntPtr> surfaces)
            {
                int numSurface = (int)(surfaces.Length);
                fixed (IntPtr* surfaces_ptr = surfaces)
                {
                    VDPAUUnmapSurfacesNV(numSurface, surfaces_ptr);
                }
            }
            public static unsafe void VDPAUUnmapSurfacesNV(IntPtr[] surfaces)
            {
                int numSurface = (int)(surfaces.Length);
                fixed (IntPtr* surfaces_ptr = surfaces)
                {
                    VDPAUUnmapSurfacesNV(numSurface, surfaces_ptr);
                }
            }
            public static unsafe void VDPAUUnmapSurfacesNV(int numSurface, in IntPtr surfaces)
            {
                fixed (IntPtr* surfaces_ptr = &surfaces)
                {
                    VDPAUUnmapSurfacesNV(numSurface, surfaces_ptr);
                }
            }
            public static unsafe IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV(IntPtr vdpSurface, All target, ReadOnlySpan<uint> textureNames, bool isFrameStructure)
            {
                IntPtr returnValue;
                int numTextureNames = (int)(textureNames.Length);
                fixed (uint* textureNames_ptr = textureNames)
                {
                    void* vdpSurface_vptr = (void*)vdpSurface;
                    byte isFrameStructure_byte = (byte)(isFrameStructure ? 1 : 0);
                    returnValue = VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface_vptr, target, numTextureNames, textureNames_ptr, isFrameStructure_byte);
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV(IntPtr vdpSurface, All target, uint[] textureNames, bool isFrameStructure)
            {
                IntPtr returnValue;
                int numTextureNames = (int)(textureNames.Length);
                fixed (uint* textureNames_ptr = textureNames)
                {
                    void* vdpSurface_vptr = (void*)vdpSurface;
                    byte isFrameStructure_byte = (byte)(isFrameStructure ? 1 : 0);
                    returnValue = VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface_vptr, target, numTextureNames, textureNames_ptr, isFrameStructure_byte);
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV(IntPtr vdpSurface, All target, int numTextureNames, in uint textureNames, bool isFrameStructure)
            {
                IntPtr returnValue;
                fixed (uint* textureNames_ptr = &textureNames)
                {
                    void* vdpSurface_vptr = (void*)vdpSurface;
                    byte isFrameStructure_byte = (byte)(isFrameStructure ? 1 : 0);
                    returnValue = VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface_vptr, target, numTextureNames, textureNames_ptr, isFrameStructure_byte);
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV<T1>(in T1 vdpSurface, All target, ReadOnlySpan<uint> textureNames, bool isFrameStructure)
                where T1 : unmanaged
            {
                IntPtr returnValue;
                fixed (void* vdpSurface_ptr = &vdpSurface)
                {
                    int numTextureNames = (int)(textureNames.Length);
                    fixed (uint* textureNames_ptr = textureNames)
                    {
                        byte isFrameStructure_byte = (byte)(isFrameStructure ? 1 : 0);
                        returnValue = VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface_ptr, target, numTextureNames, textureNames_ptr, isFrameStructure_byte);
                    }
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV<T1>(in T1 vdpSurface, All target, uint[] textureNames, bool isFrameStructure)
                where T1 : unmanaged
            {
                IntPtr returnValue;
                fixed (void* vdpSurface_ptr = &vdpSurface)
                {
                    int numTextureNames = (int)(textureNames.Length);
                    fixed (uint* textureNames_ptr = textureNames)
                    {
                        byte isFrameStructure_byte = (byte)(isFrameStructure ? 1 : 0);
                        returnValue = VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface_ptr, target, numTextureNames, textureNames_ptr, isFrameStructure_byte);
                    }
                }
                return returnValue;
            }
            public static unsafe IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV<T1>(in T1 vdpSurface, All target, int numTextureNames, in uint textureNames, bool isFrameStructure)
                where T1 : unmanaged
            {
                IntPtr returnValue;
                fixed (void* vdpSurface_ptr = &vdpSurface)
                fixed (uint* textureNames_ptr = &textureNames)
                {
                    byte isFrameStructure_byte = (byte)(isFrameStructure ? 1 : 0);
                    returnValue = VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface_ptr, target, numTextureNames, textureNames_ptr, isFrameStructure_byte);
                }
                return returnValue;
            }
            public static unsafe void VertexArrayRangeNV(int length, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                VertexArrayRangeNV(length, pointer_vptr);
            }
            public static unsafe void VertexArrayRangeNV<T1>(int length, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    VertexArrayRangeNV(length, pointer_ptr);
                }
            }
            public static unsafe void VertexArrayRangeNV<T1>(int length, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    VertexArrayRangeNV(length, pointer_ptr);
                }
            }
            public static unsafe void VertexArrayRangeNV<T1>(int length, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    VertexArrayRangeNV(length, pointer_ptr);
                }
            }
            public static unsafe void VertexAttribL1i64vNV(uint index, ReadOnlySpan<long> v)
            {
                fixed (long* v_ptr = v)
                {
                    VertexAttribL1i64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL1i64vNV(uint index, long[] v)
            {
                fixed (long* v_ptr = v)
                {
                    VertexAttribL1i64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL1i64vNV(uint index, in long v)
            {
                fixed (long* v_ptr = &v)
                {
                    VertexAttribL1i64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL2i64vNV(uint index, ReadOnlySpan<long> v)
            {
                fixed (long* v_ptr = v)
                {
                    VertexAttribL2i64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL2i64vNV(uint index, long[] v)
            {
                fixed (long* v_ptr = v)
                {
                    VertexAttribL2i64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL2i64vNV(uint index, in long v)
            {
                fixed (long* v_ptr = &v)
                {
                    VertexAttribL2i64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL3i64vNV(uint index, ReadOnlySpan<long> v)
            {
                fixed (long* v_ptr = v)
                {
                    VertexAttribL3i64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL3i64vNV(uint index, long[] v)
            {
                fixed (long* v_ptr = v)
                {
                    VertexAttribL3i64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL3i64vNV(uint index, in long v)
            {
                fixed (long* v_ptr = &v)
                {
                    VertexAttribL3i64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL4i64vNV(uint index, ReadOnlySpan<long> v)
            {
                fixed (long* v_ptr = v)
                {
                    VertexAttribL4i64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL4i64vNV(uint index, long[] v)
            {
                fixed (long* v_ptr = v)
                {
                    VertexAttribL4i64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL4i64vNV(uint index, in long v)
            {
                fixed (long* v_ptr = &v)
                {
                    VertexAttribL4i64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL1ui64vNV(uint index, ReadOnlySpan<ulong> v)
            {
                fixed (ulong* v_ptr = v)
                {
                    VertexAttribL1ui64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL1ui64vNV(uint index, ulong[] v)
            {
                fixed (ulong* v_ptr = v)
                {
                    VertexAttribL1ui64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL1ui64vNV(uint index, in ulong v)
            {
                fixed (ulong* v_ptr = &v)
                {
                    VertexAttribL1ui64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL2ui64vNV(uint index, ReadOnlySpan<ulong> v)
            {
                fixed (ulong* v_ptr = v)
                {
                    VertexAttribL2ui64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL2ui64vNV(uint index, ulong[] v)
            {
                fixed (ulong* v_ptr = v)
                {
                    VertexAttribL2ui64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL2ui64vNV(uint index, in ulong v)
            {
                fixed (ulong* v_ptr = &v)
                {
                    VertexAttribL2ui64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL3ui64vNV(uint index, ReadOnlySpan<ulong> v)
            {
                fixed (ulong* v_ptr = v)
                {
                    VertexAttribL3ui64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL3ui64vNV(uint index, ulong[] v)
            {
                fixed (ulong* v_ptr = v)
                {
                    VertexAttribL3ui64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL3ui64vNV(uint index, in ulong v)
            {
                fixed (ulong* v_ptr = &v)
                {
                    VertexAttribL3ui64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL4ui64vNV(uint index, ReadOnlySpan<ulong> v)
            {
                fixed (ulong* v_ptr = v)
                {
                    VertexAttribL4ui64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL4ui64vNV(uint index, ulong[] v)
            {
                fixed (ulong* v_ptr = v)
                {
                    VertexAttribL4ui64vNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribL4ui64vNV(uint index, in ulong v)
            {
                fixed (ulong* v_ptr = &v)
                {
                    VertexAttribL4ui64vNV(index, v_ptr);
                }
            }
            public static unsafe void GetVertexAttribLi64vNV(uint index, VertexAttribEnum pname, Span<long> parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetVertexAttribLi64vNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribLi64vNV(uint index, VertexAttribEnum pname, long[] parameters)
            {
                fixed (long* parameters_ptr = parameters)
                {
                    GetVertexAttribLi64vNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribLi64vNV(uint index, VertexAttribEnum pname, ref long parameters)
            {
                fixed (long* parameters_ptr = &parameters)
                {
                    GetVertexAttribLi64vNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribLui64vNV(uint index, VertexAttribEnum pname, Span<ulong> parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetVertexAttribLui64vNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribLui64vNV(uint index, VertexAttribEnum pname, ulong[] parameters)
            {
                fixed (ulong* parameters_ptr = parameters)
                {
                    GetVertexAttribLui64vNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribLui64vNV(uint index, VertexAttribEnum pname, ref ulong parameters)
            {
                fixed (ulong* parameters_ptr = &parameters)
                {
                    GetVertexAttribLui64vNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void VertexAttribFormatNV(uint index, int size, VertexAttribType type, bool normalized, int stride)
            {
                byte normalized_byte = (byte)(normalized ? 1 : 0);
                VertexAttribFormatNV(index, size, type, normalized_byte, stride);
            }
            public static unsafe void GetIntegerui64i_vNV(All value, uint index, Span<ulong> result)
            {
                fixed (ulong* result_ptr = result)
                {
                    GetIntegerui64i_vNV(value, index, result_ptr);
                }
            }
            public static unsafe void GetIntegerui64i_vNV(All value, uint index, ulong[] result)
            {
                fixed (ulong* result_ptr = result)
                {
                    GetIntegerui64i_vNV(value, index, result_ptr);
                }
            }
            public static unsafe void GetIntegerui64i_vNV(All value, uint index, ref ulong result)
            {
                fixed (ulong* result_ptr = &result)
                {
                    GetIntegerui64i_vNV(value, index, result_ptr);
                }
            }
            public static unsafe byte AreProgramsResidentNV(int n, ReadOnlySpan<ProgramHandle> programs, Span<byte> residences)
            {
                byte returnValue;
                fixed (ProgramHandle* programs_ptr = programs)
                {
                    fixed (byte* residences_ptr = residences)
                    {
                        returnValue = AreProgramsResidentNV(n, programs_ptr, residences_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe byte AreProgramsResidentNV(int n, ProgramHandle[] programs, byte[] residences)
            {
                byte returnValue;
                fixed (ProgramHandle* programs_ptr = programs)
                {
                    fixed (byte* residences_ptr = residences)
                    {
                        returnValue = AreProgramsResidentNV(n, programs_ptr, residences_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe byte AreProgramsResidentNV(int n, in ProgramHandle programs, ref byte residences)
            {
                byte returnValue;
                fixed (ProgramHandle* programs_ptr = &programs)
                fixed (byte* residences_ptr = &residences)
                {
                    returnValue = AreProgramsResidentNV(n, programs_ptr, residences_ptr);
                }
                return returnValue;
            }
            public static unsafe void DeleteProgramsNV(ReadOnlySpan<ProgramHandle> programs)
            {
                int n = (int)(programs.Length);
                fixed (ProgramHandle* programs_ptr = programs)
                {
                    DeleteProgramsNV(n, programs_ptr);
                }
            }
            public static unsafe void DeleteProgramsNV(ProgramHandle[] programs)
            {
                int n = (int)(programs.Length);
                fixed (ProgramHandle* programs_ptr = programs)
                {
                    DeleteProgramsNV(n, programs_ptr);
                }
            }
            public static unsafe void DeleteProgramsNV(int n, in ProgramHandle programs)
            {
                fixed (ProgramHandle* programs_ptr = &programs)
                {
                    DeleteProgramsNV(n, programs_ptr);
                }
            }
            public static unsafe void ExecuteProgramNV(VertexAttribEnumNV target, uint id, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ExecuteProgramNV(target, id, parameters_ptr);
                }
            }
            public static unsafe void ExecuteProgramNV(VertexAttribEnumNV target, uint id, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ExecuteProgramNV(target, id, parameters_ptr);
                }
            }
            public static unsafe void ExecuteProgramNV(VertexAttribEnumNV target, uint id, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    ExecuteProgramNV(target, id, parameters_ptr);
                }
            }
            public static unsafe void GenProgramsNV(Span<ProgramHandle> programs)
            {
                int n = (int)(programs.Length);
                fixed (ProgramHandle* programs_ptr = programs)
                {
                    GenProgramsNV(n, programs_ptr);
                }
            }
            public static unsafe void GenProgramsNV(ProgramHandle[] programs)
            {
                int n = (int)(programs.Length);
                fixed (ProgramHandle* programs_ptr = programs)
                {
                    GenProgramsNV(n, programs_ptr);
                }
            }
            public static unsafe void GenProgramsNV(int n, ref ProgramHandle programs)
            {
                fixed (ProgramHandle* programs_ptr = &programs)
                {
                    GenProgramsNV(n, programs_ptr);
                }
            }
            public static unsafe void GetProgramParameterdvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, Span<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetProgramParameterdvNV(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramParameterdvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetProgramParameterdvNV(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramParameterdvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    GetProgramParameterdvNV(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramParameterfvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetProgramParameterfvNV(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramParameterfvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetProgramParameterfvNV(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramParameterfvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetProgramParameterfvNV(target, index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramivNV(ProgramHandle id, VertexAttribEnumNV pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetProgramivNV(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramivNV(ProgramHandle id, VertexAttribEnumNV pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetProgramivNV(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramivNV(ProgramHandle id, VertexAttribEnumNV pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetProgramivNV(id, pname, parameters_ptr);
                }
            }
            public static unsafe void GetProgramStringNV(ProgramHandle id, VertexAttribEnumNV pname, Span<byte> program)
            {
                fixed (byte* program_ptr = program)
                {
                    GetProgramStringNV(id, pname, program_ptr);
                }
            }
            public static unsafe void GetProgramStringNV(ProgramHandle id, VertexAttribEnumNV pname, byte[] program)
            {
                fixed (byte* program_ptr = program)
                {
                    GetProgramStringNV(id, pname, program_ptr);
                }
            }
            public static unsafe void GetProgramStringNV(ProgramHandle id, VertexAttribEnumNV pname, ref byte program)
            {
                fixed (byte* program_ptr = &program)
                {
                    GetProgramStringNV(id, pname, program_ptr);
                }
            }
            public static unsafe void GetTrackMatrixivNV(VertexAttribEnumNV target, uint address, VertexAttribEnumNV pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTrackMatrixivNV(target, address, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTrackMatrixivNV(VertexAttribEnumNV target, uint address, VertexAttribEnumNV pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTrackMatrixivNV(target, address, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTrackMatrixivNV(VertexAttribEnumNV target, uint address, VertexAttribEnumNV pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetTrackMatrixivNV(target, address, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribdvNV(uint index, VertexAttribEnumNV pname, Span<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetVertexAttribdvNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribdvNV(uint index, VertexAttribEnumNV pname, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetVertexAttribdvNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribdvNV(uint index, VertexAttribEnumNV pname, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    GetVertexAttribdvNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribfvNV(uint index, VertexAttribEnumNV pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetVertexAttribfvNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribfvNV(uint index, VertexAttribEnumNV pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetVertexAttribfvNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribfvNV(uint index, VertexAttribEnumNV pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetVertexAttribfvNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribivNV(uint index, VertexAttribEnumNV pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVertexAttribivNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribivNV(uint index, VertexAttribEnumNV pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVertexAttribivNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribivNV(uint index, VertexAttribEnumNV pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetVertexAttribivNV(index, pname, parameters_ptr);
                }
            }
            public static unsafe void LoadProgramNV(VertexAttribEnumNV target, uint id, ReadOnlySpan<byte> program)
            {
                int len = (int)(program.Length);
                fixed (byte* program_ptr = program)
                {
                    LoadProgramNV(target, id, len, program_ptr);
                }
            }
            public static unsafe void LoadProgramNV(VertexAttribEnumNV target, uint id, byte[] program)
            {
                int len = (int)(program.Length);
                fixed (byte* program_ptr = program)
                {
                    LoadProgramNV(target, id, len, program_ptr);
                }
            }
            public static unsafe void LoadProgramNV(VertexAttribEnumNV target, uint id, int len, in byte program)
            {
                fixed (byte* program_ptr = &program)
                {
                    LoadProgramNV(target, id, len, program_ptr);
                }
            }
            public static unsafe void ProgramParameter4dvNV(VertexAttribEnumNV target, uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    ProgramParameter4dvNV(target, index, v_ptr);
                }
            }
            public static unsafe void ProgramParameter4dvNV(VertexAttribEnumNV target, uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    ProgramParameter4dvNV(target, index, v_ptr);
                }
            }
            public static unsafe void ProgramParameter4dvNV(VertexAttribEnumNV target, uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    ProgramParameter4dvNV(target, index, v_ptr);
                }
            }
            public static unsafe void ProgramParameter4fvNV(VertexAttribEnumNV target, uint index, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    ProgramParameter4fvNV(target, index, v_ptr);
                }
            }
            public static unsafe void ProgramParameter4fvNV(VertexAttribEnumNV target, uint index, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    ProgramParameter4fvNV(target, index, v_ptr);
                }
            }
            public static unsafe void ProgramParameter4fvNV(VertexAttribEnumNV target, uint index, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    ProgramParameter4fvNV(target, index, v_ptr);
                }
            }
            public static unsafe void ProgramParameters4dvNV(VertexAttribEnumNV target, uint index, ReadOnlySpan<double> v)
            {
                int count = (int)(v.Length / 4);
                fixed (double* v_ptr = v)
                {
                    ProgramParameters4dvNV(target, index, count, v_ptr);
                }
            }
            public static unsafe void ProgramParameters4dvNV(VertexAttribEnumNV target, uint index, double[] v)
            {
                int count = (int)(v.Length / 4);
                fixed (double* v_ptr = v)
                {
                    ProgramParameters4dvNV(target, index, count, v_ptr);
                }
            }
            public static unsafe void ProgramParameters4dvNV(VertexAttribEnumNV target, uint index, int count, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    ProgramParameters4dvNV(target, index, count, v_ptr);
                }
            }
            public static unsafe void ProgramParameters4fvNV(VertexAttribEnumNV target, uint index, ReadOnlySpan<float> v)
            {
                int count = (int)(v.Length / 4);
                fixed (float* v_ptr = v)
                {
                    ProgramParameters4fvNV(target, index, count, v_ptr);
                }
            }
            public static unsafe void ProgramParameters4fvNV(VertexAttribEnumNV target, uint index, float[] v)
            {
                int count = (int)(v.Length / 4);
                fixed (float* v_ptr = v)
                {
                    ProgramParameters4fvNV(target, index, count, v_ptr);
                }
            }
            public static unsafe void ProgramParameters4fvNV(VertexAttribEnumNV target, uint index, int count, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    ProgramParameters4fvNV(target, index, count, v_ptr);
                }
            }
            public static unsafe void RequestResidentProgramsNV(ReadOnlySpan<ProgramHandle> programs)
            {
                int n = (int)(programs.Length);
                fixed (ProgramHandle* programs_ptr = programs)
                {
                    RequestResidentProgramsNV(n, programs_ptr);
                }
            }
            public static unsafe void RequestResidentProgramsNV(ProgramHandle[] programs)
            {
                int n = (int)(programs.Length);
                fixed (ProgramHandle* programs_ptr = programs)
                {
                    RequestResidentProgramsNV(n, programs_ptr);
                }
            }
            public static unsafe void RequestResidentProgramsNV(int n, in ProgramHandle programs)
            {
                fixed (ProgramHandle* programs_ptr = &programs)
                {
                    RequestResidentProgramsNV(n, programs_ptr);
                }
            }
            public static unsafe void VertexAttribPointerNV(uint index, int fsize, VertexAttribEnumNV type, int stride, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                VertexAttribPointerNV(index, fsize, type, stride, pointer_vptr);
            }
            public static unsafe void VertexAttribPointerNV<T1>(uint index, int fsize, VertexAttribEnumNV type, int stride, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    VertexAttribPointerNV(index, fsize, type, stride, pointer_ptr);
                }
            }
            public static unsafe void VertexAttribPointerNV<T1>(uint index, int fsize, VertexAttribEnumNV type, int stride, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    VertexAttribPointerNV(index, fsize, type, stride, pointer_ptr);
                }
            }
            public static unsafe void VertexAttribPointerNV<T1>(uint index, int fsize, VertexAttribEnumNV type, int stride, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    VertexAttribPointerNV(index, fsize, type, stride, pointer_ptr);
                }
            }
            public static unsafe void VertexAttrib1dvNV(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib1dvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1dvNV(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib1dvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1dvNV(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttrib1dvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1fvNV(uint index, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib1fvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1fvNV(uint index, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib1fvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1fvNV(uint index, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    VertexAttrib1fvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1svNV(uint index, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib1svNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1svNV(uint index, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib1svNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib1svNV(uint index, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttrib1svNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2dvNV(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib2dvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2dvNV(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib2dvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2dvNV(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttrib2dvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2fvNV(uint index, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib2fvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2fvNV(uint index, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib2fvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2fvNV(uint index, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    VertexAttrib2fvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2svNV(uint index, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib2svNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2svNV(uint index, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib2svNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib2svNV(uint index, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttrib2svNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3dvNV(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib3dvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3dvNV(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib3dvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3dvNV(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttrib3dvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3fvNV(uint index, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib3fvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3fvNV(uint index, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib3fvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3fvNV(uint index, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    VertexAttrib3fvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3svNV(uint index, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib3svNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3svNV(uint index, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib3svNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib3svNV(uint index, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttrib3svNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4dvNV(uint index, ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib4dvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4dvNV(uint index, double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    VertexAttrib4dvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4dvNV(uint index, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttrib4dvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4fvNV(uint index, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib4fvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4fvNV(uint index, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    VertexAttrib4fvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4fvNV(uint index, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    VertexAttrib4fvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4svNV(uint index, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib4svNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4svNV(uint index, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttrib4svNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4svNV(uint index, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttrib4svNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4ubvNV(uint index, ReadOnlySpan<byte> v)
            {
                fixed (byte* v_ptr = v)
                {
                    VertexAttrib4ubvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4ubvNV(uint index, byte[] v)
            {
                fixed (byte* v_ptr = v)
                {
                    VertexAttrib4ubvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttrib4ubvNV(uint index, in byte v)
            {
                fixed (byte* v_ptr = &v)
                {
                    VertexAttrib4ubvNV(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribs1dvNV(uint index, ReadOnlySpan<double> v)
            {
                int count = (int)(v.Length);
                fixed (double* v_ptr = v)
                {
                    VertexAttribs1dvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs1dvNV(uint index, double[] v)
            {
                int count = (int)(v.Length);
                fixed (double* v_ptr = v)
                {
                    VertexAttribs1dvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs1dvNV(uint index, int count, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttribs1dvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs1fvNV(uint index, ReadOnlySpan<float> v)
            {
                int count = (int)(v.Length);
                fixed (float* v_ptr = v)
                {
                    VertexAttribs1fvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs1fvNV(uint index, float[] v)
            {
                int count = (int)(v.Length);
                fixed (float* v_ptr = v)
                {
                    VertexAttribs1fvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs1fvNV(uint index, int count, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    VertexAttribs1fvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs1svNV(uint index, ReadOnlySpan<short> v)
            {
                int count = (int)(v.Length);
                fixed (short* v_ptr = v)
                {
                    VertexAttribs1svNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs1svNV(uint index, short[] v)
            {
                int count = (int)(v.Length);
                fixed (short* v_ptr = v)
                {
                    VertexAttribs1svNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs1svNV(uint index, int count, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttribs1svNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs2dvNV(uint index, ReadOnlySpan<double> v)
            {
                int count = (int)(v.Length / 2);
                fixed (double* v_ptr = v)
                {
                    VertexAttribs2dvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs2dvNV(uint index, double[] v)
            {
                int count = (int)(v.Length / 2);
                fixed (double* v_ptr = v)
                {
                    VertexAttribs2dvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs2dvNV(uint index, int count, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttribs2dvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs2fvNV(uint index, ReadOnlySpan<float> v)
            {
                int count = (int)(v.Length / 2);
                fixed (float* v_ptr = v)
                {
                    VertexAttribs2fvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs2fvNV(uint index, float[] v)
            {
                int count = (int)(v.Length / 2);
                fixed (float* v_ptr = v)
                {
                    VertexAttribs2fvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs2fvNV(uint index, int count, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    VertexAttribs2fvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs2svNV(uint index, ReadOnlySpan<short> v)
            {
                int count = (int)(v.Length / 2);
                fixed (short* v_ptr = v)
                {
                    VertexAttribs2svNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs2svNV(uint index, short[] v)
            {
                int count = (int)(v.Length / 2);
                fixed (short* v_ptr = v)
                {
                    VertexAttribs2svNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs2svNV(uint index, int count, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttribs2svNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs3dvNV(uint index, ReadOnlySpan<double> v)
            {
                int count = (int)(v.Length / 3);
                fixed (double* v_ptr = v)
                {
                    VertexAttribs3dvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs3dvNV(uint index, double[] v)
            {
                int count = (int)(v.Length / 3);
                fixed (double* v_ptr = v)
                {
                    VertexAttribs3dvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs3dvNV(uint index, int count, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttribs3dvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs3fvNV(uint index, ReadOnlySpan<float> v)
            {
                int count = (int)(v.Length / 3);
                fixed (float* v_ptr = v)
                {
                    VertexAttribs3fvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs3fvNV(uint index, float[] v)
            {
                int count = (int)(v.Length / 3);
                fixed (float* v_ptr = v)
                {
                    VertexAttribs3fvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs3fvNV(uint index, int count, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    VertexAttribs3fvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs3svNV(uint index, ReadOnlySpan<short> v)
            {
                int count = (int)(v.Length / 3);
                fixed (short* v_ptr = v)
                {
                    VertexAttribs3svNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs3svNV(uint index, short[] v)
            {
                int count = (int)(v.Length / 3);
                fixed (short* v_ptr = v)
                {
                    VertexAttribs3svNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs3svNV(uint index, int count, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttribs3svNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4dvNV(uint index, ReadOnlySpan<double> v)
            {
                int count = (int)(v.Length / 4);
                fixed (double* v_ptr = v)
                {
                    VertexAttribs4dvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4dvNV(uint index, double[] v)
            {
                int count = (int)(v.Length / 4);
                fixed (double* v_ptr = v)
                {
                    VertexAttribs4dvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4dvNV(uint index, int count, in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    VertexAttribs4dvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4fvNV(uint index, ReadOnlySpan<float> v)
            {
                int count = (int)(v.Length / 4);
                fixed (float* v_ptr = v)
                {
                    VertexAttribs4fvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4fvNV(uint index, float[] v)
            {
                int count = (int)(v.Length / 4);
                fixed (float* v_ptr = v)
                {
                    VertexAttribs4fvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4fvNV(uint index, int count, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    VertexAttribs4fvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4svNV(uint index, ReadOnlySpan<short> v)
            {
                int count = (int)(v.Length / 4);
                fixed (short* v_ptr = v)
                {
                    VertexAttribs4svNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4svNV(uint index, short[] v)
            {
                int count = (int)(v.Length / 4);
                fixed (short* v_ptr = v)
                {
                    VertexAttribs4svNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4svNV(uint index, int count, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttribs4svNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4ubvNV(uint index, ReadOnlySpan<byte> v)
            {
                int count = (int)(v.Length / 4);
                fixed (byte* v_ptr = v)
                {
                    VertexAttribs4ubvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4ubvNV(uint index, byte[] v)
            {
                int count = (int)(v.Length / 4);
                fixed (byte* v_ptr = v)
                {
                    VertexAttribs4ubvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribs4ubvNV(uint index, int count, in byte v)
            {
                fixed (byte* v_ptr = &v)
                {
                    VertexAttribs4ubvNV(index, count, v_ptr);
                }
            }
            public static unsafe void VertexAttribI1ivEXT(uint index, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI1ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI1ivEXT(uint index, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI1ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI1ivEXT(uint index, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    VertexAttribI1ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI2ivEXT(uint index, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI2ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI2ivEXT(uint index, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI2ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI2ivEXT(uint index, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    VertexAttribI2ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI3ivEXT(uint index, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI3ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI3ivEXT(uint index, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI3ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI3ivEXT(uint index, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    VertexAttribI3ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4ivEXT(uint index, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI4ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4ivEXT(uint index, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    VertexAttribI4ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4ivEXT(uint index, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    VertexAttribI4ivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI1uivEXT(uint index, ReadOnlySpan<uint> v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI1uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI1uivEXT(uint index, uint[] v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI1uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI1uivEXT(uint index, in uint v)
            {
                fixed (uint* v_ptr = &v)
                {
                    VertexAttribI1uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI2uivEXT(uint index, ReadOnlySpan<uint> v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI2uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI2uivEXT(uint index, uint[] v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI2uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI2uivEXT(uint index, in uint v)
            {
                fixed (uint* v_ptr = &v)
                {
                    VertexAttribI2uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI3uivEXT(uint index, ReadOnlySpan<uint> v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI3uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI3uivEXT(uint index, uint[] v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI3uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI3uivEXT(uint index, in uint v)
            {
                fixed (uint* v_ptr = &v)
                {
                    VertexAttribI3uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4uivEXT(uint index, ReadOnlySpan<uint> v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI4uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4uivEXT(uint index, uint[] v)
            {
                fixed (uint* v_ptr = v)
                {
                    VertexAttribI4uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4uivEXT(uint index, in uint v)
            {
                fixed (uint* v_ptr = &v)
                {
                    VertexAttribI4uivEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4bvEXT(uint index, ReadOnlySpan<sbyte> v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    VertexAttribI4bvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4bvEXT(uint index, sbyte[] v)
            {
                fixed (sbyte* v_ptr = v)
                {
                    VertexAttribI4bvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4bvEXT(uint index, in sbyte v)
            {
                fixed (sbyte* v_ptr = &v)
                {
                    VertexAttribI4bvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4svEXT(uint index, ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttribI4svEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4svEXT(uint index, short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    VertexAttribI4svEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4svEXT(uint index, in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    VertexAttribI4svEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4ubvEXT(uint index, ReadOnlySpan<byte> v)
            {
                fixed (byte* v_ptr = v)
                {
                    VertexAttribI4ubvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4ubvEXT(uint index, byte[] v)
            {
                fixed (byte* v_ptr = v)
                {
                    VertexAttribI4ubvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4ubvEXT(uint index, in byte v)
            {
                fixed (byte* v_ptr = &v)
                {
                    VertexAttribI4ubvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4usvEXT(uint index, ReadOnlySpan<ushort> v)
            {
                fixed (ushort* v_ptr = v)
                {
                    VertexAttribI4usvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4usvEXT(uint index, ushort[] v)
            {
                fixed (ushort* v_ptr = v)
                {
                    VertexAttribI4usvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribI4usvEXT(uint index, in ushort v)
            {
                fixed (ushort* v_ptr = &v)
                {
                    VertexAttribI4usvEXT(index, v_ptr);
                }
            }
            public static unsafe void VertexAttribIPointerEXT(uint index, int size, VertexAttribIType type, int stride, IntPtr pointer)
            {
                void* pointer_vptr = (void*)pointer;
                VertexAttribIPointerEXT(index, size, type, stride, pointer_vptr);
            }
            public static unsafe void VertexAttribIPointerEXT<T1>(uint index, int size, VertexAttribIType type, int stride, ReadOnlySpan<T1> pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    VertexAttribIPointerEXT(index, size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void VertexAttribIPointerEXT<T1>(uint index, int size, VertexAttribIType type, int stride, T1[] pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = pointer)
                {
                    VertexAttribIPointerEXT(index, size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void VertexAttribIPointerEXT<T1>(uint index, int size, VertexAttribIType type, int stride, in T1 pointer)
                where T1 : unmanaged
            {
                fixed (void* pointer_ptr = &pointer)
                {
                    VertexAttribIPointerEXT(index, size, type, stride, pointer_ptr);
                }
            }
            public static unsafe void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVertexAttribIivEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVertexAttribIivEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetVertexAttribIivEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, Span<uint> parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetVertexAttribIuivEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, uint[] parameters)
            {
                fixed (uint* parameters_ptr = parameters)
                {
                    GetVertexAttribIuivEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetVertexAttribIuivEXT(index, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoCaptureivNV(uint video_capture_slot, All pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVideoCaptureivNV(video_capture_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoCaptureivNV(uint video_capture_slot, All pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVideoCaptureivNV(video_capture_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoCaptureivNV(uint video_capture_slot, All pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetVideoCaptureivNV(video_capture_slot, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, All pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVideoCaptureStreamivNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, All pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetVideoCaptureStreamivNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, All pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetVideoCaptureStreamivNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, All pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, All pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, All pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, All pname, Span<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, All pname, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    GetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void GetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, All pname, ref double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    GetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe All VideoCaptureNV(uint video_capture_slot, ref uint sequence_num, ref ulong capture_time)
            {
                All returnValue;
                fixed (uint* sequence_num_ptr = &sequence_num)
                fixed (ulong* capture_time_ptr = &capture_time)
                {
                    returnValue = VideoCaptureNV(video_capture_slot, sequence_num_ptr, capture_time_ptr);
                }
                return returnValue;
            }
            public static unsafe void VideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, All pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    VideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void VideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, All pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    VideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void VideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, All pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    VideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void VideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, All pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    VideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void VideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, All pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    VideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void VideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, All pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    VideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void VideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, All pname, ReadOnlySpan<double> parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    VideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void VideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, All pname, double[] parameters)
            {
                fixed (double* parameters_ptr = parameters)
                {
                    VideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
            public static unsafe void VideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, All pname, in double parameters)
            {
                fixed (double* parameters_ptr = &parameters)
                {
                    VideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, parameters_ptr);
                }
            }
        }
        public static unsafe partial class GREMEDY
        {
            public static unsafe void StringMarkerGREMEDY(int len, IntPtr str)
            {
                void* str_vptr = (void*)str;
                StringMarkerGREMEDY(len, str_vptr);
            }
            public static unsafe void StringMarkerGREMEDY<T1>(ReadOnlySpan<T1> str)
                where T1 : unmanaged
            {
                int len = (int)(str.Length * sizeof(T1));
                fixed (void* str_ptr = str)
                {
                    StringMarkerGREMEDY(len, str_ptr);
                }
            }
            public static unsafe void StringMarkerGREMEDY<T1>(T1[] str)
                where T1 : unmanaged
            {
                int len = (int)(str.Length * sizeof(T1));
                fixed (void* str_ptr = str)
                {
                    StringMarkerGREMEDY(len, str_ptr);
                }
            }
            public static unsafe void StringMarkerGREMEDY<T1>(int len, in T1 str)
                where T1 : unmanaged
            {
                fixed (void* str_ptr = &str)
                {
                    StringMarkerGREMEDY(len, str_ptr);
                }
            }
        }
        public static unsafe partial class HP
        {
            public static unsafe void ImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ImageTransformParameterivHP(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ImageTransformParameterivHP(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    ImageTransformParameterivHP(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ImageTransformParameterfvHP(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ImageTransformParameterfvHP(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    ImageTransformParameterfvHP(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetImageTransformParameterivHP(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetImageTransformParameterivHP(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetImageTransformParameterivHP(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetImageTransformParameterfvHP(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetImageTransformParameterfvHP(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetImageTransformParameterfvHP(target, pname, parameters_ptr);
                }
            }
        }
        public static unsafe partial class IBM
        {
            public static unsafe void MultiModeDrawArraysIBM(ReadOnlySpan<PrimitiveType> mode, ReadOnlySpan<int> first, ReadOnlySpan<int> count, int primcount, int modestride)
            {
                fixed (PrimitiveType* mode_ptr = mode)
                {
                    fixed (int* first_ptr = first)
                    {
                        fixed (int* count_ptr = count)
                        {
                            MultiModeDrawArraysIBM(mode_ptr, first_ptr, count_ptr, primcount, modestride);
                        }
                    }
                }
            }
            public static unsafe void MultiModeDrawArraysIBM(PrimitiveType[] mode, int[] first, int[] count, int primcount, int modestride)
            {
                fixed (PrimitiveType* mode_ptr = mode)
                {
                    fixed (int* first_ptr = first)
                    {
                        fixed (int* count_ptr = count)
                        {
                            MultiModeDrawArraysIBM(mode_ptr, first_ptr, count_ptr, primcount, modestride);
                        }
                    }
                }
            }
            public static unsafe void MultiModeDrawArraysIBM(in PrimitiveType mode, in int first, in int count, int primcount, int modestride)
            {
                fixed (PrimitiveType* mode_ptr = &mode)
                fixed (int* first_ptr = &first)
                fixed (int* count_ptr = &count)
                {
                    MultiModeDrawArraysIBM(mode_ptr, first_ptr, count_ptr, primcount, modestride);
                }
            }
            public static unsafe void MultiModeDrawElementsIBM(ReadOnlySpan<PrimitiveType> mode, ReadOnlySpan<int> count, DrawElementsType type, void** indices, int primcount, int modestride)
            {
                fixed (PrimitiveType* mode_ptr = mode)
                {
                    fixed (int* count_ptr = count)
                    {
                        MultiModeDrawElementsIBM(mode_ptr, count_ptr, type, indices, primcount, modestride);
                    }
                }
            }
            public static unsafe void MultiModeDrawElementsIBM(PrimitiveType[] mode, int[] count, DrawElementsType type, void** indices, int primcount, int modestride)
            {
                fixed (PrimitiveType* mode_ptr = mode)
                {
                    fixed (int* count_ptr = count)
                    {
                        MultiModeDrawElementsIBM(mode_ptr, count_ptr, type, indices, primcount, modestride);
                    }
                }
            }
            public static unsafe void MultiModeDrawElementsIBM(in PrimitiveType mode, in int count, DrawElementsType type, void** indices, int primcount, int modestride)
            {
                fixed (PrimitiveType* mode_ptr = &mode)
                fixed (int* count_ptr = &count)
                {
                    MultiModeDrawElementsIBM(mode_ptr, count_ptr, type, indices, primcount, modestride);
                }
            }
        }
        public static unsafe partial class INGR
        {
        }
        public static unsafe partial class INTEL
        {
            public static unsafe void* MapTexture2DINTEL(TextureHandle texture, int level, All access, Span<int> stride, Span<All> layout)
            {
                void* returnValue;
                fixed (int* stride_ptr = stride)
                {
                    fixed (All* layout_ptr = layout)
                    {
                        returnValue = MapTexture2DINTEL(texture, level, access, stride_ptr, layout_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe void* MapTexture2DINTEL(TextureHandle texture, int level, All access, int[] stride, All[] layout)
            {
                void* returnValue;
                fixed (int* stride_ptr = stride)
                {
                    fixed (All* layout_ptr = layout)
                    {
                        returnValue = MapTexture2DINTEL(texture, level, access, stride_ptr, layout_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe void* MapTexture2DINTEL(TextureHandle texture, int level, All access, ref int stride, ref All layout)
            {
                void* returnValue;
                fixed (int* stride_ptr = &stride)
                fixed (All* layout_ptr = &layout)
                {
                    returnValue = MapTexture2DINTEL(texture, level, access, stride_ptr, layout_ptr);
                }
                return returnValue;
            }
            public static unsafe void CreatePerfQueryINTEL(uint queryId, ref uint queryHandle)
            {
                fixed (uint* queryHandle_ptr = &queryHandle)
                {
                    CreatePerfQueryINTEL(queryId, queryHandle_ptr);
                }
            }
            public static unsafe void GetFirstPerfQueryIdINTEL(ref uint queryId)
            {
                fixed (uint* queryId_ptr = &queryId)
                {
                    GetFirstPerfQueryIdINTEL(queryId_ptr);
                }
            }
            public static unsafe void GetNextPerfQueryIdINTEL(uint queryId, ref uint nextQueryId)
            {
                fixed (uint* nextQueryId_ptr = &nextQueryId)
                {
                    GetNextPerfQueryIdINTEL(queryId, nextQueryId_ptr);
                }
            }
            public static unsafe void GetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, out string counterName, uint counterDescLength, out string counterDesc, ref uint counterOffset, ref uint counterDataSize, ref uint counterTypeEnum, ref uint counterDataTypeEnum, ref ulong rawCounterMaxValue)
            {
                fixed (uint* counterOffset_ptr = &counterOffset)
                fixed (uint* counterDataSize_ptr = &counterDataSize)
                fixed (uint* counterTypeEnum_ptr = &counterTypeEnum)
                fixed (uint* counterDataTypeEnum_ptr = &counterDataTypeEnum)
                fixed (ulong* rawCounterMaxValue_ptr = &rawCounterMaxValue)
                {
                    var counterName_ptr = (byte*)Marshal.AllocCoTaskMem((int)counterNameLength);
                    var counterDesc_ptr = (byte*)Marshal.AllocCoTaskMem((int)counterDescLength);
                    GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName_ptr, counterDescLength, counterDesc_ptr, counterOffset_ptr, counterDataSize_ptr, counterTypeEnum_ptr, counterDataTypeEnum_ptr, rawCounterMaxValue_ptr);
                    counterDesc = Marshal.PtrToStringUTF8((IntPtr)counterDesc_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)counterDesc_ptr);
                    counterName = Marshal.PtrToStringUTF8((IntPtr)counterName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)counterName_ptr);
                }
            }
            public static unsafe void GetPerfQueryDataINTEL(uint queryHandle, uint flags, int dataSize, IntPtr data, ref uint bytesWritten)
            {
                fixed (uint* bytesWritten_ptr = &bytesWritten)
                {
                    void* data_vptr = (void*)data;
                    GetPerfQueryDataINTEL(queryHandle, flags, dataSize, data_vptr, bytesWritten_ptr);
                }
            }
            public static unsafe void GetPerfQueryDataINTEL<T1>(uint queryHandle, uint flags, int dataSize, ref T1 data, ref uint bytesWritten)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                fixed (uint* bytesWritten_ptr = &bytesWritten)
                {
                    GetPerfQueryDataINTEL(queryHandle, flags, dataSize, data_ptr, bytesWritten_ptr);
                }
            }
            public static unsafe void GetPerfQueryIdByNameINTEL(byte* queryName, ref uint queryId)
            {
                fixed (uint* queryId_ptr = &queryId)
                {
                    GetPerfQueryIdByNameINTEL(queryName, queryId_ptr);
                }
            }
            public static unsafe string GetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, ref uint dataSize, ref uint noCounters, ref uint noInstances, ref uint capsMask)
            {
                string queryName;
                fixed (uint* dataSize_ptr = &dataSize)
                fixed (uint* noCounters_ptr = &noCounters)
                fixed (uint* noInstances_ptr = &noInstances)
                fixed (uint* capsMask_ptr = &capsMask)
                {
                    var queryName_ptr = (byte*)Marshal.AllocCoTaskMem((int)queryNameLength);
                    GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName_ptr, dataSize_ptr, noCounters_ptr, noInstances_ptr, capsMask_ptr);
                    queryName = Marshal.PtrToStringUTF8((IntPtr)queryName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)queryName_ptr);
                }
                return queryName;
            }
            public static unsafe void GetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, out string queryName, ref uint dataSize, ref uint noCounters, ref uint noInstances, ref uint capsMask)
            {
                fixed (uint* dataSize_ptr = &dataSize)
                fixed (uint* noCounters_ptr = &noCounters)
                fixed (uint* noInstances_ptr = &noInstances)
                fixed (uint* capsMask_ptr = &capsMask)
                {
                    var queryName_ptr = (byte*)Marshal.AllocCoTaskMem((int)queryNameLength);
                    GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName_ptr, dataSize_ptr, noCounters_ptr, noInstances_ptr, capsMask_ptr);
                    queryName = Marshal.PtrToStringUTF8((IntPtr)queryName_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)queryName_ptr);
                }
            }
        }
        public static unsafe partial class KHR
        {
            public static unsafe void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, ReadOnlySpan<uint> ids, bool enabled)
            {
                int count = (int)(ids.Length);
                fixed (uint* ids_ptr = ids)
                {
                    byte enabled_byte = (byte)(enabled ? 1 : 0);
                    DebugMessageControl(source, type, severity, count, ids_ptr, enabled_byte);
                }
            }
            public static unsafe void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, uint[] ids, bool enabled)
            {
                int count = (int)(ids.Length);
                fixed (uint* ids_ptr = ids)
                {
                    byte enabled_byte = (byte)(enabled ? 1 : 0);
                    DebugMessageControl(source, type, severity, count, ids_ptr, enabled_byte);
                }
            }
            public static unsafe void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, in uint ids, bool enabled)
            {
                fixed (uint* ids_ptr = &ids)
                {
                    byte enabled_byte = (byte)(enabled ? 1 : 0);
                    DebugMessageControl(source, type, severity, count, ids_ptr, enabled_byte);
                }
            }
            public static unsafe void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, string buf)
            {
                byte* buf_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(buf);
                DebugMessageInsert(source, type, id, severity, length, buf_ptr);
                Marshal.FreeCoTaskMem((IntPtr)buf_ptr);
            }
            public static unsafe void DebugMessageCallback(GLDebugProc callback, IntPtr userParam)
            {
                void* userParam_vptr = (void*)userParam;
                IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                DebugMessageCallback(callback_ptr, userParam_vptr);
            }
            public static unsafe void DebugMessageCallback<T1>(GLDebugProc callback, in T1 userParam)
                where T1 : unmanaged
            {
                fixed (void* userParam_ptr = &userParam)
                {
                    IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                    DebugMessageCallback(callback_ptr, userParam_ptr);
                }
            }
            public static unsafe uint GetDebugMessageLog(uint count, int bufSize, Span<DebugSource> sources, Span<DebugType> types, Span<uint> ids, Span<DebugSeverity> severities, Span<int> lengths, out string messageLog)
            {
                uint returnValue;
                fixed (DebugSource* sources_ptr = sources)
                {
                    fixed (DebugType* types_ptr = types)
                    {
                        fixed (uint* ids_ptr = ids)
                        {
                            fixed (DebugSeverity* severities_ptr = severities)
                            {
                                fixed (int* lengths_ptr = lengths)
                                {
                                    var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                    returnValue = GetDebugMessageLog(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                    messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                    Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                                }
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe uint GetDebugMessageLog(uint count, int bufSize, DebugSource[] sources, DebugType[] types, uint[] ids, DebugSeverity[] severities, int[] lengths, out string messageLog)
            {
                uint returnValue;
                fixed (DebugSource* sources_ptr = sources)
                {
                    fixed (DebugType* types_ptr = types)
                    {
                        fixed (uint* ids_ptr = ids)
                        {
                            fixed (DebugSeverity* severities_ptr = severities)
                            {
                                fixed (int* lengths_ptr = lengths)
                                {
                                    var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                    returnValue = GetDebugMessageLog(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                    messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                    Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                                }
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe uint GetDebugMessageLog(uint count, int bufSize, ref DebugSource sources, ref DebugType types, ref uint ids, ref DebugSeverity severities, ref int lengths, out string messageLog)
            {
                uint returnValue;
                fixed (DebugSource* sources_ptr = &sources)
                fixed (DebugType* types_ptr = &types)
                fixed (uint* ids_ptr = &ids)
                fixed (DebugSeverity* severities_ptr = &severities)
                fixed (int* lengths_ptr = &lengths)
                {
                    var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    returnValue = GetDebugMessageLog(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                    messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                }
                return returnValue;
            }
            public static unsafe void PushDebugGroup(DebugSource source, uint id, int length, string message)
            {
                byte* message_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(message);
                PushDebugGroup(source, id, length, message_ptr);
                Marshal.FreeCoTaskMem((IntPtr)message_ptr);
            }
            public static unsafe void ObjectLabel(ObjectIdentifier identifier, uint name, int length, string label)
            {
                byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
                ObjectLabel(identifier, name, length, label_ptr);
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            public static unsafe string GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, Span<int> length)
            {
                string label;
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, Span<int> length, out string label)
            {
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe string GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int[] length)
            {
                string label;
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int[] length, out string label)
            {
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe string GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, ref int length)
            {
                string label;
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, ref int length, out string label)
            {
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabel(identifier, name, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe void ObjectPtrLabel(IntPtr ptr, int length, string label)
            {
                byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
                void* ptr_vptr = (void*)ptr;
                ObjectPtrLabel(ptr_vptr, length, label_ptr);
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            public static unsafe void ObjectPtrLabel<T1>(in T1 ptr, int length, string label)
                where T1 : unmanaged
            {
                fixed (void* ptr_ptr = &ptr)
                {
                    byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
                    ObjectPtrLabel(ptr_ptr, length, label_ptr);
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe string GetObjectPtrLabel(IntPtr ptr, int bufSize, Span<int> length)
            {
                string label;
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    void* ptr_vptr = (void*)ptr;
                    GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectPtrLabel(IntPtr ptr, int bufSize, Span<int> length, out string label)
            {
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    void* ptr_vptr = (void*)ptr;
                    GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe string GetObjectPtrLabel(IntPtr ptr, int bufSize, int[] length)
            {
                string label;
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    void* ptr_vptr = (void*)ptr;
                    GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectPtrLabel(IntPtr ptr, int bufSize, int[] length, out string label)
            {
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    void* ptr_vptr = (void*)ptr;
                    GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe string GetObjectPtrLabel(IntPtr ptr, int bufSize, ref int length)
            {
                string label;
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    void* ptr_vptr = (void*)ptr;
                    GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectPtrLabel(IntPtr ptr, int bufSize, ref int length, out string label)
            {
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    void* ptr_vptr = (void*)ptr;
                    GetObjectPtrLabel(ptr_vptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe string GetObjectPtrLabel<T1>(in T1 ptr, int bufSize, Span<int> length)
                where T1 : unmanaged
            {
                string label;
                fixed (void* ptr_ptr = &ptr)
                {
                    fixed (int* length_ptr = length)
                    {
                        var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                        label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                    }
                }
                return label;
            }
            public static unsafe void GetObjectPtrLabel<T1>(in T1 ptr, int bufSize, Span<int> length, out string label)
                where T1 : unmanaged
            {
                fixed (void* ptr_ptr = &ptr)
                {
                    fixed (int* length_ptr = length)
                    {
                        var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                        label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                    }
                }
            }
            public static unsafe string GetObjectPtrLabel<T1>(in T1 ptr, int bufSize, int[] length)
                where T1 : unmanaged
            {
                string label;
                fixed (void* ptr_ptr = &ptr)
                {
                    fixed (int* length_ptr = length)
                    {
                        var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                        label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                    }
                }
                return label;
            }
            public static unsafe void GetObjectPtrLabel<T1>(in T1 ptr, int bufSize, int[] length, out string label)
                where T1 : unmanaged
            {
                fixed (void* ptr_ptr = &ptr)
                {
                    fixed (int* length_ptr = length)
                    {
                        var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                        label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                    }
                }
            }
            public static unsafe string GetObjectPtrLabel<T1>(in T1 ptr, int bufSize, ref int length)
                where T1 : unmanaged
            {
                string label;
                fixed (void* ptr_ptr = &ptr)
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectPtrLabel<T1>(in T1 ptr, int bufSize, ref int length, out string label)
                where T1 : unmanaged
            {
                fixed (void* ptr_ptr = &ptr)
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectPtrLabel(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe void DebugMessageControlKHR(DebugSource source, DebugType type, DebugSeverity severity, int count, in uint ids, bool enabled)
            {
                fixed (uint* ids_ptr = &ids)
                {
                    byte enabled_byte = (byte)(enabled ? 1 : 0);
                    DebugMessageControlKHR(source, type, severity, count, ids_ptr, enabled_byte);
                }
            }
            public static unsafe void DebugMessageInsertKHR(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, string buf)
            {
                byte* buf_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(buf);
                DebugMessageInsertKHR(source, type, id, severity, length, buf_ptr);
                Marshal.FreeCoTaskMem((IntPtr)buf_ptr);
            }
            public static unsafe void DebugMessageCallbackKHR(GLDebugProcKHR callback, IntPtr userParam)
            {
                void* userParam_vptr = (void*)userParam;
                IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                DebugMessageCallbackKHR(callback_ptr, userParam_vptr);
            }
            public static unsafe void DebugMessageCallbackKHR<T1>(GLDebugProcKHR callback, in T1 userParam)
                where T1 : unmanaged
            {
                fixed (void* userParam_ptr = &userParam)
                {
                    IntPtr callback_ptr = Marshal.GetFunctionPointerForDelegate(callback);
                    DebugMessageCallbackKHR(callback_ptr, userParam_ptr);
                }
            }
            public static unsafe uint GetDebugMessageLogKHR(uint count, int bufSize, Span<DebugSource> sources, Span<DebugType> types, Span<uint> ids, Span<DebugSeverity> severities, Span<int> lengths, out string messageLog)
            {
                uint returnValue;
                fixed (DebugSource* sources_ptr = sources)
                {
                    fixed (DebugType* types_ptr = types)
                    {
                        fixed (uint* ids_ptr = ids)
                        {
                            fixed (DebugSeverity* severities_ptr = severities)
                            {
                                fixed (int* lengths_ptr = lengths)
                                {
                                    var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                    returnValue = GetDebugMessageLogKHR(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                    messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                    Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                                }
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe uint GetDebugMessageLogKHR(uint count, int bufSize, DebugSource[] sources, DebugType[] types, uint[] ids, DebugSeverity[] severities, int[] lengths, out string messageLog)
            {
                uint returnValue;
                fixed (DebugSource* sources_ptr = sources)
                {
                    fixed (DebugType* types_ptr = types)
                    {
                        fixed (uint* ids_ptr = ids)
                        {
                            fixed (DebugSeverity* severities_ptr = severities)
                            {
                                fixed (int* lengths_ptr = lengths)
                                {
                                    var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                                    returnValue = GetDebugMessageLogKHR(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                                    messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                                    Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                                }
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe uint GetDebugMessageLogKHR(uint count, int bufSize, ref DebugSource sources, ref DebugType types, ref uint ids, ref DebugSeverity severities, ref int lengths, out string messageLog)
            {
                uint returnValue;
                fixed (DebugSource* sources_ptr = &sources)
                fixed (DebugType* types_ptr = &types)
                fixed (uint* ids_ptr = &ids)
                fixed (DebugSeverity* severities_ptr = &severities)
                fixed (int* lengths_ptr = &lengths)
                {
                    var messageLog_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    returnValue = GetDebugMessageLogKHR(count, bufSize, sources_ptr, types_ptr, ids_ptr, severities_ptr, lengths_ptr, messageLog_ptr);
                    messageLog = Marshal.PtrToStringUTF8((IntPtr)messageLog_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)messageLog_ptr);
                }
                return returnValue;
            }
            public static unsafe void PushDebugGroupKHR(DebugSource source, uint id, int length, string message)
            {
                byte* message_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(message);
                PushDebugGroupKHR(source, id, length, message_ptr);
                Marshal.FreeCoTaskMem((IntPtr)message_ptr);
            }
            public static unsafe void ObjectLabelKHR(ObjectIdentifier identifier, uint name, int length, string label)
            {
                byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
                ObjectLabelKHR(identifier, name, length, label_ptr);
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            public static unsafe string GetObjectLabelKHR(All identifier, uint name, int bufSize, ref int length)
            {
                string label;
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabelKHR(identifier, name, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectLabelKHR(All identifier, uint name, int bufSize, ref int length, out string label)
            {
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectLabelKHR(identifier, name, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe void ObjectPtrLabelKHR(IntPtr ptr, int length, string label)
            {
                byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
                void* ptr_vptr = (void*)ptr;
                ObjectPtrLabelKHR(ptr_vptr, length, label_ptr);
                Marshal.FreeCoTaskMem((IntPtr)label_ptr);
            }
            public static unsafe void ObjectPtrLabelKHR<T1>(in T1 ptr, int length, string label)
                where T1 : unmanaged
            {
                fixed (void* ptr_ptr = &ptr)
                {
                    byte* label_ptr = (byte*)Marshal.StringToCoTaskMemUTF8(label);
                    ObjectPtrLabelKHR(ptr_ptr, length, label_ptr);
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe string GetObjectPtrLabelKHR(IntPtr ptr, int bufSize, Span<int> length)
            {
                string label;
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    void* ptr_vptr = (void*)ptr;
                    GetObjectPtrLabelKHR(ptr_vptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectPtrLabelKHR(IntPtr ptr, int bufSize, Span<int> length, out string label)
            {
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    void* ptr_vptr = (void*)ptr;
                    GetObjectPtrLabelKHR(ptr_vptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe string GetObjectPtrLabelKHR(IntPtr ptr, int bufSize, int[] length)
            {
                string label;
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    void* ptr_vptr = (void*)ptr;
                    GetObjectPtrLabelKHR(ptr_vptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectPtrLabelKHR(IntPtr ptr, int bufSize, int[] length, out string label)
            {
                fixed (int* length_ptr = length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    void* ptr_vptr = (void*)ptr;
                    GetObjectPtrLabelKHR(ptr_vptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe string GetObjectPtrLabelKHR(IntPtr ptr, int bufSize, ref int length)
            {
                string label;
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    void* ptr_vptr = (void*)ptr;
                    GetObjectPtrLabelKHR(ptr_vptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectPtrLabelKHR(IntPtr ptr, int bufSize, ref int length, out string label)
            {
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    void* ptr_vptr = (void*)ptr;
                    GetObjectPtrLabelKHR(ptr_vptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe string GetObjectPtrLabelKHR<T1>(in T1 ptr, int bufSize, Span<int> length)
                where T1 : unmanaged
            {
                string label;
                fixed (void* ptr_ptr = &ptr)
                {
                    fixed (int* length_ptr = length)
                    {
                        var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetObjectPtrLabelKHR(ptr_ptr, bufSize, length_ptr, label_ptr);
                        label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                    }
                }
                return label;
            }
            public static unsafe void GetObjectPtrLabelKHR<T1>(in T1 ptr, int bufSize, Span<int> length, out string label)
                where T1 : unmanaged
            {
                fixed (void* ptr_ptr = &ptr)
                {
                    fixed (int* length_ptr = length)
                    {
                        var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetObjectPtrLabelKHR(ptr_ptr, bufSize, length_ptr, label_ptr);
                        label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                    }
                }
            }
            public static unsafe string GetObjectPtrLabelKHR<T1>(in T1 ptr, int bufSize, int[] length)
                where T1 : unmanaged
            {
                string label;
                fixed (void* ptr_ptr = &ptr)
                {
                    fixed (int* length_ptr = length)
                    {
                        var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetObjectPtrLabelKHR(ptr_ptr, bufSize, length_ptr, label_ptr);
                        label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                    }
                }
                return label;
            }
            public static unsafe void GetObjectPtrLabelKHR<T1>(in T1 ptr, int bufSize, int[] length, out string label)
                where T1 : unmanaged
            {
                fixed (void* ptr_ptr = &ptr)
                {
                    fixed (int* length_ptr = length)
                    {
                        var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                        GetObjectPtrLabelKHR(ptr_ptr, bufSize, length_ptr, label_ptr);
                        label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                        Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                    }
                }
            }
            public static unsafe string GetObjectPtrLabelKHR<T1>(in T1 ptr, int bufSize, ref int length)
                where T1 : unmanaged
            {
                string label;
                fixed (void* ptr_ptr = &ptr)
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectPtrLabelKHR(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
                return label;
            }
            public static unsafe void GetObjectPtrLabelKHR<T1>(in T1 ptr, int bufSize, ref int length, out string label)
                where T1 : unmanaged
            {
                fixed (void* ptr_ptr = &ptr)
                fixed (int* length_ptr = &length)
                {
                    var label_ptr = (byte*)Marshal.AllocCoTaskMem(bufSize);
                    GetObjectPtrLabelKHR(ptr_ptr, bufSize, length_ptr, label_ptr);
                    label = Marshal.PtrToStringUTF8((IntPtr)label_ptr)!;
                    Marshal.FreeCoTaskMem((IntPtr)label_ptr);
                }
            }
            public static unsafe void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, IntPtr data)
            {
                void* data_vptr = (void*)data;
                ReadnPixels(x, y, width, height, format, type, bufSize, data_vptr);
            }
            public static unsafe void ReadnPixels<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, Span<T1> data)
                where T1 : unmanaged
            {
                int bufSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    ReadnPixels(x, y, width, height, format, type, bufSize, data_ptr);
                }
            }
            public static unsafe void ReadnPixels<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, T1[] data)
                where T1 : unmanaged
            {
                int bufSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    ReadnPixels(x, y, width, height, format, type, bufSize, data_ptr);
                }
            }
            public static unsafe void ReadnPixels<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, ref T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    ReadnPixels(x, y, width, height, format, type, bufSize, data_ptr);
                }
            }
            public static unsafe void GetnUniformf(ProgramHandle program, int location, Span<float> parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (float* parameters_ptr = parameters)
                {
                    GetnUniformfv(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformf(ProgramHandle program, int location, float[] parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (float* parameters_ptr = parameters)
                {
                    GetnUniformfv(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformf(ProgramHandle program, int location, int bufSize, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetnUniformfv(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformi(ProgramHandle program, int location, Span<int> parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (int* parameters_ptr = parameters)
                {
                    GetnUniformiv(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformi(ProgramHandle program, int location, int[] parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (int* parameters_ptr = parameters)
                {
                    GetnUniformiv(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformi(ProgramHandle program, int location, int bufSize, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetnUniformiv(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformui(ProgramHandle program, int location, Span<uint> parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (uint* parameters_ptr = parameters)
                {
                    GetnUniformuiv(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformui(ProgramHandle program, int location, uint[] parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (uint* parameters_ptr = parameters)
                {
                    GetnUniformuiv(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformui(ProgramHandle program, int location, int bufSize, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetnUniformuiv(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void ReadnPixelsKHR(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, IntPtr data)
            {
                void* data_vptr = (void*)data;
                ReadnPixelsKHR(x, y, width, height, format, type, bufSize, data_vptr);
            }
            public static unsafe void ReadnPixelsKHR<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, Span<T1> data)
                where T1 : unmanaged
            {
                int bufSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    ReadnPixelsKHR(x, y, width, height, format, type, bufSize, data_ptr);
                }
            }
            public static unsafe void ReadnPixelsKHR<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, T1[] data)
                where T1 : unmanaged
            {
                int bufSize = (int)(data.Length * sizeof(T1));
                fixed (void* data_ptr = data)
                {
                    ReadnPixelsKHR(x, y, width, height, format, type, bufSize, data_ptr);
                }
            }
            public static unsafe void ReadnPixelsKHR<T1>(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, ref T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    ReadnPixelsKHR(x, y, width, height, format, type, bufSize, data_ptr);
                }
            }
            public static unsafe void GetnUniformfvKHR(ProgramHandle program, int location, Span<float> parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (float* parameters_ptr = parameters)
                {
                    GetnUniformfvKHR(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformfvKHR(ProgramHandle program, int location, float[] parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (float* parameters_ptr = parameters)
                {
                    GetnUniformfvKHR(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformfvKHR(ProgramHandle program, int location, int bufSize, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetnUniformfvKHR(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformivKHR(ProgramHandle program, int location, Span<int> parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (int* parameters_ptr = parameters)
                {
                    GetnUniformivKHR(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformivKHR(ProgramHandle program, int location, int[] parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (int* parameters_ptr = parameters)
                {
                    GetnUniformivKHR(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformivKHR(ProgramHandle program, int location, int bufSize, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetnUniformivKHR(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformuivKHR(ProgramHandle program, int location, Span<uint> parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (uint* parameters_ptr = parameters)
                {
                    GetnUniformuivKHR(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformuivKHR(ProgramHandle program, int location, uint[] parameters)
            {
                int bufSize = (int)(parameters.Length * 4);
                fixed (uint* parameters_ptr = parameters)
                {
                    GetnUniformuivKHR(program, location, bufSize, parameters_ptr);
                }
            }
            public static unsafe void GetnUniformuivKHR(ProgramHandle program, int location, int bufSize, ref uint parameters)
            {
                fixed (uint* parameters_ptr = &parameters)
                {
                    GetnUniformuivKHR(program, location, bufSize, parameters_ptr);
                }
            }
        }
        public static unsafe partial class MESA
        {
            public static unsafe void GetFramebufferParameterivMESA(FramebufferTarget target, FramebufferAttachmentParameterName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFramebufferParameterivMESA(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFramebufferParameterivMESA(FramebufferTarget target, FramebufferAttachmentParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFramebufferParameterivMESA(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFramebufferParameterivMESA(FramebufferTarget target, FramebufferAttachmentParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetFramebufferParameterivMESA(target, pname, parameters_ptr);
                }
            }
            public static unsafe void WindowPos2dvMESA(ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    WindowPos2dvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos2dvMESA(double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    WindowPos2dvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos2dvMESA(in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    WindowPos2dvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos2fvMESA(ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    WindowPos2fvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos2fvMESA(float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    WindowPos2fvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos2fvMESA(in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    WindowPos2fvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos2ivMESA(ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    WindowPos2ivMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos2ivMESA(int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    WindowPos2ivMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos2ivMESA(in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    WindowPos2ivMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos2svMESA(ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    WindowPos2svMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos2svMESA(short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    WindowPos2svMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos2svMESA(in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    WindowPos2svMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos3dvMESA(ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    WindowPos3dvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos3dvMESA(double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    WindowPos3dvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos3dvMESA(in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    WindowPos3dvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos3fvMESA(ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    WindowPos3fvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos3fvMESA(float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    WindowPos3fvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos3fvMESA(in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    WindowPos3fvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos3ivMESA(ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    WindowPos3ivMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos3ivMESA(int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    WindowPos3ivMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos3ivMESA(in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    WindowPos3ivMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos3svMESA(ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    WindowPos3svMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos3svMESA(short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    WindowPos3svMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos3svMESA(in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    WindowPos3svMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos4dvMESA(ReadOnlySpan<double> v)
            {
                fixed (double* v_ptr = v)
                {
                    WindowPos4dvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos4dvMESA(double[] v)
            {
                fixed (double* v_ptr = v)
                {
                    WindowPos4dvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos4dvMESA(in double v)
            {
                fixed (double* v_ptr = &v)
                {
                    WindowPos4dvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos4fvMESA(ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    WindowPos4fvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos4fvMESA(float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    WindowPos4fvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos4fvMESA(in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    WindowPos4fvMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos4ivMESA(ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    WindowPos4ivMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos4ivMESA(int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    WindowPos4ivMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos4ivMESA(in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    WindowPos4ivMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos4svMESA(ReadOnlySpan<short> v)
            {
                fixed (short* v_ptr = v)
                {
                    WindowPos4svMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos4svMESA(short[] v)
            {
                fixed (short* v_ptr = v)
                {
                    WindowPos4svMESA(v_ptr);
                }
            }
            public static unsafe void WindowPos4svMESA(in short v)
            {
                fixed (short* v_ptr = &v)
                {
                    WindowPos4svMESA(v_ptr);
                }
            }
        }
        public static unsafe partial class NVX
        {
            public static unsafe void LGPUNamedBufferSubDataNVX(All gpuMask, BufferHandle buffer, IntPtr offset, nint size, IntPtr data)
            {
                void* data_vptr = (void*)data;
                LGPUNamedBufferSubDataNVX(gpuMask, buffer, offset, size, data_vptr);
            }
            public static unsafe void LGPUNamedBufferSubDataNVX<T1>(All gpuMask, BufferHandle buffer, IntPtr offset, nint size, in T1 data)
                where T1 : unmanaged
            {
                fixed (void* data_ptr = &data)
                {
                    LGPUNamedBufferSubDataNVX(gpuMask, buffer, offset, size, data_ptr);
                }
            }
            public static unsafe void MulticastViewportArrayvNVX(uint gpu, uint first, int count, ReadOnlySpan<float> v)
            {
                fixed (float* v_ptr = v)
                {
                    MulticastViewportArrayvNVX(gpu, first, count, v_ptr);
                }
            }
            public static unsafe void MulticastViewportArrayvNVX(uint gpu, uint first, int count, float[] v)
            {
                fixed (float* v_ptr = v)
                {
                    MulticastViewportArrayvNVX(gpu, first, count, v_ptr);
                }
            }
            public static unsafe void MulticastViewportArrayvNVX(uint gpu, uint first, int count, in float v)
            {
                fixed (float* v_ptr = &v)
                {
                    MulticastViewportArrayvNVX(gpu, first, count, v_ptr);
                }
            }
            public static unsafe void MulticastScissorArrayvNVX(uint gpu, uint first, int count, ReadOnlySpan<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    MulticastScissorArrayvNVX(gpu, first, count, v_ptr);
                }
            }
            public static unsafe void MulticastScissorArrayvNVX(uint gpu, uint first, int count, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    MulticastScissorArrayvNVX(gpu, first, count, v_ptr);
                }
            }
            public static unsafe void MulticastScissorArrayvNVX(uint gpu, uint first, int count, in int v)
            {
                fixed (int* v_ptr = &v)
                {
                    MulticastScissorArrayvNVX(gpu, first, count, v_ptr);
                }
            }
            public static unsafe uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, ReadOnlySpan<uint> waitSemaphoreArray, ReadOnlySpan<ulong> fenceValueArray, uint readGpu, All writeGpuMask, BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size, int signalSemaphoreCount, ReadOnlySpan<uint> signalSemaphoreArray, ReadOnlySpan<ulong> signalValueArray)
            {
                uint returnValue;
                fixed (uint* waitSemaphoreArray_ptr = waitSemaphoreArray)
                {
                    fixed (ulong* fenceValueArray_ptr = fenceValueArray)
                    {
                        fixed (uint* signalSemaphoreArray_ptr = signalSemaphoreArray)
                        {
                            fixed (ulong* signalValueArray_ptr = signalValueArray)
                            {
                                returnValue = AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray_ptr, fenceValueArray_ptr, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray_ptr, signalValueArray_ptr);
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint[] waitSemaphoreArray, ulong[] fenceValueArray, uint readGpu, All writeGpuMask, BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size, int signalSemaphoreCount, uint[] signalSemaphoreArray, ulong[] signalValueArray)
            {
                uint returnValue;
                fixed (uint* waitSemaphoreArray_ptr = waitSemaphoreArray)
                {
                    fixed (ulong* fenceValueArray_ptr = fenceValueArray)
                    {
                        fixed (uint* signalSemaphoreArray_ptr = signalSemaphoreArray)
                        {
                            fixed (ulong* signalValueArray_ptr = signalValueArray)
                            {
                                returnValue = AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray_ptr, fenceValueArray_ptr, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray_ptr, signalValueArray_ptr);
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, in uint waitSemaphoreArray, in ulong fenceValueArray, uint readGpu, All writeGpuMask, BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size, int signalSemaphoreCount, in uint signalSemaphoreArray, in ulong signalValueArray)
            {
                uint returnValue;
                fixed (uint* waitSemaphoreArray_ptr = &waitSemaphoreArray)
                fixed (ulong* fenceValueArray_ptr = &fenceValueArray)
                fixed (uint* signalSemaphoreArray_ptr = &signalSemaphoreArray)
                fixed (ulong* signalValueArray_ptr = &signalValueArray)
                {
                    returnValue = AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray_ptr, fenceValueArray_ptr, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray_ptr, signalValueArray_ptr);
                }
                return returnValue;
            }
            public static unsafe uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, ReadOnlySpan<uint> waitSemaphoreArray, ReadOnlySpan<ulong> waitValueArray, uint srcGpu, All dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, ReadOnlySpan<uint> signalSemaphoreArray, ReadOnlySpan<ulong> signalValueArray)
            {
                uint returnValue;
                fixed (uint* waitSemaphoreArray_ptr = waitSemaphoreArray)
                {
                    fixed (ulong* waitValueArray_ptr = waitValueArray)
                    {
                        fixed (uint* signalSemaphoreArray_ptr = signalSemaphoreArray)
                        {
                            fixed (ulong* signalValueArray_ptr = signalValueArray)
                            {
                                returnValue = AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray_ptr, waitValueArray_ptr, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray_ptr, signalValueArray_ptr);
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint[] waitSemaphoreArray, ulong[] waitValueArray, uint srcGpu, All dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint[] signalSemaphoreArray, ulong[] signalValueArray)
            {
                uint returnValue;
                fixed (uint* waitSemaphoreArray_ptr = waitSemaphoreArray)
                {
                    fixed (ulong* waitValueArray_ptr = waitValueArray)
                    {
                        fixed (uint* signalSemaphoreArray_ptr = signalSemaphoreArray)
                        {
                            fixed (ulong* signalValueArray_ptr = signalValueArray)
                            {
                                returnValue = AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray_ptr, waitValueArray_ptr, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray_ptr, signalValueArray_ptr);
                            }
                        }
                    }
                }
                return returnValue;
            }
            public static unsafe uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, in uint waitSemaphoreArray, in ulong waitValueArray, uint srcGpu, All dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, in uint signalSemaphoreArray, in ulong signalValueArray)
            {
                uint returnValue;
                fixed (uint* waitSemaphoreArray_ptr = &waitSemaphoreArray)
                fixed (ulong* waitValueArray_ptr = &waitValueArray)
                fixed (uint* signalSemaphoreArray_ptr = &signalSemaphoreArray)
                fixed (ulong* signalValueArray_ptr = &signalValueArray)
                {
                    returnValue = AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray_ptr, waitValueArray_ptr, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray_ptr, signalValueArray_ptr);
                }
                return returnValue;
            }
            public static unsafe void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, ReadOnlySpan<uint> semaphoreArray, ReadOnlySpan<ulong> fenceValueArray)
            {
                fixed (uint* semaphoreArray_ptr = semaphoreArray)
                {
                    fixed (ulong* fenceValueArray_ptr = fenceValueArray)
                    {
                        SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray_ptr, fenceValueArray_ptr);
                    }
                }
            }
            public static unsafe void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, uint[] semaphoreArray, ulong[] fenceValueArray)
            {
                fixed (uint* semaphoreArray_ptr = semaphoreArray)
                {
                    fixed (ulong* fenceValueArray_ptr = fenceValueArray)
                    {
                        SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray_ptr, fenceValueArray_ptr);
                    }
                }
            }
            public static unsafe void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, in uint semaphoreArray, in ulong fenceValueArray)
            {
                fixed (uint* semaphoreArray_ptr = &semaphoreArray)
                fixed (ulong* fenceValueArray_ptr = &fenceValueArray)
                {
                    SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray_ptr, fenceValueArray_ptr);
                }
            }
            public static unsafe void WaitSemaphoreui64NVX(uint waitGpu, int fenceObjectCount, ReadOnlySpan<uint> semaphoreArray, ReadOnlySpan<ulong> fenceValueArray)
            {
                fixed (uint* semaphoreArray_ptr = semaphoreArray)
                {
                    fixed (ulong* fenceValueArray_ptr = fenceValueArray)
                    {
                        WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray_ptr, fenceValueArray_ptr);
                    }
                }
            }
            public static unsafe void WaitSemaphoreui64NVX(uint waitGpu, int fenceObjectCount, uint[] semaphoreArray, ulong[] fenceValueArray)
            {
                fixed (uint* semaphoreArray_ptr = semaphoreArray)
                {
                    fixed (ulong* fenceValueArray_ptr = fenceValueArray)
                    {
                        WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray_ptr, fenceValueArray_ptr);
                    }
                }
            }
            public static unsafe void WaitSemaphoreui64NVX(uint waitGpu, int fenceObjectCount, in uint semaphoreArray, in ulong fenceValueArray)
            {
                fixed (uint* semaphoreArray_ptr = &semaphoreArray)
                fixed (ulong* fenceValueArray_ptr = &fenceValueArray)
                {
                    WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray_ptr, fenceValueArray_ptr);
                }
            }
            public static unsafe void ClientWaitSemaphoreui64NVX(int fenceObjectCount, ReadOnlySpan<uint> semaphoreArray, ReadOnlySpan<ulong> fenceValueArray)
            {
                fixed (uint* semaphoreArray_ptr = semaphoreArray)
                {
                    fixed (ulong* fenceValueArray_ptr = fenceValueArray)
                    {
                        ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray_ptr, fenceValueArray_ptr);
                    }
                }
            }
            public static unsafe void ClientWaitSemaphoreui64NVX(int fenceObjectCount, uint[] semaphoreArray, ulong[] fenceValueArray)
            {
                fixed (uint* semaphoreArray_ptr = semaphoreArray)
                {
                    fixed (ulong* fenceValueArray_ptr = fenceValueArray)
                    {
                        ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray_ptr, fenceValueArray_ptr);
                    }
                }
            }
            public static unsafe void ClientWaitSemaphoreui64NVX(int fenceObjectCount, in uint semaphoreArray, in ulong fenceValueArray)
            {
                fixed (uint* semaphoreArray_ptr = &semaphoreArray)
                fixed (ulong* fenceValueArray_ptr = &fenceValueArray)
                {
                    ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray_ptr, fenceValueArray_ptr);
                }
            }
        }
        public static unsafe partial class OES
        {
            public static unsafe void MultiTexCoord1bvOES(TextureUnit texture, ReadOnlySpan<sbyte> coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    MultiTexCoord1bvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord1bvOES(TextureUnit texture, sbyte[] coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    MultiTexCoord1bvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord1bvOES(TextureUnit texture, in sbyte coords)
            {
                fixed (sbyte* coords_ptr = &coords)
                {
                    MultiTexCoord1bvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord2bvOES(TextureUnit texture, ReadOnlySpan<sbyte> coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    MultiTexCoord2bvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord2bvOES(TextureUnit texture, sbyte[] coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    MultiTexCoord2bvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord2bvOES(TextureUnit texture, in sbyte coords)
            {
                fixed (sbyte* coords_ptr = &coords)
                {
                    MultiTexCoord2bvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord3bvOES(TextureUnit texture, ReadOnlySpan<sbyte> coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    MultiTexCoord3bvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord3bvOES(TextureUnit texture, sbyte[] coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    MultiTexCoord3bvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord3bvOES(TextureUnit texture, in sbyte coords)
            {
                fixed (sbyte* coords_ptr = &coords)
                {
                    MultiTexCoord3bvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord4bvOES(TextureUnit texture, ReadOnlySpan<sbyte> coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    MultiTexCoord4bvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord4bvOES(TextureUnit texture, sbyte[] coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    MultiTexCoord4bvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord4bvOES(TextureUnit texture, in sbyte coords)
            {
                fixed (sbyte* coords_ptr = &coords)
                {
                    MultiTexCoord4bvOES(texture, coords_ptr);
                }
            }
            public static unsafe void TexCoord1bvOES(ReadOnlySpan<sbyte> coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    TexCoord1bvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord1bvOES(sbyte[] coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    TexCoord1bvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord1bvOES(in sbyte coords)
            {
                fixed (sbyte* coords_ptr = &coords)
                {
                    TexCoord1bvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord2bvOES(ReadOnlySpan<sbyte> coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    TexCoord2bvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord2bvOES(sbyte[] coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    TexCoord2bvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord2bvOES(in sbyte coords)
            {
                fixed (sbyte* coords_ptr = &coords)
                {
                    TexCoord2bvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord3bvOES(ReadOnlySpan<sbyte> coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    TexCoord3bvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord3bvOES(sbyte[] coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    TexCoord3bvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord3bvOES(in sbyte coords)
            {
                fixed (sbyte* coords_ptr = &coords)
                {
                    TexCoord3bvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord4bvOES(ReadOnlySpan<sbyte> coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    TexCoord4bvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord4bvOES(sbyte[] coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    TexCoord4bvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord4bvOES(in sbyte coords)
            {
                fixed (sbyte* coords_ptr = &coords)
                {
                    TexCoord4bvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex2bvOES(ReadOnlySpan<sbyte> coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    Vertex2bvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex2bvOES(sbyte[] coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    Vertex2bvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex2bvOES(in sbyte coords)
            {
                fixed (sbyte* coords_ptr = &coords)
                {
                    Vertex2bvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex3bvOES(ReadOnlySpan<sbyte> coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    Vertex3bvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex3bvOES(sbyte[] coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    Vertex3bvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex3bvOES(in sbyte coords)
            {
                fixed (sbyte* coords_ptr = &coords)
                {
                    Vertex3bvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex4bvOES(ReadOnlySpan<sbyte> coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    Vertex4bvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex4bvOES(sbyte[] coords)
            {
                fixed (sbyte* coords_ptr = coords)
                {
                    Vertex4bvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex4bvOES(in sbyte coords)
            {
                fixed (sbyte* coords_ptr = &coords)
                {
                    Vertex4bvOES(coords_ptr);
                }
            }
            public static unsafe void ClipPlanexOES(ClipPlaneName plane, ReadOnlySpan<int> equation)
            {
                fixed (int* equation_ptr = equation)
                {
                    ClipPlanexOES(plane, equation_ptr);
                }
            }
            public static unsafe void ClipPlanexOES(ClipPlaneName plane, int[] equation)
            {
                fixed (int* equation_ptr = equation)
                {
                    ClipPlanexOES(plane, equation_ptr);
                }
            }
            public static unsafe void ClipPlanexOES(ClipPlaneName plane, in int equation)
            {
                fixed (int* equation_ptr = &equation)
                {
                    ClipPlanexOES(plane, equation_ptr);
                }
            }
            public static unsafe void FogxvOES(FogPName pname, ReadOnlySpan<int> param)
            {
                fixed (int* param_ptr = param)
                {
                    FogxvOES(pname, param_ptr);
                }
            }
            public static unsafe void FogxvOES(FogPName pname, int[] param)
            {
                fixed (int* param_ptr = param)
                {
                    FogxvOES(pname, param_ptr);
                }
            }
            public static unsafe void FogxvOES(FogPName pname, in int param)
            {
                fixed (int* param_ptr = &param)
                {
                    FogxvOES(pname, param_ptr);
                }
            }
            public static unsafe void GetClipPlanexOES(ClipPlaneName plane, Span<int> equation)
            {
                fixed (int* equation_ptr = equation)
                {
                    GetClipPlanexOES(plane, equation_ptr);
                }
            }
            public static unsafe void GetClipPlanexOES(ClipPlaneName plane, int[] equation)
            {
                fixed (int* equation_ptr = equation)
                {
                    GetClipPlanexOES(plane, equation_ptr);
                }
            }
            public static unsafe void GetClipPlanexOES(ClipPlaneName plane, ref int equation)
            {
                fixed (int* equation_ptr = &equation)
                {
                    GetClipPlanexOES(plane, equation_ptr);
                }
            }
            public static unsafe void GetFixedvOES(GetPName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFixedvOES(pname, parameters_ptr);
                }
            }
            public static unsafe void GetFixedvOES(GetPName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFixedvOES(pname, parameters_ptr);
                }
            }
            public static unsafe void GetFixedvOES(GetPName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetFixedvOES(pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTexEnvxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTexEnvxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetTexEnvxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexParameterxvOES(TextureTarget target, GetTextureParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTexParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexParameterxvOES(TextureTarget target, GetTextureParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTexParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexParameterxvOES(TextureTarget target, GetTextureParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetTexParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void LightModelxvOES(LightModelParameter pname, ReadOnlySpan<int> param)
            {
                fixed (int* param_ptr = param)
                {
                    LightModelxvOES(pname, param_ptr);
                }
            }
            public static unsafe void LightModelxvOES(LightModelParameter pname, int[] param)
            {
                fixed (int* param_ptr = param)
                {
                    LightModelxvOES(pname, param_ptr);
                }
            }
            public static unsafe void LightModelxvOES(LightModelParameter pname, in int param)
            {
                fixed (int* param_ptr = &param)
                {
                    LightModelxvOES(pname, param_ptr);
                }
            }
            public static unsafe void LightxvOES(LightName light, LightParameter pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    LightxvOES(light, pname, parameters_ptr);
                }
            }
            public static unsafe void LightxvOES(LightName light, LightParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    LightxvOES(light, pname, parameters_ptr);
                }
            }
            public static unsafe void LightxvOES(LightName light, LightParameter pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    LightxvOES(light, pname, parameters_ptr);
                }
            }
            public static unsafe void LoadMatrixxOES(ReadOnlySpan<int> m)
            {
                fixed (int* m_ptr = m)
                {
                    LoadMatrixxOES(m_ptr);
                }
            }
            public static unsafe void LoadMatrixxOES(int[] m)
            {
                fixed (int* m_ptr = m)
                {
                    LoadMatrixxOES(m_ptr);
                }
            }
            public static unsafe void LoadMatrixxOES(in int m)
            {
                fixed (int* m_ptr = &m)
                {
                    LoadMatrixxOES(m_ptr);
                }
            }
            public static unsafe void MaterialxvOES(MaterialFace face, MaterialParameter pname, ReadOnlySpan<int> param)
            {
                fixed (int* param_ptr = param)
                {
                    MaterialxvOES(face, pname, param_ptr);
                }
            }
            public static unsafe void MaterialxvOES(MaterialFace face, MaterialParameter pname, int[] param)
            {
                fixed (int* param_ptr = param)
                {
                    MaterialxvOES(face, pname, param_ptr);
                }
            }
            public static unsafe void MaterialxvOES(MaterialFace face, MaterialParameter pname, in int param)
            {
                fixed (int* param_ptr = &param)
                {
                    MaterialxvOES(face, pname, param_ptr);
                }
            }
            public static unsafe void MultMatrixxOES(ReadOnlySpan<int> m)
            {
                fixed (int* m_ptr = m)
                {
                    MultMatrixxOES(m_ptr);
                }
            }
            public static unsafe void MultMatrixxOES(int[] m)
            {
                fixed (int* m_ptr = m)
                {
                    MultMatrixxOES(m_ptr);
                }
            }
            public static unsafe void MultMatrixxOES(in int m)
            {
                fixed (int* m_ptr = &m)
                {
                    MultMatrixxOES(m_ptr);
                }
            }
            public static unsafe void PointParameterxvOES(PointParameterNameARB pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    PointParameterxvOES(pname, parameters_ptr);
                }
            }
            public static unsafe void PointParameterxvOES(PointParameterNameARB pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    PointParameterxvOES(pname, parameters_ptr);
                }
            }
            public static unsafe void PointParameterxvOES(PointParameterNameARB pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    PointParameterxvOES(pname, parameters_ptr);
                }
            }
            public static unsafe void TexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    TexEnvxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void TexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    TexEnvxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void TexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    TexEnvxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void TexParameterxvOES(TextureTarget target, GetTextureParameter pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    TexParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void TexParameterxvOES(TextureTarget target, GetTextureParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    TexParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void TexParameterxvOES(TextureTarget target, GetTextureParameter pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    TexParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetLightxvOES(LightName light, LightParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetLightxvOES(light, pname, parameters_ptr);
                }
            }
            public static unsafe void GetLightxvOES(LightName light, LightParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetLightxvOES(light, pname, parameters_ptr);
                }
            }
            public static unsafe void GetLightxvOES(LightName light, LightParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetLightxvOES(light, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMaterialxvOES(MaterialFace face, MaterialParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMaterialxvOES(face, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMaterialxvOES(MaterialFace face, MaterialParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetMaterialxvOES(face, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMaterialxvOES(MaterialFace face, MaterialParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetMaterialxvOES(face, pname, parameters_ptr);
                }
            }
            public static unsafe void SampleCoveragexOES(int value, bool invert)
            {
                byte invert_byte = (byte)(invert ? 1 : 0);
                SampleCoveragexOES(value, invert_byte);
            }
            public static unsafe void BitmapxOES(int width, int height, int xorig, int yorig, int xmove, int ymove, ReadOnlySpan<byte> bitmap)
            {
                fixed (byte* bitmap_ptr = bitmap)
                {
                    BitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap_ptr);
                }
            }
            public static unsafe void BitmapxOES(int width, int height, int xorig, int yorig, int xmove, int ymove, byte[] bitmap)
            {
                fixed (byte* bitmap_ptr = bitmap)
                {
                    BitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap_ptr);
                }
            }
            public static unsafe void BitmapxOES(int width, int height, int xorig, int yorig, int xmove, int ymove, in byte bitmap)
            {
                fixed (byte* bitmap_ptr = &bitmap)
                {
                    BitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap_ptr);
                }
            }
            public static unsafe void Color3xvOES(ReadOnlySpan<int> components)
            {
                fixed (int* components_ptr = components)
                {
                    Color3xvOES(components_ptr);
                }
            }
            public static unsafe void Color3xvOES(int[] components)
            {
                fixed (int* components_ptr = components)
                {
                    Color3xvOES(components_ptr);
                }
            }
            public static unsafe void Color3xvOES(in int components)
            {
                fixed (int* components_ptr = &components)
                {
                    Color3xvOES(components_ptr);
                }
            }
            public static unsafe void Color4xvOES(ReadOnlySpan<int> components)
            {
                fixed (int* components_ptr = components)
                {
                    Color4xvOES(components_ptr);
                }
            }
            public static unsafe void Color4xvOES(int[] components)
            {
                fixed (int* components_ptr = components)
                {
                    Color4xvOES(components_ptr);
                }
            }
            public static unsafe void Color4xvOES(in int components)
            {
                fixed (int* components_ptr = &components)
                {
                    Color4xvOES(components_ptr);
                }
            }
            public static unsafe void ConvolutionParameterxvOES(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ConvolutionParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ConvolutionParameterxvOES(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ConvolutionParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ConvolutionParameterxvOES(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    ConvolutionParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void EvalCoord1xvOES(ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    EvalCoord1xvOES(coords_ptr);
                }
            }
            public static unsafe void EvalCoord1xvOES(int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    EvalCoord1xvOES(coords_ptr);
                }
            }
            public static unsafe void EvalCoord1xvOES(in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    EvalCoord1xvOES(coords_ptr);
                }
            }
            public static unsafe void EvalCoord2xvOES(ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    EvalCoord2xvOES(coords_ptr);
                }
            }
            public static unsafe void EvalCoord2xvOES(int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    EvalCoord2xvOES(coords_ptr);
                }
            }
            public static unsafe void EvalCoord2xvOES(in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    EvalCoord2xvOES(coords_ptr);
                }
            }
            public static unsafe void FeedbackBufferxOES(All type, ReadOnlySpan<int> buffer)
            {
                int n = (int)(buffer.Length);
                fixed (int* buffer_ptr = buffer)
                {
                    FeedbackBufferxOES(n, type, buffer_ptr);
                }
            }
            public static unsafe void FeedbackBufferxOES(All type, int[] buffer)
            {
                int n = (int)(buffer.Length);
                fixed (int* buffer_ptr = buffer)
                {
                    FeedbackBufferxOES(n, type, buffer_ptr);
                }
            }
            public static unsafe void FeedbackBufferxOES(int n, All type, in int buffer)
            {
                fixed (int* buffer_ptr = &buffer)
                {
                    FeedbackBufferxOES(n, type, buffer_ptr);
                }
            }
            public static unsafe void GetConvolutionParameterxvOES(All target, All pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetConvolutionParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetConvolutionParameterxvOES(All target, All pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetConvolutionParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetConvolutionParameterxvOES(All target, All pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetConvolutionParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetHistogramParameterxvOES(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetHistogramParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetHistogramParameterxvOES(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetHistogramParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetHistogramParameterxvOES(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetHistogramParameterxvOES(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetLightxOES(LightName light, LightParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetLightxOES(light, pname, parameters_ptr);
                }
            }
            public static unsafe void GetLightxOES(LightName light, LightParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetLightxOES(light, pname, parameters_ptr);
                }
            }
            public static unsafe void GetLightxOES(LightName light, LightParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetLightxOES(light, pname, parameters_ptr);
                }
            }
            public static unsafe void GetMapxvOES(MapTarget target, GetMapQuery query, Span<int> v)
            {
                fixed (int* v_ptr = v)
                {
                    GetMapxvOES(target, query, v_ptr);
                }
            }
            public static unsafe void GetMapxvOES(MapTarget target, GetMapQuery query, int[] v)
            {
                fixed (int* v_ptr = v)
                {
                    GetMapxvOES(target, query, v_ptr);
                }
            }
            public static unsafe void GetMapxvOES(MapTarget target, GetMapQuery query, ref int v)
            {
                fixed (int* v_ptr = &v)
                {
                    GetMapxvOES(target, query, v_ptr);
                }
            }
            public static unsafe void GetPixelMapx(PixelMap map, Span<int> values)
            {
                int size = (int)(values.Length);
                fixed (int* values_ptr = values)
                {
                    GetPixelMapxv(map, size, values_ptr);
                }
            }
            public static unsafe void GetPixelMapx(PixelMap map, int[] values)
            {
                int size = (int)(values.Length);
                fixed (int* values_ptr = values)
                {
                    GetPixelMapxv(map, size, values_ptr);
                }
            }
            public static unsafe void GetPixelMapx(PixelMap map, int size, ref int values)
            {
                fixed (int* values_ptr = &values)
                {
                    GetPixelMapxv(map, size, values_ptr);
                }
            }
            public static unsafe void GetTexGenxvOES(TextureCoordName coord, TextureGenParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTexGenxvOES(coord, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexGenxvOES(TextureCoordName coord, TextureGenParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTexGenxvOES(coord, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexGenxvOES(TextureCoordName coord, TextureGenParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetTexGenxvOES(coord, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexLevelParameterxvOES(TextureTarget target, int level, GetTextureParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTexLevelParameterxvOES(target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexLevelParameterxvOES(TextureTarget target, int level, GetTextureParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetTexLevelParameterxvOES(target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void GetTexLevelParameterxvOES(TextureTarget target, int level, GetTextureParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetTexLevelParameterxvOES(target, level, pname, parameters_ptr);
                }
            }
            public static unsafe void IndexxvOES(ReadOnlySpan<int> component)
            {
                fixed (int* component_ptr = component)
                {
                    IndexxvOES(component_ptr);
                }
            }
            public static unsafe void IndexxvOES(int[] component)
            {
                fixed (int* component_ptr = component)
                {
                    IndexxvOES(component_ptr);
                }
            }
            public static unsafe void IndexxvOES(in int component)
            {
                fixed (int* component_ptr = &component)
                {
                    IndexxvOES(component_ptr);
                }
            }
            public static unsafe void LoadTransposeMatrixxOES(ReadOnlySpan<int> m)
            {
                fixed (int* m_ptr = m)
                {
                    LoadTransposeMatrixxOES(m_ptr);
                }
            }
            public static unsafe void LoadTransposeMatrixxOES(int[] m)
            {
                fixed (int* m_ptr = m)
                {
                    LoadTransposeMatrixxOES(m_ptr);
                }
            }
            public static unsafe void LoadTransposeMatrixxOES(in int m)
            {
                fixed (int* m_ptr = &m)
                {
                    LoadTransposeMatrixxOES(m_ptr);
                }
            }
            public static unsafe void MultTransposeMatrixxOES(ReadOnlySpan<int> m)
            {
                fixed (int* m_ptr = m)
                {
                    MultTransposeMatrixxOES(m_ptr);
                }
            }
            public static unsafe void MultTransposeMatrixxOES(int[] m)
            {
                fixed (int* m_ptr = m)
                {
                    MultTransposeMatrixxOES(m_ptr);
                }
            }
            public static unsafe void MultTransposeMatrixxOES(in int m)
            {
                fixed (int* m_ptr = &m)
                {
                    MultTransposeMatrixxOES(m_ptr);
                }
            }
            public static unsafe void MultiTexCoord1xvOES(TextureUnit texture, ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    MultiTexCoord1xvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord1xvOES(TextureUnit texture, int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    MultiTexCoord1xvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord1xvOES(TextureUnit texture, in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    MultiTexCoord1xvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord2xvOES(TextureUnit texture, ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    MultiTexCoord2xvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord2xvOES(TextureUnit texture, int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    MultiTexCoord2xvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord2xvOES(TextureUnit texture, in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    MultiTexCoord2xvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord3xvOES(TextureUnit texture, ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    MultiTexCoord3xvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord3xvOES(TextureUnit texture, int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    MultiTexCoord3xvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord3xvOES(TextureUnit texture, in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    MultiTexCoord3xvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord4xvOES(TextureUnit texture, ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    MultiTexCoord4xvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord4xvOES(TextureUnit texture, int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    MultiTexCoord4xvOES(texture, coords_ptr);
                }
            }
            public static unsafe void MultiTexCoord4xvOES(TextureUnit texture, in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    MultiTexCoord4xvOES(texture, coords_ptr);
                }
            }
            public static unsafe void Normal3xvOES(ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    Normal3xvOES(coords_ptr);
                }
            }
            public static unsafe void Normal3xvOES(int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    Normal3xvOES(coords_ptr);
                }
            }
            public static unsafe void Normal3xvOES(in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    Normal3xvOES(coords_ptr);
                }
            }
            public static unsafe void PixelMapx(PixelMap map, ReadOnlySpan<int> values)
            {
                int size = (int)(values.Length);
                fixed (int* values_ptr = values)
                {
                    PixelMapx(map, size, values_ptr);
                }
            }
            public static unsafe void PixelMapx(PixelMap map, int[] values)
            {
                int size = (int)(values.Length);
                fixed (int* values_ptr = values)
                {
                    PixelMapx(map, size, values_ptr);
                }
            }
            public static unsafe void PixelMapx(PixelMap map, int size, in int values)
            {
                fixed (int* values_ptr = &values)
                {
                    PixelMapx(map, size, values_ptr);
                }
            }
            public static unsafe void PrioritizeTexturesxOES(int n, ReadOnlySpan<TextureHandle> textures, ReadOnlySpan<int> priorities)
            {
                fixed (TextureHandle* textures_ptr = textures)
                {
                    fixed (int* priorities_ptr = priorities)
                    {
                        PrioritizeTexturesxOES(n, textures_ptr, priorities_ptr);
                    }
                }
            }
            public static unsafe void PrioritizeTexturesxOES(int n, TextureHandle[] textures, int[] priorities)
            {
                fixed (TextureHandle* textures_ptr = textures)
                {
                    fixed (int* priorities_ptr = priorities)
                    {
                        PrioritizeTexturesxOES(n, textures_ptr, priorities_ptr);
                    }
                }
            }
            public static unsafe void PrioritizeTexturesxOES(int n, in TextureHandle textures, in int priorities)
            {
                fixed (TextureHandle* textures_ptr = &textures)
                fixed (int* priorities_ptr = &priorities)
                {
                    PrioritizeTexturesxOES(n, textures_ptr, priorities_ptr);
                }
            }
            public static unsafe void RasterPos2xvOES(ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    RasterPos2xvOES(coords_ptr);
                }
            }
            public static unsafe void RasterPos2xvOES(int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    RasterPos2xvOES(coords_ptr);
                }
            }
            public static unsafe void RasterPos2xvOES(in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    RasterPos2xvOES(coords_ptr);
                }
            }
            public static unsafe void RasterPos3xvOES(ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    RasterPos3xvOES(coords_ptr);
                }
            }
            public static unsafe void RasterPos3xvOES(int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    RasterPos3xvOES(coords_ptr);
                }
            }
            public static unsafe void RasterPos3xvOES(in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    RasterPos3xvOES(coords_ptr);
                }
            }
            public static unsafe void RasterPos4xvOES(ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    RasterPos4xvOES(coords_ptr);
                }
            }
            public static unsafe void RasterPos4xvOES(int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    RasterPos4xvOES(coords_ptr);
                }
            }
            public static unsafe void RasterPos4xvOES(in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    RasterPos4xvOES(coords_ptr);
                }
            }
            public static unsafe void RectxvOES(ReadOnlySpan<int> v1, ReadOnlySpan<int> v2)
            {
                fixed (int* v1_ptr = v1)
                {
                    fixed (int* v2_ptr = v2)
                    {
                        RectxvOES(v1_ptr, v2_ptr);
                    }
                }
            }
            public static unsafe void RectxvOES(int[] v1, int[] v2)
            {
                fixed (int* v1_ptr = v1)
                {
                    fixed (int* v2_ptr = v2)
                    {
                        RectxvOES(v1_ptr, v2_ptr);
                    }
                }
            }
            public static unsafe void RectxvOES(in int v1, in int v2)
            {
                fixed (int* v1_ptr = &v1)
                fixed (int* v2_ptr = &v2)
                {
                    RectxvOES(v1_ptr, v2_ptr);
                }
            }
            public static unsafe void TexCoord1xvOES(ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    TexCoord1xvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord1xvOES(int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    TexCoord1xvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord1xvOES(in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    TexCoord1xvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord2xvOES(ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    TexCoord2xvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord2xvOES(int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    TexCoord2xvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord2xvOES(in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    TexCoord2xvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord3xvOES(ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    TexCoord3xvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord3xvOES(int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    TexCoord3xvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord3xvOES(in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    TexCoord3xvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord4xvOES(ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    TexCoord4xvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord4xvOES(int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    TexCoord4xvOES(coords_ptr);
                }
            }
            public static unsafe void TexCoord4xvOES(in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    TexCoord4xvOES(coords_ptr);
                }
            }
            public static unsafe void TexGenxvOES(TextureCoordName coord, TextureGenParameter pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    TexGenxvOES(coord, pname, parameters_ptr);
                }
            }
            public static unsafe void TexGenxvOES(TextureCoordName coord, TextureGenParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    TexGenxvOES(coord, pname, parameters_ptr);
                }
            }
            public static unsafe void TexGenxvOES(TextureCoordName coord, TextureGenParameter pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    TexGenxvOES(coord, pname, parameters_ptr);
                }
            }
            public static unsafe void Vertex2xvOES(ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    Vertex2xvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex2xvOES(int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    Vertex2xvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex2xvOES(in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    Vertex2xvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex3xvOES(ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    Vertex3xvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex3xvOES(int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    Vertex3xvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex3xvOES(in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    Vertex3xvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex4xvOES(ReadOnlySpan<int> coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    Vertex4xvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex4xvOES(int[] coords)
            {
                fixed (int* coords_ptr = coords)
                {
                    Vertex4xvOES(coords_ptr);
                }
            }
            public static unsafe void Vertex4xvOES(in int coords)
            {
                fixed (int* coords_ptr = &coords)
                {
                    Vertex4xvOES(coords_ptr);
                }
            }
            public static unsafe All QueryMatrixxOES(Span<int> mantissa, Span<int> exponent)
            {
                All returnValue;
                fixed (int* mantissa_ptr = mantissa)
                {
                    fixed (int* exponent_ptr = exponent)
                    {
                        returnValue = QueryMatrixxOES(mantissa_ptr, exponent_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe All QueryMatrixxOES(int[] mantissa, int[] exponent)
            {
                All returnValue;
                fixed (int* mantissa_ptr = mantissa)
                {
                    fixed (int* exponent_ptr = exponent)
                    {
                        returnValue = QueryMatrixxOES(mantissa_ptr, exponent_ptr);
                    }
                }
                return returnValue;
            }
            public static unsafe All QueryMatrixxOES(ref int mantissa, ref int exponent)
            {
                All returnValue;
                fixed (int* mantissa_ptr = &mantissa)
                fixed (int* exponent_ptr = &exponent)
                {
                    returnValue = QueryMatrixxOES(mantissa_ptr, exponent_ptr);
                }
                return returnValue;
            }
            public static unsafe void ClipPlanefOES(ClipPlaneName plane, ReadOnlySpan<float> equation)
            {
                fixed (float* equation_ptr = equation)
                {
                    ClipPlanefOES(plane, equation_ptr);
                }
            }
            public static unsafe void ClipPlanefOES(ClipPlaneName plane, float[] equation)
            {
                fixed (float* equation_ptr = equation)
                {
                    ClipPlanefOES(plane, equation_ptr);
                }
            }
            public static unsafe void ClipPlanefOES(ClipPlaneName plane, in float equation)
            {
                fixed (float* equation_ptr = &equation)
                {
                    ClipPlanefOES(plane, equation_ptr);
                }
            }
            public static unsafe void GetClipPlanefOES(ClipPlaneName plane, Span<float> equation)
            {
                fixed (float* equation_ptr = equation)
                {
                    GetClipPlanefOES(plane, equation_ptr);
                }
            }
            public static unsafe void GetClipPlanefOES(ClipPlaneName plane, float[] equation)
            {
                fixed (float* equation_ptr = equation)
                {
                    GetClipPlanefOES(plane, equation_ptr);
                }
            }
            public static unsafe void GetClipPlanefOES(ClipPlaneName plane, ref float equation)
            {
                fixed (float* equation_ptr = &equation)
                {
                    GetClipPlanefOES(plane, equation_ptr);
                }
            }
        }
        public static unsafe partial class OVR
        {
        }
        public static unsafe partial class PGI
        {
        }
        public static unsafe partial class SGIS
        {
            public static unsafe void DetailTexFuncSGIS(TextureTarget target, ReadOnlySpan<float> points)
            {
                int n = (int)(points.Length / 2);
                fixed (float* points_ptr = points)
                {
                    DetailTexFuncSGIS(target, n, points_ptr);
                }
            }
            public static unsafe void DetailTexFuncSGIS(TextureTarget target, float[] points)
            {
                int n = (int)(points.Length / 2);
                fixed (float* points_ptr = points)
                {
                    DetailTexFuncSGIS(target, n, points_ptr);
                }
            }
            public static unsafe void DetailTexFuncSGIS(TextureTarget target, int n, in float points)
            {
                fixed (float* points_ptr = &points)
                {
                    DetailTexFuncSGIS(target, n, points_ptr);
                }
            }
            public static unsafe void GetDetailTexFuncSGIS(TextureTarget target, Span<float> points)
            {
                fixed (float* points_ptr = points)
                {
                    GetDetailTexFuncSGIS(target, points_ptr);
                }
            }
            public static unsafe void GetDetailTexFuncSGIS(TextureTarget target, float[] points)
            {
                fixed (float* points_ptr = points)
                {
                    GetDetailTexFuncSGIS(target, points_ptr);
                }
            }
            public static unsafe void GetDetailTexFuncSGIS(TextureTarget target, ref float points)
            {
                fixed (float* points_ptr = &points)
                {
                    GetDetailTexFuncSGIS(target, points_ptr);
                }
            }
            public static unsafe void FogFuncSGIS(ReadOnlySpan<float> points)
            {
                int n = (int)(points.Length / 2);
                fixed (float* points_ptr = points)
                {
                    FogFuncSGIS(n, points_ptr);
                }
            }
            public static unsafe void FogFuncSGIS(float[] points)
            {
                int n = (int)(points.Length / 2);
                fixed (float* points_ptr = points)
                {
                    FogFuncSGIS(n, points_ptr);
                }
            }
            public static unsafe void FogFuncSGIS(int n, in float points)
            {
                fixed (float* points_ptr = &points)
                {
                    FogFuncSGIS(n, points_ptr);
                }
            }
            public static unsafe void GetFogFuncSGIS(Span<float> points)
            {
                fixed (float* points_ptr = points)
                {
                    GetFogFuncSGIS(points_ptr);
                }
            }
            public static unsafe void GetFogFuncSGIS(float[] points)
            {
                fixed (float* points_ptr = points)
                {
                    GetFogFuncSGIS(points_ptr);
                }
            }
            public static unsafe void GetFogFuncSGIS(ref float points)
            {
                fixed (float* points_ptr = &points)
                {
                    GetFogFuncSGIS(points_ptr);
                }
            }
            public static unsafe void SampleMaskSGIS(float value, bool invert)
            {
                byte invert_byte = (byte)(invert ? 1 : 0);
                SampleMaskSGIS(value, invert_byte);
            }
            public static unsafe void PixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    PixelTexGenParameterivSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void PixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    PixelTexGenParameterivSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void PixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    PixelTexGenParameterivSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void PixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    PixelTexGenParameterfvSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void PixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    PixelTexGenParameterfvSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void PixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    PixelTexGenParameterfvSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void GetPixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetPixelTexGenParameterivSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void GetPixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetPixelTexGenParameterivSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void GetPixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetPixelTexGenParameterivSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void GetPixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetPixelTexGenParameterfvSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void GetPixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetPixelTexGenParameterfvSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void GetPixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetPixelTexGenParameterfvSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void PointParameterfvSGIS(PointParameterNameARB pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    PointParameterfvSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void PointParameterfvSGIS(PointParameterNameARB pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    PointParameterfvSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void PointParameterfvSGIS(PointParameterNameARB pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    PointParameterfvSGIS(pname, parameters_ptr);
                }
            }
            public static unsafe void SharpenTexFuncSGIS(TextureTarget target, ReadOnlySpan<float> points)
            {
                int n = (int)(points.Length / 2);
                fixed (float* points_ptr = points)
                {
                    SharpenTexFuncSGIS(target, n, points_ptr);
                }
            }
            public static unsafe void SharpenTexFuncSGIS(TextureTarget target, float[] points)
            {
                int n = (int)(points.Length / 2);
                fixed (float* points_ptr = points)
                {
                    SharpenTexFuncSGIS(target, n, points_ptr);
                }
            }
            public static unsafe void SharpenTexFuncSGIS(TextureTarget target, int n, in float points)
            {
                fixed (float* points_ptr = &points)
                {
                    SharpenTexFuncSGIS(target, n, points_ptr);
                }
            }
            public static unsafe void GetSharpenTexFuncSGIS(TextureTarget target, Span<float> points)
            {
                fixed (float* points_ptr = points)
                {
                    GetSharpenTexFuncSGIS(target, points_ptr);
                }
            }
            public static unsafe void GetSharpenTexFuncSGIS(TextureTarget target, float[] points)
            {
                fixed (float* points_ptr = points)
                {
                    GetSharpenTexFuncSGIS(target, points_ptr);
                }
            }
            public static unsafe void GetSharpenTexFuncSGIS(TextureTarget target, ref float points)
            {
                fixed (float* points_ptr = &points)
                {
                    GetSharpenTexFuncSGIS(target, points_ptr);
                }
            }
            public static unsafe void TexImage4DSGIS(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int size4d, int border, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels_vptr);
            }
            public static unsafe void TexImage4DSGIS<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int size4d, int border, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexImage4DSGIS<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int size4d, int border, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexImage4DSGIS<T1>(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int size4d, int border, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexSubImage4DSGIS(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, PixelFormat format, PixelType type, IntPtr pixels)
            {
                void* pixels_vptr = (void*)pixels;
                TexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels_vptr);
            }
            public static unsafe void TexSubImage4DSGIS<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, PixelFormat format, PixelType type, ReadOnlySpan<T1> pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexSubImage4DSGIS<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, PixelFormat format, PixelType type, T1[] pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = pixels)
                {
                    TexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels_ptr);
                }
            }
            public static unsafe void TexSubImage4DSGIS<T1>(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, PixelFormat format, PixelType type, in T1 pixels)
                where T1 : unmanaged
            {
                fixed (void* pixels_ptr = &pixels)
                {
                    TexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels_ptr);
                }
            }
            public static unsafe void TextureColorMaskSGIS(bool red, bool green, bool blue, bool alpha)
            {
                byte red_byte = (byte)(red ? 1 : 0);
                byte green_byte = (byte)(green ? 1 : 0);
                byte blue_byte = (byte)(blue ? 1 : 0);
                byte alpha_byte = (byte)(alpha ? 1 : 0);
                TextureColorMaskSGIS(red_byte, green_byte, blue_byte, alpha_byte);
            }
            public static unsafe void GetTexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, Span<float> weights)
            {
                fixed (float* weights_ptr = weights)
                {
                    GetTexFilterFuncSGIS(target, filter, weights_ptr);
                }
            }
            public static unsafe void GetTexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, float[] weights)
            {
                fixed (float* weights_ptr = weights)
                {
                    GetTexFilterFuncSGIS(target, filter, weights_ptr);
                }
            }
            public static unsafe void GetTexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, ref float weights)
            {
                fixed (float* weights_ptr = &weights)
                {
                    GetTexFilterFuncSGIS(target, filter, weights_ptr);
                }
            }
            public static unsafe void TexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, ReadOnlySpan<float> weights)
            {
                int n = (int)(weights.Length);
                fixed (float* weights_ptr = weights)
                {
                    TexFilterFuncSGIS(target, filter, n, weights_ptr);
                }
            }
            public static unsafe void TexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, float[] weights)
            {
                int n = (int)(weights.Length);
                fixed (float* weights_ptr = weights)
                {
                    TexFilterFuncSGIS(target, filter, n, weights_ptr);
                }
            }
            public static unsafe void TexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, int n, in float weights)
            {
                fixed (float* weights_ptr = &weights)
                {
                    TexFilterFuncSGIS(target, filter, n, weights_ptr);
                }
            }
        }
        public static unsafe partial class SGIX
        {
            public static unsafe int FinishAsyncSGIX(Span<uint> markerp)
            {
                int returnValue;
                fixed (uint* markerp_ptr = markerp)
                {
                    returnValue = FinishAsyncSGIX(markerp_ptr);
                }
                return returnValue;
            }
            public static unsafe int FinishAsyncSGIX(uint[] markerp)
            {
                int returnValue;
                fixed (uint* markerp_ptr = markerp)
                {
                    returnValue = FinishAsyncSGIX(markerp_ptr);
                }
                return returnValue;
            }
            public static unsafe int FinishAsyncSGIX(ref uint markerp)
            {
                int returnValue;
                fixed (uint* markerp_ptr = &markerp)
                {
                    returnValue = FinishAsyncSGIX(markerp_ptr);
                }
                return returnValue;
            }
            public static unsafe int PollAsyncSGIX(Span<uint> markerp)
            {
                int returnValue;
                fixed (uint* markerp_ptr = markerp)
                {
                    returnValue = PollAsyncSGIX(markerp_ptr);
                }
                return returnValue;
            }
            public static unsafe int PollAsyncSGIX(uint[] markerp)
            {
                int returnValue;
                fixed (uint* markerp_ptr = markerp)
                {
                    returnValue = PollAsyncSGIX(markerp_ptr);
                }
                return returnValue;
            }
            public static unsafe int PollAsyncSGIX(ref uint markerp)
            {
                int returnValue;
                fixed (uint* markerp_ptr = &markerp)
                {
                    returnValue = PollAsyncSGIX(markerp_ptr);
                }
                return returnValue;
            }
            public static unsafe void FragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    FragmentLightfvSGIX(light, pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    FragmentLightfvSGIX(light, pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    FragmentLightfvSGIX(light, pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    FragmentLightivSGIX(light, pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    FragmentLightivSGIX(light, pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    FragmentLightivSGIX(light, pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentLightModelfvSGIX(FragmentLightModelParameterSGIX pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    FragmentLightModelfvSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentLightModelfvSGIX(FragmentLightModelParameterSGIX pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    FragmentLightModelfvSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentLightModelfvSGIX(FragmentLightModelParameterSGIX pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    FragmentLightModelfvSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentLightModelivSGIX(FragmentLightModelParameterSGIX pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    FragmentLightModelivSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentLightModelivSGIX(FragmentLightModelParameterSGIX pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    FragmentLightModelivSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentLightModelivSGIX(FragmentLightModelParameterSGIX pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    FragmentLightModelivSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    FragmentMaterialfvSGIX(face, pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    FragmentMaterialfvSGIX(face, pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    FragmentMaterialfvSGIX(face, pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    FragmentMaterialivSGIX(face, pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    FragmentMaterialivSGIX(face, pname, parameters_ptr);
                }
            }
            public static unsafe void FragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    FragmentMaterialivSGIX(face, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetFragmentLightfvSGIX(light, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetFragmentLightfvSGIX(light, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetFragmentLightfvSGIX(light, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFragmentLightivSGIX(light, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFragmentLightivSGIX(light, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetFragmentLightivSGIX(light, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetFragmentMaterialfvSGIX(face, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetFragmentMaterialfvSGIX(face, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetFragmentMaterialfvSGIX(face, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFragmentMaterialivSGIX(face, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetFragmentMaterialivSGIX(face, pname, parameters_ptr);
                }
            }
            public static unsafe void GetFragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetFragmentMaterialivSGIX(face, pname, parameters_ptr);
                }
            }
            public static unsafe void IglooInterfaceSGIX(All pname, IntPtr parameters)
            {
                void* parameters_vptr = (void*)parameters;
                IglooInterfaceSGIX(pname, parameters_vptr);
            }
            public static unsafe void IglooInterfaceSGIX<T1>(All pname, ReadOnlySpan<T1> parameters)
                where T1 : unmanaged
            {
                fixed (void* parameters_ptr = parameters)
                {
                    IglooInterfaceSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void IglooInterfaceSGIX<T1>(All pname, T1[] parameters)
                where T1 : unmanaged
            {
                fixed (void* parameters_ptr = parameters)
                {
                    IglooInterfaceSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void IglooInterfaceSGIX<T1>(All pname, in T1 parameters)
                where T1 : unmanaged
            {
                fixed (void* parameters_ptr = &parameters)
                {
                    IglooInterfaceSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void InstrumentsBufferSGIX(Span<int> buffer)
            {
                int size = (int)(buffer.Length);
                fixed (int* buffer_ptr = buffer)
                {
                    InstrumentsBufferSGIX(size, buffer_ptr);
                }
            }
            public static unsafe void InstrumentsBufferSGIX(int[] buffer)
            {
                int size = (int)(buffer.Length);
                fixed (int* buffer_ptr = buffer)
                {
                    InstrumentsBufferSGIX(size, buffer_ptr);
                }
            }
            public static unsafe void InstrumentsBufferSGIX(int size, ref int buffer)
            {
                fixed (int* buffer_ptr = &buffer)
                {
                    InstrumentsBufferSGIX(size, buffer_ptr);
                }
            }
            public static unsafe int PollInstrumentsSGIX(Span<int> marker_p)
            {
                int returnValue;
                fixed (int* marker_p_ptr = marker_p)
                {
                    returnValue = PollInstrumentsSGIX(marker_p_ptr);
                }
                return returnValue;
            }
            public static unsafe int PollInstrumentsSGIX(int[] marker_p)
            {
                int returnValue;
                fixed (int* marker_p_ptr = marker_p)
                {
                    returnValue = PollInstrumentsSGIX(marker_p_ptr);
                }
                return returnValue;
            }
            public static unsafe int PollInstrumentsSGIX(ref int marker_p)
            {
                int returnValue;
                fixed (int* marker_p_ptr = &marker_p)
                {
                    returnValue = PollInstrumentsSGIX(marker_p_ptr);
                }
                return returnValue;
            }
            public static unsafe void GetListParameterfvSGIX(uint list, ListParameterName pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetListParameterfvSGIX(list, pname, parameters_ptr);
                }
            }
            public static unsafe void GetListParameterfvSGIX(uint list, ListParameterName pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetListParameterfvSGIX(list, pname, parameters_ptr);
                }
            }
            public static unsafe void GetListParameterfvSGIX(uint list, ListParameterName pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetListParameterfvSGIX(list, pname, parameters_ptr);
                }
            }
            public static unsafe void GetListParameterivSGIX(uint list, ListParameterName pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetListParameterivSGIX(list, pname, parameters_ptr);
                }
            }
            public static unsafe void GetListParameterivSGIX(uint list, ListParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetListParameterivSGIX(list, pname, parameters_ptr);
                }
            }
            public static unsafe void GetListParameterivSGIX(uint list, ListParameterName pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetListParameterivSGIX(list, pname, parameters_ptr);
                }
            }
            public static unsafe void ListParameterfvSGIX(uint list, ListParameterName pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ListParameterfvSGIX(list, pname, parameters_ptr);
                }
            }
            public static unsafe void ListParameterfvSGIX(uint list, ListParameterName pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ListParameterfvSGIX(list, pname, parameters_ptr);
                }
            }
            public static unsafe void ListParameterfvSGIX(uint list, ListParameterName pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    ListParameterfvSGIX(list, pname, parameters_ptr);
                }
            }
            public static unsafe void ListParameterivSGIX(uint list, ListParameterName pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ListParameterivSGIX(list, pname, parameters_ptr);
                }
            }
            public static unsafe void ListParameterivSGIX(uint list, ListParameterName pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ListParameterivSGIX(list, pname, parameters_ptr);
                }
            }
            public static unsafe void ListParameterivSGIX(uint list, ListParameterName pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    ListParameterivSGIX(list, pname, parameters_ptr);
                }
            }
            public static unsafe void DeformationMap3dSGIX(FfdTargetSGIX target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, ReadOnlySpan<double> points)
            {
                fixed (double* points_ptr = points)
                {
                    DeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points_ptr);
                }
            }
            public static unsafe void DeformationMap3dSGIX(FfdTargetSGIX target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, double[] points)
            {
                fixed (double* points_ptr = points)
                {
                    DeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points_ptr);
                }
            }
            public static unsafe void DeformationMap3dSGIX(FfdTargetSGIX target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, in double points)
            {
                fixed (double* points_ptr = &points)
                {
                    DeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points_ptr);
                }
            }
            public static unsafe void DeformationMap3fSGIX(FfdTargetSGIX target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, ReadOnlySpan<float> points)
            {
                fixed (float* points_ptr = points)
                {
                    DeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points_ptr);
                }
            }
            public static unsafe void DeformationMap3fSGIX(FfdTargetSGIX target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, float[] points)
            {
                fixed (float* points_ptr = points)
                {
                    DeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points_ptr);
                }
            }
            public static unsafe void DeformationMap3fSGIX(FfdTargetSGIX target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, in float points)
            {
                fixed (float* points_ptr = &points)
                {
                    DeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points_ptr);
                }
            }
            public static unsafe void ReferencePlaneSGIX(ReadOnlySpan<double> equation)
            {
                fixed (double* equation_ptr = equation)
                {
                    ReferencePlaneSGIX(equation_ptr);
                }
            }
            public static unsafe void ReferencePlaneSGIX(double[] equation)
            {
                fixed (double* equation_ptr = equation)
                {
                    ReferencePlaneSGIX(equation_ptr);
                }
            }
            public static unsafe void ReferencePlaneSGIX(in double equation)
            {
                fixed (double* equation_ptr = &equation)
                {
                    ReferencePlaneSGIX(equation_ptr);
                }
            }
            public static unsafe void SpriteParameterfvSGIX(SpriteParameterNameSGIX pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    SpriteParameterfvSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void SpriteParameterfvSGIX(SpriteParameterNameSGIX pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    SpriteParameterfvSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void SpriteParameterfvSGIX(SpriteParameterNameSGIX pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    SpriteParameterfvSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void SpriteParameterivSGIX(SpriteParameterNameSGIX pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    SpriteParameterivSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void SpriteParameterivSGIX(SpriteParameterNameSGIX pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    SpriteParameterivSGIX(pname, parameters_ptr);
                }
            }
            public static unsafe void SpriteParameterivSGIX(SpriteParameterNameSGIX pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    SpriteParameterivSGIX(pname, parameters_ptr);
                }
            }
        }
        public static unsafe partial class SGI
        {
            public static unsafe void ColorTableSGI(ColorTableTargetSGI target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, IntPtr table)
            {
                void* table_vptr = (void*)table;
                ColorTableSGI(target, internalformat, width, format, type, table_vptr);
            }
            public static unsafe void ColorTableSGI<T1>(ColorTableTargetSGI target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, ReadOnlySpan<T1> table)
                where T1 : unmanaged
            {
                fixed (void* table_ptr = table)
                {
                    ColorTableSGI(target, internalformat, width, format, type, table_ptr);
                }
            }
            public static unsafe void ColorTableSGI<T1>(ColorTableTargetSGI target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, T1[] table)
                where T1 : unmanaged
            {
                fixed (void* table_ptr = table)
                {
                    ColorTableSGI(target, internalformat, width, format, type, table_ptr);
                }
            }
            public static unsafe void ColorTableSGI<T1>(ColorTableTargetSGI target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, in T1 table)
                where T1 : unmanaged
            {
                fixed (void* table_ptr = &table)
                {
                    ColorTableSGI(target, internalformat, width, format, type, table_ptr);
                }
            }
            public static unsafe void ColorTableParameterfvSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, ReadOnlySpan<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ColorTableParameterfvSGI(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ColorTableParameterfvSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    ColorTableParameterfvSGI(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ColorTableParameterfvSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, in float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    ColorTableParameterfvSGI(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ColorTableParameterivSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, ReadOnlySpan<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ColorTableParameterivSGI(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ColorTableParameterivSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    ColorTableParameterivSGI(target, pname, parameters_ptr);
                }
            }
            public static unsafe void ColorTableParameterivSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, in int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    ColorTableParameterivSGI(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetColorTableSGI(ColorTableTargetSGI target, PixelFormat format, PixelType type, IntPtr table)
            {
                void* table_vptr = (void*)table;
                GetColorTableSGI(target, format, type, table_vptr);
            }
            public static unsafe void GetColorTableSGI<T1>(ColorTableTargetSGI target, PixelFormat format, PixelType type, Span<T1> table)
                where T1 : unmanaged
            {
                fixed (void* table_ptr = table)
                {
                    GetColorTableSGI(target, format, type, table_ptr);
                }
            }
            public static unsafe void GetColorTableSGI<T1>(ColorTableTargetSGI target, PixelFormat format, PixelType type, T1[] table)
                where T1 : unmanaged
            {
                fixed (void* table_ptr = table)
                {
                    GetColorTableSGI(target, format, type, table_ptr);
                }
            }
            public static unsafe void GetColorTableSGI<T1>(ColorTableTargetSGI target, PixelFormat format, PixelType type, ref T1 table)
                where T1 : unmanaged
            {
                fixed (void* table_ptr = &table)
                {
                    GetColorTableSGI(target, format, type, table_ptr);
                }
            }
            public static unsafe void GetColorTableParameterfvSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, Span<float> parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetColorTableParameterfvSGI(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetColorTableParameterfvSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, float[] parameters)
            {
                fixed (float* parameters_ptr = parameters)
                {
                    GetColorTableParameterfvSGI(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetColorTableParameterfvSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, ref float parameters)
            {
                fixed (float* parameters_ptr = &parameters)
                {
                    GetColorTableParameterfvSGI(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetColorTableParameterivSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, Span<int> parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetColorTableParameterivSGI(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetColorTableParameterivSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, int[] parameters)
            {
                fixed (int* parameters_ptr = parameters)
                {
                    GetColorTableParameterivSGI(target, pname, parameters_ptr);
                }
            }
            public static unsafe void GetColorTableParameterivSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, ref int parameters)
            {
                fixed (int* parameters_ptr = &parameters)
                {
                    GetColorTableParameterivSGI(target, pname, parameters_ptr);
                }
            }
        }
        public static unsafe partial class SUNX
        {
        }
        public static unsafe partial class SUN
        {
            public static unsafe void ReplacementCodeuivSUN(ReadOnlySpan<uint> code)
            {
                fixed (uint* code_ptr = code)
                {
                    ReplacementCodeuivSUN(code_ptr);
                }
            }
            public static unsafe void ReplacementCodeuivSUN(uint[] code)
            {
                fixed (uint* code_ptr = code)
                {
                    ReplacementCodeuivSUN(code_ptr);
                }
            }
            public static unsafe void ReplacementCodeuivSUN(in uint code)
            {
                fixed (uint* code_ptr = &code)
                {
                    ReplacementCodeuivSUN(code_ptr);
                }
            }
            public static unsafe void ReplacementCodeusvSUN(ReadOnlySpan<ushort> code)
            {
                fixed (ushort* code_ptr = code)
                {
                    ReplacementCodeusvSUN(code_ptr);
                }
            }
            public static unsafe void ReplacementCodeusvSUN(ushort[] code)
            {
                fixed (ushort* code_ptr = code)
                {
                    ReplacementCodeusvSUN(code_ptr);
                }
            }
            public static unsafe void ReplacementCodeusvSUN(in ushort code)
            {
                fixed (ushort* code_ptr = &code)
                {
                    ReplacementCodeusvSUN(code_ptr);
                }
            }
            public static unsafe void ReplacementCodeubvSUN(ReadOnlySpan<byte> code)
            {
                fixed (byte* code_ptr = code)
                {
                    ReplacementCodeubvSUN(code_ptr);
                }
            }
            public static unsafe void ReplacementCodeubvSUN(byte[] code)
            {
                fixed (byte* code_ptr = code)
                {
                    ReplacementCodeubvSUN(code_ptr);
                }
            }
            public static unsafe void ReplacementCodeubvSUN(in byte code)
            {
                fixed (byte* code_ptr = &code)
                {
                    ReplacementCodeubvSUN(code_ptr);
                }
            }
            public static unsafe void Color4ubVertex2fvSUN(ReadOnlySpan<byte> c, ReadOnlySpan<float> v)
            {
                fixed (byte* c_ptr = c)
                {
                    fixed (float* v_ptr = v)
                    {
                        Color4ubVertex2fvSUN(c_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void Color4ubVertex2fvSUN(byte[] c, float[] v)
            {
                fixed (byte* c_ptr = c)
                {
                    fixed (float* v_ptr = v)
                    {
                        Color4ubVertex2fvSUN(c_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void Color4ubVertex2fvSUN(in byte c, in float v)
            {
                fixed (byte* c_ptr = &c)
                fixed (float* v_ptr = &v)
                {
                    Color4ubVertex2fvSUN(c_ptr, v_ptr);
                }
            }
            public static unsafe void Color4ubVertex3fvSUN(ReadOnlySpan<byte> c, ReadOnlySpan<float> v)
            {
                fixed (byte* c_ptr = c)
                {
                    fixed (float* v_ptr = v)
                    {
                        Color4ubVertex3fvSUN(c_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void Color4ubVertex3fvSUN(byte[] c, float[] v)
            {
                fixed (byte* c_ptr = c)
                {
                    fixed (float* v_ptr = v)
                    {
                        Color4ubVertex3fvSUN(c_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void Color4ubVertex3fvSUN(in byte c, in float v)
            {
                fixed (byte* c_ptr = &c)
                fixed (float* v_ptr = &v)
                {
                    Color4ubVertex3fvSUN(c_ptr, v_ptr);
                }
            }
            public static unsafe void Color3fVertex3fvSUN(ReadOnlySpan<float> c, ReadOnlySpan<float> v)
            {
                fixed (float* c_ptr = c)
                {
                    fixed (float* v_ptr = v)
                    {
                        Color3fVertex3fvSUN(c_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void Color3fVertex3fvSUN(float[] c, float[] v)
            {
                fixed (float* c_ptr = c)
                {
                    fixed (float* v_ptr = v)
                    {
                        Color3fVertex3fvSUN(c_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void Color3fVertex3fvSUN(in float c, in float v)
            {
                fixed (float* c_ptr = &c)
                fixed (float* v_ptr = &v)
                {
                    Color3fVertex3fvSUN(c_ptr, v_ptr);
                }
            }
            public static unsafe void Normal3fVertex3fvSUN(ReadOnlySpan<float> n, ReadOnlySpan<float> v)
            {
                fixed (float* n_ptr = n)
                {
                    fixed (float* v_ptr = v)
                    {
                        Normal3fVertex3fvSUN(n_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void Normal3fVertex3fvSUN(float[] n, float[] v)
            {
                fixed (float* n_ptr = n)
                {
                    fixed (float* v_ptr = v)
                    {
                        Normal3fVertex3fvSUN(n_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void Normal3fVertex3fvSUN(in float n, in float v)
            {
                fixed (float* n_ptr = &n)
                fixed (float* v_ptr = &v)
                {
                    Normal3fVertex3fvSUN(n_ptr, v_ptr);
                }
            }
            public static unsafe void Color4fNormal3fVertex3fvSUN(ReadOnlySpan<float> c, ReadOnlySpan<float> n, ReadOnlySpan<float> v)
            {
                fixed (float* c_ptr = c)
                {
                    fixed (float* n_ptr = n)
                    {
                        fixed (float* v_ptr = v)
                        {
                            Color4fNormal3fVertex3fvSUN(c_ptr, n_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void Color4fNormal3fVertex3fvSUN(float[] c, float[] n, float[] v)
            {
                fixed (float* c_ptr = c)
                {
                    fixed (float* n_ptr = n)
                    {
                        fixed (float* v_ptr = v)
                        {
                            Color4fNormal3fVertex3fvSUN(c_ptr, n_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void Color4fNormal3fVertex3fvSUN(in float c, in float n, in float v)
            {
                fixed (float* c_ptr = &c)
                fixed (float* n_ptr = &n)
                fixed (float* v_ptr = &v)
                {
                    Color4fNormal3fVertex3fvSUN(c_ptr, n_ptr, v_ptr);
                }
            }
            public static unsafe void TexCoord2fVertex3fvSUN(ReadOnlySpan<float> tc, ReadOnlySpan<float> v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (float* v_ptr = v)
                    {
                        TexCoord2fVertex3fvSUN(tc_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void TexCoord2fVertex3fvSUN(float[] tc, float[] v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (float* v_ptr = v)
                    {
                        TexCoord2fVertex3fvSUN(tc_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void TexCoord2fVertex3fvSUN(in float tc, in float v)
            {
                fixed (float* tc_ptr = &tc)
                fixed (float* v_ptr = &v)
                {
                    TexCoord2fVertex3fvSUN(tc_ptr, v_ptr);
                }
            }
            public static unsafe void TexCoord4fVertex4fvSUN(ReadOnlySpan<float> tc, ReadOnlySpan<float> v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (float* v_ptr = v)
                    {
                        TexCoord4fVertex4fvSUN(tc_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void TexCoord4fVertex4fvSUN(float[] tc, float[] v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (float* v_ptr = v)
                    {
                        TexCoord4fVertex4fvSUN(tc_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void TexCoord4fVertex4fvSUN(in float tc, in float v)
            {
                fixed (float* tc_ptr = &tc)
                fixed (float* v_ptr = &v)
                {
                    TexCoord4fVertex4fvSUN(tc_ptr, v_ptr);
                }
            }
            public static unsafe void TexCoord2fColor4ubVertex3fvSUN(ReadOnlySpan<float> tc, ReadOnlySpan<byte> c, ReadOnlySpan<float> v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (byte* c_ptr = c)
                    {
                        fixed (float* v_ptr = v)
                        {
                            TexCoord2fColor4ubVertex3fvSUN(tc_ptr, c_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void TexCoord2fColor4ubVertex3fvSUN(float[] tc, byte[] c, float[] v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (byte* c_ptr = c)
                    {
                        fixed (float* v_ptr = v)
                        {
                            TexCoord2fColor4ubVertex3fvSUN(tc_ptr, c_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void TexCoord2fColor4ubVertex3fvSUN(in float tc, in byte c, in float v)
            {
                fixed (float* tc_ptr = &tc)
                fixed (byte* c_ptr = &c)
                fixed (float* v_ptr = &v)
                {
                    TexCoord2fColor4ubVertex3fvSUN(tc_ptr, c_ptr, v_ptr);
                }
            }
            public static unsafe void TexCoord2fColor3fVertex3fvSUN(ReadOnlySpan<float> tc, ReadOnlySpan<float> c, ReadOnlySpan<float> v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (float* c_ptr = c)
                    {
                        fixed (float* v_ptr = v)
                        {
                            TexCoord2fColor3fVertex3fvSUN(tc_ptr, c_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void TexCoord2fColor3fVertex3fvSUN(float[] tc, float[] c, float[] v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (float* c_ptr = c)
                    {
                        fixed (float* v_ptr = v)
                        {
                            TexCoord2fColor3fVertex3fvSUN(tc_ptr, c_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void TexCoord2fColor3fVertex3fvSUN(in float tc, in float c, in float v)
            {
                fixed (float* tc_ptr = &tc)
                fixed (float* c_ptr = &c)
                fixed (float* v_ptr = &v)
                {
                    TexCoord2fColor3fVertex3fvSUN(tc_ptr, c_ptr, v_ptr);
                }
            }
            public static unsafe void TexCoord2fNormal3fVertex3fvSUN(ReadOnlySpan<float> tc, ReadOnlySpan<float> n, ReadOnlySpan<float> v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (float* n_ptr = n)
                    {
                        fixed (float* v_ptr = v)
                        {
                            TexCoord2fNormal3fVertex3fvSUN(tc_ptr, n_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void TexCoord2fNormal3fVertex3fvSUN(float[] tc, float[] n, float[] v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (float* n_ptr = n)
                    {
                        fixed (float* v_ptr = v)
                        {
                            TexCoord2fNormal3fVertex3fvSUN(tc_ptr, n_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void TexCoord2fNormal3fVertex3fvSUN(in float tc, in float n, in float v)
            {
                fixed (float* tc_ptr = &tc)
                fixed (float* n_ptr = &n)
                fixed (float* v_ptr = &v)
                {
                    TexCoord2fNormal3fVertex3fvSUN(tc_ptr, n_ptr, v_ptr);
                }
            }
            public static unsafe void TexCoord2fColor4fNormal3fVertex3fvSUN(ReadOnlySpan<float> tc, ReadOnlySpan<float> c, ReadOnlySpan<float> n, ReadOnlySpan<float> v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (float* c_ptr = c)
                    {
                        fixed (float* n_ptr = n)
                        {
                            fixed (float* v_ptr = v)
                            {
                                TexCoord2fColor4fNormal3fVertex3fvSUN(tc_ptr, c_ptr, n_ptr, v_ptr);
                            }
                        }
                    }
                }
            }
            public static unsafe void TexCoord2fColor4fNormal3fVertex3fvSUN(float[] tc, float[] c, float[] n, float[] v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (float* c_ptr = c)
                    {
                        fixed (float* n_ptr = n)
                        {
                            fixed (float* v_ptr = v)
                            {
                                TexCoord2fColor4fNormal3fVertex3fvSUN(tc_ptr, c_ptr, n_ptr, v_ptr);
                            }
                        }
                    }
                }
            }
            public static unsafe void TexCoord2fColor4fNormal3fVertex3fvSUN(in float tc, in float c, in float n, in float v)
            {
                fixed (float* tc_ptr = &tc)
                fixed (float* c_ptr = &c)
                fixed (float* n_ptr = &n)
                fixed (float* v_ptr = &v)
                {
                    TexCoord2fColor4fNormal3fVertex3fvSUN(tc_ptr, c_ptr, n_ptr, v_ptr);
                }
            }
            public static unsafe void TexCoord4fColor4fNormal3fVertex4fvSUN(ReadOnlySpan<float> tc, ReadOnlySpan<float> c, ReadOnlySpan<float> n, ReadOnlySpan<float> v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (float* c_ptr = c)
                    {
                        fixed (float* n_ptr = n)
                        {
                            fixed (float* v_ptr = v)
                            {
                                TexCoord4fColor4fNormal3fVertex4fvSUN(tc_ptr, c_ptr, n_ptr, v_ptr);
                            }
                        }
                    }
                }
            }
            public static unsafe void TexCoord4fColor4fNormal3fVertex4fvSUN(float[] tc, float[] c, float[] n, float[] v)
            {
                fixed (float* tc_ptr = tc)
                {
                    fixed (float* c_ptr = c)
                    {
                        fixed (float* n_ptr = n)
                        {
                            fixed (float* v_ptr = v)
                            {
                                TexCoord4fColor4fNormal3fVertex4fvSUN(tc_ptr, c_ptr, n_ptr, v_ptr);
                            }
                        }
                    }
                }
            }
            public static unsafe void TexCoord4fColor4fNormal3fVertex4fvSUN(in float tc, in float c, in float n, in float v)
            {
                fixed (float* tc_ptr = &tc)
                fixed (float* c_ptr = &c)
                fixed (float* n_ptr = &n)
                fixed (float* v_ptr = &v)
                {
                    TexCoord4fColor4fNormal3fVertex4fvSUN(tc_ptr, c_ptr, n_ptr, v_ptr);
                }
            }
            public static unsafe void ReplacementCodeuiVertex3fvSUN(ReadOnlySpan<uint> rc, ReadOnlySpan<float> v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* v_ptr = v)
                    {
                        ReplacementCodeuiVertex3fvSUN(rc_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void ReplacementCodeuiVertex3fvSUN(uint[] rc, float[] v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* v_ptr = v)
                    {
                        ReplacementCodeuiVertex3fvSUN(rc_ptr, v_ptr);
                    }
                }
            }
            public static unsafe void ReplacementCodeuiVertex3fvSUN(in uint rc, in float v)
            {
                fixed (uint* rc_ptr = &rc)
                fixed (float* v_ptr = &v)
                {
                    ReplacementCodeuiVertex3fvSUN(rc_ptr, v_ptr);
                }
            }
            public static unsafe void ReplacementCodeuiColor4ubVertex3fvSUN(ReadOnlySpan<uint> rc, ReadOnlySpan<byte> c, ReadOnlySpan<float> v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (byte* c_ptr = c)
                    {
                        fixed (float* v_ptr = v)
                        {
                            ReplacementCodeuiColor4ubVertex3fvSUN(rc_ptr, c_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiColor4ubVertex3fvSUN(uint[] rc, byte[] c, float[] v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (byte* c_ptr = c)
                    {
                        fixed (float* v_ptr = v)
                        {
                            ReplacementCodeuiColor4ubVertex3fvSUN(rc_ptr, c_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiColor4ubVertex3fvSUN(in uint rc, in byte c, in float v)
            {
                fixed (uint* rc_ptr = &rc)
                fixed (byte* c_ptr = &c)
                fixed (float* v_ptr = &v)
                {
                    ReplacementCodeuiColor4ubVertex3fvSUN(rc_ptr, c_ptr, v_ptr);
                }
            }
            public static unsafe void ReplacementCodeuiColor3fVertex3fvSUN(ReadOnlySpan<uint> rc, ReadOnlySpan<float> c, ReadOnlySpan<float> v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* c_ptr = c)
                    {
                        fixed (float* v_ptr = v)
                        {
                            ReplacementCodeuiColor3fVertex3fvSUN(rc_ptr, c_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiColor3fVertex3fvSUN(uint[] rc, float[] c, float[] v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* c_ptr = c)
                    {
                        fixed (float* v_ptr = v)
                        {
                            ReplacementCodeuiColor3fVertex3fvSUN(rc_ptr, c_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiColor3fVertex3fvSUN(in uint rc, in float c, in float v)
            {
                fixed (uint* rc_ptr = &rc)
                fixed (float* c_ptr = &c)
                fixed (float* v_ptr = &v)
                {
                    ReplacementCodeuiColor3fVertex3fvSUN(rc_ptr, c_ptr, v_ptr);
                }
            }
            public static unsafe void ReplacementCodeuiNormal3fVertex3fvSUN(ReadOnlySpan<uint> rc, ReadOnlySpan<float> n, ReadOnlySpan<float> v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* n_ptr = n)
                    {
                        fixed (float* v_ptr = v)
                        {
                            ReplacementCodeuiNormal3fVertex3fvSUN(rc_ptr, n_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiNormal3fVertex3fvSUN(uint[] rc, float[] n, float[] v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* n_ptr = n)
                    {
                        fixed (float* v_ptr = v)
                        {
                            ReplacementCodeuiNormal3fVertex3fvSUN(rc_ptr, n_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiNormal3fVertex3fvSUN(in uint rc, in float n, in float v)
            {
                fixed (uint* rc_ptr = &rc)
                fixed (float* n_ptr = &n)
                fixed (float* v_ptr = &v)
                {
                    ReplacementCodeuiNormal3fVertex3fvSUN(rc_ptr, n_ptr, v_ptr);
                }
            }
            public static unsafe void ReplacementCodeuiColor4fNormal3fVertex3fvSUN(ReadOnlySpan<uint> rc, ReadOnlySpan<float> c, ReadOnlySpan<float> n, ReadOnlySpan<float> v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* c_ptr = c)
                    {
                        fixed (float* n_ptr = n)
                        {
                            fixed (float* v_ptr = v)
                            {
                                ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc_ptr, c_ptr, n_ptr, v_ptr);
                            }
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiColor4fNormal3fVertex3fvSUN(uint[] rc, float[] c, float[] n, float[] v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* c_ptr = c)
                    {
                        fixed (float* n_ptr = n)
                        {
                            fixed (float* v_ptr = v)
                            {
                                ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc_ptr, c_ptr, n_ptr, v_ptr);
                            }
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiColor4fNormal3fVertex3fvSUN(in uint rc, in float c, in float n, in float v)
            {
                fixed (uint* rc_ptr = &rc)
                fixed (float* c_ptr = &c)
                fixed (float* n_ptr = &n)
                fixed (float* v_ptr = &v)
                {
                    ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc_ptr, c_ptr, n_ptr, v_ptr);
                }
            }
            public static unsafe void ReplacementCodeuiTexCoord2fVertex3fvSUN(ReadOnlySpan<uint> rc, ReadOnlySpan<float> tc, ReadOnlySpan<float> v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* tc_ptr = tc)
                    {
                        fixed (float* v_ptr = v)
                        {
                            ReplacementCodeuiTexCoord2fVertex3fvSUN(rc_ptr, tc_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiTexCoord2fVertex3fvSUN(uint[] rc, float[] tc, float[] v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* tc_ptr = tc)
                    {
                        fixed (float* v_ptr = v)
                        {
                            ReplacementCodeuiTexCoord2fVertex3fvSUN(rc_ptr, tc_ptr, v_ptr);
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiTexCoord2fVertex3fvSUN(in uint rc, in float tc, in float v)
            {
                fixed (uint* rc_ptr = &rc)
                fixed (float* tc_ptr = &tc)
                fixed (float* v_ptr = &v)
                {
                    ReplacementCodeuiTexCoord2fVertex3fvSUN(rc_ptr, tc_ptr, v_ptr);
                }
            }
            public static unsafe void ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(ReadOnlySpan<uint> rc, ReadOnlySpan<float> tc, ReadOnlySpan<float> n, ReadOnlySpan<float> v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* tc_ptr = tc)
                    {
                        fixed (float* n_ptr = n)
                        {
                            fixed (float* v_ptr = v)
                            {
                                ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc_ptr, tc_ptr, n_ptr, v_ptr);
                            }
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(uint[] rc, float[] tc, float[] n, float[] v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* tc_ptr = tc)
                    {
                        fixed (float* n_ptr = n)
                        {
                            fixed (float* v_ptr = v)
                            {
                                ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc_ptr, tc_ptr, n_ptr, v_ptr);
                            }
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(in uint rc, in float tc, in float n, in float v)
            {
                fixed (uint* rc_ptr = &rc)
                fixed (float* tc_ptr = &tc)
                fixed (float* n_ptr = &n)
                fixed (float* v_ptr = &v)
                {
                    ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc_ptr, tc_ptr, n_ptr, v_ptr);
                }
            }
            public static unsafe void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(ReadOnlySpan<uint> rc, ReadOnlySpan<float> tc, ReadOnlySpan<float> c, ReadOnlySpan<float> n, ReadOnlySpan<float> v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* tc_ptr = tc)
                    {
                        fixed (float* c_ptr = c)
                        {
                            fixed (float* n_ptr = n)
                            {
                                fixed (float* v_ptr = v)
                                {
                                    ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_ptr, tc_ptr, c_ptr, n_ptr, v_ptr);
                                }
                            }
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint[] rc, float[] tc, float[] c, float[] n, float[] v)
            {
                fixed (uint* rc_ptr = rc)
                {
                    fixed (float* tc_ptr = tc)
                    {
                        fixed (float* c_ptr = c)
                        {
                            fixed (float* n_ptr = n)
                            {
                                fixed (float* v_ptr = v)
                                {
                                    ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_ptr, tc_ptr, c_ptr, n_ptr, v_ptr);
                                }
                            }
                        }
                    }
                }
            }
            public static unsafe void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(in uint rc, in float tc, in float c, in float n, in float v)
            {
                fixed (uint* rc_ptr = &rc)
                fixed (float* tc_ptr = &tc)
                fixed (float* c_ptr = &c)
                fixed (float* n_ptr = &n)
                fixed (float* v_ptr = &v)
                {
                    ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_ptr, tc_ptr, c_ptr, n_ptr, v_ptr);
                }
            }
        }
    }
}
